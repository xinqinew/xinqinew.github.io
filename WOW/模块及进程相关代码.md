# 模块及进程相关代码
## 句柄 进程 内存
### 窗口句柄
```cpp
HWND FindWindow(LPCTSTR IpClassName，LPCTSTR IpWindowName); 
HWND FindWindowW(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用Unicode字符集,IpWindowName前要加L,如L”魔兽世界“
HWND FindWindowA(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用多字节字符集
```

> 通过类名或窗口名查找，返回窗口句

### 进程ID和线程ID
```cpp
DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId); 
```
> 得到窗口句柄后通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID
### 进程句柄
```c
HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId);
```
> 打开一个已存在的进程对象，并返回进程的句柄

### 写入内存
```c
bool WriteProcessMemory(HANDLE hProcess,LPVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesWritten ); 
```
> 能写入某一进程的内存区域。入口区必须可以访问，否则操作将失败

### 读取内存
```c
HWND ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead); 
```
> 根据进程句柄读入该进程的某个内存空间lpBaseAddress的nSize字节，并写入缓冲区lpBuffer，多次计算基址和偏移即可

## 遍历模块
```cpp

int 遍历进程模块(DWORD 进程PID)
{
	HMODULE hMods[1024];	//20*sizeof(HMODULE)
	HANDLE 进程句柄;
	DWORD cbNeeded;
	unsigned int i;
	//Print the proess identifier.
	printf("\nprocess ID: %u\n",进程PID);
	//Get a handle to the process.
	进程句柄=OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程PID);

	if (NULL == 进程句柄)
		return 1;

	//Get a list of all the modules in this process.
	BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),&cbNeeded);
	if (br)
	{
		UINT32 模块数量=cbNeeded/sizeof(HMODULE);
		for ( i = 0; i < 模块数量; i++)
		{
			TCHAR szModName[MAX_PATH];

			//Get the full path to the module file.
			if(GetModuleFileNameEx(进程句柄,hMods[i],szModName,
									sizeof(szModName)/sizeof(TCHAR)))
			{
				//Print the module name and handle value.
				
				//_tprintf(TEXT("模块名[%d]=%s 地址=%08X\n"),i,szModName,hModes[i]);
				printf("模块名[%d]=%s 地址=%p\n",i,szModName,hMods[i]);
			}
		}
	}
	//Release the handle to the process.
	//
	CloseHandle(进程句柄);
	return 0;
}


```

## 获取窗口句柄
```cpp

HWND CFINDCODE::GetGameHwnd(void)
{
	HWND hNext = FindWindowExA(HWND_DESKTOP,0,0,0);
	HWND h2 = FindWindowExA(HWND_DESKTOP,hNext,0,0);
	int i =0;
	while(h2)
	{
		char buf[256]={0};
		GetWindowTextA(h2,buf,256);
		if (strstr(buf,szGameSubCaption))
		{
			break;
		}
		h2 = FindWindowExA(HWND_DESKTOP,h2,0,0);
	}
	return h2;
}
```

## 获取进程ID
```cpp

DWORD CFINDCODE::GetPID()
{
	HWND h=GetGameHwnd();
	DWORD dwpid=0;
	GetWindowThreadProcessId(h,&dwpid);
	return dwpid;
}


```
## 获取进程句柄
```cpp
HANDLE CFINDCODE::GetGameHp()
{
	DWORD dwPid = GetPID();
	HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS,0,dwPid);
	// printf("hp=%hp, pid=%d\r\n",hp,dwPid);
	return hp;
}
```

## 获取EXE模块起始地址
```cpp
UINT_PTR CFINDCODE::GetExeBase()
{
	UINT_PTR exeBase64=NULL;
	HMODULE hMods[1024];	//20*sizeof(HMODULE)
	
	DWORD cbNeeded;
	unsigned int i;
	HANDLE 进程句柄=GetGameHp();

	//Get a list of all the modules in this process.
	BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),&cbNeeded);
	if (br)
	{
		UINT32 模块数量=cbNeeded/sizeof(HMODULE);
		for ( i = 0; i < 模块数量; i++)
		{
			TCHAR szModName[MAX_PATH];

			//Get the full path to the module file.
			if(GetModuleFileNameEx(进程句柄,hMods[i],szModName,
									sizeof(szModName)/sizeof(TCHAR)))
			{
				//如果是“*.exe”的模块,直接返回基址
				if (strstr(szModName,".exe"))
				{
					exeBase64 = (UINT_PTR)hMods[i];
				}
				//Print the module name and handle value.
				
				//_tprintf(TEXT("模块名[%d]=%s 地址=%08X\n"),i,szModName,hModes[i]);
				// printf("模块名[%d]=%s 地址=%p\n",i,szModName,hMods[i]);
			}
		}
	}
	//Release the handle to the process.
	//
	CloseHandle(进程句柄);
	return exeBase64;
}
```
## 获取EXE结束地址
```cpp
UINT_PTR CFINDCODE::GetExeEnd()
{
	// HANDLE 进程句柄=GetGameHp();
	// UINT_PTR 模块基址 = GetExeBegin();
	// MEMORY_BASIC_INFORMATION meminfo;

	// //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败
	// SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,&meminfo,sizeof(meminfo));
	// UINT_PTR 结束地址=(UINT_PTR)meminfo.AllocationBase+meminfo.RegionSize;
	// printf("GetExeEnd: AllocationBase=%llx,RegionSize=%X 结束地址=%llx \r\n",meminfo.AllocationBase,meminfo.RegionSize,结束地址);
	// return 结束地址;
	return GetExeBase()+GetExeSize();

}
```
## 获取EXE模块大小
```cpp

SIZE_T CFINDCODE::GetExeSize();		
{
	static SIZE_T nSize=0;
	if (nSize)
	{
		/* code */
		return nSize;
	}
	HANDLE 进程句柄=GetGameHp();
	UINT_PTR 模块基址 = GetExeBase();
	MEMORY_BASIC_INFORMATION meminfo;

	//nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败
	SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,&meminfo,sizeof(meminfo));
	nSize = meminfo.RegionSize;
	CloseHandle(进程句柄);
	return nSize;
}
```
