[{"categories":["C++"],"content":"C++ 自增自减运算符 C++ 运算符 自增运算符 ++ 会把操作数加 1，自减运算符 – 会把操作数减 1。因此： x = x+1; 等同于 x++; 同样的： x = x-1; 等同于 x--; 无论是自增运算符还是自减运算符，都可以放在操作数的前面（前缀）或后面（后缀）。例如： x = x+1; 可以写成： ++x; // 前缀形式 或者： x++; // 后缀形式 前缀形式与后缀形式之间有一点不同。如果使用前缀形式，则会在表达式计算之前完成自增或自减，如果使用后缀形式，则会在表达式计算之后完成自增或自减。 实例 请看下面的实例，理解二者之间的区别： #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int c ; // a 的值在赋值之前不会自增 c = a++; cout \u003c\u003c \"Line 1 - Value of a++ is :\" \u003c\u003c c \u003c\u003c endl ; // 表达式计算之后，a 的值增加 1 cout \u003c\u003c \"Line 2 - Value of a is :\" \u003c\u003c a \u003c\u003c endl ; // a 的值在赋值之前自增 c = ++a; cout \u003c\u003c \"Line 3 - Value of ++a is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of a++ is :21 Line 2 - Value of a is :22 Line 3 - Value of ++a is :23 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 12a自增自减运算符","uri":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 杂项运算符 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ sizeof 运算符 sizeof 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。 sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。 使用 sizeof 的语法如下： sizeof (data type) 其中，data type 是要计算大小的数据类型，包括类、结构、共用体和其他用户自定义数据类型。 请尝试下面的实例，理解 C++ 中 sizeof 的用法。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Size of char : \" \u003c\u003c sizeof(char) \u003c\u003c endl; cout \u003c\u003c \"Size of int : \" \u003c\u003c sizeof(int) \u003c\u003c endl; cout \u003c\u003c \"Size of short int : \" \u003c\u003c sizeof(short int) \u003c\u003c endl; cout \u003c\u003c \"Size of long int : \" \u003c\u003c sizeof(long int) \u003c\u003c endl; cout \u003c\u003c \"Size of float : \" \u003c\u003c sizeof(float) \u003c\u003c endl; cout \u003c\u003c \"Size of double : \" \u003c\u003c sizeof(double) \u003c\u003c endl; cout \u003c\u003c \"Size of wchar_t : \" \u003c\u003c sizeof(wchar_t) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果，结果会根据使用的机器而不同： Size of char : 1 Size of int : 4 Size of short int : 2 Size of long int : 4 Size of float : 4 Size of double : 8 Size of wchar_t : 4 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 条件运算符 ? : Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意冒号的使用和位置。? : 表达式的值取决于 Exp1 的计算结果。如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为整个 ? : 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为整个 ? : 表达式的值。 ? 被称为三元运算符，因为它需要三个操作数，可以用来代替如下所示的 if-else 语句： if(condition){ var = X; }else{ var = Y; } 例如，请看下面这段代码： if(y \u003c 10){ var = 30; }else{ var = 40; } 上面的代码可以写成以下语句： var = (y \u003c 10) ? 30 : 40; 在这里，如果 y 小于 10，则 var 被赋值为 30，如果 y 不小于 10，则 var 被赋值为 40。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int main () { // 局部变量声明 int x, y = 10; x = (y \u003c 10) ? 30 : 40; cout \u003c\u003c \"value of x: \" \u003c\u003c x \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： value of x: 40 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 逗号运算符 使用逗号运算符是为了把几个表达式放在一起。 整个逗号表达式的值为系列中最后一个表达式的值。 从本质上讲，逗号的作用是将一系列运算按顺序执行。 表达式1, 表达式2 求解过程是：先求解表达式 1，再求解表达式 2。整个逗号表达式的值是表达式 2 的值。 最右边的那个表达式的值将作为整个逗号表达式的值，其他表达式的值会被丢弃。 例如： var = (count=19, incr=10, count+1); 在这里，首先把 count 赋值为 19，把 incr 赋值为 10，然后把 count 加 1，最后，把最右边表达式 count+1 的计算结果 20 赋给 var。上面表达式中的括号是必需的，因为逗号运算符的优先级低于赋值操作符。 尝试运行下面的实例，理解逗号运算符的用法。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int i, j; j = 10; i = (j++, j+100, 999+j); cout \u003c\u003c i; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 1010 上面的程序中，j 最初的值为 10，然后自增到 11，这时 j 的值就为 11，然后再计算第二个表达式 j+100，最后 j（j 为 11） 再加上 999，最后 i 为 最后一个表达式的值 999+j，及 999+ 11=1010。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。箭头运算符与一个指向对象的指针一起使用。例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:1","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:2","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 强制转换运算符 强制转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。强制转换运算符是一元运算符，它的优先级与其他一元运算符相同。 大多数的 C++ 编译器都支持大部分通用的强制转换运算符： (type) expression 其中，type 是转换后的数据类型。下面列出了 C++ 支持的其他几种强制转换运算符： const_cast (expr): const_cast 运算符用于修改类型的 const / volatile 属性。除了 const 或 volatile 属性之外，目标类型必须与源类型相同。这种类型的转换主要是用来操作所传对象的 const 属性，可以加上 const 属性，也可以去掉 const 属性。 dynamic_cast (expr): dynamic_cast 在运行时执行转换，验证转换的有效性。如果转换未执行，则转换失败，表达式 expr 被判定为 null。dynamic_cast 执行动态转换时，type 必须是类的指针、类的引用或者 void*，如果 type 是类指针类型，那么 expr 也必须是一个指针，如果 type 是一个引用，那么 expr 也必须是一个引用。 reinterpret_cast (expr): reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。 static_cast (expr): static_cast 运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。 上述所有的强制转换运算符在使用类和对象时会用到。现在，请看下面的实例，理解 C++ 中如何使用一个简单的强制转换运算符。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003eusing namespace std; int main() { double a = 21.09399; float b = 10.20; int c ; c = (int) a; cout \u003c\u003c \"Line 1 - Value of (int)a is :\" \u003c\u003c c \u003c\u003c endl ; c = (int) b; cout \u003c\u003c \"Line 2 - Value of (int)b is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of (int)a is :21 Line 2 - Value of (int)b is :10 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 指针运算符（\u0026 和 *） C++ 提供了两种指针运算符，一种是取地址运算符 \u0026，一种是间接寻址运算符 *。 指针是一个包含了另一个变量地址的变量，您可以把一个包含了另一个变量地址的变量说成是\"指向\"另一个变量。变量可以是任意的数据类型，包括对象、结构或者指针。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作**“取地址运算符”**，这意味着，**\u0026var** 读作\"var 的地址\"。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:1","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:2","tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C 风格字符串 C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。 char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char site[] = \"RUNOOB\"; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。让我们尝试输出上面的字符串： 实例 #include \u003ciostream\u003e using namespace std; int main () { char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; cout \u003c\u003c \"菜鸟教程: \"; cout \u003c\u003c site \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 菜鸟教程: RUNOOB C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 \u0026 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = “runoob”;string str2 = “google”; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： 实例 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; int main () { char str1[13] = \"runoob\"; char str2[13] = \"google\"; char str3[13]; int len ; // 复制 str1 到 str3 strcpy( str3, str1); cout \u003c\u003c \"strcpy( str3, str1) : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 strcat( str1, str2); cout \u003c\u003c \"strcat( str1, str2): \" \u003c\u003c str1 \u003c\u003c endl; // 连接后，str1 的总长度 len = strlen(str1); cout \u003c\u003c \"strlen(str1) : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： strcpy( str3, str1) : runoob strcat( str1, str2): runoobgoogle strlen(str1) : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 中的 String 类 C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例： 现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。 实例 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; int main () { string str1 = \"runoob\"; string str2 = \"google\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： str3 : runoob str1 + str2 : runoobgoogle str3.size() : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解什么是局部变量和全局变量。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c; return 0; } ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:1","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout \u003c\u003c g; return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:1","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; // 全局变量声明 int g = 20; int main () { // 局部变量声明 int g = 10; cout \u003c\u003c g; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 10 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:2","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"auto 存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 实例 #include \u003ciostream\u003e // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main() { while(count--) { func(); } return 0; } // 函数定义 void func( void ) { static int i = 5; // 局部静态变量 i++; std::cout \u003c\u003c \"变量 i 为 \" \u003c\u003c i ; std::cout \u003c\u003c \" , 变量 count 为 \" \u003c\u003c count \u003c\u003c std::endl; } 当上面的代码被编译和执行时，它会产生下列结果： 变量 i 为 6 , 变量 count 为 9 变量 i 为 7 , 变量 count 为 8 变量 i 为 8 , 变量 count 为 7 变量 i 为 9 , 变量 count 为 6 变量 i 为 10 , 变量 count 为 5 变量 i 为 11 , 变量 count 为 4 变量 i 为 12 , 变量 count 为 3 变量 i 为 13 , 变量 count 为 2 变量 i 为 14 , 变量 count 为 1 变量 i 为 15 , 变量 count 为 0 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"extern 存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.cpp 实例 #include \u003ciostream\u003e int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件：support.cpp 实例 #include \u003ciostream\u003e extern int count; void write_extern(void) { std::cout \u003c\u003c \"Count is \" \u003c\u003c count \u003c\u003c std::endl; } 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示： $ g++ main.cpp support.cpp -o write 这会产生 write 可执行程序，尝试执行 write，它会产生下列结果： $ ./write Count is 5 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"thread_local 存储类 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"C++ 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"算术运算符 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 实例 请看下面的实例，了解 C++ 中可用的算术运算符。 复制并粘贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int b = 10; int c; c = a + b; cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a - b; cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a * b; cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a / b; cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a % b; cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; int d = 10; // 测试自增、自减 c = d++; cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; d = 10; // 重新赋值 c = d--; cout \u003c\u003c \"Line 7 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 10 Line 7 - c 的值是 10 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"关系运算符 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 #实例 请看下面的实例，了解 C++ 中可用的关系运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int b = 10; int c ; if( a == b ) { cout \u003c\u003c \"Line 1 - a 等于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 1 - a 不等于 b\" \u003c\u003c endl ; } if ( a \u003c b ) { cout \u003c\u003c \"Line 2 - a 小于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 2 - a 不小于 b\" \u003c\u003c endl ; } if ( a \u003e b ) { cout \u003c\u003c \"Line 3 - a 大于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 3 - a 不大于 b\" \u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 5; b = 20; if ( a \u003c= b ) { cout \u003c\u003c \"Line 4 - a 小于或等于 b\" \u003c\u003c endl ; } if ( b \u003e= a ) { cout \u003c\u003c \"Line 5 - b 大于或等于 a\" \u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - a 不等于 b Line 2 - a 不小于 b Line 3 - a 大于 b Line 4 - a 小于或等于 b Line 5 - b 大于或等于 a ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"逻辑运算符 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A || B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 #实例 请看下面的实例，了解 C++ 中可用的逻辑运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 5; int b = 20; int c ; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 1 - 条件为真\"\u003c\u003c endl ; } if ( a || b ) { cout \u003c\u003c \"Line 2 - 条件为真\"\u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 0; b = 10; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 3 - 条件为真\"\u003c\u003c endl ; } else { cout \u003c\u003c \"Line 4 - 条件不为真\"\u003c\u003c endl ; } if ( !(a \u0026\u0026 b) ) { cout \u003c\u003c \"Line 5 - 条件为真\"\u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - 条件为真 Line 2 - 条件为真 Line 4 - 条件不为真 Line 5 - 条件为真 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示： p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 -—————- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则：0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：`0 0=0; 0 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 » 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 #实例 请看下面的实例，了解 C++ 中可用的位运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { unsigned int a = 60; // 60 = 0011 1100 unsigned int b = 13; // 13 = 0000 1101 int c = 0; c = a \u0026 b; // 12 = 0000 1100 cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a | b; // 61 = 0011 1101 cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a ^ b; // 49 = 0011 0001 cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = ~a; // -61 = 1100 0011 cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003c\u003c 2; // 240 = 1111 0000 cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003e\u003e 2; // 15 = 0000 1111 cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"赋值运算符 下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 #实例 请看下面的实例，了解 C++ 中可用的赋值运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int c ; c = a; cout \u003c\u003c \"Line 1 - = 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c += a; cout \u003c\u003c \"Line 2 - += 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c -= a; cout \u003c\u003c \"Line 3 - -= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c *= a; cout \u003c\u003c \"Line 4 - *= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c /= a; cout \u003c\u003c \"Line 5 - /= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c = 200; c %= a; cout \u003c\u003c \"Line 6 - %= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003c\u003c= 2; cout \u003c\u003c \"Line 7 - \u003c\u003c= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003e\u003e= 2; cout \u003c\u003c \"Line 8 - \u003e\u003e= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u0026= 2; cout \u003c\u003c \"Line 9 - \u0026= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c ^= 2; cout \u003c\u003c \"Line 10 - ^= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c |= 2; cout \u003c\u003c \"Line 11 - |= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - = 运算符实例，c 的值 = 21 Line 2 - += 运算符实例，c 的值 = 42 Line 3 - -= 运算符实例，c 的值 = 21 Line 4 - *= 运算符实例，c 的值 = 441 Line 5 - /= 运算符实例，c 的值 = 21 Line 6 - %= 运算符实例，c 的值 = 11 Line 7 - \u003c\u003c= 运算符实例，c 的值 = 44 Line 8 - \u003e\u003e= 运算符实例，c 的值 = 11 Line 9 - \u0026= 运算符实例，c 的值 = 2 Line 10 - ^= 运算符实例，c 的值 = 0 Line 11 - |= 运算符实例，c 的值 = 2 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"杂项运算符 下表列出了 C++ 支持的其他一些重要的运算符。 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 中的运算符优先级 运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 #实例 请看下面的实例，了解 C++ 中运算符的优先级。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 cout \u003c\u003c \"(a + b) * c / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = ((a + b) * c) / d; // (30 * 15 ) / 5 cout \u003c\u003c \"((a + b) * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = (a + b) * (c / d); // (30) * (15/5) cout \u003c\u003c \"(a + b) * (c / d) 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = a + (b * c) / d; // 20 + (150/5) cout \u003c\u003c \"a + (b * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： (a + b) * c / d 的值是 90 ((a + b) * c) / d 的值是 90 (a + b) * (c / d) 的值是 90 a + (b * c) / d 的值是 50 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 循环 有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。 编程语言提供了允许更为复杂的执行路径的多种控制结构。 循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环类型 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环控制语句 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 实例 #include \u003ciostream\u003eusing namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 **注意：**您可以按 Ctrl + C 键终止一个无限循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"C++ 判断 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。 下面是大多数编程语言中典型的判断结构的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"判断语句 C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"? : 运算符 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"C++ 函数 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"定义函数 C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 实例 以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"调用函数 创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 实例 #include \u003ciostream\u003eusing namespace std; // 函数声明 int max(int num1, int num2); int main () { // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout \u003c\u003c \"Max value is : \" \u003c\u003c ret \u003c\u003c endl; return 0; } // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： Max value is : 200 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"参数的默认值 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int sum(int a, int b=20) { int result; result = a + b; return (result); } int main () { // 局部变量声明 int a = 100; int b = 200; int result; // 调用函数来添加值 result = sum(a, b); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; // 再次调用函数 result = sum(a); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total value is :300 Total value is :120 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: [capture](parameters)-\u003ereturn-type{body} 例如： [](int x, int y){ return x \u003c y ; } 如果没有返回值可以表示为： [capture](parameters){body} 例如： []{ ++global_x; } 在一个更为复杂的例子中，返回类型可以被明确的指定如下： [](int x, int y) -\u003e int { int z = x + y; return z + x; } 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： [this]() { this-\u003esomeFunc(); }(); ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 数字 通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 定义数字 我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例： 实例 #include \u003ciostream\u003eusing namespace std; int main () { // 数字定义 short s; int i; long l; float f; double d; // 数字赋值 s = 10; i = 1000; l = 1000000; f = 230.47; d = 30949.374; // 数字输出 cout \u003c\u003c \"short s :\" \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c \"int i :\" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"long l :\" \u003c\u003c l \u003c\u003c endl; cout \u003c\u003c \"float f :\" \u003c\u003c f \u003c\u003c endl; cout \u003c\u003c \"double d :\" \u003c\u003c d \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： short s :10 int i :1000 long l :1000000 float f :230.47 double d :30949.4 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数学运算 在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件 。 序号 函数 \u0026 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 下面是一个关于数学运算的简单实例： 实例 #include \u003ciostream\u003e#include \u003ccmath\u003eusing namespace std; int main () { // 数字定义 short s = 10; int i = -1000; long l = 100000; float f = 230.47; double d = 200.374; // 数学运算 cout \u003c\u003c \"sin(d) :\" \u003c\u003c sin(d) \u003c\u003c endl; cout \u003c\u003c \"abs(i) :\" \u003c\u003c abs(i) \u003c\u003c endl; cout \u003c\u003c \"floor(d) :\" \u003c\u003c floor(d) \u003c\u003c endl; cout \u003c\u003c \"sqrt(f) :\" \u003c\u003c sqrt(f) \u003c\u003c endl; cout \u003c\u003c \"pow( d, 2) :\" \u003c\u003c pow(d, 2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： sin(d) :-0.634939 abs(i) :1000 floor(d) :200 sqrt(f) :15.1812 pow( d, 2 ) :40149.7 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 随机数 在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数： 实例 #include \u003ciostream\u003e#include \u003cctime\u003e#include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 随机数： 1748144778 随机数： 630873888 随机数： 2134540646 随机数： 219404170 随机数： 902129458 随机数： 920445370 随机数： 1319072661 随机数： 257938873 随机数： 1256201101 随机数： 580322989 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数组 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"声明数组 在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"初始化数组 在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： 实例 #include \u003ciostream\u003eusing namespace std; #include \u003ciomanip\u003eusing std::setw; int main () { int n[ 10 ]; // n 是一个包含 10 个整数的数组 // 初始化数组元素 for ( int i = 0; i \u003c 10; i++ ) { n[ i ] = i + 100; // 设置元素 i 为 i + 100 } cout \u003c\u003c \"Element\" \u003c\u003c setw( 13 ) \u003c\u003c \"Value\" \u003c\u003c endl; // 输出数组中每个元素的值 for ( int j = 0; j \u003c 10; j++ ) { cout \u003c\u003c setw( 7 )\u003c\u003c j \u003c\u003c setw( 13 ) \u003c\u003c n[ j ] \u003c\u003c endl; } return 0; } 上面的程序使用了 setw() 函数 来格式化输出。当上面的代码被编译和执行时，它会产生下列结果： Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 中数组详解 在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解： 类型 描述 bool 存储值 true 或 false。 char 通常是一个字符（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 下面我们将讲解如何定义、声明和使用各种类型的变量。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。 变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。 变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： type variable_name = value; 下面列举几个实例： extern int d = 3, f = 5; // d 和 f 的声明 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = 'x'; // 变量 x 的值为 'x' 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量声明 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的： #include \u003ciostream\u003eusing namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 30 23.3333 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如： // 函数声明 int func(); int main() { // 函数调用 int i = func(); } // 函数定义 int func() { return 0; } ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:1","tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的左值（Lvalues）和右值（Rvalues） C++ 中有两种类型的表达式： **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： int g = 20; 但是下面这个就不是一个有效的语句，会生成编译时错误： 10 = 20; ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++教程","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 数据类型 使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。 您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其实 wchar_t 是这样来的： typedef short int wchar_t; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 **注意：**不同系统会有所差异，一字节为 8 位。 **注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。 下面实例会输出您电脑上各种数据类型的大小。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } 实例使用了 endl，这将在每一行后插入一个换行符，« 运算符用于向屏幕传多个值，sizeof() 函数用来获取各种数据类型的大小。 当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同： type: ************size************** bool: 所占字节数：1 最大值：1 最小值：0 char: 所占字节数：1 最大值： 最小值：? signed char: 所占字节数：1 最大值： 最小值：? unsigned char: 所占字节数：1 最大值：? 最小值： wchar_t: 所占字节数：4 最大值：2147483647 最小值：-2147483648 short: 所占字节数：2 最大值：32767 最小值：-32768 int: 所占字节数：4 最大值：2147483647 最小值：-2147483648 unsigned: 所占字节数：4 最大值：4294967295 最小值：0 long: 所占字节数：8 最大值：9223372036854775807 最小值：-9223372036854775808 unsigned long: 所占字节数：8 最大值：18446744073709551615 最小值：0 double: 所占字节数：8 最大值：1.79769e+308 最小值：2.22507e-308 long double: 所占字节数：16 最大值：1.18973e+4932 最小值：3.3621e-4932 float: 所占字节数：4 最大值：3.40282e+38 最小值：1.17549e-38 size_t: 所占字节数：8 最大值：18446744073709551615 最小值：0 string: 所占字节数：24 type: ************size************** ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"typedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 212 // 合法的 215u // 合法的 0xFeeL // 合法的 078 // 非法的：8 不是八进制的数字 032UU // 非法的：不能重复后缀 以下是各种类型的整数常量的实例： 85 // 十进制 0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 3.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数 210f // 非法的：没有小数或指数 .e55 // 非法的：缺少整数或分数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"布尔常量 布尔常量共有两个，它们都是标准的 C++ 关键字： true 值代表真。 false 值代表假。 我们不应把 true 的值看成 1，把 false 的值看成 0。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符常量 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x'），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 ' ' 字符 \" \" 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 下面的实例显示了一些转义序列字符： 实例 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello\\tWorld\\n\\n\"; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Hello World ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符串常量 字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用 ** 做分隔符，把一个很长的字符串常量进行分行。 下面的实例显示了一些字符串常量： 实例 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string greeting = \"hello, runoob\"; cout \u003c\u003c greeting; cout \u003c\u003c \"\\n\"; // 换行符 string greeting2 = \"hello, \\ runoob\"; cout \u003c\u003c greeting; return 0; } hello, runoob hello, runoob ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"定义常量 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"#define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\\n' int main() { int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:7:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value; 具体请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 请注意，把常量定义为大写字母形式，是一个很好的编程实践。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:8:0","tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"C++ 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 unsigned x; unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： 实例 #include \u003ciostream\u003eusing namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000 上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 教程 C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。 本教程通过通俗易懂的语言来讲解 C++ 编程语言。 现在开始学习 C++ 编程！ C++ 在线工具 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"谁适合阅读本教程？ 本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"阅读本教程前，您需要了解的知识： 在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"编译/执行 C++ 程序 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 运行实例 » 你可以用 \"\\n\" 代替以上代码里的 endl。 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c \"\\n\"; return 0; } ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 简介 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 **注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"面向对象程序设计 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准库 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"ANSI 标准 ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。 由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"学习 C++ 学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。 学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。 C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"C++ 的使用 基本上每个应用程序领域的程序员都有使用 C++。 C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。 C++ 广泛用于教学和研究。 任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准化 发布时间 通称 备注 2017 C++17 第五个C++标准 2017 coroutines TS 协程库扩展 2017 ranges TS 提供范围机制 2017 library fundamentals TS 标准库扩展 2016 concurrency TS 用于并发计算的扩展 2015 concepts TS 概念库，用于优化编译期信息 2015 TM TS 事务性内存操作 2015 parallelism TS 用于并行计算的扩展 2015 filesystem TS 文件系统 2014 C++14 第四个C++标准 2011 - 十进制浮点数扩展 2011 C++11 第三个C++标准 2010 - 数学函数扩展 2007 C++TR1 C++技术报告：库扩展 2006 - C++性能技术报告 2003 C++03 第二个C++标准 1998 C++98 第一个C++标准 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"C++ 环境设置 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"本地环境设置 如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"文本编辑器 这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。 文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。 通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。 在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 编译器 写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。 C++ 编译器用于把源代码编译成最终的可执行程序。 大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。 最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"安装 GNU 的 C/C++ 编译器 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"UNIX/Linux 上的安装 如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC： $ g++ -v 如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息： Using built-in specs. Target: i386-redhat-linux Configured with: ../configure --prefix=/usr ....... Thread model: posix gcc version 4.1.2 20080704 (Red Hat 4.1.2-46) 如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:1","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Mac OS X 上的安装 如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。 Xcode 目前可从 https://developer.apple.com/download 上下载，需要使用 apple ID 登录 。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:2","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Windows 上的安装 为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 mingw-w64.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-.exe。 当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。 添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。 当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:3","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"使用 Visual Studio (Graphical Interface) 编译 1、下载及安装 Visual Studio Community 2015。 2、打开 Visual Studio Community 3、点击 File -\u003e New -\u003e Project 4、左侧列表选择 Templates -\u003e Visual C++ -\u003e Win32 Console Application，并设置项目名为 MyFirstProgram。 5、点击 OK。 6、在以下窗口中点击 Next 7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮： 8、右击文件夹 Source File 并点击 Add –\u003e New Item… : 9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add： 10、拷贝以下代码到 main.cpp 中： #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\\n\"; return 0; } 界面如下所示： 11、点击菜单上的 Debug -\u003e Start Without Debugging (或按下 ctrl + F5) : 12、完成以上操作后，你可以看到以下输出： ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 应用说明 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示： $ gcc main.cpp -lstdc++ -o main 下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码： #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 最简单的编译方式： $ g++ helloworld.cpp 由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行： $ ./a.out Hello, world! 通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件： $ g++ helloworld.cpp -o helloworld 执行 helloworld: $ ./helloworld Hello, world! 如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下： $ g++ runoob1.cpp runoob2.cpp -o runoob 生成一个 runoob 可执行文件。 g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件： g++ -g -Wall -std=c++11 main.cpp ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 常用命令选项 选项 解释 -ansi 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 -c 只编译并生成目标文件。 -DMACRO 以字符串\"1\"定义 MACRO 宏。 -DMACRO=DEFN 以字符串\"DEFN\"定义 MACRO 宏。 -E 只运行 C 预编译器。 -g 生成调试信息。GNU 调试器可利用该信息。 -IDIRECTORY 指定额外的头文件搜索路径DIRECTORY。 -LDIRECTORY 指定额外的函数库搜索路径DIRECTORY。 -lLIBRARY 连接时搜索指定的函数库LIBRARY。 -m486 针对 486 进行代码优化。 -o FILE 生成指定的输出文件。用在生成可执行文件时。 -O0 不进行优化处理。 -O 或 -O1 优化生成代码。 -O2 进一步优化。 -O3 比 -O2 更进一步优化，包括 inline 函数。 -shared 生成共享目标文件。通常用在建立共享库时。 -static 禁止使用共享连接。 -UMACRO 取消对 MACRO 宏的定义。 -w 不生成任何警告信息。 -Wall 生成所有警告信息。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:1","tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 基本语法 C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"实例 #include using namespace std; // main() 是程序开始执行的地方 int main() { cout « “Hello World”; // 输出 Hello World return 0; } 接下来我们讲解一下上面这段程序： C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout « “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:1","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"编译 \u0026 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤： 打开一个文本编辑器，添加上述代码。 保存文件为 hello.cpp。 打开命令提示符，进入到保存文件所在的目录。 键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。 现在，键入 ' a.out’ 来运行程序。 您可以看到屏幕上显示 ' Hello World ‘。 $ g++ hello.cpp $ ./a.out Hello World 请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。 您也可以使用 makefile 来编译 C/C++ 程序。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的分号 \u0026 语句块 在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 例如，下面是三个不同的语句： x = y; y = y+1; add(x, y); 语句块是一组使用大括号括起来的按逻辑连接的语句。例如： { cout « “Hello World”; // 输出 Hello World return 0; } C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如： x = y; y = y+1; add(x, y); 等同于 x = y; y = y+1; add(x, y); ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 标识符 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、\u0026 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。 下面列出几个有效的标识符： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 关键字 下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 完整关键字介绍可查阅：C++ 的关键字（保留字）完整介绍 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"三字符组 三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。 下面列出了最常用的三字符序列： 三字符组 替换 ??= # ??/ \\ ??’ ^ ??( [ ??) ] ??! | ??\u003c { ??\u003e } ??- ~ 如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"…?\"\"?…“或者转义序列：”…??…\"。 从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs g++仍默认支持三字符组，但会给出编译警告。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的空格 只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。 在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中： int age; 在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中： fruit = apples + oranges; // 获取水果的总数 fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 注释 程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。 C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。 C++ 注释一般有两种： // - 一般用于单行注释。 /*** … */** - 一般用于多行注释。 注释以 // 开始，直到行末为止。例如： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:0:0","tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main() { // 这是一个注释 cout \u003c\u003c \"Hello World!\"; return 0; } 也可以放在语句后面： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:1:0","tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello World!\"; // 输出 Hello World! return 0; } 当上面的代码被编译时，编译器会忽略 // 这是一个注释 和 // 输出 Hello World!，最后会产生以下结果： Hello World! C++ 注释以 /* 开始，以 */ 终止。例如： #include \u003ciostream\u003eusing namespace std; int main() { /* 这是注释 */ /* C++ 注释也可以 * 跨行 */ cout \u003c\u003c \"Hello World!\"; return 0; } 在 /* 和 / 注释内部，//* 字符没有特殊的含义。在 **//** 注释内，**/*** 和 ***/** 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如： /* 用于输出 Hello World 的注释 cout \u003c\u003c \"Hello World\"; // 输出 Hello World */ ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:2:0","tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":null,"content":"LoveIt主题介绍：https://hugoloveit.com/zh-cn/ LoveIt主题仓库：https://github.com/dillonzq/LoveIt 更新搜索专用 shenweiwei hugo serve -e production ","date":"2021-08-01","objectID":"/2021/08/hello-world/:0:0","tags":null,"title":"LoveIt 主题","uri":"/2021/08/hello-world/"},{"categories":null,"content":"content.","date":"2021-08-01","objectID":"/2021/08/hello-world/:1:0","tags":null,"title":"LoveIt 主题","uri":"/2021/08/hello-world/"},{"categories":["C++"],"content":"循环与判断","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"C++ 循环 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:0:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:1:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"基于范围的for循环(C++11) 拷贝range的元素时，使用for(auto x : range). 修改range的元素时，使用for(auto \u0026\u0026 x : range). 只读range的元素时，使用for(const auto \u0026 x : range). vector\u003cbool\u003e时使用auto会有问题，对于其他包含代理类的类也会有问题，直接使用for(bool x : vector\u003cbool\u003e) ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:1:1","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"do…while 循环 do { statement(s); }while( condition ); ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:1:2","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"循环控制语句 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:2:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"break 语句 C++ 中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case。 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:2:1","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"continue 语句 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:2:2","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"goto 语句 goto 语句一个很好的作用是退出深嵌套例程。例如，请看下面的代码片段： for(...) { for(...) { while(...) { if(...) goto stop; . . . } } } stop: cout \u003c\u003c \"Error in program.\\n\"; 消除 goto 会导致一些额外的测试被执行。一个简单的 break 语句在这里不会起到作用，因为它只会使程序退出最内层循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:2:3","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"无限循环 #include \u003ciostream\u003eusing namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 注意：您可以按 Ctrl + C 键终止一个无限循环。 判断 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:3:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:4:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"switch 语句 switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } switch 语句必须遵循下面的规则： switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:4:1","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"嵌套 switch 语句 switch(ch1) { case 'A': cout \u003c\u003c \"这个 A 是外部 switch 的一部分\"; switch(ch2) { case 'A': cout \u003c\u003c \"这个 A 是内部 switch 的一部分\"; break; case 'B': // 内部 B case 代码 } break; case 'B': // 外部 B case 代码 } ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:4:2","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["C++"],"content":"? : 运算符 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; ","date":"2021-08-15","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/:5:0","tags":["C++"],"title":"C++知识点(四) 循环与判断","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9B/"},{"categories":["博客"],"content":"俺如何为 hugo-theme-even 提供 mermaid 支持 如上是一个利用 mermaid 绘制的 SVG 图形 ，相比于直接在某些软件绘制好再截图，显然利用 mermaid 绘图具备诸多优点： 网站保存的是带 mermaid 的 markdown 文件，不涉及到图片存储。存储占用小。 渲染出图是 SVG 格式，上面的文字可以直接拷贝。 网站数据传输时是使用 mermaid 源码，而不是图片，可以有效减少网站加载过程产生的流量耗费。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:0:0","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"如何为你的 Hugo 博客引入 mermaid 支持？ 贴士 虽然由于 even theme 更新过慢，似乎久已无更多维护，因此本站已经开始使用 LoveIt 作为主题。 但是对于 even theme 而言，本方法应当依旧适用。 对于这一点，俺可以说前人之述备矣。反手就是一堆参考资料： Diagrams in hugo with mermaid 拓展 Hugo 的 MarkDown 流程图 这些解决方案引入 mermaid 的方法简单素雅，这一套流程可以总结为： 在博客中加载 mermaidJS。具体方法有： 直接在一定会加载的 HTML 文件中引入 \u003cscript\u003e 标签，加载 mermaid。 在部分支持自定义 JavaScript 的主题中，引入 JavaScript 文件。 自定义 ShortCodes，依靠 ShortCodes 实现标签替换。 但是习惯了通过 typora 之类的 MarkDown 拓展编辑器，他们无一例外都支持按照如下风格进行渲染： ```mermaid ... 图表内容 ... ``` 能不能实现它，从而实现更加一颗赛艇的编辑体验呢？ 能的。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:1:0","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"实现原理 通过阅读 mermaid 的 API 咱们可以得知 mermaidAPI 渲染 mermaid 图形的大致流程： 上述的特定标签是指\u003cdiv class=\"mermaid\"\u003e的 HTML 标签。通过检查页面元素，咱们会发现如今的大部分博客将代码块渲染成如下式样： \u003cpre\u003e\u003ccode class=\"language-语言种类\"\u003e \u003c!-- code --\u003e \u003c/code\u003e\u003c/pre\u003e 也就是说咱们只需要找到形如： \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e \u003c!-- mermaid code --\u003e \u003c/code\u003e\u003c/pre\u003e 的代码块，并将其替换成\u003cdiv class=\"mermaid\"\u003e即可。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:2:0","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"在 even theme 中的实现 注意 注意： 下文中的 “/” 目录代表 even theme 项目的根目录而不是 *nix 文件系统的 root. 本博客使用的是 even theme. 但是俺相信参照本文在其他博客中进行实现也会大差不差。 俺在自己实现了此种风格之后即向 hugo-theme-even 提出了 PR，even theme 的用户应该可以在不久以后在新版本中得到 mermaid 支持。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:0","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"导入 mermaid.min.js 实现应当遵循原理的指示精神，首先咱们需要拥有 mermaid 库。通过观察源码猜测 even 主题在 /static/layouts/partials/scripts.html 中进行 JS 的载入。于是咱们向其中插入能够引入 mermaid 模块的 script 标签。（实际上只要是会被加载的 HTML 文件都可以插） 这个标签在 HTML 文件里随便找个地方插就完事了，如果完全不懂，建议怼到 HTML 文件末尾。 通过 CDN 导入 为了保持文章的时效性，俺不会直接提供该 script 标签，但是你可以在 jsdelivr.com 中找到你中意版本的 mermaid.min.js 并按下右边的 Copy HTML + SRI 按钮即可获得对应的标签。 通过本地文件导入 由于房间里的大象太大挡住了境外CDN的信号，所以你也可以选择本地文件。在网上找到你中意版本的 mermaid.min.js, 下载下来并放在 /static/lib/mermaid/ 目录下（没有就新建一个），这时可以得到对应的 script 标签如下： \u003cscript src=\"{{ \"lib/mermaid/mermaid.min.js\" | relURL }}\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e 本人对境外 CDN 在内地的稳定性持悲观态度，建议中国大陆用户使用此方法。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:1","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"替换 HTML 标签 观察 even 主题的源码，咱们可以在 /assets/js/ 目录下发现 main.js 和 even.js。在 even.js 中插入如下代码段： // 插到文件末尾完事了 Even.mermaid = function () { if (!window.mermaid) return; const blocks = document.querySelectorAll(\"pre code.language-mermaid\"); // change all \u003cpre\u003e\u003ccode mamaid\u003e tags to \u003cdiv class=\"mermaid\"\u003e // mermaid will handle the rest! for (let i = 0; i \u003c blocks.length; i++) { if (!window.hljs \u0026\u0026 i % 2 === 0) continue; const block = blocks[i]; const rootElement = window.hljs ? block.parentElement : block.parentElement.parentElement.parentElement.parentElement .parentElement.parentElement.parentElement; var container = document.createElement(\"div\"); const id = `js-mermaid-diagrams-${i}`; container.id = id; container.className = \"align-center mermaid\"; container.textContent = block.childNodes[0].textContent; rootElement.parentElement.replaceChild(container, rootElement); } window.mermaid.mermaidAPI.initialize( window.mermaidOptions ? window.mermaidOptions : { securityLevel: \"loose\", theme: \"base\" } // 替换它可以修改 mermaid 的样式=======↑ ); }; 在 main.js 中插入： // 个人比较喜欢插在 Even.sequence(); 的后面 Even.mermaid(); 现在你应该可以在自己的博客中写 mermaid 了。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:2","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"工具推荐 Typora 写 MarkDown 咋能少得了 「Typora」？ Visual Studio Code 俺写这篇文章用的无所不能的编辑器，建议添加插件： Markdown All in One Markdown Preview Enhanced Mermaid Markdown Syntax Highlighting 之所以用 Visual Studio Code，很大程度上是因为它的 Vim 拓展。 “2021年了不会还有人不会用 Vim 吧？” vim ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:3","tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["C++"],"content":"存储类与运算符","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:0:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"auto 存储类 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:1:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:2:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"static 存储类 静态变量 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:3:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"extern 存储类 extern 是用来在另一个文件中声明一个全局变量或函数。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:4:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:5:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"thread_local 存储类 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } C++运算符 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:6:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A– 将得到 9 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:7:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:8:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A|| B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:9:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"位运算符 p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则： 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：0|0=0; 0|1=1; 1|0=1; 1|1=1; (A | B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则： ~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 \u003e\u003e 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:10:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 \u003e\u003e= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:11:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"杂项运算符 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:12:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"逗号运算符 var = (count=19, incr=10, count+1); ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:12:1","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。 箭头运算符与一个指向对象的指针一起使用。 例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; （.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); （-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:12:2","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"指针运算符（\u0026 和 *) 取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作\"取地址运算符\"，这意味着，\u0026var 读作\"var 的地址\"。 间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:12:3","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"C++ 中的运算符优先级 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:13:0","tags":["C++"],"title":"C++知识点(三) 存储类与运算符","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++","任鸟飞"],"content":"小知识 16进制 4x xx xx xx一般是浮点数（正数） 16进制 Cx xx xx xx一般是浮点数（负数） st0 st1 st2 … 是浮点栈 sar 算术右移 每右移一位，相当于除以一次2 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:1:0","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"汇编 dd 查看dword db 查看字节集 EAX call的返回值 ECX call的参数 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:0","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"汇编指令 AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中。 TEST 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。 test eax,eax //判断eax是否为0 xor eax,eax //eax清0 FLD类似于 PUSH指令 将浮点数据压入协处理器的堆栈中 FSTP类似于 POP指令 与FST相类似，FSTP执行完后，需要进行堆栈的弹出操作，堆栈将发生变化。 FADD类似于 ADD指令 源操作数与目的操作数相加 FST 将协处理器堆栈栈顶的数据传送到目标操作数中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:1","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"三大发包函数 send WSASend sendto send在64位系统上是ws2_32.send ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:2","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"确定堆栈平衡 方法： 在call的栈上双击 F8步过call 此时看栈上差值 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:3","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"应该熟悉的汇编指令 mov 传值 和 lea 传址 push 入栈 和 pop 出栈 pushad 和 popad 调用call之前pushad，调用call之后popad，保证寄存器不受影响 add 加法 和 sub 减法 inc 自加1 和 dec 自减1 mul 乘法 div 除法 call 和 retn xor 异或 相同为0，不同为1 and 都是1为1 or 有一个是1为1 xor 是可逆运算，即 A xor B == C 那么 A xor C == B ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:4","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"堆栈详解 什么是堆栈 堆栈就是一种数据项按序排列的数据结构，只能在栈顶对数据项进行插入和删除，其它位置只能改变数值。 特点是先进后出，像个杯子。 堆栈指针寄存器 ESP 栈顶指针 EBP 栈底指针（本层CALL的栈底） 改变堆栈的操作 push eax == sub esp,4 + mov [esp],eax pop eax == mov eax,[esp] + add esp,4 call 1234 == push eip + jmp 1234 retn 8 == pop eip + add esp,8 add esp,xxx sub esp,xxx 堆栈中储存的都是 参数、局部变量、操作中间数 那么我们怎么去找他的来源 例如[ebp-4] [ebp+8] [esp+20] 实例来说明 通过ebp来传递参数和局部变量 push ebp mov ebp,esp … … mov esp,ebp pop ebp [ebp-8] 第二个局部变量 [ebp-4] 第一个局部变量 [ebp] 保存着上一层的ebp值 [ebp+4] 指向call返回到 [ebp+8] 第一个参数 [ebp+c] 第二个参数 同时知道了 ebp为什么是栈底指针 通过esp来传递参数和局部变量 头部没有push ebp mov ebp，esp 这样的代码，往往是用esp来表示 sub esp，xxxx 开辟局部变量 算到头部，如果是[esp+]，那么是参数 如果是[esp-]，那么是局部变量，是在本层找来源 更简单的方法是，直接断下看堆栈，看看这个堆栈指针，指向的位置是，上一层返回的上面还是下面。 但是不用全部计算，往往一个call都是自身堆栈平衡的。 我们只需要计算头部的一些堆栈处理。 [esp-8] 第二个局部变量 [esp-4] 第一个局部变量 [esp] 指向call返回到 [esp+4] 第一个参数 [esp+8] 第二个参数 首先要确定 我们要追的[esp+]是参数还是局部变量 两种方法可以确定 一条一条往上推，推到最上面，如果是esp+，那就是参数，如果是esp-那就是局部变量 直接下断，看堆栈，在call返回到下面的是参数，上面的是局部变量 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:5","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"数据结构 一般我们接触的数据结构有三种 数组、链表、二叉树，也就是数据不同的排列方式 二叉树 graph TD; a--\"[a+0]\"--\u003eb; a--\"[a+8]\"--\u003ec; b --\"[[a+0]+0]\"--\u003e d; b --\"[[a+0]+8]\"--\u003e e; c--\"[[a+8]+0]\"--\u003ef; e--\"[[[a+0]+8]+0]\"--\u003eg; 00433FA6 cmp dword ptr [eax+10],esi #可能是ID 00433FA9 jge short 00433FB0 00433FAB mov eax,dword ptr [eax+8] #右 00433FAE jmp short 00433FB4 00433FB0 mov edx,eax 00433FB2 mov eax,dword ptr [eax] #左 00433FB4 cmp byte ptr [eax+231],0 #判断 00433FBB je short 00433FA6 链表 graph LR a--\u003eb[\"[a+x]\"] --\u003ec[\"[[a+x]+x]\"]--\u003ed[\"[[[a+x]+x]+x]\"] 010A1BE0 cmp dword ptr [edx+C],esi #链表循环 010A1BE3 je short 010A1BF8 010A1BE5 mov edx,dword ptr [edx] #链表循环 010A1BE7 test edx,edx 010A1BE9 jnz short 010A1BE0 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:6","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"转移追踪代码 在call内部栈顶下条件断点 [esp]!=0A2BA8C 或者 [esp]!=0A2BA8C \u0026\u0026 [esp]!=0A12D1D 在call内部被追踪处下条件断点，断点内容和上面的相同也可以。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:7","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"跳出系统领空 在OD内存窗口对X地址下断，游戏暂停在系统领空后，跳出系统领空的方法： 在堆栈中查找X，找到后看是不是程序领空，如果不是的话，ctrl+L继续查找下一个。 如果找到程度领空的话，ctrl+f9返回。跳到第5步。 如果找不到的话，可以在堆栈中搜X省略后两位的数据，看能不能搜到。 实在找不到，就在堆栈里肉眼找相近的地址。（前提是程序领空） 找到后，前往“返回到”对应的地址。看“相近的地址”是第几个参数，加上相应的偏移。每有一个参数就加4 。之后就可以正常逆向了。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:8","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++","任鸟飞"],"content":"汇编实例 x,z,y [[[D0DF1C]+1C]+28]+3C,40,44 #运行时出错 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] fld [ecx+44] #y 入浮点栈 fld [ecx+40] #z fld [ecx+3C] #x fstp [esp] #x 出浮点栈 fstp [esp+4] #z fstp [esp+8] #y 手动建立一个堆栈的结构体 push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] push [ecx+44] #y push [ecx+40] #z push [ecx+3C] #x push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 add esp,0C #堆栈平衡 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:3:0","tags":["C++","任鸟飞"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":" #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } ","date":"2021-08-10","objectID":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/:0:0","tags":["C++"],"title":"输出您电脑上各种数据类型的大小","uri":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/"},{"categories":["C++"],"content":"runoob C++教程 语言中文网C++教程 ","date":"2021-08-08","objectID":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/:0:0","tags":["C++","非官方教程"],"title":"C++非官方教程","uri":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"一、L\"str\" 如 L\"我的字符串\" 表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 strlen(“asd”) = 3; strlen(L\"asd\") = 6; 二、 _T(“str”) _T(“str”)是一个宏，定义于tchar.h下,他的作用是让你的程序支持Unicode编码。 如果定义了UNICODE 那么_T(“ABCD”) 相当于 L\"ABCD\" ，这是宽字符串。 否则_T(“ABCD”) 就等价于 “ABCD” ","date":"2021-08-08","objectID":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","tags":["C++"],"title":"L和_T()的区别","uri":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C++"],"content":"#pragma once 与 #ifndef 解析 为了避免同一个文件被include多次，C/C++中有两种方式，一种是#ifndef方式，一种是#pragma once方式。在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。 方式一： #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 方式二： #pragma once … … // 声明、定义语句 #ifndef的方式受C/C++语言标准支持。它不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。 当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，编译器却硬说找不到声明的状况——这种情况有时非常让人抓狂。 由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。 #pragma once一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。 其好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。大型项目的编译速度也因此提高了一些。 对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。 #pragma once方式产生于#ifndef之后，因此很多人可能甚至没有听说过。目前看来#ifndef更受到推崇。因为#ifndef受C/C++语言标准的支持，不受编译器的任何限制；而#pragma once方式却不受一些较老版本的编译器支持，一些支持了的编译器又打算去掉它，所以它的兼容性可能不够好。一般而言，当程序员听到这样的话，都会选择#ifndef方式，为了努力使得自己的代码“存活”时间更久，通常宁愿降低一些编译性能，这是程序员的个性，当然这是题外话啦。 还看到一种用法是把两者放在一起的： #pragma once #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 看起来似乎是想兼有两者的优点。不过只要使用了#ifndef就会有宏名冲突的危险，也无法避免不支持#pragma once的编译器报错，所以混用两种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑。 选择哪种方式，应该在了解两种方式的情况下，视具体情况而定。只要有一个合理的约定来避开缺点，我认为哪种方式都是可以接受的。而这个已经不是标准或者编译器的责任了，应当由程序员自己或者小范围内的开发规范来搞定。 btw：我看到GNU的一些讨论似乎是打算在GCC 3.4（及其以后？）的版本取消对#pragma once的支持。不过事实上，我手上的GCC 3.4.2和GCC 4.1.1仍然支持#pragma once，甚至没有deprecation warning，倒是GCC2.95会对#pragma once提出warning。 VC6及其以后版本亦提供对#pragma once方式的支持，这一特性应该基本稳定下来了。 ","date":"2021-08-08","objectID":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/:0:0","tags":["C++"],"title":"pragma once与ifndef 解析","uri":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/"},{"categories":["C++"],"content":"待研究项目 ","date":"2021-08-08","objectID":"/2021/08/%E5%BE%85%E7%A0%94%E7%A9%B6/:0:0","tags":["C++","待研究"],"title":"待研究","uri":"/2021/08/%E5%BE%85%E7%A0%94%E7%A9%B6/"},{"categories":["C++"],"content":"跨进程调用CALL ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CreateRemoteThread 创建远程进程 HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, //进程句柄. _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL _In_ SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M _In_ LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址 _In_ LPVOID lpParameter, //线程参数 _In_ DWORD dwCreationFlags, //线程的创建标志 _Out_ LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); ​ 线程的创建标志. 值 含义 0 线程创建后立即运行 CREATE_SUSPENDED 0x00000004 线程创建后先将线程挂起,直到 ResumeThread 被调用. STACK_SIZE_PARAM_IS_A_RESERVATION0x00010000 dwStackSize 参数指定为线程栈预订大小,如果STACK_SIZE_PARAM_IS_A_RESERVATION没有被指定,dwStackSize 参数指定为线程栈分配大小. ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:1","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"DLL注入调用CALL CWinApp::InitInstance 初始化函数（一般用于MFC初始化实例） ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:2:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"C++类与对象 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CEdit类 为Edit控件关联变量 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:1","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CString类 CString 成员函数用法 // CStringA，CStringW CString::GetBuffer //获取字符串地址 char*或者wchar_t* CString::Format格式化函数 //类似printf CString::Empty() //清空 CString::GetLength() //返回字符串长度 字节数 CString::IsEmpty() //判断字符串是否为空 CString::LoadString(资源ID) //加载资源字符串 CDialogEx类 CButton类 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:2","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"C++类的构造函数与析构函数 类成员函数 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:4:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"枚举类型 enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:5:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"extern变量声明 #include \u003ciostream\u003eusing namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:6:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"全局变量和局部变量 全局变量和和局部变量同名时，可通过域名在函数中引用到全局变量，不加域名解析则引用局部变量。 #include\u003ciostream\u003eusing namespace std; int a = 10; int main() { int a = 20; cout \u003c\u003c ::a \u003c\u003c endl; // 10 cout \u003c\u003c a \u003c\u003c endl; // 20 return 0; } 在 VS2013 环境，对全局变量的引用以及重新赋值，直接用全局变量名会出现：count 变量不明确的问题。 在变量名前加上 :: 符号即可。 #include \u003ciostream\u003e using namespace std; int count = 10; //全局变量初始化 int main() { ::count = 1; //全局变量重新赋值 for (;::count \u003c= 10; ++::count) { cout \u003c\u003c\"全局变量count=\"\u003c\u003c ::count \u003c\u003c endl; } return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:7:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:8:0","tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["GitHub"],"content":"图标fontawesome 图标dashgame 留言板disqus 留言板valine 搜索algolia 自动发布travis google分析 sitemaps.xml检查 ghproxy加速站 ","date":"2021-08-07","objectID":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/:0:0","tags":["GitHub","网址整理"],"title":"GitHub网址整理","uri":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/"},{"categories":["Git"],"content":"git使用总结 Git 分布式版本管理系统 Git 命令清单 workspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区(或本地仓库) Remote: 远程仓库 ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 细崽一个项目和它的整个代码历史 $ git clone [url] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"配置 Git 的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每一个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并将这次删除放入暂存区 $ git rm [file1] [file2] # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上一次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有的diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit,并包括指定文件的新变化 $ git commit --amend [file1] [file2] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:4:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，单依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git cleckout -b [branch] # 新建一个分支，并指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并近当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:5:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] ＃新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] ＃提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，并指向某个tag $ git checkout -b [branch] [tag] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:6:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"查看信息 # 显示有变更的文件 $ git status # 显示当前分支的历史版本 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其”提交说明“必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去的5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --short --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:7:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:8:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区与工作区，与上一次commit保持一致,但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针未指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:9:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"其他 # 生成一个可供发布的压缩包 $ git archive ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:10:0","tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"Git pwd 显示当前目录 git init 初始化仓库 ls -ah 查看隐藏文件及目录 git add \u003cfile\u003e 添加文件 git commit -m \u003cmessage\u003e 提交说明 git status 仓库状态 git diff \u003cfile\u003e 查看差别 git log 日志 git reflog 查看命令历史 git reset --hard commit_id 回退 用HEAD表示当前版本 上一个版本就是HEAD^ 上上一个版本就是HEAD^^ 往上100个版本HEAD~100 git rm \u003cfile\u003e 删除 git checkout -- test.txt 恢复 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:1:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"GitHub ssh-keygen -t rsa -C \"youremail@example.com\" 创建SSH Key 登陆GitHub，打开“Account settings”，“SSH Keys”页面。 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 点“Add Key”，你就应该看到已经添加的Key： git remote add origin git@github.com:xinqinew/test.git 本地仓库关联到GitHub仓库 git push -u origin master 首次推送并关联 git push origin master 日常推送 git remote -v 查看远程库信息 git remote rm \u003cname\u003e 与远程库解除关系 git clone git@github.com:xinqinew/test.git 克隆远程库 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:2:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"分支 git branch dev 创建分支dev git switch dev git checkout dev 切换分支dev git switch -c dev git checkout -b dev 创建并切换分支dev git branch 查看当前分支 git merge dev 合并dev分支到当前分支 git branch -d dev 删除dev分支 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:3:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"标签 git tag \u003cname\u003e 创建标签 git tag 查看所有标签 git tag \u003ctagname\u003e f52c633 对历史打标签 git tag -a \u003ctagname\u003e -m \"message\" 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git show \u003ctagname\u003e 查看标签信息 git tag -d \u003ctagname\u003e 删除标签 git push origin \u003ctagname\u003e 推送指定标签 git push origin --tags 推送所有标签 git push origin :refs/tags/\u003ctagname\u003e 删除远程标签 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:4:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"忽略特殊文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class # 不排除.gitignore和App.class: !.gitignore !App.class GitHub官方提供的各种忽略文件配置 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:5:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"参考网站-廖雪峰 git-cheat-sheet.pdf ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:6:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["GitHub"],"content":"首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可)。 等几分钟，等到它显示 “好消息！Cloudflare 正在保护您的站点” 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/:0:0","tags":["GitHub","域名"],"title":"Github绑定Cloudflare及freenom","uri":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/"},{"categories":["GitHub"],"content":"freenom域名申请 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:0:0","tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["GitHub"],"content":"freenom.com设置DNS freenom.com中选择Services-My Domains-\u003eManage Domain 然后选择选择下面的nameservers-\u003ecustom nameservers(enter below) 前面两行分别填入 BROAD.DNSPOD.NET PHONE.DNSPOD.NET 然后点击Change Nameservers 上述操作的意思是,不使用freenom.com的默认DNS,而是授权给DNSpod来处理域名解析 DNSpod设置 进入DNSPOD,实名认证后选择: DNS管理-\u003e我的域名-\u003e添加域名xinqi.cf https://console.dnspod.cn/dns/list 然后点击绿色小按钮右侧的域名xinqi.cf得到 下图: https://console.dnspod.cn/dns/yuchi.ml/record githubpage设置 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:1:0","tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["博客"],"content":"GitHub Pages 不仅不花钱，而且还有免费的证书拿，可以说是相当划算的。但有个问题就是 GitHub 的服务器都部署在海外，也就是说在国内访问本博客的速度的速度会比较慢 (Ping 下来 100 到 200 多毫秒)。 解决这一问题的最优解就是使用 CDN。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:0:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"CDN 是什么？ 内容分发网络（英语：Content delivery network 或 Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。  —— 维基百科 简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。 世界上的 CDN 服务提供商有很多，七牛云、阿里云、腾讯云等等都提供了 CDN 服务，它们有的收费有的部分免费。我今天选择的 CDN 服务来自于 Cloudflare。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:1:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"Why Cloudflare？ Cloudflare 是全球最大的 DNS 服务提供商之一 (号称是全球最快的 DNS 1.1.1.1 就是它们搞的)。除此之外他们还提供 CDN、SSL 证书、DDos 保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。我今天要使用的就是免费版的 SSL 证书以及 CDN 服务。 除了 Cloudflare 比较 NB 以外选择他的另一个更重要的原因是国内的 CDN 无一例外都要要求域名在公安局备过案。作为一个遵纪守法的好市民，我肯定是不怕什么公安局备案的，我主要是觉得太麻烦了。并且在公安局备案后，放到网站上的那个小图标有点丑 ,,Ծ‸Ծ,, ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:2:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"配置 CDN 首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)，有钱也可以选择收费的，提供的服务更多。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可) 等几分钟，等到它显示 Great news! Cloudflare is now protecting your site 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:3:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"设置 SSL 证书 除了免费的 DNS 和 CDN 以外，Cloudflare 还提供了免费的 SSL 证书。 Cloudflare 的 SSL 证书默认是已经开启了的。不过最好还是在 Crypto 页面将 Always Use HTTPS 勾选上，这个选项可以自动在访问你的网站时将所有的 http 的链接重定向到相应的 https 链接上。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:4:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"使用Hugo+LoveIt主题搭建博客 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 Hugo 可参考Hugo 官方的 Quick Start ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装二进制（Mac） # 使用brew安装hugo brew install hugo # 创建新项目（网站） hugo new site my_website # 生成用于发布的静态文件（不包含草稿） hugo # 生成用于发布的静态文件（包括草稿） hugo -D # 本地运行网站 hugo server ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"直接使用 Docker # 创建新项目（网站） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo \\ new site my_website # 生成用于发布的静态文件（不包含草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo # 生成用于发布的静态文件（包括草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo -D # 本地运行网站 docker run --rm -it \\ -v $(pwd):/src \\ -p 1313:1313 \\ klakegg/hugo \\ server 可以在镜像后面增加版本号，指定使用的hugo版本 # 比如 docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo:0.82.0 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 LoveIt 主题 # 位于你的博客项目根目录 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 代码克隆成功后在./themes文件夹下应出现LoveIt文件夹。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"项目文件树结构 . ├── archetypes # markdown文章的模版 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，主要发布这个 ├── resources # 通过hugo命令一起生成的资源文件，暂时不知道什么用 ├── static # 静态文件，比如文章中的图片/视频文件、缩略图等 └── themes # 保存可用的hugo主题 通常，我们只会用到以下几个文件夹的东西 config.toml ：保存 hugo 的配置，包括主题的配置等。详细设置见下方 #网站配置 content：保存网站的各种内容，比如文章。 archetypes： 保存文章的 markdown 模版，通常包括文章的前缀注释，是一些在创建新文章时会被用到。 static ：保存文章中用到的静态文件，比如图片、网站缩略图等。 public ：通过hugo命令生成的静态 html 文件、css、js 等。在服务器上发布时主要发布这个文件夹。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置网站设置 配置文件位置：./config.toml 引用 具体的配置条目参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置缩略图 使用的网站：https://realfavicongenerator.net/ 获取缩略图的各种格式 下载到的全部内容\" 下载到的全部内容 将整个压缩包的文件（包括图片之外的文件）放到./static下 重启浏览器，应该可以看到标签上的缩略图出现了。 浏览器标签出现缩略图\" 浏览器标签出现缩略图 缩略图没生效？ 缩略图未生效的原因可能是浏览器使用了之前的缓存。尝试： 彻底关闭并重启浏览器。 通过这个步骤强制删除缓存。 强制 Chrome 禁用网页缓存。 打开 Chrome 开发者工具。（网页空白处右键-检查，或者按 F12） 在Network栏勾选Disable cache。 或者在设置里找到Preferences -\u003e Network -\u003e Disable cache ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"开始写第一篇文章 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"文章前缀参数 在每篇 markdown 文章最前面可以用一部分注释来告诉LoveIt主题，这篇文章的属性，譬如文章标签、分类、是否为草稿等。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"将文章前缀参数保存在 markdown 模版中 模版文件位置：./archetypes/default.md 我使用的md模版 --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} draft: true tags: [] categories: [] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: \"\" featuredImagePreview: \"\" license: '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' --- ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成新文章 生成新文章的命令： hugo new posts/文章标题.md 执行完成后，在./content/posts目录下应该可以看到新文件，同时里面已经有 markdown 模版中的文章前缀参数。 技巧 也可以手动复制旧文章来生成新文章，不通过命令。 也可以在content文件夹下建新的文件夹，方便管理。这种情况下生成的静态 Html 文件路由效果如下： . └── content └── about | └── index.md // \u003c- https://example.com/about/ ├── posts | ├── firstpost.md // \u003c- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // \u003c- https://example.com/posts/secondpost/ └── quote ├── first.md // \u003c- https://example.com/quote/first/ └── second.md // \u003c- https://example.com/quote/second/ ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:3","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"本地调试 本地调试命令： hugo server --disableFastRender 本地运行网站\" 本地运行网站 出现成功的提示后在浏览器打开http://localhost:1313即可看到网站。 Bug 如果你看到如图的编译错误，可能是因为你的文章除了前缀参数外没有任何内容。随便写几句话就可以解决这个问题。 有文章为空时的编译报错\" 有文章为空时的编译报错 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:4","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 Github 仓库 个人建议创建两个仓库： 一个用于托管博客项目源文件，包括配置文件等包含后续可能配置 API KEY 的东西。设置权限为 Private（不公开） 一个用于托管博客编译后生成的静态 Html 文件(即使用 hugo 命令编译生成的public文件夹)，并配置该仓库使用 Github Pages，然后 Github 就会自动检测到它其中的静态Html文件并搭建网站。设置权限为 Public（公开） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第一个仓库 按照常规方式创建仓库即可，反正设置为private权限等级，也没人看得见。 第一个仓库示例，保存博客源代码\" 第一个仓库示例，保存博客源代码 链接本地仓库与远端仓库 ## 位于博客源代码根目录 ## 初始化本地Git仓库 git init ## 设置名为Origin的远端Git仓库 git remote add origin {{这里替换成你的仓库在Github Clone用的地址}} ## 选择所有文件 git add -A ## Push到github git push -u origin master 创建.gitignore 在源代码项目中创建.gitignore文件，来防止把生成的静态文件上传。创建位置如下： . ├── .git ├── .github ├── .gitignore \u003c---- 在根目录下 ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes 在.gitignore中写入/public，来防止 Git 将其上传。 cat .gitignore ## 输出 /public ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第二个仓库 创建仓库，注意名称 第二个仓库名字比较重要，必须是{{你的github用户名}}.github.io。 比如我的 Github 名字为JellyZhang,那么我需要创建的仓库名称为JellyZhang.github.io，如图所示。 第二个仓库示例（注意仓库名称与自己用户名对应）\" 第二个仓库示例（注意仓库名称与自己用户名对应） 在仓库设置里设置启用Github Pages 找到仓库设置\" 找到仓库设置 找到Pages一栏\" 找到Pages一栏 设置Branch与静态文件位置\" 设置Branch与静态文件位置 这个地方设置Branch为master，静态文件位置为/(root)，原因是我们在下个步骤中会直接将生成的public文件夹中的内容push到master分支的/目录下。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"给源代码仓库添加 Github Action ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 CI 脚本 什么是Github Action? Github Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 在源代码项目根目录下新建.github/workflow/main.yml。(通过 Github Action 网页端操作也可以) . ├── .git ├── .github │ └── workflows │ └── main.yml \u003c---在这里创建 ├── .gitignore ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes main.yml脚本内容： # This is a basic workflow to help you get started with Actionsname:CI# Controls when the action will run.on:# Triggers the workflow on push or pull request events but only for the master branchpush:branches:[master]pull_request:branches:[master]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Hugo setup# You may pin to the exact commit or the version.# uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2euses:peaceiris/actions-hugo@v2.4.13with:# The Hugo version to download (if necessary) and use. Example: 0.58.2hugo-version:latest# optional, default is latest# Download (if necessary) and use Hugo extended version. Example: trueextended:true# optional, default is false- name:Buildrun:hugo- name:Pushes to another repositoryuses:cpina/github-action-push-to-another-repository@masterenv:API_TOKEN_GITHUB:${{ secrets.API_TOKEN_GITHUB }}with:source-directory:\"public\"destination-github-username:\"这里输入你的Github用户名\"destination-repository-name:\"这里输入你的Github用户名.github.io\"user-email:这里输入你的Github邮箱 需要自定义的部分 注意on里的 branch 是否和自己的相同，因为现在 Github 默认分支为 main。 同时最后三行内容需要自行替换。 脚本主要做了以下事情： 创建一个 Hugo 环境 使用 hugo 命令编译代码，产生 public 文件夹 将 public 文件 push 到你的Github用户名.github.io仓库。（也就是你之前创建的第二个仓库） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"设置 Push 用的密钥 为了让 Github Action 脚本有权限将代码 Push 到我们的xx.github.io仓库，我们需要申请一个密钥并告诉它。在 Github 设置中找到Developer settings/Personal access tokens 个人密钥设置界面\" 个人密钥设置界面 新建一个密钥，权限设置把Repo打勾。 新建密钥\" 新建密钥 回到第一个仓库的设置里，选择Secrets（密钥） 仓库密钥设置\" 仓库密钥设置 新建密钥，将刚才生成的个人密钥填进去，名字设为API_TOKEN_GITHUB(跟 CI 脚本里的名称对应即可) 新建仓库密钥\" 新建仓库密钥 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"观察效果 在 Push 新修改到第一个仓库后，在Action界面可以看到新的workflow开始运行了。 第一个仓库workflow界面（图中已经完成）\" 第一个仓库workflow界面（图中已经完成） 在workflow结束后，可以在第二个仓库看到新的Push 第二个仓库自动push了新的静态页面\" 第二个仓库自动push了新的静态页面 在等待 1-2 分钟后，即可在xx.github.io观察到变化。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:3","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置评论系统 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"GitTalk GitTalk是基于 github 的 repo issues 作为数据库来存储评论的。 Love-It主题集成了GitTalk ，需要使用的话只需要在config.toml里填写指定信息就可以了。 首先要去Github -\u003e Settings -\u003e Developer Settings -\u003e OAuth App 里注册一个新的 OAuth App 来给 Gitalk 使用。 两个 Url 填自己博客的地址就行。 注册OAuth App\" 注册OAuth App 修改config.toml: [params.page.comment] enable = true \u003c-- 启用评论系统 ... [params.page.comment.gitalk] enable = true owner = \"JellyZhang\" \u003c-- Github用户名 repo = \"blog-comment\" \u003c-- 用来存放评论的repo名称 clientId = \"\" \u003c-- 申请好的OAuth的ClientId clientSecret = \"\" \u003c-- 申请好的OAuth的ClientSecret 升级Gitalk来防止403问题 Gitalk 1.6.2版本 存在一个自身 Bug，它里面用到了一个链接来依赖某个下游，而事实上这个链接是 demo 演示用的，已经因为滥用被取消了，所以需要将 LoveIt 主题使用的 1.6.2 版本改成1.7.2 修改./themes/LoveIt/assets/data/cdn/jsdelivr.yml中的Gitalk的链接： ...metingJS:meting@2.0.1/dist/Meting.min.js# gitalk@1.6.2 https://github.com/gitalk/gitalkgitalkCSS:gitalk@1.7.2/dist/gitalk.min.css \u003c-- 改为1.7.2gitalkJS:gitalk@1.7.2/dist/gitalk.min.js \u003c-- 改为1.7.2# valine@1.4.14 https://valine.js.org/valineJS:valine@1.4.14/dist/Valine.min.js... 在本地环境看不到生效？ 评论系统在本地运行时不生效，需要 publish 后查看效果。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置搜索系统 LoveIt集成了两种搜索引擎，Lunr和algolia。 两种搜索引擎的区别 参考LoveIt 官方文档 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 我这里记录algolia的配置方法。 首先需要在配置文件中新增Outputs的JSON类型，用于产生index.json文件来提供给搜索引擎。 config.toml: [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] 设置后，在使用hugo命令编译后应该可以在public文件夹下找到index.json 之后在algolia注册账号并创建一个application与index: 创建application, freePlan一般够用\" 创建application, freePlan一般够用 然后在API Keys里找到appID和searchKey: 在API Keys里找到appId与searchKey\" 在API Keys里找到appId与searchKey config.toml: [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"\" \u003c--- 你创建的index的名字 appID = \"\" \u003c--- Application ID searchKey = \"\" \u003c--- Search-Only API Key 然后可以上传生成的index.json到 algolia 来生成索引，实现搜索功能。 手动上传index.json的方法\" 手动上传index.json的方法 当然，每次生成完上传index.json未免太过麻烦，况且我们还是用Github Action来自动编译的，因此接下来我们让Github Action来帮我们上传index.json到algolia。 首先生成一个 Admin API Key 用于调用 API 来上传 index.json: 生成Admin API Key\" 生成Admin API Key 然后修改我们的Github Action的脚本： 在`main.yml`末尾加上：- name:Algolia Index Uploader# You may pin to the exact commit or the version.# uses: rxrw/algolia-index-uploader@294d1d600c4a2197a64903b6161cc80acea1becbuses:rxrw/algolia-index-uploader@v1with:# Your Algolia IndexPathindex_path:public/index.json \u003c-- 生成的index.json位置，默认即可# Algolia Index Idalgolia_index_id:XXXXXXXXX \u003c-- 你的indexId, 即之前获得的`application ID`# Algolia Index Namealgolia_index_name:XXXX \u003c--- 你创建的index名字# Algolia Admin Keyalgolia_index_admin_key:XXXXXXXXXXXX \u003c--- 上图中获取的admin Key 之后运行脚本即可在algolia在 dashboard 里看到新增的记录。 algolia新增了record\" algolia新增了record 删除文章后需要删除旧Record 每次上传的记录是增量的，意味着不会清除旧的记录。 因此如果删除了发布过的旧文章，需要手动去algolia网站上清理相关的 Object。（也可以使用 Clear 功能全部清除） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:10:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Analytics 网站分析 Google analytics是将用户的动作行为收集后发送到 Google，交由 Google 进行统计与分析，形成看板。 在Google analytics创建媒体资源 –\u003e 添加数据流 –\u003e 网站，之后在数据流详情里获取到衡量ID: 获取衡量ID\" 获取衡量ID 之后可以在Dashboard里查看网站的用户行为，有很多内容可以慢慢探索。 Google analytics Dashboard\" Google analytics Dashboard ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:11:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Search Console 首先确定自己的站点地图有正常生成。打开/sitemap.xml链接： sitemap\" sitemap 之后在Google Search Console里填写自己站点地图的链接，可以帮助谷歌爬虫了解网站结构。 上传sitemap\" 上传sitemap 显示`无法获取`? 事实上是没有问题的，谷歌可能有点延迟。可以在bing webmaster tool 导入 Google 的设置，可以看到 bing 是可以立即获取的。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:12:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"参考文献 LoveIt 官方文档 Hugo 官方文档 刷新 Chrome 缓存 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:13:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"欢迎留言！😄 ","date":"2021-08-04","objectID":"/message-board/:0:0","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["博客"],"content":"Hugo使用algolia搜索 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:0:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"背景 在将hexo迁移到hugo后我就开始折腾博客搜索了，下面的配置正对loveit主题配置 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:1:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"开启algolia搜索 在config.toml中添加下面字段，xxxxx是必填，你可以参考loveit主题中的config.toml # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] # algolia注册的索引名称 index = \"xxxxx\" # 在你注册完成后，点击API Keys就能看见下面的参数 appID = \"xxxxx\" searchKey = \"xxxxx\" ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:2:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"自动提交索引到algolia 又又用到了npm,好在集成到travis中眼不见为净。 在config.toml同级目录下运行npm init，一路回车即可。 修改npm int生成的package.json添加下面字段 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在config.toml同级目录添加.env文件并添加下面字段 ❯ cat .env ALGOLIA_APP_ID=U9QMQ70DKL ALGOLIA_INDEX_NAME=gaojila.github.io ALGOLIA_INDEX_FILE=public/index.json 修改.travis.yml文件如下 language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装搜索插件- npm install atomic-algolia --save-devscript:# 运行hugo命令- hugo# 生成索引命令- echo \"ALGOLIA_ADMIN_KEY=$ALGOLIA_ADMIN_KEY\" \u003e\u003e .env- npm run algoliaafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 在travis中添加变量$ALGOLIA_ADMIN_KEY ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:3:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"参考链接 aligolia的其他配置可以看下面的链接 dreamsafari.info nashome.cn ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:4:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"Hugo使用travis自动发布","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Hugo使用travis自动发布 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"背景 从hexo迁移到hugo后，发布博客开始变的繁琐，没有hexo -d这样的快捷部署，但是好在有travis这样的免费CI平台，在使用travis来部署博客的确快捷了很多，只需要发布源码即可。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:1:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Github获取token 记下 Token 的值 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:2:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"设置Travis CI 使用github帐号注册一个travis帐号，登录在hugo仓库上打上，然后再点击setting然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:3:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"编写.trabis.yml language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.debscript:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 hugo 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色代表正在部署 红色 代表部署失败 灰色 代表部署被取消 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:4:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"相关文章 使用 Travis CI 自动部署 Hugo 博客 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:5:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"通过 Travis CI 来部署 Hugo 或者 Hexo 博客可能在配置的时候会麻烦一点，但配置好后确实是方便了不少。特别是对于 Hugo 这种没有部署插件的静态网站生成器，只能手动部署到 GitHub。 网上有很多关于用 Travis 自动部署 Hexo 的文章，却没看到几篇关于 Hugo，虽然原理都差不多，但细节上还是有很多容易让小白头疼的地方，所以今天我就来教教如何用 Travis 来自动部署 Hugo。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:0:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"正文 废话不多说，我们开始吧！ ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置代码仓库 首先确保你的 GitHub 上有这两个仓库：用来部署博客的 [用户名].github.io 和 用来存放 “源码” 的 Blog 这里与别的使用 Travis 自动部署博客教程稍微有点不同，别人家大多上将博客的源码放在 [用户名].github.io 的分支上，而不是向我一样开两个仓库 开两个仓库的好处有： 结构更清晰。与博客相关的内容都在 Blog 仓库里， [用户名].github.io 只用来提供一个 GitHub Pages 的服务 「源码」存放在 master 分支下，clone 更快 我不知道上我的原因还是 GitHub 或是 Git 的原因，我从 GitHub clone 除 master 分支以外的分支时，下载速度贼慢，只有几百 kb 每秒，clone 一个 「源码」 都至少要半个多小时 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:1","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"申请 Token 然后要去 GitHub 上申请一个新的 personal access token。 Token description 也就是 Token 的名字，可以随便填。然后一定要勾选上 repo 上的所以项目，然后别的项目一个都不要选。点 Generate token 生成 Token。 然后记下 Token 的值，也就是我打码的那一部分 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:2","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置 Travis CI 接着来到 Travis CI，使用 GitHub 帐号登录；然后为 Blog 仓库打上 ☑，然后点 setting。 然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击 Add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:3","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"编写 .travis.yml 在 Blog 的目录下创建并编辑一个 .travis.yml 文件。这个文件的作用是告诉 Travis CI 如何部署你的博客的 language:gogo:- \"1.8\"# 指定Golang 1.8# Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建# branches:# only:# - masterinstall:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.51/hugo_0.51_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装主题- git clone [你使用的主题的 Git 地址]script:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[你的名字]\"- git config user.email \"[你的邮箱]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:[用来部署博客的 Git 地址]deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 Copy 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 Blog 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色 代表正在部署 红色 代表部署失败 灰色 代表部署被取消 然后再去你的博客，如果没有出什么偏差的话就说明部署成功了 | ・ω・’） 以后的话就只需要把写好的文章推送到 Blog 仓库 下就可以了，就不需要再自己编译然后手动推送了 甚至连 Hugo 都可以不要装 | ・ω・’） ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:4","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"附录 以及一些坑 (:з)∠) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"添加 .gitignore 文件 在 Hugo 本地编译时会产生 public 文件夹，但是这个文件夹中的内容对于 Blog 仓库 来说是不需要的 (包括用来存放主题的 themes 文件夹和主题产生的 resources 文件夹也是不需要的) 我们可以用一个.gitignore 文件来排除这些内容 在 Blog 目录下创建并修改 .gitignore，然后提交到 GitHub public/* themes/* resources/* Copy ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:1","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"Travis CI 的分支白名单 我给你的 .travis.yml 文件中有怎么一段 # Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建branches:only:- master Copy 这一段的作用是限制触发构建的分支。这在正常开发中是很重要的配置，特别是在团队 (多人) 开发的场景中。 不过这里不存在这个场景，并且如果配置错了会出很大的问题，很容易坑到小白， 比如说我 (:з)∠) 所以默认就给注释掉了。 如果你晓得这是干啥的，并且觉得有必要的话，可以考虑开启 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:2","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"相关文章 使用 Hugo + GitHub Pages 搭建个人博客 为 Hugo 添加谈笑风生区 (Gitalk) 为 Hugo 博客添加字数统计 Leavelt 主题优化 为博客添加独立域名 为博客添加免费的 CDN (Cloudflare) 为 LeaveIt 主题添加阅读进度条 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:3:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":null,"content":"模板 ","date":"2021-08-04","objectID":"/2021/08/md%E6%A8%A1%E6%9D%BF/:0:0","tags":["GitHub","博客"],"title":"md模板","uri":"/2021/08/md%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"万能代码安装说明 将以下代码放置在您希望 Disqus 加载的地方： \u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e \u003cscript\u003e /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://xinqinew.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); \u003c/script\u003e \u003cnoscript\u003ePlease enable JavaScript to view the \u003ca href=\"https://disqus.com/?ref_noscript\"\u003ecomments powered by Disqus.\u003c/a\u003e\u003c/noscript\u003e （推荐）使用您的 CMS 或平台的动态值编辑推荐的配置变量部分。 请参阅我们的文档以了解为什么定义标识符和 url 对防止重复线程很重要。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:1:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"如何显示评论计数 在网站关闭\u003c/body\u003e标签之前放置以下代码： \u003cscript id=\"dsq-count-scr\" src=\"//xinqinew.disqus.com/count.js\" async\u003e\u003c/script\u003e 将 #disqus_thread 附加到链接中的 href 属性。 这将告诉 Disqus 查找哪些链接并返回评论计数。 例如：\u003ca href=\"http://foo.com/bar.html#disqus_thread\"\u003eLink\u003c/a\u003e ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:2:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"设置完成！ 恭喜你，你安装完Disqus！这里有几页可以帮助您开始使用Disqus。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:3:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo 最终还是投入Hugo的怀抱，原因是： 熟悉和欣赏Go 发现一个超级喜欢的Hugo主题 - LoveIt 本文记录下博客从Jekyll迁移到Hugo的过程。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:0:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"创建项目 安装Hugo sudo pacman -S hugo 创建名称为Demo的新项目 hugo new site Demo 添加主题（此为必需步骤，可以选择其他主题） cd Demo \u0026\u0026 git init \u0026\u0026 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 也可以自行下载主题，放置于 Demo/themes 目录下 但作为submodule添加进Git项目是一个更好的方式 创建示例文章 hugo new posts/first.md 产生的文件位于是 Demo/content/posts/first.md 启动Hugo服务 hugo server 本地预览访问 http://localhost:1313/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:1:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"文章迁移 hugo import jekyll /Volumes/video/GitHub/xinqinew.github.io /Volumes/video/GitHub/Eureka2 Hugo提供了迁移命令import，可以方便地将Jekyll项目转换为Hugo项目，包括文章和其他静态资源文件。 命令格式是hugo import jekyll JEKYLL_ROOT_PATH TARGET_PATH，其中 JEKYLL_ROOT_PATH 是Jekyll项目主目录，TARGET_PATH 是新生成的Hugo项目目录。 以我的一篇文章为例，原Jekyll项目中的位置是 _post/2020-07-29-cpp-template-notes.md，Hugo项目中的位置是 content/post/2020-07-29-cpp-template-notes.md，需要注意的是，迁移前后文件名保持一致，划重点后面用到。 Jekyll Front Matter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- Hugo Front Matter ---categories:- 编程语言date:\"2020-07-29T00:00:00Z\"tags:- C++- Templatetitle:C++类与模板--- 同时需要注意，Jekyll和Hugo在FrontMatter变量的定义有区别，划重点。 Jekyll Hugo date post文件名或FrontMatter指定，FrontMatter重写前者 FrontMatter指定 title post文件名指定 FrontMatter指定，即文章标题 filename N/A 即文件名（不包含扩展名） section N/A content下的目录名 以 2020-07-29-cpp-template-notes.md 为例， 对于Jekyll，date是 2020-07-29，title是 cpp-template-notes； 对于Hugo，date是 2020-07-29，title是 C++类与模板，filename是 2020-07-29-cpp-template-notes。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:2:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"URL规则 URL规则在全局配置文件（config.toml）的 permalinks 进行配置，也可以使用文章HugoFrontMatter的 url 变量指定（优先级高于前者）。 需要保证，无论URL规则是否变化，都能通过原始URL访问到文章。 对于迁移后的三种情形： 保持原有URL规则 如果原Jekyll的permalink配置使用 title 变量，相应地在Hugo下使用 filename 变量，由于迁移前后文件名保持一致，这将破坏原有的URL规则，可以采取两个方案： 使用HugoFrontMatter的 url 变量指定原始URL 去除迁移后文件名的date部分 个人采用第一种，因为通过文件名可以区分哪些是迁移前的文章。 老文章保持原有URL规则，新文章采用新的URL规则 老文章使用HugoFrontMatter的 url 变量指定原始URL，新文章采用全局 permalinks 配置，这种方式实现起来最简单，但URL规则不统一，看着很不规范，不推荐！ 采用新的URL规则 如果原Jekyll的permalink配置使用 title 变量，使用HugoFrontMatter的 url 变量指定新URL； 使用HugoFrontMatter的 aliases 变量指定原始URL，实现页面重定向。 对于我的博客，原Jekyll的URL规则是 permalink:/:year/:month/:day/:title 在Hugo下使用了新的URL规则 [permalinks]posts = \"/:section/:year/:month/:day/:filename/\" JekyllFrontMatter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- HugoFrontMatter ---title:C++类与模板categories:- 编程语言tags:- C++- Templatedate:2020-07-29 00:00:00+08:00url:/posts/2020/07/29/cpp-template-notes/aliases:- /2020/07/29/cpp-template-notes/--- Hugo import命令无法满足我的场景，而且HugoFrontMatter变量按照首字符顺序排序，看着实在难受，本着轮子能造就造的原则，写了一个转换工具，仅对_posts下文章进行转换，有需要可以尝试下，项目地址是 https://github.com/caosiyang/convert-jekyll-to-hugo ，嗯，这个硬广阔以：） ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:3:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"GitHub Pages发布 执行hugo命令，在 public 目录下生成静态网站，push里面的内容到github就可以了。 Hugo官方提供的方案是submodule方式，如下： $ rm -rf public $ git submodule add -b master https://github.com/\u003cUSERNAME\u003e/\u003cUSERNAME\u003e.github.io.git public $ hugo 发布新的Hugo页面时遇到了问题，顺便说一下吧。 之前我的博客项目已经托管在GitHub，我把原repo重命名了（暂且称“A\"），新建一个repo（暂且称为“B”），名字是.github.io，然后push页面，之后浏览，“首页/分类/标签/关于”页面都是正常的，而“文章”页面还是原始的Jekyll生成的页面，初以为是缓存问题，过了一晚还这样，怀疑跟A有管，把A删除，问题仍然存在，之后又把B删除，重新建repo和push，恢复正常。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:4:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"博客历程回顾 最初产生写博客的想法是2011年，试用了当时几个流行的技术博客平台（csdn/cnblogs/cppblog），最终选择了cnblogs。 2015年了解到GitHub Pages可以搭建博客，当时已经在用GitHub，所以不假思索地转过去，使用Jekyll搭建了新博客，看了很多主题，选了一个并进行小改，但并不满意，最后抱着学习前端的想法，自己写了一个相当相当粗糙的主题，凑合用着了。 后来先后了解到Hexo和Hugo，同为热门的静态网站生成工具，前者node.js实现，后者Go实现，看过它们的主题，感觉都比Jekyll的好看，也很玄学，但迟迟没有折腾，现在想来，能坚持更博就不错了。 2020年是不平凡的一年，新冠疫情爆发，我的工作生活发生了很大变化，在一段闲暇的日子里，又开始琢磨博客，在看到一个相当中意的Hugo主题，坚定了我转到Hugo的决心，于是有了现在的博客。 参考文档 https://gohugo.io/tools/migrations/ https://gohugo.io/commands/hugo_import_jekyll/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:5:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"安装Lovelt博客","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Lovelt博客 下载地址 安装文档 参考-晓的记忆 LoveIt参考站2 LoveIt参考站3 LoveIt参考站4 参考1 参考2 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"1 准备 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2 安装 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.1 创建你的项目 hugo new site LoveIt cd LoveIt ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.2 安装主题 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt git submodule add https://ghproxy.com/https://github.com/dillonzq/LoveIt.git themes/LoveIt # 代理 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:2","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:3","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:4","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:5","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:6","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3 配置 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"google搜索优化 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源，如https://skyao.io/learning-hugo/。会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。 进入资源页面，点\"索引\"下的\"站点地图\"，在\"添加新的站点地图\"处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://skyao.io/learning-hugo/sitemap.xml。 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客 http://themes.jekyllrc.org/ https://jekyllthemes.io/ jekyll-rtd-theme minimal-mistakes/ flexible-jekyll ","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装先决条件 在 Mac 和 Windows 上，下载并安装Docker Desktop。在 Linux 上，安装Docker 引擎和Docker compose。 安装可能需要您重新启动计算机以使更改生效。 安装 git。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从文档示例模板创建存储库 文档示例存储库提供了一个基本的站点结构，您可以将其用作创建自己文档的起点。 使用docsy-example模板 创建自己的存储库。 通过克隆新创建的存储库，将代码下载到本地机器。 将工作目录更改为新创建的文件夹： cd docsy-example ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"构建并运行容器 文档示例存储库包括一个Dockerfile，可用于运行站点。 构建docker镜像： docker-compose build 运行已构建的图像： docker-compose up 在网页浏览器中打开地址http://localhost:1313以加载文档示例主页。您现在可以对源文件进行更改，这些更改将在浏览器中实时重新加载。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"清理 要清理系统并删除容器映像，请按照以下步骤操作。 使用Ctrl + C停止Docker作曲。 移除生成的图像 docker-compose rm ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装docsy主题","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装docsy主题 下载并安装npm ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:0:0","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:0","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"作为npm模块 您可以npm使用hugo-bin. 这会添加hugo-bin到您的node_modules文件夹并将依赖项添加到您的package.json文件中。要安装 Hugo 的扩展版本： npm install hugo-extended --save-dev ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:1","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装 PostCSS 要构建或更新站点的 CSS 资源，您还需要PostCSS创建最终资产。如果您需要安装它，您必须在您的机器上安装最新版本的NodeJS，以便您可以使用npmNode 包管理器。默认情况npm下，在您运行的目录下安装工具npm install： sudo npm install -D autoprefixer sudo npm install -D postcss-cli ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:2","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"选项 1：复制 Docsy 示例站点 该示例站点为您提供了一个很好的起点构建您的文档的网站，并预先配置为使用Docsy主题为Git的子模块。您可以通过以下方式复制示例站点： 使用 GitHub 用户界面 使用命令行 使用 GitHub 用户界面 这是最简单的方法，因为 Docsy 示例站点存储库是一个模板存储库。要创建您自己的 Docsy 示例站点存储库副本： 转到repo 页面并单击Use this template。 在存储库名称字段中输入您为新存储库选择的名称。您还可以添加可选的Description。 单击从模板创建存储库以创建新存储库。恭喜，您现在拥有一个 Docsy 站点存储库！ 要使用 Hugo 在本地测试您复制的站点，或进行本地编辑，您还需要制作新存储库的本地副本。为此，请使用git clone, 替换https://github.com/my/example.git为您的存储库的网址（不要忘记使用，--recurse-submodules否则您将不会下拉生成工作站点所需的一些代码）： cd /Volumes/video/GitHub/Hugo git clone --recurse-submodules --depth 1 https://github.com/xinqinew/Docsy.git //git clone --recurse-submodules --depth 1 https://ghproxy.com/https://github.com/xinqinew/Docsy.git cd Docsy hugo server 您现在可以编辑站点源文件的本地版本。要预览您的站点，请转到站点根目录并运行hugo server（请参阅 MacOS 上的已知问题）。默认情况下，您的站点将在 http://localhost:1313/ 上可用。要将更改推送到您的新存储库，请转到您的站点根目录并使用git push. ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:3","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 错误：too many open files或fatal error: pipe failed 默认情况下，MacOS 允许少量打开的文件描述符。对于较大的站点，或者当您同时运行多个应用程序时，当您运行hugo server以在本地预览站点时，您可能会收到以下错误之一： POSTCSS v7 及更早版本： ERROR 2020/04/14 12:37:16 Error: listen tcp 127.0.0.1:1313: socket: too many open files POSTCSS v8 及更高版本： fatal error: pipe failed 解决方法 暂时允许更多打开的文件： 通过运行查看您当前的设置： sudo launchctl limit maxfiles 65535通过运行以下命令增加对文件的限制。如果您的站点文件较少，您可以选择设置较低的软 ( 65535) 和硬 ( 200000) 限制。 sudo launchctl limit maxfiles 65535 200000 ulimit -n 65535 sudo sysctl -w kern.maxfiles=200000 sudo sysctl -w kern.maxfilesperproc=65535 请注意，您可能需要为每个新 shell 设置这些限制。 详细了解这些限制以及如何使它们永久化。 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:4","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装Eureka博客","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Eureka博客 官方文档 cd /Volumes/video/GitHub/Eureka git init git submodule add https://github.com/wangchucheng/hugo-eureka.git themes/eureka 切换版本方法如下: cd themes/eureka git checkout v0.8.2 #git checkout \u003ceureka_version\u003e #eureka_version 替换成版本号 接下来，将exampleSite中的config文件夹复制到项目根目录下，对config文件夹的内容进行配置。配置后删除原先的config.toml文件即可。 如果你是新建的Hugo项目，content文件夹下默认没有内容。你可以将exampleSite中的content文件夹复制到项目根目录下预览主题效果。 完成以上步骤后使用以下命令即可在浏览器中预览项目： hugo server 草稿不会被Hugo部署，所以你需要将内容头部的draft属性设为false或使用hugo server -D预览网站。 内容管理 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"目录结构 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文章页 文章内容为Eureka默认的文章结构，因此新建文章页时不需指定其类型。 hugo new posts/\u003cyour_post.md\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文档页 新建文档页时需指定其类型为docs。 hugo new -k docs docs/\u003cyour_doc\u003e/\u003cyour_page.md\u003e 如果你此前没有创建过文档类型的内容，你需要先生成文档列表： hugo new -k docs docs ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建作者页 新建作者页时需指定其类型为authors。 hugo new -k authors authors/\u003cyour_author\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:3","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言"],"content":"植物大战僵尸","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":["易语言"],"content":"植物大战僵尸 .版本 2 .程序集 窗口程序集_启动窗口 .程序集变量 process, 整数型 .程序集变量 BaseAddress, 整数型 .程序集变量 setoff1, 整数型 .程序集变量 setoff2, 整数型 .程序集变量 PlantAddress, 整数型 .程序集变量 ZombiesAddress, 整数型 .程序集变量 图像x, 整数型 .程序集变量 图像y, 整数型 .程序集变量 真实x, 整数型 .程序集变量 真实y, 整数型 .子程序 _选择框_不消耗阳光_被单击 .如果 (选择框_不消耗阳光.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“90 90”)) .否则 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“2b f3”)) .如果结束 .子程序 __启动窗口_创建完毕 process ＝ 进程_取进程句柄 (“PlantsVsZombies.exe”) BaseAddress ＝ 内存_读整数型 (process, 十六到十 (“6aa00c”)) ' 基址 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) ' 一级偏移 PlantAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“ac”)) ' 植物 ZombiesAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“90”)) ' 僵尸 时钟_监视进程.时钟周期 ＝ 3000 按钮割草机CALL.禁止 ＝ 真 .子程序 _按钮_阳光9999_被单击 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) 内存_写整数型 (process, setoff1 ＋ 十六到十 (“5560”), 9999) .子程序 _选择框_无冷却_被单击 .如果 (选择框_无冷却.选中 ＝ 真) 时钟1.时钟周期 ＝ 1000 .否则 时钟1.时钟周期 ＝ 0 .如果结束 .子程序 _时钟1_周期事件 .局部变量 onePlant, 整数型 .局部变量 Index, 整数型 .局部变量 setoffPlant, 整数型 setoffPlant ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .计次循环首 (10, Index) ' onePlant ＝ 内存_读整数型 (process, setoffPlant+十六到十(\"4c\") ＋ (Index － 1) × 80) 内存_写整数型 (process, setoffPlant ＋ 十六到十 (“4c”) ＋ (Index － 1) × 80, 5000) ' 无冷却 .计次循环尾 () .子程序 _选择框_无冷却1_被单击 .如果 (选择框_无冷却1.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“E9 CB 6B 2A 00 90 90”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“C7 47 24 88 13 00 00 83 47 24 01 8B 47 24 E9 24 94 D5 FF”)) .否则 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“83 47 24 01 8B 47 24”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00”)) .如果结束 .子程序 _选择框_自动收集_被单击 .如果 (选择框_自动收集.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 01”)) .否则 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 00”)) .如果结束 .子程序 _选择框_子弹叠加_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“90 90 90 90 90 90”)) .否则 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“0F 85 98 FE FF FF”)) .如果结束 .子程序 _按钮_更改卡槽_被单击 .局部变量 setoffxxx, 整数型 setoffxxx ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .如果真 (卡槽组合框.现行选中项 ＝ 0) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 1) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 2) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 18) .如果真结束 .如果真结束 .子程序 _按钮_种植CALL_被单击 asm_置代码 () asm_pushad () asm_push (-1) ' 固定-1 asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID asm_mov_eax_常数 (到整数 (编辑框_y.内容)) ' Y asm_push (到整数 (编辑框_x.内容)) ' X asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) asm_push_ebp () ' ebp asm_mov_ebx_常数 (十六到十 (“40d120”)) asm_call_ebx () ' call asm_popad () asm_ret () asm_调用函数2 (process, asm_取代码 ()) .子程序 _按钮_乱种CALL1_被单击 .局部变量 坐标x, 整数型 .局部变量 坐标y, 整数型 .局部变量 index1, 整数型 .局部变量 index2, 整数型 .局部变量 index3, 整数型 坐标x ＝ 0 坐标y ＝ 0 .计次循环首 (3, index3) .如果 (index3 ＝ 1) 编辑框_植物ID.内容 ＝ “38” .否则 .如果 (index3 ＝ 2) 编辑框_植物ID.内容 ＝ “40” .否则 编辑框_植物ID.内容 ＝ “43” .如果结束 ​ .如果结束 ​ .计次循环首 (6, index1) ​ .计次循环首 (6, index2) ​ asm_置代码 () ​ asm_pushad () ​ asm_push (-1) ' 固定-1 ​ asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID ​ asm_mov_eax_常数 (坐标y ＋ index1 － 1) ' Y ​ asm_push (到整数 (坐标x ＋ index2 － 1)) ' X ​ asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) ​ asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) ​ asm_push_ebp () ' ebp ​ asm_mov_ebx_常数 (十六到十 (“40d120”)) ​ asm_call_ebx () ' call ​ asm_popad () ​ asm_ret () ​ asm_调用函数2 (process, asm_取代码 ()) ​ .计次循环尾 () ​ .计次循环尾 () .计次循环尾 () .子程序 _选择框_重叠种植_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 ","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/:0:0","tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":null,"content":"知识点描述","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"知识点 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"小知识 ptr 强制类型转换 lea 指令可以用来将一个内存地址直接赋给目的操作数，例如： lea eax,[ebx+8] 就是将ebx+8这个值直接赋给eax mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。 通用寄存器 32 位 16 位 8 位（高） 8 位（低） EAX AX AH AL EBX BX BH BL ECX CX CH CL EDX DX DH DL 32 位 16 位 32 位 16 位 ESI SI EBP BP EDI DI ESP SP 特殊用法 乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。 CPU 默认使用 ECX 为循环计数器。 ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。 ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。 高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。 状态标志位 进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。 溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。 符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。 零标志位（ZF），算术或逻辑操作产生的结果为零时，设置该标志位。 辅助进位标志位（AC），算术操作在 8 位操作数中产生了位 3 向位 4 的进位时，设置该标志位。 奇偶校验标志位（PF），结果的最低有效字节包含偶数个 1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行 错误检测。 64位通用寄存器 操作数大小 可用寄存器 8 位 AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L 16 位 AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W 32 位 EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D 64 位 RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15 整数常量 h 十六进制 r 编码实数 q/o 八进制 t 十进制（备用） d 十进制 y 二进制（备用） b 二进制 26 ;十进制 26d ;十进制 11010011b ;二进制 42q ;八进制 42o ;八进制 1Ah ;十六进制 0A3h ;十六进制 整型常量表达式 运算符 名称 优先级 () 圆括号 1 +,- 一元加、减 2 *, / 乘、除 3 MOD 取模 3 +, - 加、减 4 保留字列表。 $ PARITY? DWORD STDCALL ? PASCAL FAR SWORD @B QWORD FAR16 SYSCALL @F REAL4 FORTRAN TBYTE ADDR REAL8 FWORD VARARG BASIC REAL10 NEAR WORD BYTE SBYTE NEAR16 ZERO? C SDORD OVERFLOW? CARRY? SIGN? 定义段 .DATA 伪指令进行标识： .data .CODE 伪指令标识的程序区段包含了可执行的指令： .code .STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小： .stack 100h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令 一条指令有四个组成部分： 标号（可选） 指令助记符（必需） 操作数（通常是必需的） 注释（可选） 不同部分的位置安排如下所示： [label: ] mnemonic [operands] [;comment] ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"标号 数据标号 count DWORD 100 代码标号 target: mov ax,bx ... jmp target ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:1","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令助记符 助记符 说明 助记符 说明 MOV 传送（分配）数值 MUL 两个数值相乘 ADD 两个数值相加 JMP 跳转到一个新位置 SUB 从一个数值中减去另一个数值 CALL 调用一个子程序 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:2","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"操作数 示例 操作数类型 示例 操作数类型 96 整数常量 eax 寄存器 2+4 整数表达式 count 内存 STC 指令没有操作数： stc ;进位标志位置 1 INC 指令有一个操作数： inc eax ;EAX 加 1 MOV 指令有两个操作数： mov count, ebx ;将 EBX 传送给变量 count IMUL 指令有三个操作数，第一个是目的操作数，第二个和第三个是进行乘法的源操作数： imul eax,ebx,5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:3","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"注释 单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。 块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。 COMMENT ! This line is a comment. This line is also a comment. ! ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:4","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"NOP（空操作）指令 .data ;此为数据区 sum DWORD 0 ;定义名为sum的变量 .code ;此为代码区 main PROC mov eax,5 ;将数字5送入而eax寄存器 add eax,6 ;eax寄存器加6 mox sum,eax INVOKE ExitProcess,0 ;结束程序 main ENDP ; AddTwo.asm -两个 32 位整数相加 .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .code main PROC mov eax,5 ;将数字5送入eax寄存器 add eax,6 ;eax寄存器加6 INVOKE ExitProcess,0 main ENDP END main 第 3 行是 .386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。 第 4 行选择了程序的内存模式（flat），并确定了子程序的调用规范（称为 stdcall）。其原因是 32 位 Windows 服务要求使用 stdcall 规范。 第 5 行为运行时堆栈保留了 4096 字节的存储空间，每个程序都必须有。 第 6 行声明了 ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode。 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:5","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"汇编伪指令回顾 CODE 的下一行声明程序的入口 .code main PROC ENDP 伪指令标记一个过程的结束。 main ENDP END 伪指令标记一个程序的结束，并要引用程序入口： END main ; AddTwo.asm - adds two 32-bit integers. ; Chapter 3 example .386 .model flat,stdcall .stack 4096 ExitProcess PROTO,dwExitCode:DWORD 00000000 .code 00000000 main PROC 00000000 B8 00000005 mov eax, 5 00000005 83 C0 06 add eax,6 invoke ExitProcess,0 00000008 6A 00 push +000000000h 0000000A E8 00000000 E call ExitProcess 0000000F main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:6","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据类型以及数据定义详解 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"内部数据类型 类型 用法 BYTE 8 位无符号整数，B 代表字节 SBYTE 8 位有符号整数，S 代表有符号 WORD 16 位无符号整数 SWORD 16 位有符号整数 DWORD 32 位无符号整数，D 代表双（字） SDWORD 32 位有符号整数，SD 代表有符号双（字） FWORD 48 位整数（保护模式中的远指针） QWORD 64 位整数，Q 代表四（字） TBYTE 80 位（10 字节）整数，T 代表 10 字节 REAL4 32 位（4 字节）IEEE 短实数 REAL8 64 位（8 字节）IEEE 长实数 REAL10 80 位（10 字节）IEEE 扩展实数 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:1","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据定义语句 数据定义语法如下所示： [name] directive initializer [,initializer]… 下面是数据定义语句的一个例子： count DWORD 12345 伪指令 用法 伪指令 用法 DB 8位整数 DQ 64 位整数或实数 DW 16 位整数 DT 定义 80 位（10 字节）整数 DD 32 位整数或实数 ;AddTowSum.asm .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .data sum DWORD 0 .code main PROC mov eax,5 add eax,6 mov sum,eax INVOKE ExitProcess,0 main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:2","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 BYTE 和 SBYTE 数据 value1 BYTE 'A' ;字符常量 value2 BYTE 0 ;最小无符号字节 value3 BYTE 255 ;最大无符号字节 value4 SBYTE -128 ;最小有符号字节 value5 SBYTE +127 ;最大有符号字节 value6 BYTE ? ;变量 val1 DB 255 ;无符号字节 val2 DB -128 ;有符号字节 多初始值 list BYTE 10,20,30,40 偏移量 数值 0000 10 0001 20 0002 30 0003 40 list BYTE 10,20,30,40 BYTE 50,60,70,80 BYTE 81,82,83,84 list1 BYTE 10, 32, 41h, 00100010b list2 BYTE 0Ah, 20h, 'A', 22h list1与list2不同进制，但值相同 定义字符串 greeting1 BYTE \"Good afternoon\",0 greeting2 BYTE 'Good night',0 0作为结束标记 greeting1 BYTE \"Welcome to the Encryption Demo program \" BYTE \"created by Kip Irvine.\",0dh, 0ah BYTE \"If you wish to modify this program, please \" BYTE \"send me a copy.\",0dh,0ah,0 十六进制代码 0Dh 和 0Ah 也被称为 CR/LF （回车换行符）或行结束字符。 greeting1 BYTE \"Welcome to the Encryption Demo program \" 和 greeting1 \\ BYTE \"Welcome to the Encryption Demo program \" 行连续字符（\\）把两个源代码行连接成一条语句，它必须是一行的最后一个字符。上面的语句是等价的。 DUP 操作符 BYTE 20 DUP ( 0 ) ;20 个字节，值都为 0 BYTE 20 DUP ( ? ) ;20 个字节，非初始化 BYTE 4 DUP ( \"STACK\" ) ; 20 个字节： ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:3","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 WORD 和 SWORD 数据 word1 WORD 65535 ;最大无符号数 word2 SWORD -32768 ;最小有符号数 word3 WORD ? ;未初始化，无符号 val1 DW 65535 ;无符号 val2 DW -32768 ;有符号 也可以使用传统的 DW 伪指令 myList WORD 1,2,3,4,5 偏移量 数值 0000 1 0002 2 0004 3 0006 4 0008 5 array WORD 5 DUP (?) ; 5 个数值，未初始化 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:4","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 DWORD 和 SDWORD 数据 val1 DWORD 12345678h ;无符号 val2 SDWORD -2147483648 ;有符号 val3 DWORD 20 DUP (?) ;无符号数组 val1 DD 12345678h ;无符号 val2 DD -2147483648 ;有符号 pVal DWORD val3 myList DWORD 1,2,3,4,5 偏移量 数值 0000 1 0004 2 0008 3 000C 4 0010 5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:5","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 QWORD 数据 quad1 QWORD 1234567812345678h quad1 DQ 1234567812345678h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:6","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"C++关键字描述","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["C++"],"content":"C++关键字 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量\"自动\"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ' 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: const double pi(3.14159); 或 const double pi = 3.14159; 10. const_cast用法： const_cast\u003ctype_id\u003e (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是\"继续循环\"之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是\"禁止单参数构造函数\"被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： extern “C” 声明语句 extern “C” { 声明语句块 } 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： reinpreter_cast (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 size","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["博客"],"content":"Jekyll 插入图片","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["博客"],"content":"Jekyll 插入图片 用 Markdown 插入图片是一件很简单的事，只需要这样写： ![AltText](/path/to/img.jpg) 然而，如果你需要进行更多的控制，情况立刻变得复杂了起来。由于 Markdown 秉持结构和样式分离的原则，你无法在插入图片时控制其大小。要达到这样的目的，你需要使用普通的 \u003cimg\u003e 标签： \u003cimg src=\"/path/to/img.jpg\" width=\"100\" height=\"100\" alt=\"AltText\" /\u003e 相对前一种语法，后者明显麻烦许多。所幸这种情况一般都是极少数。一般来说，我们只需要使用前一种语法。然而，有一种状况会让你需要大量使用后一种语法 —— Retina 屏幕的截图。一张 100pt * 100pt 的截图事实上是 200px * 200px。贴到文章里之后，电脑又会以 200pt * 200pt 的大小来渲染。你的截图立刻变得大而模糊。为了避免这种状况，你需要手动计算图片的实际大小，然后使用 HTML 语法插入图片。当你需要插入大量图片时，这一工作很快变得枯燥而难以忍受。 当然，你可以通过指定比例从而避免手工计算大小： \u003cimg src=\"/path/to/img.jpg\" width=\"50%\" alt=\"AltText\" /\u003e 虽然免去了计算大小，你依然需要使用冗长的 HTML 语法。能不能用 Markdown 语法来做这件事呢？ 我们知道有些 Markdown 方言支持调整图片大小，例如： Mou: ![AltText](/path/to/img.jpg =100x) MWeb: ![AltText-w100](/path/to/img.jpg) ... 显然，这些在 Jekyll 中都是不支持的。不过，我们有更好的方法： ![AltText @2x]() 只需添加 @2x 后缀，图片就会自动缩放为50%大小 这显然不是 Markdown 或 Jekyll 的功能，在你的博客中使用不会有任何效果。真正的魔法在 CSS 样式表中： .post-container img[alt~=\"@2x\"] { zoom: 50%; } 我们用到了 CSS 中的属性选择器，它可以对拥有指定属性的 HTML 元素设置样式。在这里，我们对 alt 中包含 @2x 的所有图片添加了 zoom: 50% 属性。 同理，你也可以为 iPhone * Plus 的截图设置三倍缩放： .post-container img[alt~=\"@3x\"] { zoom: 33%; } ","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/:0:0","tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["Markdown"],"content":"Mermaid教程收录","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid教程收录 时间管理、头脑风暴、阅读、会议记录神器-Mermaid Mermaid英文教程 Mermaid在线编辑器 Mermaid，就像用 Markdown 码字一样，高效制作简易流图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:0:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid - 流程图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"基本结构 圆角矩形 表示“开始”与“结束” 矩形表示行动方案、普通工作环节用 菱形表示问题判断或判定（审核/审批/评审）环节 用平行四边形表示输入输出 箭头代表工作流方向 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:1","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"流程图与节点的创建 graph 流程图声明 graph S[声明一个流程图] graph s(\"开始(START)\") 语法：id(\":转义字符;\") graph s(\"开始:#9829;\") ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:2","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"各方向 graph TB s[开始]--\u003e e[结束] graph BT s[开始]--\u003e e[结束] graph LR s[开始]--\u003e e[结束] graph RL s[开始]--\u003e e[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:3","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"节点形状 graph a[矩形] b(圆角矩形) c([体育场]) d[(圆柱)] e((圆形)) graph f{菱形} g{{6}} h\u003e非对称] i[/平行四边形/] j[/梯形\\] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:4","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"线条形状 graph g[开始] --- h[结束] a[开始] -.- b[结束] c[开始] === d[结束] e[开始] --\u003e f[结束] i[开始] -.-\u003e j[结束] k[开始] ==\u003e l[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:5","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"带文字的链接线 graph a[开始] --过程1--- b[结束] c[开始] --\u003e|过程2| d[结束] e[开始] -.过程3.-\u003e f[结束] g[开始] ==过程4==\u003e h[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:6","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"关系链 graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] s--走路--\u003e o[永辉超市]--付钱--\u003e e graph LR s[家] --走路--\u003eP[菜市场]--走路--\u003eL[水果店]--走路--\u003e j[超市]--\u003es graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e s s--网上--\u003e o[永辉超市]--付钱--\u003e s 正常写法 graph z[张三]--\u003eC[内卷] z--\u003eD[躺平] L[李四]--\u003eC[内卷] L--\u003eD 简易写法 graph z[张三] \u0026 L[李四]--\u003eC[内卷] \u0026 D[躺平] 不美观 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--\u003e|躺平|N[喝快乐水] 美观:加长某一项 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X---\u003e|躺平|N[喝快乐水] 增加层级:再加长 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--躺平----\u003eN[喝快乐水] 可用—-\u003e 链接线会增加3个层级的长度 一下是各个类型连接线增加层级长度语法 增加层级长度 1 2 3 实线 — —- —– 带箭头的实线 –\u003e —\u003e —-\u003e 粗实线 === ==== ===== 带箭头的粗实线 ==\u003e ===\u003e ====\u003e 虚线 -.- -..- -…- 带箭头的虚线 -.-\u003e -..-\u003e -…-\u003e ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:7","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"子图表 subgraph graph 节点关系 subgraph title //子图表的名称 子图表的节点关系 end //子图标结束标志 graph TB c1--\u003ea2 subgraph 表1 a1--\u003ea2 end subgraph 表2 b1--\u003eb2 end subgraph 表3 c1--\u003ec2 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:8","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"交互 为节点添加事件 以及点击跳转 这个现在还不是很好用 var callback = function(){ alert('A callback was triggered'); } 源代码： ```mermaid graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 生成效果 ```mermaid graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 注释 %% 源代码 ```mermaid graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C 生成效果 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:9","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"添加样式 方式1 语法： style id key:value,key:value 源代码： ```mermaid graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式2 定义样式 class 语法：classDef className 样式定义 应用 :::classname 源代码： ```mermaid graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 复制代码 生成效果 graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式3 css class形式添加样式 定义 \u003cstyle\u003e .cssClass \u003e rect{ fill:red; stroke:#FFFF00; stroke-width:4px; } \u003c/style\u003e 实例： 源代码 ```mermaid graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; 生成效果： ```mermaid graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:10","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid - 时序图（序列图） ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"基本结构 角色 Actor 系统角色 可是是人或者其他系统子系统 对象 Object 交互过程中扮演的角色 一般位于时序图顶部 生命线 Lifeline 生命线代表时序图中的对象在一段时期内的存在 控制焦点 Activation 控制焦点代表时序图中的对象执行一项活动的时期 消息 Message 定义交互和协作中交换信息的类 基本对象声明 sequenceDiagram participant 张三 participant 李四 对象声明-别名 Aliases sequenceDiagram participant Z as 张三 participant L as 李四 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:1","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"消息 Message 语法：participant1 箭头 participant2：消息内容 sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003eL:我是没有箭头的实线 L--\u003eZ:我是没有箭头的虚线 Z-\u003e\u003eL:带箭头的实线 L--\u003e\u003eZ:带箭头的虚线 Z-xL:带x箭头实线 L-)Z:结束时候 带箭头的实线 Z--)L:结束时候 带箭头的虚线 线型对照表 线形 含义 -\u003e 无箭头的实线 –\u003e 没箭头的虚线 -» 带箭头的实线 –» 带箭头的实线 -x 带x号箭头实线 –x 结尾x号箭头实线 -) 结束 带箭头的实线 –) 结束 带箭头的虚线 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:2","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"控制焦点 Activations 语法： activate participant //激活 消息 deactivate participant //释放激活 这个有一些抽象我们用一个场景来去理解 场景1： ``` 张三：hi李四你还好么 // 李四听了开始回话 此时李四是激活状态 开始进行对话 李四：hi张三我可以听到你，我很好，不用担心。 //李四会话结束 不会再跟张三有活动 此时李四的激活状态被释放 ``` 源代码： ``` ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L ``` ``` 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L 场景2： 张三：hi李四你还好么 张三：你可以听到我说话么 //李四开始回话 被激活 李四：hi张三我可以听到你 李四：不用担心我 复制代码 源代码： ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:3","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图-批注 Note 语法： 单个对象： Note 位置 of participant:批注内容 多个对象： Note 位置 角色名称1，角色名称2:批注内容 位于对象左侧： 源代码 ```mermaid sequenceDiagram participant 张三 Note left of 张三 :我是张三 复制代码 生成效果 sequenceDiagram participant 张三 Note left of 张三 :我是张三 sequenceDiagram participant 张三 Note right of 张三 :我是张三 sequenceDiagram participant 张三 participant 李四 Note over 张三,李四 :我是张三 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:4","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图-逻辑循环 Loop 交互过程中表示某些循环的环节 语法： loop 循环描述 循环内容 end //结束标记 复制代码 场景： 李四跟张三是好朋友 李四生病了 张三很关心他 每过一小时 为了不让张三如此担心 李四就约定每一个小时给张三发消息 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:5","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图 抉择（Alt）\u0026选项（Opt） 组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。 Alt 抉择 用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else.. 只能发生一种情况 语法： alt 第一种情况描述 具体发生的动作 else 剩余情况描述 具体发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 如果李四生病了他会说：我不是很好 如果李四很健康他会说：我很好 又是很好的一天 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end opt 选择\" 包含一个可能发生或不发生的序列 就是一种场景有可能发生也有可能不发生 语法： opt 情况描述 有可能发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 李四会可能会说谢谢你的问候也可能不会说 这个并无法预测 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:6","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图 并行关系 par 并行处理: 一个对象同时发出的交互动作 基本语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end 复制代码 场景： participants: 张三 李四 王五 张三 在下午5点分别给李四和王五分一条信息：内容是吃了么 李四回复：吃了 张三回复：没吃 复制代码 源代码 ```mermaid sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 复制代码 生成效果 sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 嵌套语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end par 动作描述1 participant3 -\u003e\u003e participant4:内容 and 王五发消息给A8 participant3 -\u003e\u003e participant5:内容 end 复制代码 场景： participants: 张三 李四 王五 赵六 A8 王五明天请吃饭 张三发消息问李四明天去不去 同时发消息给王五问明天都有哪些人参加 王五发消息给赵六:明天一起吃饭8 同事也发消息给A8告诉他让他带着小伙伴一起 复制代码 源代码 ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 复制代码 生成效果 sequenceDiagram participant 张三 participant 李四 participant 王五 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 背景高亮 语法： rect rgba(0,213,123) 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:7","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"类图 classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:3:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"状态图 stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:4:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"实体关系图 erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:5:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"用户旅程图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:6:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"gantt图 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:7:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"饼图 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:8:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"需求图 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:9:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["C++"],"content":"字符的输入与输出","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"字符的输入与输出 \\b 退格 \\f 走纸换页 \\r 回车 \\t 横向跳格(ctrl-i) ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"格式化字符 %c 字符 %d 十进制整数 %s 字符串 %S or %ws 宽字符串 %x 十六进制整数 %p 指针或地址 %o 八进制整数 %f 小数(浮点数) %u 无符号十进制整数 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:1:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"scanf输入 scanf(\"%s\",\u0026str1); ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:2:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"指针读写内存","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"指针读写内存 #include \u003ccstdio\u003e#define BASE 0x00417000 int g_a = 111; //0x00417000 int g_b = 222; //0x00417004 int g_c = 333; //0x00417008 typedef struct T3 { int a1; //偏移0 int a2; //偏移4 int a3; //偏移8 }TYPE3; int main(int argc, char const *argv[]) { //指针读内存 int* p1=(int*)0x00417000; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,333 printf(\"B:%d,%d,%d \\n\",*(p1+0),*(p1+1),*(p1+2)); //B:111,222,333 printf(\"C:%d,%d,%d \\n\",p1[0],p1[1],p1[2]); //C:111,222,333 printf(\"D:%d,%d,%d \\n\",*(int*)0x0041700,*(int*)0x00417004,*(int*)0x0041708); //D:111,222,333 //用指针向内存地址写入数据 *(p1+2)=11567; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,11567 p1[2]=22567; printf(\"B:%d,%d,%d \\n\",g_a,g_b,g_c ); //B:111,222,22567 *(int*)(0x0041700+8)=333678; printf(\"C:%d,%d,%d \\n\",g_a,g_b,g_c ); //C:111,222,333678 TYPE3* p3 =(TYPE3*)0x00417000; printf(\"%p,%p,%p \\n\",\u0026p3-\u003ea1,\u0026p3-\u003ea2,\u0026p3-\u003ea3); //111,222,333678 printf(\"%d,%d,%d \\n\",p3-\u003ea1,p3-\u003ea2,p3-\u003ea3); //111,222,333678 printf(\"p3=%p,p3+1=%p,sizeof(TYPE3)=%X \\n\",p3,p3+1,sizeof(TYPE3)); //p3=00417000,p3+1=0041700C,sizeof(TYPE3)=C printf(\"p3=%p,p3+2=%p,sizeof(TYPE3)=%X \\n\",p3,p3+2,sizeof(TYPE3)); //p3=00417000,p3+2=00417018,sizeof(TYPE3)=C printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+sizeof(TYPE3)*2); //\u003e\u003e\u003e:p3+2=417018 =417018 printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+0xC*2); //\u003e\u003e\u003e:p3+2=417018 =417018 return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/:0:0","tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++知识点","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"C++知识点（一） ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:0:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"阻断函数 getchar() //等待键盘输入回车 sysem(\"pause\")//任意键继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:1:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"常用函数 printf(\"Hello World!\") //输出函数 atoi(arg) //字符串转整数 Sleep(arg) //等待 MessageBeep(1); //播放系统音乐,方便OD定位 void *memcpy(void *str1, const void *str2, size_t n) //内存copy(读取与写入) //str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 //str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 //n -- 要被复制的字节数。 //返回值 -- 该函数返回一个指向目标存储区 str1 的指针。 void *memset(void *s, int ch, size_t n); //内存设置 //将s中当前位置后面的n个字节,用 ch 替换并返回 s 。 size_t strlen(const char *string); //计算给定字符串的长度 (ANSI) size_t wcslen(const wchar_t * str); //strlen函式的宽字节版 (Unicode) BOOL CloseHandle( HANDLE hObject //对象句柄 );//关闭对象句柄。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:2:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"用汇编来调用CALL int pcall =(int)MessageBoxC; __asm { push 0 //4 push 0 //3 push 0 //2 push 0 //1 call dword ptr ds:[MessageBoxA] //第一种 mov eax,MessageBoxB call eax //第二种 call pcall //第三种 ;分号 注释语句 } ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:3:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"循环 break; //退出循环 continue; //跳到循环首部,循环继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:4:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"其它 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_In_ 表示是一个输入参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:1","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_Out_ 表示是一个输出参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:2","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026arg 引用 1.必须传变量 2.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:3","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026变量 取变量地址运算符 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:4","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"*arg 指针 1.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:5","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"冒号: 冒号代表标签,常用于goto跳转 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:6","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"typedef 关键字，作用是为一种数据类型定义一个新名字 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:7","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"三元运算子 条件式 ? 条件式为true时执行的陈述句 : 条件式为false时执行的陈述句 int ret, a = 10, b = 11; bool flag = true; if (flag) ret = a; else ret = b; 等价于 ret = flag ? a : b; ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:8","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"const 声明变量是不变的 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:9","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"define 定义宏,可用于起别名,也可带参数,如 #define hanshu(a,b) (a+b) ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:10","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"指针 LPSTR char* LPCSTR const char* LPCTSTR const TCHAR* LPTSTR TCHAR* LP = 指针 C = const 只读 TSTR = TCHAR ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:11","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"HINSTANCE “句柄型”数据类型。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:12","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"static 关键字 定义静态变量或静态函数,生存周期和全局变量一样,作用域和局部变量一样,初始化仅执行一次. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:13","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"char* 定义字符串 char p[256]=\"hijk\"; //可读写 char src2[]=\"opq\"; //可读写 char *p=\"abcd\"; //只读 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:1","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcpy 字符串复制(wcscpy宽字节版) char *strcpy(char* dest, const char *src); 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 strcpy_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:2","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcat 字符串连接(wcscat宽字节版) extern char *strcat(char *dest, const char *src); strcat_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:3","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strstr 查找字符串(wcsstr宽字节版) string strstr( string1，string2) ​ strstr返回一个指针，指向string2在string1中首次出现的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:4","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strchr 查找字符(wcschr宽字节版) char *strchr(const char *str, int c) 在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:5","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcmp 字符串比较(wcscmp宽字节版) extern int strcmp(const char *s1,const char *s2); 当s1\u003cs2时，返回为负数； 当s1=s2时，返回值= 0； 当s1\u003es2时，返回正数. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:6","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"以下仅了解 strrev strncmp strncmpi strerror strncpy strnicmp ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:7","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"Unicode字符串(wchar)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"wchar_t 宽字符 wchar_t c1='A'; //单个字符不用加\"L\" wchar_t wStr[]=L\"这是一段中文\"; //字符串前要加\"L\" wchar_t appName[5]=TEXT(\"test\"); //可以用TEXT()方法将char转换成wchar_t char是8位字符类型,wchar_t数据类型一般为16位或32位,wchar_t所能表示的字符数远超char型。 如果你想使用ANSI字符串，那么请使用这一套写法： char szString[100]; strcpy(szString,\"test\"); 如果你想使用Unicode字符串，那么请使用这一套： wchar_t szString[100]; wcscpyszString,L\"test\"); 如果你想通过定义_UNICODE宏，而编译ANSI或者Unicode字符串代码： TCHAR szString[100]; _tcscpy(szString,_TEXT(\"test\")); ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:1","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"相关函数见 多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:2","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"TCHAR兼容型字符串及常用函数 TCHAR ANSI Unicode TCHAR char wchar_t _tcscpy() strcpy() wcscpy() _tmain() main() wmain() _tWinMain() WinMain() wWinMain() _T\"str\" “str” L\"str\" _tprintf() printf() wprintf() _tcslen() strlen() wcslen() ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:8:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"DLL动态链接库及入口函数 LoadLibrary 加载动态链接库 HMODULE LoadLibrary(_In_ LPCTSTR lpFileName); __stdcall 参数从右向左压入堆栈 APIENTRY 则表明此函数是应用程序的入口点,其实都是__stdcall winapi 表示此函数是普通的winapi函数调用方式,其实都是__stdcall FreeLibrary 释放动态链接库 BOOL WINAPI FreeLibrary(_In_ HMODULE hModule); FreeLibraryAndExitThread 释放动态链接库并退出线程 void FreeLibraryAndExitThread( HMODULE hLibModule, //模块的句柄 DWORD dwExitCode //调用线程的退出代码 ); DLL_PROCESS_ATTACH 宏 进程载入 // 1 DLL_PROCESS_DETACH 宏 进程卸载 // 0 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:9:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"跨进程分配内存 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:0","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"VirtualAllocEx 向指定进程申请内存 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); ​ flAllocationType 可取下列值： MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储 MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存） MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用 MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效 MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志） MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98） flProtect 可取下列值 PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访 PAGE_READWRITE 区域可被应用程序读写 PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。 PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域。 PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。 PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限 PAGE_NOACCESS： 任何访问该区域的操作将被拒绝 PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached) 注:PAGE_GUARD和PAGE_NOCHACHE标志可以和其他标志合并使用以进一步指定页的特征。PAGE_GUARD标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个one-shot异常，接着取得指定的访问权限。PAGE_NOCACHE防止当它映射到虚拟页的时候被微处理器缓存。这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:1","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"VirtualFreeEx 释放申请的虚拟内存空间 BOOL WINAPI VirtualFreeEx( HANDLE hProcess, //目标进程的句柄。 LPVOID lpAddress, //指向要释放的虚拟内存空间首地址的指针 SIZE_T dwSize, //虚拟内存空间的字节数 DWORD dwFreeType );//释放类型 ​ lpAddress ​ 指向要释放的虚拟内存空间首地址的指针。 ​ 如果 dwFreeType 为 MEM_RELEASE, 则该参数必须为VirtualAllocEx的返回值. ​ dwSize ​ 虚拟内存空间的字节数 ​ 如果 dwFreeType 为 MEM_RELEASE，则 dwSize 必须为0 . 按 VirtualAllocEx申请时的大小全部释放。 ​ 如果dwFreeType 为 MEM_DECOMMIT, 则释放从lpAddress 开始的一个或多个字节 ，即 lpAddress +dwSize。 ​ dwFreeType ​ 释放类型，取值见下表： 值 释义 MEM_DECOMMIT0x400016384D 这种试 仅标示 内存空间不可用，内存页还将存在。 MEM_RELEASE0x800032768D 这种方式 很彻底，完全回收。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:2","tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["GitHub"],"content":"GitHub回退历史版本","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"GitHub回退历史版本 前提是本地已经有了git的origin master库或者克隆需要回退的代码到本地。 ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:0","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"1. 查询历史对应不同版本的ID ，用于回退使用 git log --pretty=oneline 假设查到历史版本的id是 ： 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:1","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"2. 恢复到历史版本 git reset --hard 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:2","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"3. 把修改推到远程服务器 git push -f -u origin master ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:3","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"4. 重新更新 git pull ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:4","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"Git与GitHub绑定","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/","tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["GitHub"],"content":"Git与GitHub绑定 终端输入ssh-keygen -t rsa命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 密钥和公钥生成后，把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！ 在 Git Bash 中输入ssh -T git@github.com进行测试： ","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/:0:0","tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["博客"],"content":"Hugo常用命令","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"Hugo常用命令 新建章节 hugo new –kind chapter /_index.md 新建文件 hugo new //_index.md hugo new /.md hugo new posts/.md 解除环境限制 hugo serve -e production 生成指定模板的样例文章 hugo new –kind post-bundle posts/my-post 实时预览 hugo serve –disableFastRender ","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"安装hugo博客","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装hugo博客 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Generate new site 要產生一個新的 web site 內容，可直接執行 hugo new site ssg-site 執行後會建立一個名為 ssg-site 的資料夾，包含以下內容 . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾（可先暫時不管）。 config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。(也支援 yaml 與 json 格式) content: 放置 Markdown 文章與網頁內容的資料夾。 data: 儲存一些 configuration 檔案的地ㄌㄌ方，協助建構靜態網頁(也先不管)。 layouts: 儲存產生的網頁 layout 樣板(之後範例使用其他的 theme，先不管)。 static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。 themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:1","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Import Hugo themes Hugo 並沒有預設的 theme，所以在建立好內容資料夾後，需自行建立 theme 或使用其他 theme，在這我們已 Mainroad theme 做範例。 # 將 mainroid theme 加入 themes/ 中 cd /Users/xinqinew/ssg-site git clone https://github.com/Vimux/Mainroad.git themes/mainroad 除了使用 git 指令外，直接從 Github 上下載最新原始檔案壓縮檔，解壓縮後放到 themes 資料夾中。此外對 git 熟悉的是使用者也可用 git submodule 或 git subtree 等方式管理外部引入的 theme repo。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:2","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Configuration Hugo 在生成 SSG 時會使用到 config.toml 檔案的設定內容。我們可以將之前 Mainroad theme 中的 config.toml 修改後加以使用 # 將 mainroid 的 config.toml 覆蓋原先的預設值 cp themes/mainroad/exampleSite/config.toml . 之後編輯 config.toml 內容，將其修改為自己想要的內容。更詳細的 configuration 設定可參考 Hugo 官方文件 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:3","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新增 Blog 文章 我們可以手動新增 Markdown 文件 hugo new post/hello-world.md 之後會在 ./content/post/hello-world.md 的位置新增一個 Markdown 文件，其中預設內容會根據 archetype/default.md 這個樣板檔案內容加以建立。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:4","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"預覽內容 先將 ./content/post/hello-world.md 內容修改為 --- title: \"Hello World\" date: 2018-07-06T16:00:21+08:00 categories: - \"Blog\" tags: - \"Hugo\" draft: true --- # Hello World. Post example 之後執行以下指令 hugo server --buildDrafts 若在 Markdown 的 Front Matter，加入 draft: true，代表該篇文章為草稿不會被 Hugo 轉換為網頁。因此可在指令後加入 --buildDrafts 來轉換草稿文件。 執行成功後會在 localhost:1313 建立一個暫時的網頁，可接載在瀏覽器網址列輸入預覽結果。 Hugo Mainroad theme 結果預覽 1313 為 Hugo 的預設 Port，可以使用 --port xxx 來指定使用其他 Port ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:5","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成靜態內容 Hugo 要生成靜態網頁內容只執行 hugo 指令即可 hugo 執行後生成的網頁內容會自動加入 public 資料夾中。 public 為預設資料夾，若要修改可在 config 檔案中設定 publishDir 參數指定輸出位置。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:6","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"從 Jekyll 轉移到 Hugo 如果要從其他的 SSG 轉換到 Hugo，官方也提供了一些轉換方式。以從 Jekyll 轉換到 Hugo 為例，只要執行 hugo import jekyll [jekyll_root_path] [target_path] 就會將 Jekyll 轉換為 Hugo 格式資料夾。但這方式也不是沒問題，原先在的 Jekyll 的 theme 無法直接在 Hugo 使用，且有部分 Front Matter 無法正確轉換，因此建議還是手動轉移較好。而因爲個人轉移時選用的 theme 為 Mainroad，在過程中也遇到了一些問題，在此提出來以供參考。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Markdown Front Matter 由於 Hugo 與 Jekyll 所使用的 Front Matter 設定不同，有些部分需要每個檔案逐一修改內容，如 categories 或 tags 的內容，之前使用的 voyager theme 在執行時會成格式不對，需修改將其改為 List 結構，如在 Jekyll 中， categories: posts 是可行的，但換到 Hugo 的 Mainroad theme 時，需使用 List 結構才行，如 categories: [\"posts\"] 才可正常產生靜態網頁，否則會出現錯誤。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Math equation support 在加入數學式的支援花了一些時間去解決，主要分為兩個問題 - Markdown 轉換成 HTML 以及 Mainroad theme 的 CSS conflict 問題。 Markdown parser support 在加入數學式時，我們習慣直接使用 Latex 語法在 Markdown 中，這樣可以更容易寫出方便的數學式。而 Hugo 預設的 Markdown parser Blackfriday(使用 Go 語言實作的 Markdown parser) 會進行某些預先處理，造成 MathJax 無法正確顯示內容以及斷行的問題。因此需要將原先的 Blackfriday parser 更換成 Mmark，即在 Markdown 文件中使用 Latex 數學式語法。方法為將檔案副檔名命名為 *.mmark，或是在 Markdown Front Matter 中加入 markup: \"mmark\" 來指定使用 Mmark 處理 Markdown 文件。更詳細的內容可參考官網說明。 Katex support 雖然 Mainroad theme 雖然有支援 MathJax，但該 theme 的 CSS style 中有部分和 Katex 的 CSS 設定衝突，造成當把 Mainroad 中的 MathJax 部分的樣板原始碼換成支援 Katex 後，在顯示 Matrix 時會造成跑版。詳情狀況可參考個人發在 GitHub 上的 Issue #1445。在 Katex 小組了解問題並經過 Mainroad 作者修改樣板後即解決了該問題。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Syntax highlighting 要在 Hugo 中讓程式碼有高亮效果，可在 config 檔案中加入以下設定 # use Chroma for syntax highlight pygmentsCodeFences = true # 啟動 Code Fence 區域的高亮效果 pygmentsCodefencesGuessSyntax = true # 對沒有指定程式類型的 Code Fence 自行推導語言類型 pygmentsStyle = \"fruity\" # 指定使用的高亮風格，如 vim 或 fruity 等(預設為 \"monokai\") 若想換成其他風格可參考這裡的格式，將 pgmentsStyle 的設定修改為該風格 Hugo 就會用該風格顯示 Markdown 中 Code Fence 區段的內容。其他設定可參考 Hugo 官網關於 Syntax Hightlighting 的章節。 pygment 為原先 Hugo 所使用的 Syntax Hightlighting 工具， 在 Hugo 0.28 版後改為 Chroma 為預設內容，但設定檔仍維持原先的格式。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:3","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"首頁大綱內容 Mainroad 的 Markdown 文件顯示在列表中的大綱內容，會是最前面段落開始一直延續到預設長度為止，這在排版上會很難看，因此可以手動在 Markdown 文件中加入 ` ` 標籤隔開大綱與主題內容，如下範例 ...{大綱內容}... \u003c!--more--\u003e ...{文章內容}... 這樣在首頁的列表中就只會顯示大綱內容的部分。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:4","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Disqus Support Hugo 本身所產生的內容為靜態網頁，若要有像留言板之類的動態內容就必須藉助外部服務。Hugo 本身支援 Disqus 這個知名的 Blog 留言服務樣板，只要建立帳號取得 shortname，在 config 檔案中設定完成即可。若使用的 theme 有支援應該能正確顯示 disqusShortname = \"yourdiscussshortname\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:5","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Google Analysis support 和 Disqus 相同，Hugo 也有內部支援 Google Analysis 來統計你網站的流量與人潮。只要去 Google Analysis 申請一組 Tracking Id 並在 config 中加入設定。如 使用的 theme 有支援該功能則會自動設定 googleAnalytics = \"yourtrackingid\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:6","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Reference Hugo Mainroad theme Disqus Katex 从Jekyll迁移到Hugo，Hugo不完全指南 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"\u003c\u003e尖括号","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/","tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"\u003c \u003e尖括号 我习惯将尖括号用于指定类型，作为参数: vector\u003cint\u003e vecOfInts ; 但是在rapidjson中，有这样的代码: document.Parse\u003c0\u003e(json) ; document.Parse方法的签名是: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 我不知道您可以在尖括号内传递值-认为尖括号仅用于类型名称。 这里的代码在做什么，为什么他在尖括号中传递一个值？ 这是一个好主意吗？什么时候？ 最佳答案 这里有两个不同的因素。 首先，可以定义除类型以外的参数化模板。例如，这是一个简单的数组类型: template \u003ctypename T, size_t N\u003e struct Array { T arr[N]; }; 我们可以这样使用 Array\u003cint, 137\u003e myArray; 我们知道vector\u003cint\u003e和vector\u003cdouble\u003e是不同的类型。但是现在我们还必须指出，Array\u003cint,137\u003e和Array\u003cint,136\u003e是不同的类型。 其次，使用模板时，编译器必须能够为所有模板参数找出一个值。使用模板类时，这就是为什么通常指定所有模板参数的原因。例如，您不说vector x，而是说类似vector\u003cdouble\u003e x。使用模板函数时，大多数时候编译器可以找出参数。例如，要使用std::sort，您只需说出类似 std::sort(v.begin(), v.end()); 但是，您也可以写 std::sort\u003cvector\u003cint\u003e::iterator\u003e(v.begin(), v.end()); 更明确地说。但是有时候，您有一个模板函数，对于该函数，并非所有参数都可以被找出来。在您的示例中，我们有: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 注意，不能仅从函数的参数推导parseFlags模板参数。因此，要调用该函数，必须指定template参数，否则编译器将无法确定该参数。这就是为什么你会写类似 Parse\u003c0\u003e(myString); 此处，0是模板参数(在编译时解析)，而myString是实际参数(在运行时解析)。 实际上，您可以使用结合了一些类型推断和一些显式类型参数的方法。例如，在Boost中，有一个函数lexical_cast可以在字符串类型之间进行转换。从非字符串类型转换为字符串类型的函数签名是 template \u003ctypename Target, typename Source\u003e Target lexical_cast(const Source\u0026 arg); 在这里，如果您调用lexical_cast，则编译器可以确定Source是什么，但如果没有一些提示，就无法推断出Target。因此，要使用lexical_cast，您需要编写类似 std::string myString = boost::lexical_cast\u003cstd::string\u003e(toConvertToString); 更一般而言，编译器说您必须指定一定数量的模板参数(可选为0)，它将尝试推断其余的参数。如果可以的话，太好了!如果不是，则为编译时错误。如果需要，可以使用此代码编写类似的函数 template \u003cint IntArgument, typename TypeArgment\u003e void DoSomething(const TypeArgument\u0026 t) { /* ... */ } 要调用此函数，您必须像这样调用它: DoSomething\u003cintArg\u003e(otherArg); 在这里，这是可行的，因为您必须显式告诉编译器IntArgument是什么，但是编译器可以从TypeArgument的参数类型推导DoSomething。 ","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/:0:0","tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/","tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例 雙端隊列或雙頭隊列是序列容器，兩端都有擴展和收縮功能。它們類似於向量，但是在元素的結尾和開始處插入和刪除時效率更高。與向量不同，可能無法保證連續的存儲分配。 deque::clear() clear()函數用於刪除雙端隊列容器的所有元素，從而使其大小為0。 用法: dequename.clear() Parameters : No parameters are passed. Result : All the elements of the deque are removed ( or destroyed ) 例子： Input :mydeque = {1, 2, 3, 4, 5} mydeque.clear(); Output:mydeque = {} Input :mydeque = {} mydeque.clear(); Output:mydeque = {} 錯誤和異常 1.它沒有異常拋出保證。 2.傳遞參數時顯示錯誤。 // CPP program to illustrate // Implementation of clear() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; mydeque.clear(); // Deque becomes empty  // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： No Output deque::erase() erase()函數用於從指定位置或範圍中刪除容器中的元素。 用法: 1. _**dequename.erase(position)**_ 2. _**dequename.erase(startingposition, endingposition)**_ **Parameters :** Position of the element to be removed in the form of iterator. or the range specified using start and end iterator. **Result :** Elements are removed from the specified position of the container. 例子： Input : mydeque{1, 2, 3, 4, 5}, iterator= 2 mydeque.erase(iterator); Output : 1, 2, 4, 5 Input : mydeque{1, 2, 3, 4, 5, 6, 7, 8}, iterator1= 3, iterator2= 6 mydeque.erase(iterator1, iterator2); Output : 1, 2, 3, 8 錯誤和異常 1.如果位置有效，則沒有異常拋出保證。 2.否則顯示未定義的行為。 從特定位置移除元件 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it; it = mydeque.begin(); mydeque.erase(it); // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 2 3 4 5 刪除範圍內的元素 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it1, it2; it1 = mydeque.begin(); it2 = mydeque.end(); it2--; it2--; mydeque.erase(it1, it2); // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 4 5 應用 給定一個整數列表，從雙端隊列中刪除所有偶數元素並打印雙端隊列。 Input :1, 2, 3, 4, 5, 6, 7, 8, 9 Output :1 3 5 7 9 _Explanation - 2, 4, 6 and 8 which are even are erased from the deque_ 算法 1.循環運行，直到雙端隊列大小為止。 2.檢查每個位置的元素是否可被2整除，如果是，則刪除該元素並遞減迭代器。 3.打印最終雙端隊列。 // CPP program to illustrate // Application of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }; deque\u003cint\u003e::iterator i; i = mydeque.begin(); while (i != mydeque.end()) { if (*i % 2 == 0) /* Not a good idea to erase inside loop, if you delete last element, mydeque.end() cannot be found resulting in infinite loop */ mydeque.erase(i); i++; } // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 1 3 5 7 9 clear() VS erase()。什麽時候使用什麽？ **clear()**從雙端隊列容器中刪除所有元素，從而使其大小為0。使用clear()函數刪除雙端隊列中的所有元素。 **erase()**另一方麵，“函數”用於從容器中刪除特定元素或從容器中刪除一係列元素，從而通過刪除元素的數量來減小其大小。 ","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/:0:0","tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque insert()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_insert/","tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque insert()用法及示例 deque::insert(函数是C++中的内置函数，用于在双端队列中插入元素。 insert()函数可以通过三种方式使用： 通过在一个位置插入新元素val来扩展双端队列。 通过在双端队列中插入n个新值val来扩展双端队列。 通过在(first，last)范围内插入新元素来扩展双端队列。 用法: deque_name.insert (iterator position, const value_type\u0026 val); deque_name.insert (iterator position, size_type n, const value_type\u0026 val); deque_name.insert (iterator position, InputIterator first, InputIterator last); 参数 position–指定要插入元素的位置。 val–指定要分配给新插入元素的值。 n–指定要插入的元素数。每个元素都初始化为val的副本。 first, last–指定迭代器，该迭代器指定要插入的元素范围。范围包括first和last之间的所有元素，包括first指向的元素，但last指向的元素。 返回值 该函数返回一个迭代器，该迭代器指向新插入的元素中的第一个。 示例1: // CPP program to illustrate the // deque::insert() function // insert elements by iterator #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; it = dq.insert(it, 10); // 1 10 2 3 4 5  std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 2 3 4 5 示例2: // CPP program to illustrate the // deque::insert() function // program for second syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); // 0 0 1 2 3 4 5  dq.insert(it, 2, 0); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 0 0 1 2 3 4 5 示例3: // CPP program to illustrate the // deque::insert() function // program for third syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; vector\u003cint\u003e v(2, 10); // 1 10 10 2 3 4 5  dq.insert(it, v.begin(), v.end()); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 10 2 3 4 5 ","date":"2021-07-24","objectID":"/2021/07/deque_insert/:0:0","tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque 用法与示例","date":"2021-07-24","objectID":"/2021/07/deque/","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 用法与示例 本篇將介紹如何使用 C++ std deque 以及用法與範例，C++ std::deque 是一個雙向佇列(double-ended queue)，在頭尾兩端插入及刪除十分快速，在中間插入刪除元素比較費時。 std::deque 是 double-ended queue 而不是 double linked list，底層實做是用間接索引的方式實現的，類似一個 map 索引到若干個固定大小的資料區塊(連續記憶體空間)，利用兩次索引達成跟 vector 一樣的隨機訪問功能。 以下將依序介紹幾個 std::deque 容器常用的用法範例，分別為 deque 常用功能 範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 範例2. push_back 自定義類別 範例3. 用 for 迴圈遍歷 deque 容器 範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 deque 的優點與缺點 要使用 deque 容器的話，需要引入的標頭檔: \u003cdeque\u003e ","date":"2021-07-24","objectID":"/2021/07/deque/:0:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 常用功能 以下為 std::deque 內常用的成員函式 修改器 push_back: 把一個元素添加到尾端 push_front: 把一個元素插入到頭端 pop_back: 移除最後一個元素(尾端) pop_front: 移除第一個元素(頭端) insert: 插入元素 erase: 移除某個位置元素, 也可以移除某一段範圍的元素 clear: 清空容器裡所有元素 容量 empty: 回傳是否為空 size: 回傳目前長度 元素存取 [i]: 隨機存取索引值為i的元素 back: 取得最後一個元素 front: 取得第一個的元素 迭代器 begin:回傳指向第一個元素(頭端)的迭代器 cbegin:回傳指向第一個元素(頭端)的迭代器(const) end:回傳指向最後一個元素(尾端)的迭代器 cend:回傳指向最後一個元素(尾端)的迭代器(const) rbegin:回傳指向最後一個元素(尾端)的反向迭代器 crbegin:回傳指向最後一個元素(尾端)的反向迭代器(const) rend:回傳指向第一個元素(頭端)的反向迭代器 crend:回傳指向第一個元素(頭端)的反向迭代器(const) ","date":"2021-07-24","objectID":"/2021/07/deque/:1:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 以下範例為push_back(), pop_front(), push_front(), pop_back() 用法， 其中 push_back() 與 pop_front() 應該是最常用到的函式了。 另外使用 deque 相對於 queue 的好處是deque可以使用隨機訪問的功能 [i]。 std-deque.cpp // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } 輸出內容如下： 0 2 3 4 0 2 3 ","date":"2021-07-24","objectID":"/2021/07/deque/:2:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例2. push_back 自定義類別 以下範例為 std::deque 容器使用 push_back() 來推放 Student 自定義類別的範例，使用 push_back() 來放進 deque 的最尾端，這個範例限制 deque 最多塞3個，多的會用 pop_front() 給 pop 掉，最後再將 deque 容器的所有的元素印出來。 // g++ std-deque2.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; class Student { public: Student(int id) { this-\u003eid = id; } int id; }; std::deque\u003cStudent\u003e d; void deque_push_back(Student a) { d.push_back(a); if (d.size() \u003e 3) { d.pop_front(); } } int main() { Student a1(1), a2(2), a3(3), a4(4); deque_push_back(a1); deque_push_back(a2); deque_push_back(a3); deque_push_back(a4); // 印出 deque 內所有內容, c++11 才支援 for (auto \u0026i : d) { cout \u003c\u003c i.id \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/deque/:3:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例3. 用 for 迴圈遍歷 deque 容器 以下範例是用 for 迴圈配合 deque 容器的迭代器，去遍歷 deque 並且把值印出來，前兩種是從頭印到尾，後兩種是從尾印到頭。從頭端印到最尾端就是使用 begin() 搭配 end() ，從最尾端印到頭端就是使用 rbegin() 搭配 rend() 。 這裡的 begin() / end() 與 cbegin() / cend() 有什麼不同呢？begin() / end() 是回傳 iterator，而 cbegin() / cend() 是回傳 const_iterator，iterator 可以修改元素值，const_iterator 則不可修改，簡單說就是回傳的東西能不能被修改的差異，要用哪種就自行判斷要用哪種了。 cbegin(), cend(), crbegin(), crend() 是 C++11 新增的，要使用時記得編譯器要加入-std=c++11選項。 第一個 for 迴圈裡面的迭代器使用懶人快速寫法auto it = d.begin();，其全名為std::deque\u003cint\u003e::iterator it = d.begin();，如果不想寫這麼長的話，就可以像我一樣用 auto 的懶人快速寫法。 // g++ std-deque3.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 //for (std::deque\u003cint\u003e::iterator it = d.begin(); it != d.end(); ++it) { for (auto it = d.begin(); it != d.end(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從頭到尾 for (auto it = d.cbegin(); it != d.cend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.rbegin(); it != d.rend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.crbegin(); it != d.crend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } 輸出 1 2 3 4 1 2 3 4 4 3 2 1 4 3 2 1 ","date":"2021-07-24","objectID":"/2021/07/deque/:4:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 以下範例是用 while 迴圈在 deque 容器裡搜尋/尋找數字為3，這裡的 auto 懶人快速寫法如上範例解釋相同就不贅述了。 在 while 迴圈裡如果有找到就印個有找到的訊息，假如整個 while 迴圈都沒找到，最後可以判斷 it == d.end() 代表整個 deque 容器都遍歷過了也沒有找到，就印個沒找到的訊息。 // g++ std-deque4.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 int find_num = 3; //std::deque\u003cint\u003e::iterator it = d.begin(); auto it = d.begin(); while (it != d.end()) { if (*it == find_num) { cout \u003c\u003c \"Found \" \u003c\u003c find_num \u003c\u003c endl; break; } it++; } if (it == d.end()) { cout \u003c\u003c \"Not found \" \u003c\u003c find_num \u003c\u003c endl; } return 0; } 輸出 Found 3 如果將 find_num 變數改成 5 去搜尋/尋找的話則會找不到，輸出結果會變成 Not found 5 ","date":"2021-07-24","objectID":"/2021/07/deque/:5:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 的優點與缺點 deque 的優點 可以再兩端進行 push 和 pop 操作 支持隨機訪問[i] deque 的缺點 佔用記憶體較多 ","date":"2021-07-24","objectID":"/2021/07/deque/:6:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque和queue容器","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque和queue容器 标准模板库 STL 提供了两种容器：deque 和 queue，以实现和队列类似的数据 结构。deque 是一个双端队列。它类似于矢量，但允许在前端和后端高效地访问值。队列抽象数据类型就像栈抽象数据类型：它实际上是一个容器适配器。 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:0:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque容器 可以将 deque 容器想象成一个矢量，但它可以快速访问前端以及后端的元素（和矢量一样，deque 也可以使用 [] 运算符访问元素）。 图 1 deque 成员函数 使用双端队列 ADT 的程序必须包含 deque 头文件。由于本节更关心它与队列类似的特性，所以就来集中讨论一下 push_back、pop_front 和 front 成员函数，如图 1 所示。它们的示例和相应描述如表 2 所示。 成员函数 示例和描述 push_back iDeque.push back(7); 接受一个值作为参数插入到 deque 中。 参数被插入在最后一个元素之后（被推到 deque 后面） pop_front iDeque.pop front(); 删除 deque 的第一个元素并丢弃它 pop_front cout « iDeque.front() « endl; front 返回对 deque 第一个元素的引用 下面的程序演示了双端队列容器的使用： // This program demonstrates the STL deque container. #include \u003ciostream\u003e#include \u003cdeque\u003eu[sin](http://c.biancheng.net/ref/sin.html)g namespace std; int main() { deque\u003cint\u003e iDeque; cout \u003c\u003c \"I will now enqueue items. . . \\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iDeque.push_back(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while (!iDeque.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iDeque.front() \u003c\u003c endl; iDeque.pop_front(); } return 0; } 程序输出结果： I will now enqueue items. . . Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:1:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"queue容器适配器 queue 容器适配器可以建立在矢量、链表或者双端队列的基础上。默认情况下，它使用一个双端队列作为其基础。 queue 支持的插入和删除操作与栈 ADT 所支持的类似：push、pop 和 front。但是，它们的表现有所不同。queue 版本的 push 始终在队列的后面插入一个元素。queue 版本的 pop 始终从结构的前面删除一个元素。front 函数返回队列前面的元素的值。 下面的程序演示了一个队列。由于该队列的声明没有指定适配哪一种类型的容器，所以该队列将建立在一个双端队列上。 //This program demonstrates the STL queue container adapter. #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int main() { queue\u003cint\u003e iQueue; cout \u003c\u003c \"I will now enqueue items...\\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iQueue.push(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while(!iQueue.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iQueue.front () \u003c\u003c endl; iQueue.pop (); } return 0; } 程序输出结果： I will now enqueue items… Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:2:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"ifndef详解","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef详解 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:0:0","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef是\"if not defined\"的简写 #ifndef起到的效果是防止一个源文件多次包含同一个头文件, 而不是防止两个源文件包含同一个头文件。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:0","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"一、防止头文件的重复包含和编译 #ifndef \u003c标识\u003e #define \u003c标识\u003e ...... ...... #endif 标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的\".“也变成下划线，如：stdio.h #ifndef _STDIO_H #define _STDIO_H ...... ...... #endif ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:1","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"二、便于程序的调试和移植 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #ifndef 标识符 #define 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #if 表达式 程序段 1 #else 程序段 2 #endif 它的作用是当“表达式”值为真时，编译“程序段1”，否则编译“程序段2”。 注：以上三种形式中#else不是强制的，可省略；当然，当#else后需要嵌套#if时，可以使用预处理命令#elif，它相当于#else#if。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:2","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"queue 和 deque的区别","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/","tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue 和 deque的区别 从使用的角度来讲主要差别就是： deque支持push_front、pop_front、push_back、pop_back。 queue支持push_back、pop_front。 deque是双端队列 #include\u003cdeque\u003e template\u003ctypename T,typename Allocator=std::allocator\u003cT\u003e\u003eclass deque; 支持push_front、pop_front、push_back、pop_back等几种操作的。queue是容器适配器，他的声明是 #include\u003cqueue\u003e template\u003ctypename T,typename Container=std::deque\u003cT\u003e\u003eclass queue; 类型Container是用来存储元素的，相当于是这个queue的实现。这个queue模板看起来像是包装了这个Container类型，只提供一些特殊的接口，使他看起来想一个queue。 模板参数Container需要满足顺序容器的条件，而且必须支持front、back、push_back、pop_front操作，标准容器中有deque和list满足。也就是说标准容器中deque和list可以封装成queue。 ","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/:0:0","tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue与deque示例","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"queue与deque示例 queue ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:0:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例1：queue #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { queue\u003cint\u003e myQueue; cout \u003c\u003c myQueue.empty() \u003c\u003c endl; cout \u003c\u003c myQueue.size()\u003c\u003c endl; myQueue.push(1); myQueue.push(2); myQueue.push(3); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; myQueue.pop(); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; return 0; } 运行结果： 1 0 1 3 2 3 queue没找到迭代器 deque: deque是双向队列Double ended queue；can be accessed with random access iterator deque是双端队列，是可以在两端扩展和收缩的连续容器。一般deque的实现是基于某种形式的动态数组，允许单个元素用随机获取 迭代器随机读取，数组容量自动管理。 因此它有和vector相似的函数，但在序列的开始也有高效的插入和删除。但不像vector，deque的元素并不是严格连续存储的。 vector和deque有相似的接口和相似的目的，但内部实现截然不同。 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:1:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例二：deque #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cdeque\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { deque\u003cint\u003e myDeque; myDeque.push_front(1); myDeque.push_front(2); myDeque.push_back(3); myDeque.push_back(4); myDeque.push_back(5); myDeque.push_front(6); myDeque.pop_back(); deque\u003cint\u003e::iterator myItor; for(myItor=myDeque.begin(); myItor!=myDeque.end(); myItor++) cout\u003c\u003c*myItor\u003c\u003cendl; return 0; } 执行结果： 6 2 1 3 4 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:2:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例3:deque 随机访问 // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e#include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:3:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"typedef起小名","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/","tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"typedef起小名 C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 实例 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book; int main( ) { Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 typedef vs #define #define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： 实例 #include \u003cstdio.h\u003e #define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： TRUE 的值: 1 FALSE 的值: 0 ","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/:0:0","tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"常用头文件","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/","tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"常用头文件 stdafx.h MFC预编译 stdio.h 输入输出 process.h 进程 stdlib.h 声明了数值与字符串转换函数, 伪随机数 生成函数, 动态内存分配函数, 进程控制函数等公共函数 Windows.h windows系统函数(如:Sleep) string.h ANSI,多字节字符串 wchar.h Unicode,宽字符串 tchar.h 混合ANSI和Unicode字符串 ","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/:0:0","tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"笔记queue与deque","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/","tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["C++"],"content":"笔记queue与deque queue操作： queue\u003cint\u003eq; //创建一个int型空队列q q.empty(); //判断队列是否为空，为空返回true q.push(s); //将变量s从队尾入队 q.pop(); //将队头元素弹出 q.front(); //只返回队头元素 q.back(); //只返回队尾元素 q.size(); //返回队列中元素个数 queue两端访问,队尾插入,队首删除。 deque操作： deque\u003cint\u003e dq; //创建一个数双端队列dq dq.empty(); //判断队列是否为空，为空返回true dq.push_front(s);//将s从队头入队 dq.push_back(s);//将s从队尾入队，和普通队列方式一样 dq.front(); //只返回队头元素 dq.back(); //只返回队尾元素 dq.pop_front(); //将队头元素弹出 dq.pop_back(); //将队尾元素弹出 dq.size(); //返回队列中元素个数 dq.clear(); //将队列清空 dq.insert();//插入新元素,最多有四个参数 //迭代器 dq.begin(); //回傳指向第一個元素(頭端)的迭代器 dq.cbegin(); //回傳指向第一個元素(頭端)的迭代器(const) dq.end(); //回傳指向最後一個元素(尾端)的迭代器 dq.cend(); //回傳指向最後一個元素(尾端)的迭代器(const) dq.rbegin(); //回傳指向最後一個元素(尾端)的反向迭代器 dq.crbegin(); //回傳指向最後一個元素(尾端)的反向迭代器(const) dq.rend(); //回傳指向第一個元素(頭端)的反向迭代器 dq.crend(); //回傳指向第一個元素(頭端)的反向迭代器(const) deque两端访问,两端插入,两端删除。 auto it = d.begin();其全名為std::deque\u003cint\u003e::iterator it = d.begin(); ","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/:0:0","tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["WOW"],"content":"64位Call的参数","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"64位Call的参数 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:0:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call上层 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+20+8_0 参数5 rsp+20+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:1:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call内 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+28+8_0 参数5 rsp+28+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:2:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["C++"],"content":"cin和cout输入输出","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"cin和cout输入输出 简单的输入输出代码示例： #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number:\"\u003c\u003cendl; cin\u003e\u003ex; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"Please input a float number:\"\u003c\u003cendl; cin\u003e\u003ey; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果如下（↙表示按下回车键）： Please input an int number: 8↙ The int number is x= 8 Please input a float number: 7.4↙ The float number is y= 7.4 cin 连续输入示例 #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number and a float number:\"\u003c\u003cendl; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果： Please input an int number and a float number: 8 7.4↙ The int number is x= 8 The float number is y= 7.4 ","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"class 类","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/","tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["C++"],"content":"class 类 #include \u003cstdio.h\u003e//通过class关键字类定义类 class Student{ public: //类包含的变量 char *name; int age; float score; //类包含的函数 void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; int main(){ //通过类来定义变量，即创建对象 class Student stu1; //也可以省略关键字class //为类的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; //调用类的成员函数 stu1.say(); return 0; } 类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象” ","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/:0:0","tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"如何使用 GitHub pages 首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。 进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。 创建成功之后，点击右上角的 Settings 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题 这里我们就随意选择一个主题 Cayman，来看看他的效果是什么样的 选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。 在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。 到这里如果你只是想做一个例如可以随时在互联网上访问的简历，那么你只需要 GitHub Pages 项目的主页修改你 index.md 文件就可以了，比如我给出的这个模板。 修改完后，点击上图中左下角的 Commit Changes，然后访问你的自定义域名你就可以看到如下的样式了。 如果你想做一个功能更丰富的博客，那我们继续往下走。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"配置自定义域名并免费使用 HTTPS 在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。 首先在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名 blog.moyu.life 通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 brick713.GitHub.io。添加完成后等待 DNS 解析的生效（DNS 的解析记录生效到全球可能需要几分钟时间）。 之后重新回到最开始进入过的 Settings 界面，找到 GitHub Pages 的设置，填写我们刚刚建立的子域名，以我自己的 blog.moyu.life 举例，点击保存。 保存后 GitHub 需要一定的时间生成证书并确认域名的解析是否正常，我们只需要耐心的等待即可，成功后显示结果如下 现在我们再访问 blog.moyu.life 就会发现，我们的自定义域名和 HTTPS 都生效了！可以看到证书是由著名的机构 Let’s Encrypt 提供的。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:1","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站的同步 现在我们已经有了一个基本功能健全的网站了，接下来我们需要试着对博客的内容进行管理，并且给博客添加一些更个性化的设置，官方提供两种方式： 命令行方式（Mac 和 Windows 确保拥有 Git 环境） 桌面客户端形式（需要安装官方提供的客户端） 如果你没有任何 Git 的基础，也不想进行一些繁琐的配置，那么我推荐你使用桌面客户端的形式进行管理，如果你有一定的技术基础，那么 Git 的方式则更适合你。这里我两种方法都介绍一下。 首先在命令行中切换到你自定义的路径下，然后 Clone 下来你的项目（操作需要在 Mac 的 Terminal 中完成，Windows 系统可以使用 Git-bash。）这里注意这里的 path 和 username 需要根据你个人情况进行替换。 cd ~/Path git clone https://GitHub.com/username/username.GitHub.io 接着进入你的项目的文件中，并创作一个文章。 cd username.GitHub.io echo \"Hello World 我爱这个世界\" \u003e index.md 然后按照 Git 提交内容的流程，将我们的新创作的文章上传。 git add --all git commit -m \"Firs Push\" git push -u origin master 这里可能会碰到下面的情况： 按照他的提示我们把注册 GitHub 的邮箱和用户名依次输入即可： git config user.email \"你的邮箱\" git config user.name \"你的用户名\" 之后他可能会让你输入你的 GitHub 账号和密码，不用担心，正常输入即可。当我们看到这样的提升就证明提交成功了。 可以去我们的网站主页看看是不是起了变化。 如果你是使用GitHub 桌面客户端 那么就更简单了，下载安装了客户端之后，按照客户端的提示正常登陆你的 GitHub 账号。然后 Clone 下来你的 GitHub Pages 项目。 等待 Clone 完成后，界面上会显示几种管理修改你的项目的方式。 这里我选择使用 Sublime Text 进行管理，把开始的 index.md 里的内容改为 Hello World 我也爱这个世界 保存，然后在客户端上我们能看到文件的变化，我们先点击左下角的 Commit to master，再点击 Fetch origin 就可以将内容上传。 然后你发现你的主页也发生了相应改变了。到这里你基本上就掌握了网站管理的基本流程和文章发布的基本流程，下面我们要开始来学会使用静态模板系统来管理博客了。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:2","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 的生成工具 经历了上面的步骤，现在你的已经有了一个简单的页面了，可是他还远远未满足我们的需求，我们需要利用静态模板系统来让生产接管你博客的文章的生成，让你把更多的经历投入在创作里。下面就 GitHub 官方推荐的 Jekyll 为例子来展开讲讲。 因为 Jekyll 是基于 Ruby 的静态网页生成系统，因此我们首先得安装 Ruby 环境，在 Mac 下我们可以使用的 Homebrew 来进行安装。如果是其他操作系统，可以去参考 Ruby 官方安装文档进行安装。 brew install ruby command not found: brew问题解决方案 安装brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 看到==\u003e Installation successful!就说明安装成功了。 最后更新下： brew update 等 Ruby 安装完毕后再执行以下命令完成 Jekyll 的安装。 sudo gem install jekyll bundler 然后进入你 Clone 下来的 GitHub Pages 项目的路径 cd /Volumes/video/GitHub/xinqinew.github.io 执行以下命令： jekyll new . --force 完成后，Jekyll 会在你指定的目录下生成好所有文件，你可以使用 bundle exec jekyll serve 命令，然后就可以通过访问 127.0.0.1:4000 查看初始界面的样子了。 默认的界面看起来非常的简陋也很丑，但是没关系，你可以在这些网站里根据自己的喜好找到一些美观的主题http://jekyllthemes.org/、https://jekyllthemes.io/、http://themes.jekyllrc.org/。 安装方法很简单，一般情况下只需要下载主题包解压后完整的，复制到你的 GitHub Pages 的项目目录里，并覆盖你之前的文件即可，有些特殊的主题要参考作者给的安装步骤，这里我随意的更换了一个主题。 主题里的所有关键性配置都在 _config.yml 文件中，你可以根据个人的喜好和不同主题支持的功能来修改具体的内容，这里就不做展开。 到这里完整的搭建的流程已经结束了，你已经可以正常访问你一路配置下来的博客了，接下来你只需要找一个趁手的 Markdown 编辑器来编辑在你本地 GitHub Pages 项目中的 _posts 文件夹里的文章，并使用前面提到的两种方式将文章同步到 GitHub 上即可。需要注意的是，文章的内容和标题需要按照 Jekyll 的格式进行写作。 文章的文件名遵循下面的格式： 年-月-日-标题.markdown 文章内容顶部必须有下面的 YAML 头信息： --- layout: post title: Blogging Like a Hacker --- ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:3","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"尾巴 其实除了 Jekyll 还有非常多的第三方的静态模板系统来搭建 GitHub Pages。比如： Node.js 编写的 Hexo Go 编写的 Hugo Python 编写的 Pelican 以及更人性化的 Gridea 他们在各自的基础上实现了更多的功能，比如分析统计、搜索、评论系统、广告、分享系统等。喜欢折腾的同学不妨可以尝试尝试，未来如果有机会希望能更详细的给大家分享一下。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["GitHub"],"content":"Github汉化及常用插件","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"Github汉化及常用插件 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:0:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"插件 Sourcegraph Sourcegraph 可以让你在线学习代码，可以查看变量、函数等的定义和引用情况。把指针放到想查看的变量名上，它会自动显示寻找定义和引用的提示框，点击即可。 Octotree 查看整个项目的结构 油猴 Refined GitHub ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:1:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"汉化 桌面版一键汉化 下载版 chrome版汉化 GitHub那些事儿 Hexo + GitHub Pages 搭建博客 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:2:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["Markdown"],"content":"Markdown语法","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"GitBook默认使用Markdown语法。 下面这些可以作为一个快速参考和展示。更多完整的信息，请参考 John Gruber’s original spec 和 Github-flavored Markdown info page。 标题 H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:0:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H2 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H3 H4 H5 H6 对于H1和H2，有下划线样式可供选择： Alt-H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:1","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Alt-H2 强调 强调，又叫做斜体，使用 星号 或 下划线。 重点强调，又叫做粗体，使用 星号 或 下划线。 使用 **星号和_下划线_** 组合使用强调。 删除线使用两个波浪线。划掉这个 列表 在这个例子中，前导空格和尾部空格显示为圆点 : ⋅) 有序列表的第一项 另外一个项 ..* 无序子列表 事实上序号不起作用，那只是一个数字而已 ..1. 有序子列表 最后一个项 …你可以适当的缩紧列表项中的段落。注意上面的空行和前导空格（至少一个，但是这里我们使用三个来对齐原始的Markdown内容）。 …换行而不形成段落，你需要使用两个尾部空格。.. …注意这行是分开的，但还在同一个段落中。.. …（这个违背了不需要尾部空格的典型的GFM换行行为）。 无序列表可以使用星号 或者减号 或者加号 链接 有两种创建链接的方式。 内嵌式链接 带标题的内嵌式链接 引用式链接 相对引用一个库文件 你可以在引用式链接定义中使用数字 或者空着什么都不写 link text itself 用来说明引用链接的文字可以放在后面。 脚注 Markdown默认使用的脚注样式链接不会在页面中显示。有时包含一个读者可见的非超链接注脚很有用。对于这样的注脚，GitBook支持的一种简单的语法。 Text prior to footnote reference.1 这是我们的logo（停留查看标题） 内嵌式 Logo Title Text 1alt text \" Logo Title Text 1 引用式 Logo Title Text 2alt text \" Logo Title Text 2 代码和语法高亮 代码块是Markdown规范的一部分，但是语法高亮不是。然而，很多渲染器，比如GitHub的和这里的Markdown，都支持语法高亮。支持那种语言以及语言的名字应该怎样写随渲染器的不同而变化。这里的Markdown支持许语言；查看完整的列表，以及如何写语言的名字，请参考 highlight.js 演示页. 内嵌 代码 有 反引号 包含它. 代码块要么被包含三个反引号 ``` 的行包围，要么被四个空格缩进。推荐仅仅使用被包围的代码块，它们使用方便并且只有它们支持语法高亮。 var s = \"JavaScript语法高亮\"; alert(s); s = \"Python语法高亮\" print s 没有指明语言，所有没有语法高亮。 让我们随便写个标签试试 \u003cb\u003etag\u003c/b\u003e 表格 表格不是Markdown规范的核心部分，但是它是GFM的一部分，这里的Markdown也支持它。 冒号可以用来对其列。 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. 外部的管道符 (|) 是可选的，而且不需要优雅的排列Markdown。你还可以在表格中内嵌其他Markdown。 Markdown Less Pretty Still renders nicely 1 2 3 块引用 在邮件中块引用中很方便用来仿真文本的回复。 这行是同一个块的一部分。 引用结束 当这行很长的文字被包裹的时候，它依然会被恰当的引用。让我们继续写下去来确保包裹它时对于每个人来说它足够长。你可以在块引用中使用其它Markdown。 内嵌HTML You can also use raw HTML in your Markdown, and it’ll mostly work pretty well. 你同样可以在Markdown中使用HTML，并且它能很好的工作。 Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. 水平线 三个或者更多… 连字符 星号 下划线 换行符 关于学习换行符是如何工作的，我的建议是去亲身实践并总结 – 敲击 键一次（也就是插入一个换行符），然后再敲击它两次（也就是插入两个换行），看一下发生了什么。不久你就能学会它。“Markdown Toggle” 是你的朋友。 这里有一些东西可以尝试一下： 我们以这行作为开始。 This line is separated from the one above by two newlines, so it will be a separate paragraph. 这行与上面那行被两个换行符分隔，所以它会成为一个 单独的段落。 This line is also a separate paragraph, but… This line is only separated by a single newline, so it’s a separate line in the same paragraph. 这行同样是一个单独的段落，但是… 这行仅仅被一个换行符分隔，所以它是一个在 同一段落 中的单独的行。 Youtube视频 视频不能被直接添加，但你可以添加一个链接至视频的图片，像这样： 或者，使用纯Markdown，但是会丢失掉图片的大小和边框： Comment to include in footnote. 图片 ↩︎ ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"namespace 命名空间","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"namespace 命名空间 namespace 是C++中的关键字，用来定义一个命名空间，语法格式为： namespace name{ //variables, functions, classes } name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。 namespace Li{ //小李的变量定义 FILE fp = NULL; } namespace Han{ //小韩的变量定义 FILE fp = NULL } Li::fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using Li::fp; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han :: fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using namespace Li; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp #include \u003cstdio.h\u003e//将类定义在命名空间中 namespace Diy{ class Student{ public: char *name; int age; float score; public: void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; } int main(){ Diy::Student stu1; stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; stu1.say(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"printf输出","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 函式原型： int printf ( const char * format, … ); 引數說明： %[flags][width][.precision][length]specifier %[旗標][寬度][.精度][長度修飾]資料型態 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"1. 資料型態 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 必填欄位 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.1) 字元/字串 %c, %C : 字元, char c; %s : 字元陣列, char buffer[MAX_PATH]; %S : 字元陣列(Unicode), wchar buffer[MAX_PATH]; [註] %C / %S 並未被收在標準函式庫裡，屬 MSVC 特殊支援。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:1","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.2) 整數 %d, %i : 10進制整數 , int x; [lemma] %u : 10進制無號數, unsigned int x; %o : 8進制無號數, unsigned int x; %x, %X : 16進制無號數, 小寫x輸出為\"abcdef\", 大寫 X 輸出為 \"ABCDEF\", unsigned x; %lld, %I64d : long long int, __int64 輸出型態 (註：vc6.0 下只有 __int64，沒有long long int) %llu, %I64u : unsigned long long int 輸出型態 [lemma] %d : dec; %i : integer，於 scanf 時有部份差異 (%d 只接受10進位, %i 可接受指定進位，如 0x23, 045)，但於 printf 時 %d, %i 並無顯著差異 (感謝 Jacob Lee 補充指導) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:2","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.3) 浮點數 %e, %E : 浮點數使用科學符號表示之,指數將帶正負號, float x,doubley; %f : 單精度浮點數(預設輸出精度6位), float x; (註 : 對 printf 而言, %f/%lf 可適用於 double / float) %lf : 倍精度浮點數(預設輸出精度6位), double x; %llf, %LF : 雙倍精度浮點數(預設輸出精度6位), long double x; %g, %G : 由系統決定是否採科學符號表示。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:3","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.4) 特殊 原創：edisonx.pixnet.net %p : 變數位置。 ex: int a=0, printf(\"%p\", \u0026a); 即 printf(\"%08x\", \u0026a); %n : 輸出至緩衝區之長度, ex: char str[]=\"test\", int len, printf(\"%s%n\", a, \u0026len); 輸出4bytes,len = 4 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:4","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.5) C99新增 \u003c 建議 k spec. 最清楚 \u003e (註 : C99 新增了一些資料型態在 inttypes.h / stdint.h 裡面，有興趣搜尋 n1256.pdf 下載下來 K 標準， in section 7.8 。當然 MSVC 不支援 C99 是眾所皆知的事。) 部份原則還是掌握了 %i, %u, %d, %x，另由於這部份在 printf 會顯得很亂，故直接做範例對應。掌握一原則：新的資料型態在 printf 前三個字母一定是 PRI。 “%” PRIdN , “%” PRIiN: 以十進位有號數顯示 intN_t 系列之數值。ex : int8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRId8 \" \\n\", i8); int8_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIi16 \" \\n\", i16); int8_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRId32 \" \\n\", i32); int8_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIi64 \" \\n\", i64); 另上述將 PRIdN / PRIiN ，換成 PRIoN / PRIuN / PRIxN / PRIXN ，便可轉對 uintN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdLEASTN , “%” PRIiLEASTN: 以十進位有號數顯示 int_leastN_t 系列之數值。ex : int_least8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdLEAST8 \" \\n\", i8); int_least16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiLEAST16 \" \\n\", i16); int_least32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdLEAST32 \" \\n\", i32); int_least64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiLEAST64 \" \\n\", i64); 另上述將 PRIdLEASTN / PRIiLEASTN ， 換成 PRIoLEASTN/ PRIuLEASTN/ PRIxLEASTN/ PRIXLEASTN， 便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 \"%\" PRIdFASTN , \"%\" PRIiFASTN: 以十進位有號數顯示 int_fastN_t 系列之數值。ex : int_fast8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdFAST8 \" \\n\", i8); int_fast16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiFAST16 \" \\n\", i16); int_fast32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdFAST32 \" \\n\", i32); int_fast64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiFAST64 \" \\n\", i64); 另上述將 PRIdFASTN / PRIiFASTN ，換成 PRIoFASTN/ PRIuFASTN/ PRIxFASTN/ PRIXFASTN，便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdMAX , “%” PRIdPTR : 分別顯示整數最大值與指標型態。 [註 : 特別注意 inttypes.h 裡面之型態，printf 引數和 scanf 引數差很多，一樣掌握一原則，新的資料型態在 scanf 前三個字母一定是 SCN， 如 intN_t 系列，scanf 用的是 “%” SCNdN / “%” SCNiN ； uintN_t 系列，scanf 用的是 “%” SCNoN / “%” SCNuN / “%” SCNxN / “%” SCNXN ； int_fastN_t / int_leastN_t 等系列資料型態便不贅述。 ) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:5","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"2. 寬度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位net %m : 指定輸出之寬度。ex: int a=2, b=10; printf(\"%d%5d\", a, b); 輸出為 \"2 10\" (2與10之間有3個空白，因10為5個文字寬度)。 %* : 以引數方式代入指定輸出之寬度。ex: int a=2, width=10; printf(\"%*d\",width, a); 輸出為 \" 2\" (10個文字寬度)。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:2:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"3. 長度修飾 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %h : 將數字視為 short int (%hd) 或 unsigned int (%hu), 此修飾只對整數型態之 %hi, %hd, %ho, %hu, %hx, %hX 有效。 且針對 char 可用 %hhd，unsigned char 可用 %hhu。 (註 : MSVC 認得 %hd / %hu / %hhd / %hhu , 但在 gcc 下會發出認不得的警告 ) %l : 將數字視為 long int (%ld) 或 unsigned long int (%lu), 此修飾只對整數型態之 %li, %ld, %lo, %lu, %lx, %lX 有效。 %L : 此修飾只對浮點數型態之 long double 有效, 可用於修飾 %Le, %LE, %Lf, %Lg, %LG。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:3:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"4. 精度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %.n : 欲輸出小數點後幾位數,即顯示之精度,此修飾只對浮點數資料型態有效(f,F,e,E,g), 若使用其它整數型態 (i, d, o, u, x, X) 則將 n 視為 0, 即不輸出小數位數。ex: double a=2.1234, printf(\"%.2lf\", a); 輸出則為 \"2.12\" 。 %.* : 和 %.n 相似，但其 n 值可用變數引入。ex: double a=1.3456, int preci=2, printf(\"%.*lf\",preci, a); 輸出則為 \"1.35\" 。 %m.n: 這是寬度和精度合用之方法, 代表輸出會有小數點後 n 位， 且整個輸出文字寬 m 個字(包含小數點、正負號及數字)。ex: double c = -102.34567, printf(\"%10.3lf\", c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 %*.*: 和上一說明一樣, 但寬度與精度可用引數決定。ex: double c = -102.34567, int m=10, int n=3; printf(\"%*.*lf\", m, n, c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:4:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"5. 旗標 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %- : 原本輸出預設為向右對齊，使用後輸出向左對齊, 需與[寬度]配合使用。ex: char buf[] = \"Test\"; printf(\"%-10s\"); 輸出結果為 \"Test \"， Test 後面將保留6個空白。 %+ : 需為數值型之資料型態，強制輸出正負號，可與 '-' 旗標合用。 ex: double a = 3.4567: printf(\"%-+8.2lf\", a); // '-'使輸出靠左對齊, '+'強調輸出正負號, 整體寬度為8, 小數點顯示2位。 輸出結果為 \"+3.46 \" %0 : 若輸出之左半部為空白處, 則進行補0, (所以這不能和 '-' 合用) ex: unsigned int x = 122; printf(\"%05u\", x); // 寬度為5, 前半空白補零 輸出結果為 \"00122\" %# : 對進制加上前綴符號, 只對 %o, %x 有用, %#o為8進制,前綴符號為 0, %#x為16進制,前綴符號為 0x, %#X前綴符號則為 0X。ex: unsigned int a = 15; printf(\"%u %#o %#X\", a, a, a); 輸出結果為 \"15 017 0XF\" %(空白): 若數字為正號, 則會在該數字前面加上一空白，(故不可與 ‘+’ 合用)。 ex: int a=10; printf(\"% -5d\"); // 寬度5, 向左對齊, 保留正號位置 輸出結果為 \" 10 \" ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:5:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"queue用法详解","date":"2021-07-23","objectID":"/2021/07/queue/","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue用法详解 只能访问 queue 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。 许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO 准则处理的序列来说，使用 queue 容器适配器都是好的选择。 图 1 展示了一个 queue 容器及其一些基本操作： 图 1 queue容器 queue 的生成方式和 stack 相同，下面展示如何创建一个保存字符串对象的 queue: std::queue\u003cstd::string\u003e words; 也可以使用拷贝构造函数： std::queue\u003cstd::string\u003e copy_words {words}; // A duplicate of words stack、queue 这类适配器类都默认封装了一个 deque 容器，也可以通过指定第二个模板类型参数来使用其他类型的容器： std::queue\u003cstd::string, std::list\u003cstd::string\u003e\u003ewords; 底层容器必须提供这些操作：front()、back()、push_back()、pop_front()、empty() 和 size()。 ","date":"2021-07-23","objectID":"/2021/07/queue/:0:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 操作 queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同： front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026 obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T\u0026\u0026 obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 swap(queue \u0026other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 queue 模板定义了拷贝和移动版的 operator=()，对于所保存元素类型相同的 queue 对象，它们有一整套的比较运算符，这些运算符的工作方式和 stack 容器相同。 和 stack 一样，queue 也没有迭代器。访问元素的唯一方式是遍历容器内容，并移除访问过的每一个元素。例如： 1. std::deque\u003cdouble\u003e values {1.5, 2.5, 3.5, 4.5}; std::queue\u003cdouble\u003e numbers(values); 2. 3. while (!numbers, empty()) 4. { 5. std ::cout \u003c\u003c numbers. front() \u003c\u003c \" \"; // Output the 1st element 6. numbers. pop(); // Delete the 1st element 7. } 8. std::cout \u003c\u003c std::endl; 用循环列出 numbers 的内容，循环由 empty() 返回的值控制。调用 empty() 可以保证我们能够调用一个空队列的 ftont() 函数。如代码所示，为了访问 queue 中的全部元素，必须删除它们。如果不想删除容器中的元素，必须将它们复制到另一个容器中。如果一定要这么操作，我们可能需要换一个容器。 ","date":"2021-07-23","objectID":"/2021/07/queue/:1:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 容器的实际使用 这里汇集了一些使用 queue 容器的示例。这是一个用 queue 模拟超市运转的程序。结账队列的长度是超市运转的关键因素。它会影响超市可容纳的顾客数——因为太长的队伍会使顾客感到气馁，从而放弃排队。在很多情形中——医院可用病床数会严重影响应急处理设施的运转，也会产生同样的队列问题。我们的超市模拟是一个简单模型，灵活性有限。 可以在头文件 Customer.h 中定义一个类来模拟顾客： 1. // Defines a customer by their time to checkout 2. #ifndef CUSTOMER_H 3. #define CUSTOMER_H 4. 5. class Customer 6. { 7. protected: 8. size_t service_t {}; // Time to checkout 9. public: 10. explicit Customer(size_t st = 10) :service_t {st}{} 11. 12. // Decrement time remaining to checkout 13. Customer\u0026 time_decrement() 14. { 15. if (service_t \u003e 0) 16. --service_t; 17. return *this; 18. } 19. bool done() const { return service_t == 0; } 20. }; 21. #endif 这里只有一个成员变量 service_t，用来记录顾客结账需要的时间。每个顾客的结账时间都不同。每过一分钟，会调用一次 time_decrement() 函数，这个函数会减少 service_t 的值，它可以反映顾客结账所花费的时间。当 service_t 的值为 0 时，成员函数 done() 返回 true。 超市的每个结账柜台都有一队排队等待的顾客。Checkout.h 中定义的 Checkout 类如下： 1. // Supermarket checkout - maintains and processes customers in a queue 2. #ifndef CHECKOUT_H 3. #define CHECKOUT_H 4. #include \u003cqueue\u003e // For queue container 5. #include \"Customer.h\" 6. 7. class Checkout 8. { 9. private: 10. std::queue\u003cCustomer\u003e customers; // The queue waiting to checkout 11. public: 12. void add(const Customer\u0026 customer) { customers.push(customer); } 13. size_t qlength() const { return customers.size(); } 14. 15. // Increment the time by one minute 16. void time_increment() 17. { 18. if (!customers.empty()) 19. { // There are customers waiting... 20. if (customers.front().time_decrement().done()) // If the customer is done... 21. customers.pop(); // ...remove from the queue 22. } 23. }; 24. 25. bool operator\u003c(const Checkout\u0026 other) const { return qlength() \u003c other.qlength(); } 26. bool operator\u003e(const Checkout\u0026 other) const { return qlength() \u003e other.qlength(); } 27. }; 28. #endif 这相当于自我解释。queue 容器是 Checkout 唯一的成员变量，用来保存等待结账的 Customer 对象。成员函数 add() 可以向队列中添加新顾客。只能处理队列中的第一个元素。 每过一分钟，调用一次 Checkout 对象的成员函数 time_increment(}，它会调用第一个 Customer 对象的成员函数 time_decrement() 来减少剩余的服务时间，然后再调用成员函数 done()。如果 done() 返回 true，表明顾客结账完成，因此把他从队列中移除。Checkout 对象的比较运算符可以比较队列的长度。 为了模拟超市结账，我们需要有随机数生成的功能。因此打算使用 random 头文件中的一个非常简单的工具，但不打算深入解释它。我们会在教程后面的章节深入探讨 random 头文件中的内容。程序使用了一个 uniform_int_distribution() 类型的实例。顾名思义，它定义的整数值在最大值和最小值之间均匀分布。在均匀分布中，所有这个范围内的值都可能相等。可以在 10 和 100 之间定义如下分布： std::uniform_int_distribution\u003c\u003e d {10, 100}; 这里只定义了分布对象 d，它指定了整数值分布的范围。为了获取这个范围内的随机数，我们需要使用一个随机数生成器，然后把它作为参数传给 d 的调用运算符，从而返回一个随机整数。 random 头文件中定义了几种随机数生成器。这里我们使用最简单的一个，可以按如下方式定义： std::random_device random_number_engine; 为了在 d 分布范围内生成随机数，我们可以这样写： auto value = d(random_number_engine); // Calls operator()() for d value 的值在 d 分布范围内。 完整模拟器的源文件如下： 1. // Simulating a supermarket with multiple checkouts 2. #include \u003ciostream\u003e // For s[tan](http://c.biancheng.net/ref/tan.html)dard streams 3. #include \u003ciomanip\u003e // For stream manipulators 4. #include \u003cvector\u003e // For vector container 5. #include \u003cstring\u003e // For string class 6. #include \u003cnumeric\u003e // For accumulate() 7. #include \u003calgorithm\u003e // For min_element \u0026 max_element 8. #include \u003crandom\u003e // For random number generation 9. #include \"Customer.h\" 10. #include \"Checkout.h\" 12. u[sin](http://c.biancheng.net/ref/sin.html)g std::string; 13. using distribution = std::uniform_int_distribution\u003c\u003e; 15. // Output histogram of service times 16. void histogram(const std::vector\u003cint\u003e\u0026 v, int min) 17. { 18. string bar (60, '*'); // Row of asterisks for bar 19. for (size_t i {}; i \u003c v.size(); ++i) 20. { 21. std::cout \u003c\u003c std::setw(3) \u003c\u003c i+min \u003c\u003c \" \" // Service time is index + min 22. \u003c\u003c std::setw(4) \u003c\u003c v[i] \u003c\u003c \" \" // Output no. of occurrences 23. \u003c\u003c bar.substr(0, v[i]) // ...and that no. of asterisks 24. \u003c\u003c (v[i] \u003e static_cast\u003cint\u003e(bar.size()) ? \"...\": \"\") 25. \u003c\u003c std::endl; 26. } 27. } 29. int main() 30. { 31. std::random_device random_n; 33. // Setup minimum \u0026 maximum checkout periods - times in minutes 34. int service_t_min {2}, service_t_max {15}; 35. distribution service_t_d {service_t_min, service_t_max}; 37. // Setup minimum \u0026 maximum number of customers at store ","date":"2021-07-23","objectID":"/2021/07/queue/:2:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"std命名空间","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"std命名空间 使用命名空间 std： #include \u003ccstdio\u003eint main(){ std::printf(\"http://c.biancheng.net\\n\"); return 0; } 不使用命名空间 std： #include \u003ccstdio\u003eint main(){ printf(\"http://c.biancheng.net\\n\"); return 0; } 演示了如何使用 C++ 库进行输入输出： #include \u003ciostream\u003e#include \u003cstring\u003e int main(){ //声明命名空间std using namespace std; //定义字符串变量 string str; //定义 int 变量 int age; //从控制台获取用户输入 cin\u003e\u003estr\u003e\u003eage; //将数据输出到控制台 cout\u003c\u003cstr\u003c\u003c\"已经成立\"\u003c\u003cage\u003c\u003c\"年了！\"\u003c\u003cendl; return 0; } 运行结果： C语言中文网↙ 6↙ C语言中文网已经成立6年了！ 在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明. #include \u003ciostream\u003e void func(){ //必须重新声明 using namespace std; cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ //声明命名空间std using namespace std; cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中 #include \u003ciostream\u003e//声明命名空间std using namespace std; void func(){ cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"struct 结构体","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/","tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["C++"],"content":"struct 结构体 #include \u003cstdio.h\u003e //定义结构体 Student struct Student{ //结构体包含的成员变量 char *name; int age; float score; }; //显示结构体的成员变量 void display(struct Student stu){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", stu.name, stu.age, stu.score); } int main(){ struct Student stu1; //为结构体的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5; //调用函数 display(stu1); return 0; } 结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。### ","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["常见问题"],"content":"sublimetext常见问题","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"sublimetext常见问题 下载安装 汉化 1.点击tools—install package control 2.preferences—package control 3.选择 “Package Control: Install Package” 4.搜索LocalizedMenu并安装 乱码 推荐使用 Package Control 查找 ConvertToUTF8 进行自动下载安装与更新。 Mac使用Sublime撸C++代码 这两款软件让你在Mac上也能写C++ ","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"解决VS生成sdf和ipch文件太大占用空间问题 [工具]—\u003e[选项]—\u003e[文本编辑器]—\u003eC/C++]—\u003e[高级]—\u003e[回退位置]里面的三项属性值按下图进行修改，其中回退路径随便设置。 设置个回退路径这样可比较好管理这些庞大的臃肿的文件，可以定期清理它们，释放磁盘空间 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题 禁止win10五笔输入法的shift切换功能 方法一：win10系统添加开机启动项 使用组合键win+R打开运行窗口，输入“shell:startup”打开启动项文件夹。 可以把软件快捷方式复制到“启动项文件夹|”中。 方法二：注册表添加启动项 1、打开运行，输入“regedit”，打开注册表。 2、在注册表中找到如下位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run，右键“Run”新建一个字符串类型的键值。 3、右键新建的键值，选择“修改”，将数值名称改为 你要启动的程序名称如：ctfmon.exe，数值数据改为 程序所在位置的路径 如：C:\\windows\\system32\\ctfmon.exe (直接不能修改名字的，可以先点击重命名，改好名字，再点击修改，修改数值数据) 如何彻底关闭win10系统windows defender实时保护功能？ ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["WOW"],"content":"WOW部分功能代码","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"WOW部分功能代码 ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:0:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色名字 // pcall5(对象地址,0,1,0,0);//返回名字地址 void CPAGE1::OnBnClickedButton() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase64 = (UINT_PTR) LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387c88)+0x200);//角色对象 TPCALL5 pcall5 =(TPCALL5)(pBase64+0xA7640); // TPCALL5 pcall5 = (TPCALL5)((UINT_PTR) LoadLibraryA(\"Wow.exe\")+0xA7640); char szpAscii[256]={0}; // char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); char *putf8Name =(char*) pcall5(pRoleObj,0,1,0,0); utf8ToAscii(putf8Name,szpAscii); m_edt_strA=szpAscii; UpdateData(FALSE);//把变量的数据更新到窗口 //UpdateData(TRUE);//把窗口的数据更新到变量 } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:1:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历怪物列表 void 遍历怪物列表() { UINT64 exeBase = (UINT64)LoadLibraryA(\"Wow.exe\"); for (UINT i=0;i\u003c=0x7F;i++)//7F可能不是 对象数量 对象的分类编号 { // UINT64 vrax=0; UINT64 vrax = R8(R8(R8(exeBase+0x2387C88)+0x30)+0x10+i*3*8); if (vrax == 0 ) { break; } // else//vrdx !=0 // { // vrax = vrdx; // } UINT64 vrcx = (UINT64)R4(R8(R8(exeBase+0x2387C88)+0x30)+i*3*8);//+28 while((vrax\u00261)==0) { //遍历同类链表 //rcx = dword([[wow.exe+0x2387C88]+0x30]+i*3*8) //0x28 //+198]+20 //float x,y,z UINT64 pNode198 = R8(vrax+0x198); float x = R4F(pNode198+0x20); float y = R4F(pNode198+0x24); float z = R4F(pNode198+0x28); char buf[2048]; char asciiObjName[2048]={0}; char *pObjName=GetObjName(vrax); if (pObjName\u0026\u0026pNode198) { utf8ToAscii(pObjName,asciiObjName); } sprintf_s(buf,\"yjx:[%d] vrax=%p (%f,%f,%f) vrcx=%llx name=%p %s\\r\\n\",i,vrax,x,y,z,vrcx,pObjName,asciiObjName); MessageBoxA(0,buf,\"while\",0); vrax = R8(vrcx+vrax+8); //链表 } } } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:2:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取对象名字 char* GetObjName(UINT64 vrcx) { char *putf8Name=NULL; __try { UINT64 pBase64 = (UINT_PTR)LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387C88)+0x200); TPCALL5 pcall5 = (TPCALL5)(pBase64+0x8AE040); char szpAscii[256]={0}; putf8Name = (char*)pcall5(vrcx,0,1,0,0); }__except(1) { } return putf8Name; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:3:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"使用技能 void TGCALL::UseActionCall(UINT32 SkillID,UINT64* argBuf40,UINT64 *TargetID16) { typedef UINT64 (*TPCALL4)(UINT64 arg1,UINT64* arg2,UINT64 arg3,UINT64* arg4); TPCALL4 pcall=(TPCALL4)(GameBase::GetExeBase()+0x77DC40); __try { pcall(SkillID,argBuf40,0,TargetID16); }__except(1) { MessageBoxA(0,\"ERROR 0x77DC40\",\"错误\",MB_OK); } return; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"火球术 void CPAGE1::OnBnClickedButtonFire() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0,0}; // 0x006FCC00007B4493 /*ID1*/,0x204D880000001140 /*ID2*/};//目标怪物的ID TGCALL::UseActionCall(0x00000085,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:1","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"霜甲术 void CPAGE1::OnBnClickedButtonIce() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0/*ID1*/,0/*ID2*/}; //目标怪物的ID TGCALL::UseActionCall(0x000000A8,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:2","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"捡物 void CPAGE1::OnBnClickedButtonPick() { // TODO: 在此添加控件通知处理程序代码 TPCALL4 pcall4 = (TPCALL4)(GameBase::GetExeBase()+0xF2A620); pcall4(0,0,0,0); pcall4(1,0,0,0); pcall4(2,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:5:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"搜索选中怪身上的物品 void CPAGE1::OnBnClickedButtonSeachgoods() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase = R8(GameBase::GetExeBase()+0x21E2858); UINT64 ID1 = R8(pBase+0x30); UINT64 ID2 = R8(pBase+0x38); UINT64 arg1[40] = {ID1,ID2,0,0}; //通过选中对象ID 查找对象 TPCALL4 pcallGetObj1=(TPCALL4)(GameBase::GetExeBase()+0xB66AB0); UINT64 vrax = pcallGetObj1((UINT64)arg1,0,0,0);//一个参数 char buf[1024]; sprintf_s(buf,\"vrax=%llx \\r\\n\",vrax); TPCALL4 pcall =(TPCALL4)(R8(R8(vrax)+0x2C0));//2C0 右键单击 打开搜索物品的窗口 pcall(vrax,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:6:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色对象地址 UINT64 GameBase::GetRoleObj()//返回角色对象地址 { // return R8(R8(GetExeBase()+0x2387C88)+0x200); TPCALL2 pcall2 = (TPCALL2)(GameBase::GetExeBase()+0x1127550); const char *vrcx = \"player\"; return pcall2((UINT64)vrcx,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:7:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串 让喊话内容支持中文 //AnsiToUtf8.h #pragma once //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); //AnsiToUtf8.cpp #include \"stdafx.h\"#include \"AsciiToUTF8.h\"#include \u003cWindows.h\u003e /* //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); */ DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf) { int WLength = MultiByteToWideChar(CP_ACP, 0, Ansi, -1, NULL, 0); LPWSTR pszW = (LPWSTR) _alloca((WLength+1) * sizeof(WCHAR)); //Ansi字符串转Unicode字符串 MultiByteToWideChar(CP_ACP, 0, Ansi, -1, pszW, WLength); //计算UTF8转换所需要空间大小 int ALength = WideCharToMultiByte(CP_UTF8, 0, pszW, -1, NULL, 0, NULL, NULL); //LPSTR pszA = (LPSTR)_alloca( ALength + 1); WideCharToMultiByte(CP_UTF8, 0, pszW, -1, szpUtf8Buf, ALength, NULL, NULL); szpUtf8Buf[ALength]=0; szpUtf8Buf[ALength+1]=0; //pszA[ALength] = 0; return ALength;//返回UTF8字符串长度 } char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr) { //预算-缓冲区中多字节的长度 //CP_OEMCP int ansiiLen =WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,nullptr,0,nullptr,nullptr); //给指向缓冲区的指针变量分配内存 //把szpUnicodeStr里存放的Unicode编码字串 转成ASCII存放到 szpAsciiStr缓冲区 //CP_OEMCP WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,szpAsciiStr,ansiiLen,nullptr,nullptr); return szpAsciiStr; } WCHAR* utf8ToUnicode(IN char*szpUtf8,OUT WCHAR*szpUniCode) { //预算_缓冲区中宽字节的长度 //CP_UTF8 963页码 int unicodeLen = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); //给指向缓冲区的指针变量分配内存 WCHAR *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); //开始向缓冲区转换字节 //CP_UTF8 963页码 也可能 MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,pUnicode,unicodeLen); wcscpy_s(szpUniCode,unicodeLen,pUnicode); free(pUnicode); return szpUniCode; } //注意此函数没检测缓冲区大小 char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii) { int iSizeUtf8 = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); WCHAR*putf8Buf =(WCHAR*)malloc(sizeof(WCHAR)*iSizeUtf8); utf8ToUnicode(szpUtf8,putf8Buf); UniCodeToAscii(putf8Buf,szpAscii); return szpAscii; } BOOL CharToHex(OUT char*szpBufHex,BYTE c) { BYTE bLow =0; BYTE bHigh = 0; bLow = c%16;//取低位0..15 bHigh = c/16;//取高位0..15 if (bHigh\u003e9) { szpBufHex[0]='A'+bHigh-10;//'B' } else//0..9 { szpBufHex[0]='0'+bHigh;//'0'+2='2' } if (bLow\u003e9)//a,b,c,e,f { szpBufHex[1]='A'+bLow-10;//'B' } else//0..9 { szpBufHex[1]='0'+bLow;//'0'+2='2' } szpBufHex[2]=0;//0 return TRUE; } DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf) { //1 //01 for (DWORD i=0;i\u003c nbDataSize;i++) { //提高速度 CharToHex(\u0026szpHexBuf[i*2],nbData[i]); } return TRUE; } ","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客 jekyll-rtd-theme 安装配置及写作 测试文档 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装时终端出现问题的解决办法 清空Gemfile文件内容 终端运行 bundle update Gemfile文件添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 终端再次运行 bundle update ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"一.安装 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"a.基于本地主题 1.清空Gemfile文件内容,并添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 2.将以下内容添加到您的网站 _config.yml title:Your awesome titlelang:endescription:Write an awesome description for your new site heretheme:jekyll-rtd-theme ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:1","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"b.基于远程主题 将以下内容添加到您的 github 存储库 _config.yml remote_theme: rundocs/jekyll-rtd-theme 删除任何其他theme或remote_theme条目 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:2","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"二.设置侧边栏(子目录) 在根目录新建子目录 子目录中必须有一个README.md 排序 _config.yml中添加以下内容 readme_index: with_frontmatter: true 在需要排序的文件中添加 格式头 --- sort: 1 # follow a certain sequence of letters or numbers --- ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"三.在README文件中列出文件 在README文件中添加 如果要列出子目录的所有文件则添加 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"四.语法 思维导图 graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 笔记 这是笔记 支持 Markdown, 文本可以是**粗体**, _斜体, or ~~删除线~~. [链接](https://github.com) 是蓝色的,且没有下划线 `inline code` [`inline code inside link`](#) 提示 它比面包盒还大.. 警告 强烈的散文可能会引起极度的脑力消耗。强烈建议读者酌情决定. 危险 疯狂的科学家在工作！ 更新 sudo bundle install sudo bundle update sudo bundle update jekyll ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:5:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"常用API函数","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"常用API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:0:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"模拟鼠标 LRESULT SendMessage(HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam); 其中Msg可以为WM_LBUTTONDOWN或WM_LBUTTONUP,表示对鼠标的软件模拟操作(虽然兼容性和安全性不如硬件模拟的mouse_event，但不改变移动鼠标指针) 故一般写作SendMessage(hwnd, WM_LBUTTONUP/WM_LBUTTONDOWN, 0, Y坐标«16+X); Msg也可以为WM_CLOSE,表示关闭窗口,其后的两个参数传0即可. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL注入 HANDLE CreateThread(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD ,LPDWORD); CreateThread 将在主线程的基础上创建一个新线程 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); VirtualAllocEx 向指定进程申请内存 FARPROC GetProcAddress(HMODULE hModule, LPCSTR); GetProcAddress 检索指定的动态链接库(DLL)中的输出库函数地址 HANDLE CreateRemoteThread(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); CreateRemoteThread 创建一个在其它进程地址空间中运行的线程 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL劫持 __asm{ } 执行括号内的汇编代码 JMP EAX 将EIP跳转到EAX执行，劫持DLL后要获取真正的原函数地址，使用时要进行跳转 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GDI绘图 HDC GetDC(HWND hWnd); 检索显示设备上下文环境的句柄 CDC CDC类定义的是设备上下文对象的类 CPoint CDC::MoveTo(int x,int y); CPoint CDC::LineTo(int x,int y); 绘制直线 BOOL CDC::Ellipse(int x1,int y1，int x2,int y2); 绘制圆形 BOOL CRgn::CreateRectRgn(int x1,int y1,int x2,int y2); 建立方形区域 BOOL CRgn::CreateEllipticRgn(int x1,int y1,int x2,int y2) 建立圆形区域 int CombineRgn(CRgn pRgn1,CRgn pRgn2,int nCombineMode ); 合并区域(圆点准心为使得中间透明采取大圆-小圆的区域) BOOL FillRgn(CRgn pRgn,CBrush pBrush ); 填充形状 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"其它API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"MoveWindow BOOL MoveWindow( HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint ); 改变指定窗口的位置和大小 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:1","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindow BOOL IsWindow(HWND hWnd)； 判断是否是有效窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:2","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindow BOOL ShowWindow(HWND hWnd, int nCmdShow); 显示隐藏窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:3","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindowAsync BOOL ShowWindowAsync(HWND hWnd，int nCmdshow)； 异步显示窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:4","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowVisible BOOL IsWindowVisible(HWND hWnd); 获取窗口可视状态,即显示或隐藏 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:5","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsZoomed BOOL IsZoomed(HWND hWnd)； 窗口是否是最大化 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:6","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowUnicode BOOL IswindowUnicode(HWND hwnd)； 判断窗口字符集 由RegisterClassA 还是RegisterClassW注册 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:7","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"CloseWindow BOOL CloseWindow(HWND hWnd); 关闭窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:8","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"WindowFromPoint HWND WindowFromPoint(POINT Point)； 获取指定坐标处的窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:9","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ChildWindowFromPoint HWND ChildWindowFromPoint (HWND hWndParent, POINT Point); 获取指定窗口 坐标处子窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:10","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetWindowText Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount); 获取窗口标题字符串 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:11","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetClassName int GetClassName(HWND hWnd, LPTSTR IpClassName, int nMaxCount); 获取窗口注册的类名,由RegisterClass注册时的名字 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:12","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"BringWindowToTop B00L BringWindowToTop(HWND hWnd); 窗口激活并切换到Z序顶层 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:13","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnableWindow BOOL EnableWindow(HWND hWnd，BOOL bEnable); 是否接收键盘鼠标消息 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:14","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnumChildWindows BOOL EnumChildWindows(HWND hWndParent,WNDENUMPROC lpEnumFunc, LPARAM lParam); 遍历子窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:15","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowPos WINUSERAPI BOOL WINAPI SetWindowPos(HWND hWnd,HWND hWndInsertAfter,int X,int Y,int cx, int cy, UINT uFlags); 窗口位置设置 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:16","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowText BOOL SetWindowText(HWNDhwnd,LPCTSTRlpString); 设置窗口标题,SetWindowText也分A和W两种 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:17","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["WOW"],"content":"模块及进程相关代码","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"模块及进程相关代码 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:0:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"句柄 进程 内存 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"窗口句柄 HWND FindWindow( LPCTSTR IpClassName， //窗口的类名 LPCTSTR IpWindowName); //窗口的标题 HWND FindWindowW(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用Unicode字符集,IpWindowName前要加L,如L”魔兽世界“ HWND FindWindowA(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用多字节字符集 HWND FindWindowEx( //该函数获得一个窗口的句柄，该窗口的类名和窗口名与给定的字符串相匹配 HWND hwndParent, //要查找子窗口的父窗口句柄 HWND hwndChildAfter, //子窗口句柄 LPCTSTR lpszClass, //窗口的类名 LPCTSTR lpszWindow); //窗口的标题 //如果hwnjParent为NULL，则函数以桌面窗口为父窗口，查找桌面窗口的所有子窗口。 //如果hwndParent为HWND_MESSAGE，函数仅查找所有消息窗口。 //子窗口必须为hwndPareRt窗口的直接子窗口而非后代窗口。 //如果HwndChildAfter为NULL，查找从hwndParent的第一个子窗口开始。 //如果hwndParent 和 hwndChildAfter同时为NULL，则函数查找所有的顶层窗口及消息窗口。 通过类名或窗口名查找，返回窗口句 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:1","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程ID和线程ID DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId); 得到窗口句柄后通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:2","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程句柄 HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId); 打开一个已存在的进程对象，并返回进程的句柄 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:3","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"写入内存 bool WriteProcessMemory( HANDLE hProcess, //进程句柄 LPVOID lpBaseAddress, //内存首地址 LPVOID lpBuffer, //指向要写的数据的指针 DWORD nSize, //字节数 LPDWORD lpNumberOfBytesWritten ); //这个是返回实际写入的字节 能写入某一进程的内存区域。入口区必须可以访问，否则操作将失败 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:4","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"读取内存 HWND ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead); 根据进程句柄读入该进程的某个内存空间lpBaseAddress的nSize字节，并写入缓冲区lpBuffer，多次计算基址和偏移即可 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:5","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历模块 int 遍历进程模块(DWORD 进程PID) { HMODULE hMods[1024]; //20*sizeof(HMODULE) HANDLE 进程句柄; DWORD cbNeeded; unsigned int i; //Print the proess identifier. printf(\"\\nprocess ID: %u\\n\",进程PID); //Get a handle to the process. 进程句柄=OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程PID); if (NULL == 进程句柄) return 1; //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return 0; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:2:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取窗口句柄 HWND CFINDCODE::GetGameHwnd(void) { HWND hNext = FindWindowExA(HWND_DESKTOP,0,0,0); HWND h2 = FindWindowExA(HWND_DESKTOP,hNext,0,0); int i =0; while(h2) { char buf[256]={0}; GetWindowTextA(h2,buf,256); if (strstr(buf,szGameSubCaption)) { break; } h2 = FindWindowExA(HWND_DESKTOP,h2,0,0); } return h2; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:3:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程ID DWORD CFINDCODE::GetPID() { HWND h=GetGameHwnd(); DWORD dwpid=0; GetWindowThreadProcessId(h,\u0026dwpid); return dwpid; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:4:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程句柄 HANDLE CFINDCODE::GetGameHp() { DWORD dwPid = GetPID(); HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS,0,dwPid); // printf(\"hp=%hp, pid=%d\\r\\n\",hp,dwPid); return hp; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:5:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块起始地址 UINT_PTR CFINDCODE::GetExeBase() { UINT_PTR exeBase64=NULL; HMODULE hMods[1024]; //20*sizeof(HMODULE) DWORD cbNeeded; unsigned int i; HANDLE 进程句柄=GetGameHp(); //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //如果是“*.exe”的模块,直接返回基址 if (strstr(szModName,\".exe\")) { exeBase64 = (UINT_PTR)hMods[i]; } //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); // printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return exeBase64; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:6:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE结束地址 UINT_PTR CFINDCODE::GetExeEnd() { // HANDLE 进程句柄=GetGameHp(); // UINT_PTR 模块基址 = GetExeBegin(); // MEMORY_BASIC_INFORMATION meminfo; // //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 // SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); // UINT_PTR 结束地址=(UINT_PTR)meminfo.AllocationBase+meminfo.RegionSize; // printf(\"GetExeEnd: AllocationBase=%llx,RegionSize=%X 结束地址=%llx \\r\\n\",meminfo.AllocationBase,meminfo.RegionSize,结束地址); // return 结束地址; return GetExeBase()+GetExeSize(); } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:7:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块大小 SIZE_T CFINDCODE::GetExeSize(); { static SIZE_T nSize=0; if (nSize) { /* code */ return nSize; } HANDLE 进程句柄=GetGameHp(); UINT_PTR 模块基址 = GetExeBase(); MEMORY_BASIC_INFORMATION meminfo; //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); nSize = meminfo.RegionSize; CloseHandle(进程句柄); return nSize; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:8:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["博客"],"content":"LoveIt - 1前期准备","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"前言 这篇教程介绍了如何搭建这样效果的博客。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"所需步骤 可以从这样的角度出发： 注册域名。 使用CDN加快网站访问速度。 网站内容需要部署在服务器或对象存储平台上。 重要的是放什么内容。博客需要选择框架，或自己开发。 框架确定后，选择主题，或自己开发。 配置主题。 发表第一篇Hello World！ 在这个过程中，前期准备阶段包括：框架选择、主题选择、注册域名、备案和CDN配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"博客框架 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"框架选择 Wordpress 缺点：不安全。 主题推荐：Sakura Hexo 缺点：渲染生成文章速度不如Hugo。 主题推荐：matery Hugo The world’s fastest framework for building websites. ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"结论 选择Hugo框架。 静态博客方便备份。 用Markdown写文章，方便以后迁移。 缺点，使用对象存储服务需要支付流量费，存在被DDOS的风险。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"下载 Hugo和Hugo extend区别 Hugo extend支持Sass/SCSS。下载地址 Windows可考虑使用scoop下载, 安装与升级很方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"Hugo主题 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt 功能很全面的一个主题，支持很多功能，节省了不少自己折腾的时间。LoveIt主题介绍 安装主题有两种方案，如果不修改主题配置和模板，可以直接添加添加子模块，这样比较简单。 修改主题会麻烦一些，但是可以让自己的博客与众不同。需要将Fork到自己的仓库，有一个缺点，fork后添加的submodule是自己的仓库，使用Dependabot需要手动和上游同步之后，才会触发blog仓库更新检查。所以不适用Dependabot。 不修改主题模板 添加子模块到blog仓库的themes目录下。 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 可设置Dependabot自动合并主题更新，参考：About Dependabot version updates和Automate Theme Update。 Fork主题后进行DIY fork主题到自己的仓库。 添加子模块： git submodule add \u003c自己仓库的url\u003e \u003cpath\u003e 设置上游进行同步，在主题目录中执行 git remote add upstream \u003c上游主题的url\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"toha toha是一个非常适合做个人简历的主题。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"注册域名 万网注册域名。 配置DNS解析，域名邮箱解析等可能存在冲突。 参考DNS解析冲突规则 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"HTTPS证书 使用HTTPS证书避免HTTP劫持风险，劫持https请求需要伪造证书。 阿里云可申请免费HTTPS证书，但是一个子域名需要单独申请一个证书。 Chrome浏览器HTTP网站显示“不安全”，是怎么回事? 谷歌从Chrome 56版本浏览器开始对使用HTTP协议传输密码信息的网站进行“不安全”警告；而2018年7月，谷歌Chrome 68将对所有HTTP网站显示“不安全”警告。随着Chrome浏览器的版本升级，会有越来越多的用户看到HTTP网站的“不安全”警告。来源：https://www.sohu.com/a/242732942_188485 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"备案 IPC备案 公安备案 如果在万网购买的域名，备案过程很简单，按要求填写信息，上传照片即可。注意照片要合要求，否则可能会被打回来重新上传。 香港，国外的服务器不需要备案。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"CDN 购买CDN资源包，加速域名访问。静态博客不需要购买动态请求次数。 以上步骤完成后，将域名解析到CDN，CDN加速源站或对象存储服务（在部署阶段介绍）。访问域名，确定CDN是否加速。 通过ping命令查看IP是否为CDN的IP。 打开Chrome控制台，查看返回包头是否有X-Cache字段。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:7:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt - 2部署","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"前言 完成前期的准备工作后，在部署阶段需要配置服务器或对象存储服务。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储和服务器对比 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储平台 国内有阿里云OSS、腾讯COS、又拍云、七牛云等。国外有Github Pages、Netlify、Azure、Google等，其中Github Pages免费，但是有个说法：Github屏蔽百度爬虫，使用Github Pages的网站百度搜不到。 对象存储平台也可以做为Markdown图床，配合CDN，加快图片加载速度。 笔者的服务器是阿里家的，所以对象存储也用了阿里云OSS。 阿里云OSS部署参考 Hugo 静态网站部署及免费 HTTPS 证书配置 OSS常用工具汇总 对象存储的配置非常简单，哈喽沃德先生的这篇文章已经很详细了，按照这篇文章可以完成上传操作。文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 需要注意的是，上传的Bucket要设置为公共读权限，同时限制Refer，做好防盗链。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器 平时有使用VPS需求，可选择使用VPS。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对比 对象存储： 优点：便宜，不需要搭建环境。 缺点：流量费用，要考虑图床的防盗链。 服务器： 优点各种踩坑😔，可以提升技能。 费用： 对象存储平台不考虑流量费：7.2元/年。 阿里云服务器，学生党及年龄小于等于24岁：10元/月；不满足以上条件的个人：121元/月。 结论 对象存储上手简单，成本低。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器环境 不使用服务器部署的读者，可跳过这部分。 操作系统Ubuntu 更新安装源 apt update 修改hostname hostnamectl --static set-hostname localhost 重启 安装软件 apt install git apt install nginx apt install rz apt install unzip ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"SSH安全配置 安全组限制IP通过SSH远程登陆。如果使用Github Action安全组无法限制，Github Action的服务器部署在Azure上，官方文档中包含几万行IP段，不适合做限制。 修改22端口。由于第一个原因，只能修改端口。否则Massscan3分钟全网段扫描，触发SSH口令暴力破解，几乎每天都有告警。注意！修改之后，确定其他端口可以登陆再关闭22端口。 配置SSH key避免执行git命令时用户密码验证。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"Nginx配置 root权限启动。避免前端访问403的问题。/etc/nginx/nginx.conf中启动配置的用户与实际启动nginx的用户需要保持一致，可修改为低权限用户启动。 如果Nginx版本存在漏洞，以root权限启动，存在被拿到root权限的风险。 配置 /etc/nginx/nginx.conf ... include /etc/nginx/conf.d/*.conf; # 注释下面这行。如果sites-enabled/路径下存在默认配置文件，可能覆盖/etc/nginx/conf.d/default.conf配置 # include /etc/nginx/sites-enabled/*; ... 配置 /etc/nginx/conf.d/default.conf server { listen 80; server_name www.xiaodejiyi.com xiaodejiyi.com; # 注意www和没有www都要配置 index index.html index.htm; root /var/www/html/public; location / { root /var/www/html/public; index index.html; } error_page 404 /404.html; } ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"上传 将blog的public目录压缩为zip格式，使用rz命令上传到服务器上，unzip命令解压到Nginx配置的网站根目录中。 正常情况下，域名解析到CDN，CDN设置源站IP。到这一部可以访问域名，查看部署结果。如果blog配置未完成，可以先上传一张图片做测试。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"参考 阿里云帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"LoveIt - 3主题配置","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"前言 博客部署完成后，恭喜你可以发表第一篇：Hello world！但是LoveIt这么好用的主题，不配置一番可惜了。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"基本功能配置 主题配置最好参考已有的配置，比如LoveIt作者写的介绍，还有主题目录下的配置文件\\themes\\LoveIt\\exampleSite\\config.toml文件。 笔者认为一些配置项解释的不够清楚，所以将网站的源码放在了Github上，仅供参考。 下面介绍其中一些配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"双语言配置 配置后需要每篇文章存在多个语言的文件，否则会报错。 例如：content\\about\\index.en.md、content\\about\\index.zh-cn.md ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"Gravatar头像 gravatar头像注册，需要使用wordpress帐号，注册帐号时，有些邮箱的邮件会被过滤，使用163邮箱等了1个多小时方才收到注册的邮件。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"图片画廊功能 在配置文件config.toml中开启lightgallery # 是否使用 lightgallery lightgallery = true 或者在文章的头部参数中设置lightgallery: true 最后文章中的图片引用格式为：![weichat](/images/weichat-logo_500px.png \"公众号\")，注意路径后面要加\"内容\"。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"搜索配置 使用algolia作为搜索引擎，因为lunr的加载速度会让你等到花都谢了。虽然algolia需要上传index.json，但是可以使用Algolia Atomic简化操作。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:4","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"评论系统设置 国内不能用disqus，不过还有Valine评论系统。留言可以设置邮件提醒功能，但是LeanCloud的云引擎域名需要使用自己的域名并配置DNS解析。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:5","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息设置 首页的社交信息，不同语言的界面，可分别设置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:6","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息拓展 以微信公众号为例。 在config.toml的社交信息中添加 # 作者的社交信息设置[social]...Wechat = \"https://img.xiaodejiyi.com/img/wechat%20logo_500px.png\"... 配置themes\\LoveIt\\assets\\data\\social.yml: # 064: wechatwechat:# weight值排序Weight:2Title:公众号Newtab:trueIcon:Simpleicons:wechat 其中图标可参考其他形式，如： # Src形式cnblog:Weight:1Prefix:https://www.cnblogs.com/Title:博客园Icon:# themes\\LoveIt\\assets\\svg\\icons\\cnblog.svgSrc:svg/icons/cnblog.svg# fontawesome class形式mastodon:Weight:56Prefix:https://mastodon.social/Title:MastodonIcon:Class:fab fa-mastodon fa-fw# Simpleiconsgooglescholar:Weight:54Template:https://scholar.google.com/citations?%vTitle:Google ScholarIcon:# themes\\LoveIt\\assets\\lib\\simple-iconsSimpleicons:googlescholar ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:7","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"使用站长工具，向搜索引擎提交网站地图 让搜索引擎收录网站内容。 百度搜索资源平台 https://ziyuan.baidu.com/site/index#/ Google search console https://search.google.com/search-console/about?hl=zh-CN # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [verification] google = \"xxxxxxxxxxxxxxxx\" bing = \"\" yandex = \"\" pinterest = \"\" baidu = \"code-xxxxxxx\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:8","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站统计与分析 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站流量分析 分析网站点击流量，访客IP等数据。 Google Analytics 百度统计 注册后，需要先添加DNS解析，验证域名所有权，可能会与其他解析记录存在冲突。 解决方法，暂停其他解析，验证所有权通过后，在网站分析中配置ID，最后删除验证的DNS解析，重新开启其他冲突的解析记录。 # Google网站分析配置 [analytics] enable = true # Google Analytics [analytics.google] id = \"G-xxxxxxx\" # 是否匿名化用户 IP anonymizeIP = true 百度统计需要在网站代码中加入百度的统计代码，可以在themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中添加以下代码。 {{- /* baidu Analytics */ -}} \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); # 需要修改为自己的url hm.src = \"https://hm.baidu.com/hm.js?9c04b6d35915817e67da8ad2fdcfbfdf\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e # 下面网站访问数量统计中，友盟+和51LA也可以加在这里。 {{- /* 51la Analytics */ -}} \u003cscript type=\"text/javascript\" src=\"//js.users.51.la/21009067.js\"\u003e\u003c/script\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站访问数量统计 对比样式之后，选择了51LA统计。也可以用JS修改统计的样式。 这三个访问统计都需要在网站代码中加入统计的JS代码。注册后，获取JS统计代码，可以和网站流量分析中百度分析一样加到themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中。 不算子 样式： 本文总阅读量929966次 本站总访问量3152598次 本站总访客数672421人 友盟+ 互联网数据服务平台缔元信和CNZZ合并成为友盟+。 样式： 站长统计 | 今日IP[43] | 今日PV[191] | 昨日IP[31] | 昨日PV[133] | 当前在线[5] 51LA 样式： 总访问量 21,195，本月访问量 2,820，昨日访问量 93，今日访问量 103，当前在线 4 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"归档页面文章总数 在themes\\LoveIt\\layouts\\_default\\section.html中添加以下代码： \u003c!-- articles --\u003e \u003cspan style=\"font-size:.8rem;font-weight:500;\"\u003e {{- len ( where .Site.RegularPages \"Section\" \"posts\" ) | dict \"Nums\" | T \"totalPageNums\" -}} \u003c/span\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [totalPageNums] other = \"共 {{ .Nums }} 篇文章\" # themes\\LoveIt\\i18n\\en.toml [totalPageNums] other = \" {{ .Nums }} articles\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站总字数统计 参考Hugo 总文章数和总字数。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:4","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"底部链接设计 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"关于知识共享许可协议 可以看这篇“知识共享”（CC协议）简单介绍，笔者最终决定采用：知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站运行时间 在themes\\LoveIt\\layouts\\partials\\footer.html中加入以下代码。 {{- /* Hugo and LoveIt */ -}} {{- if ne .Site.Params.footer.hugo false -}} \u003cdiv class=\"footer-line\"\u003e # 运行时间在这里 \u003cspan id=\"timeDate\"\u003e{{ T \"worktime\" }}\u0026nbsp;|\u0026nbsp;\u003c/span\u003e \u003cscript\u003e var now = new Date(); function createtime() { var start_time= new Date(\"09/16/2020 00:00:00\"); now.setTime(now.getTime()+250); days = (now - start_time ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); var worktime = document.getElementById(\"timeDate\").innerHTML.replace(/time/, Math.floor(days)); document.getElementById(\"timeDate\").innerHTML = worktime ; } createtime(); \u003c/script\u003e {{- $hugo := printf `\u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener noreffer\" title=\"Hugo %v\"\u003eHugo\u003c/a\u003e` hugo.Version -}} {{- $theme := .Scratch.Get \"version\" | printf `\u003ca href=\"https://github.com/dillonzq/LoveIt\" target=\"_blank\" rel=\"noopener noreffer\" title=\"LoveIt %v\"\u003e\u003ci class=\"far fa-kiss-wink-heart fa-fw\"\u003e\u003c/i\u003e LoveIt\u003c/a\u003e` -}} {{- dict \"Hugo\" $hugo \"Theme\" $theme | T \"poweredBySome\" | safeHTML }} \u003c/div\u003e {{- end -}} i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [worktime] other = \"运行 time 天\" # themes\\LoveIt\\i18n\\en.toml [worktime] other = \"Almost time days.\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"小徽章 如果你喜欢这样的小徽章，前往shield进行DIY吧！参考动态小牌子制作 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"第三方库配置 使用jsdelivr加速第三方库文件的加载。 LoveIt主题对cdn文件的加载过程是这样的。 配置文件中补充cdn文件名称，可以直接复制主题的cdn文件到blog的assets/data/cdn/目录下。 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\"jsdelivr.yml\") # 位于 \"themes/LoveIt/assets/data/cdn/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/cdn/\" data = \"\" themes\\LoveIt\\layouts\\partials\\init.html中读取cdn文件中的数据，.Scratch.Set \"cdn\" $cdn设置全局变量，之后在其他文件中使用.Scratch.Get \"cdn\"获取cdn数据。 themes\\LoveIt\\layouts\\partials\\assets.html将cdn中的第三方库渲染后，追加在页面结尾部分。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"调用JS的三种方法 查找jsdelivr已有的第三方库，加入jsdelivr.yml中。 在themes\\LoveIt\\layouts\\partials\\assets.html中添加jquery.min.js，需要jquery文件位于assets\\js\\jquery.min.js。 {{- /* custom jquery */ -}} {{- $source := $cdn.jqueryJS | default ( resources.Get \"js/jquery.min.js\" ) -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} 配置文件中添加第三方库配置 # 第三方库配置 [page.library] [page.library.css] # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" # css路径：assets\\css\\custom.css customCSS = \"css/custom.css\" [page.library.js] # someJavascript = \"some.js\" # 位于 \"assets/\" # 或者 # someJavascript = \"https://cdn.example.com/some.js\" customJS = \"js/custom.js\" 完成以上配置后，可满足很多功能需求。但如果要拓展主题功能，像分类，列表页面，则需要学习Hugo语法。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"LoveIt - 4功能拓展","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"前言 本文介绍一些拓展功能，如文章页面功能增加二级菜单，相关文章推荐和赞赏。另外，使用脚本会大大简化写作后的上传流程。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"文章页面功能 这部分功能的拓展主要是用前端的JS和CSS，如果对前端不了解，可以参考放在Github上的网站源码。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"二级菜单 导航栏放都太多链接不分主次，不够简洁。尝试多种方案后，做出了现在的二级菜单。 使用bootstrap框架 引入了太多样式，界面被扰乱，不够友好。 Select标签 样式单一，不能修改。 Hover属性 多个二级菜单不能使用相同参数的绝对定位，拓展太麻烦。 最终方案是：引入Jquery，使用Jquery的slideToggle()方法。可拓展，不影响原有界面。步骤如下。 调整下拉菜单的样式 /* dropdown menus css*/ .dropdown { position: relative; display: inline; margin: 0px; } .dropdown-menu { position: absolute; left: 0; z-index: 1000; float: left; min-width: auto; padding: 2px 1px; font-size: 14px; text-align: left; list-style: none; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu-mobile { width: 100%; position: relative; background: transparent; text-align: center; } .dropdown-menu.show { display: block; } .dropdown-item { display: block; margin: .4rem 0.5rem; clear: both; font-weight: 400; color: #212529; text-align: inherit; white-space: nowrap; background-color: transparent; line-height: 1.5rem; } .btn { vertical-align: inherit; font-weight: 400; color: #212529; text-align: center; -webkit-user-select: none; user-select: none; background-color: transparent; font-size: 1rem; border-radius: .25rem; } /* dropdown menus css*/ 调用JS $(\".dropdown\").each(function() { $(this).on(\"click\", function(e) { // 收起其他菜单 if (isMobile()) { $(\".menu\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } else { $(\".menu-inner\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } e.stopPropagation(); var downmenu = $(this).children(\"div\"); // 展开菜单 downmenu.slideToggle(\"fast\"); // 点击其他地方，隐藏菜单 if (downmenu.is(\":visible\")) { $(document).one(\"click\", function() { downmenu.slideUp(\"fast\"); }); } }); }); # 移动端 function isMobile(){ return window.matchMedia(\"only screen and (max-width: 680px)\").matches; } 修改菜单模板，详细代码参考header.html \u003cdiv class=\"menu\" style=\"overflow: visible\"\u003e \u003cdiv class=\"menu-inner\"\u003e {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\" style=\"display: inline;\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu\" style=\"display: none;\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active {{ end }}\" href=\"{{ $url }}\"{{ with .Title }} title=\"{{ . }}\"{{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e {{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} {{- end -}} {{- /* Mobile header */ -}} {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu dropdown-menu-mobile\" style=\"display: none\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item\" href=\"{{ $url }}\" title=\"{{ .Title }}\"{{ i","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"相关文章推荐 参考Related Content themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*see also*/ -}} # 显示tag分类相关的前5篇文章 {{ $related := .Site.RegularPages.RelatedIndices . \"tags\" | first 5 }} {{ with $related }} \u003cdiv id=\"related-article\"\u003e \u003cp\u003e{{- T \"seeAlso\" -}}\u003c/p\u003e \u003cul\u003e {{ range . }} \u003cli\u003e\u003ca href=\"{{ .RelPermalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/div\u003e {{ end }} ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"赞赏 赞赏功能需要在data\\imgURL.toml中添加图片的URL。 alipay = \"https://img.xiaodejiyi.com/img/alipay.jpg\"weichatPay = \"https://img.xiaodejiyi.com/img/wechat%20pay.jpg\" 然后在模板文件themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /* sponsor */ -}} \u003cdiv style=\"text-align:center;margin-bottom:30px;\"\u003e \u003ch5 style=\"font-weight:600;margin-bottom:10px;\"\u003e「\u0026nbsp;{{- T \"thanksSponsor\" -}}\u0026nbsp;」\u003c/h5\u003e \u003cbutton id=\"rewardButton\"\u003e\u003cspan\u003e{{- T \"tips\" -}}\u003c/span\u003e\u003c/button\u003e \u003cdiv id=\"QR\" style=\"display: none;\"\u003e \u003cdiv id=\"wechat\" style=\"display:inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"wechat_qr\" src=\"{{ .Site.Data.imgURL.weichatPay }}\" alt=\"WeChat Pay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"weichatTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003cdiv id=\"alipay\" style=\"display: inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"alipay_qr\" src=\"{{ .Site.Data.imgURL.alipay }}\" alt=\"Alipay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"aliTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"版权声明 themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*copyright*/ -}} \u003cdiv id=\"copyright-container\"\u003e \u003cul class=\"post-copyright\"\u003e \u003cli class=\"post-copyright-author\"\u003e \u003cstrong\u003e{{- T \"articleAuthor\" -}}：\u003c/strong\u003e\u003ca href=\"{{ $.Site.Author.link | default .Site.Home.RelPermalink }}\" target=\"_blank\"\u003e{{ T \"penname\" }}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-link\"\u003e \u003cstrong\u003e{{- T \"articleLink\" -}}：\u003c/strong\u003e\u003ca href=\"#\" target=\"_blank\" title=\"{{ .Title }}\"\u003e{{- .Permalink | safeHTML -}}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-license\"\u003e \u003cstrong\u003e{{- T \"copyRight\" -}}：\u003c/strong\u003e {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e 需要使用T函数翻译并且根据不同语言传递参数。 [copyRightMsg] other = \"本站所有文章除特别声明外，均采用 {{ .preCopyRight }} 转载请注明来自 {{ .afterCopyRight }} \" .Site.Params.footer.license在config.toml中设置: license = 'https://creativecommons.org/licenses/by-nc-sa/4.0/' ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:4","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"同步文章到服务器 如果需要了解同步文章到对象存储平台，请参考Hugo 静态网站部署及免费 HTTPS 证书配置和OSS常用工具汇总。 文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 文章同步到服务器的步骤如下。 本地创建博客文章 配置SSH免密登陆 使用Python脚本生成网站静态资源，提交变更 Github Action使用rsync同步网站静态资源到服务器，并使用atomic-algolia同步index.json到Algolia。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"创建文章 在archetypes目录下的创建模板文件，使用hugo new --kind post-bundle posts/my-post生成指定模板的样例文章，不需要每次复制文章头部参数。 archetypes\\post-bundle\\index.md文件内容。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"SSH免密登陆 注意！服务器端要配置authorized_keys。参考设置 SSH 通过密钥登录 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"注册Algolia 使用Algolia搜索引擎为博客提供搜索功能。参考搜索配置 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"本地同步与备份脚本 在博客目录下执行该脚本，先推送blog到Github的blog仓库，再本地备份。(相信看到这里的读者都有Github帐号了) import time import os, sys def main(msg): # 备份blog/ print(\"*\"*10+\"push blog/\"+\"*\"*10, end=\"\\n\\n\") # 生成静态页面 os.system('hugo') # 需要安装Git os.system('git add .') os.system('git commit -m \"{}\"'.format(msg)) os.system('git push') local_back = input('\\n本地备份？提示: y\\n') if local_back == 'y': #7z、winrar压缩参数是一样的，只有winrar的话，7z换成winrar也可以运行 os.system(r'7z a D:\\src\\xxxxx.rar D:\\src\\xxxxx') os.system(r'move D:\\src\\code\\xxxxx.rar D:\\backup\\xxxxx') print('本地备份完成！') print('over...') if __name__ == '__main__': msg = input('commit: ') main(msg) 如果需要安装Git，试试Scoop，它用来安装应用程序非常方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:4","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"Github Action blog/文件根目录下创建package.json文件，并在scripts模块中加入\"algolia\": \"atomic-algolia\"。 { \"name\": \"algolia\", \"version\": \"0.2.0\", \"description\": \"atomic-algolia package\", \"private\": true, \"scripts\": { \"algolia\": \"atomic-algolia\" } } 在Github的Blog仓库中添加Secrets变量 同步index.json到Algolia需要配置如下变量： ALGOLIA_ADMIN_KEY ALGOLIA_APP_ID ALGOLIA_INDEX_NAME rsync同步需要配置如下变量 HOST PORT USER REMOTE_PATH Nginx中配置的网站根目录 SSH_KEY 使用Github Action，创建workflow，复制以下代码。 name: deploy_blog on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps:- name:Check Outuses:actions/checkout@v2#同步blog搜索- name:Use Node.jsuses:actions/setup-node@v1with:node-version:'12.x'- name:Install automic-algoliaenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:zh-cnALGOLIA_INDEX_FILE:\"./public/index.json\"run:| npm install atomic-algolianpm run algolia# 同步英语文章的json- name:en jsonenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:enALGOLIA_INDEX_FILE:\"./public/en/index.json\"run:| npm run algolia- name:deploy to serveruses:AEnterprise/rsync-deploy@v1.0env:DEPLOY_KEY:${{ secrets.SSH_KEY }}# avzr参数，增量备份本地文件。-delete 删除目标地址中本地没有的文件ARGS:\"-avzr --delete\"SERVER_PORT:${{ secrets.PORT }}FOLDER:\"./public/\"SERVER_IP:${{ secrets.HOST }}USERNAME:${{ secrets.USER }}SERVER_DESTINATION:${{ secrets.REMOTE_PATH }} 如果出现问题，先在本地创建linux虚拟机，测试rsync命令，确定服务器同步是否正常。 代码改变世界，现在，写作多么简单。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:5","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo官方文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"LoveIt - 5页面模板","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"前言 最初在制作友链界面时，没有学习Hugo框架，一头雾水。网上有关的教程甚少，只能去学一遍Hugo。 在学习Hugo的过程中，了解了列表模板，分类模板。开发了几个功能页面，如：留言板，友链，记忆分类等。 本文介绍这些功能页面。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"里程碑页面 首先需要了解头部参数type，通过type指定文章使用的模板类型，默认为page类型。 要注意特殊模板的文章放在一般content根目录下，模板放在layouts目录下。 里程碑界面依据themes\\LoveIt\\layouts\\posts\\single.html修改，删除赞赏，相关文章推荐等功能。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- .Scratch.Delete \"this\" -}} {{- $params := .Scratch.Get \"params\" -}} {{- $toc := $params.toc -}} {{- if eq $toc true -}} {{- $toc = .Site.Params.page.toc | default dict -}} {{- else if eq $toc false -}} {{- $toc = dict \"enable\" false -}} {{- end -}} {{- /* Auto TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"toc\" id=\"toc-auto\"\u003e \u003ch2 class=\"toc-title\"\u003e{{ T \"contents\" }}\u003c/h2\u003e \u003cdiv class=\"toc-content{{ if eq $toc.auto false }} always-active{{ end }}\" id=\"toc-content-auto\"\u003e\u003c/div\u003e \u003c/div\u003e {{- end -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e \u003ci class=\"fas fa-monument fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} \u003c/h1\u003e {{- /* Static TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003cdiv id=\"post-footer\"\u003e\u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 这个模板也可以制作“爱情故事”。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"关于页面 相对里程碑界面，关于界面又删除了目录。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e{{ .Title }}\u003c/h1\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c!-- 这里的版权声明是根据文章内容添加的，可删除 --\u003e {{- /*copyright*/ -}} {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 类似的留言板页面可以使用默认的\"page\"类型。如果页面中有标题，同时不希望有目录，“关于”页面的模板更合适。或者使用头部参数toc: false禁用目录。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"列表模板 列表页面是在文章的头部自定义参数，在模板中渲染。例如友链模板，参考LoveIt-extend/content/links/index.zh-cn.md。 头部参数需要按照yml文件的格式，注意不能用tab缩进。 links:me:name:我 weight:1people:- name:朤尧url:https://www.xiaodejiyi.com/avatar:https://www.gravatar.com/avatar/ae94c8d8ca3d56eb035a3e62c2595150?s=240\u0026d=mpdescription:just do sth i should do.friends:name:朋友 weight:2people: links模板为： \u003c!-- links按照weight排序，排序后改变了原来的数组结构，相当于weight变为key值，其他数据组成value --\u003e {{- range $weight, $website := sort .Params.links \"weight\" -}} \u003ch3 id=\"{{ $website.name }}\" tabindex=\"-1\" style=\"outline: none;\"\u003e\u003ca href=\"#{{ $website.name }}\"\u003e\u003c/a\u003e{{ $website.name }}\u003c/h3\u003e \u003cul style=\"list-style: none;\" id=\"firendLink\"\u003e {{- range $website.people -}} \u003cli\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"media\"\u003e \u003cdiv class=\"media-left\"\u003e\u003cimg src=\"{{ .avatar }}\" width=\"55\"\u003e\u003c/div\u003e \u003cdiv class=\"media-content\"\u003e \u003ci class=\"fa fa-user-ninja fa-fw\"\u003e\u003c/i\u003e \u003c!-- . 是 当前作用域 --\u003e {{ .name }}\u0026nbsp;\u003ci class=\"fa fa-link fa-fw\"\u003e\u003c/i\u003e \u003ca href=\"{{ .url }}\" target=\"_blank\"\u003e{{ .url }}\u003c/a\u003e \u003cp\u003e{{ .description }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/li\u003e {{- end -}} \u003c/ul\u003e {{- end -}} 不过这里有一个Bug，content\\links\\index.zh-cn.md正文部分不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 生成目录的代码： \u003c!-- 修改前的侧边目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e \u003c!-- 修改后links的目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e {{- /* modify director */ -}} {{- range $weight, $website := sort .Params.links \"weight\" -}} {{- $groupName := dict \"Content\" $website.name \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003cli\u003e\u003ca href=\"#{{ $groupName }}\"\u003e{{ $groupName }}\u003c/a\u003e\u003c/li\u003e {{- end -}} \u003c/ul\u003e \u003c/nav\u003e \u003c/div\u003e \u003c/div\u003e 问题不大，还能用。同理，可以使用列表模板制作说说，相册，视频页面，只是样式设计上不同。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"分类模板 分类模板，需要考虑模板的渲染顺序，这个顺序很长，参考Hugo’s Lookup Order，而且需要其他背景知识，如type的详细分类等等。 不过，按照以下步骤，你不需要深入研究这个复杂的顺序。 在config.toml中配置分类 categories和tags为默认分类 [taxonomies]# 左边单数，右边复数形式category = \"categories\"tag = \"tags\"booklist = \"booklist\" 创建样例文章 在文章的头部参数中添加分类，注意要有中括号： categories: [\"demo1\"]tags: [\"demo2\"]booklist:[\"demo3\"] 创建分类模板 首先要覆盖主题默认的分类模板，分析默认模板themes\\LoveIt\\layouts\\taxonomy\\list.html的代码： ... {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} {{- printf \"%v - %v\" (T $taxonomy | default $taxonomy) .Title -}} {{- end -}} ... 可以发现，默认模板中包含了category,tag和其他，这三种模板。 所以覆盖需要将这个模板拆开，复制到博客的layouts目录下，分别命名为：categories,tags,taxonomy。内容上可以不修改，也可以将if语句剪枝。例如layouts\\categories\\list.html： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 覆盖之后，创建booklist分类的模板，复制categories分类的模板，修改为： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"booklist\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 是的，将if判断的category改为booklist，再换个Font Awesome图标。不要忘了还有layouts\\booklist\\terms.html也要改，同样修改if判断，改标题，改图标。 刷新界面，看看booklist分类有没有demo3的文章。如果没有，hugo server重新启动，现在应该有了。Hugo在这方面不能实时刷新。 首页文章增加分类 回到首页，你会发现，文章只有categories和tags的分类：demo1和demo2。添加demo3需要在themes\\LoveIt\\layouts\\_default\\summary.html中加入新的分类。 {{- $booklist := slice -}} {{- range .Params.booklist -}} {{- $category := partialCached \"function/path.html\" . . | printf \"/booklist/%v\" | $.Site.GetPage -}} {{- $booklist = $booklist | append (printf `\u003ca href=\"%v\"\u003e\u003ci class=\"fas fa-file-alt fa-fw\"\u003e\u003c/i\u003e%v\u003c/a\u003e` $category.RelPermalink $category.Title) -}} {{- end -}} {{- with delimit $booklist \"\u0026nbsp;\" -}} \u0026nbsp;\u003cspan class=\"post-category\"\u003e {{- . | safeHTML -}} \u003c/span\u003e {{- end -}} 继续加其他分类，只需要再复制一段，用编辑器Ctrl+H替换代码中的booklist。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"笔记页面 博客最初的设计是Hugo写文章，VuePress记笔记。在写这篇教程的过程中发现，如果把OneNote记的笔记放到VuePress上，再写文章，这会消耗大量时间。 不过VuePress能给文章加上一个背景知识。权衡之后放弃了VuePress。 如果你需要搭建一个笔记网站，可以考虑VuePress和Hugo的learn主题。 VuePress搭建过程可以参考B站教程和VuePress 中文文档。 搭建时需要注意这两点： Auto Sidebar插件自动生成侧边导航栏，如果没有这个插件，VuePress会繁琐得不想再用。 内置搜索只为页面的标题、h2、h3以及tags构建搜索索引。docsearch只支持技术文档，不支持博客索引和商业内容。Algolia搜索的方法可行，但是配置Algolia步骤很麻烦。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"最后 博客搭建教程结束，如果你想要添加更多的功能，更灵活的开发自己的博客，那么学习Hugo框架吧！只是这需要投入一些成本，学习Hugo花了11个小时，开发又用了95个小时。或许你还需要了解下自媒体以及公众号，知乎等其他写作平台，这消耗了28个小时。（番茄工作法统计得出） 专心于博客的内容创作或许是更好的选择，希望这篇教程可以帮到你。 如果想学习Hugo，那么Hugo论坛是一个不错的地方。 我为什么要搭博客呢？把知识留下来！ ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:7:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"参考 Hugo官方文档 LoveIt-extend LoveIt Theme ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:8:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"alloc创建一个对象","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"​ alloc创建一个对象 dealloc销毁对象 retain增加对象的保留计数器值 release减少对象的保留计数器值 retainCount获得保留计数器的当前值 autorelease将来一个时间自动释放 NSAutoreleasePool自动释放池 ","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/:0:0","tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"NSArray","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/","tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSArray 是一个Cocoa类，用来存储对象的有序列表 arrayWithObjects用来创建新的NSArray initWithObjects 初始化数组并赋值 objectAtIndex获取指定索引处的对象 componentsSeparatedByString切分NSArray componentsJoinedByString合并NSArray NSMutableArray可变数组 arrayWithCapacity创建可变数组 addObject在数组末尾添加对象 removeObjectAtIndex删除特定索引处的对象 ","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/:0:0","tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSEnumerator","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/","tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSEnumerator 用来描述集合运算的方式 objectEnumerator向数组请求枚举器 reverseObjectEnumerator从后向前浏览集合 nextObject下一个对象 NSDictionary字典，在给定的关键字下存储一个数值 dictionaryWithObjectsAndKeys创建字典 objectForKey获取字典中的值，向方法传递之前用来存储该值的关键字 NSMutableDictionary可变字典 dictionary可以向类NSMutableDictionary发送dictionary消息创建可变字典 dictionaryWithCapacity创建可变字典 setObject: forkey:给字典添加元素 removeObjectForKey删除可变字典中的关键字 ","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/:0:0","tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSNumber","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSNumber 用来包装基本数据类型 numberWithInt创建NSNumber intValue提取NSNumber NSValue可以包装任意值 valueWithBytes: objCType:创建新NSValue getValue提取NSValue @encode编译器指令可以接受数据类型的名称并为你生成合适的字符串 valueWithSize将struct型数据转换成NSValue NSNull代表无 NSFileManager对文件系统进行操作 defaultManager创建NSFileManager对象 stringByExpandingTildeInpath替换当前用户的主目录 NSDirectoryEnumerator 是NSEnumerator的子类，调用nextObject时返回该目录中一个文件的另一个路径，这个方法也可以搜索子目录。 pathExtension输出文件的扩展名(去掉了扩展名前面的点) ","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSPredicate类","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/","tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"NSPredicate类 用于制定过滤器的条件 +predicateWithFormat创建谓词 -evaluateWithObject通知谓词根据指定的对象计算自身的值 -filteredArrayUsingPredicate循环过滤数组内容，根据谓词计算每个对象的值，并将值为Yes的对象累积到将被返回的新数组中 copy指针复制，浅拷贝，返回的是不能修改的对象 mutableCopy对象复制，深拷贝，返回的是可修改的对象 -filterUsingPredicate针对可变数组进行过滤及返回 predicateWithSubstitutionVariables构造新的专用谓词，创建一个键/值对字典，其中，键是变量名，值是插入谓词的内容 \u0026\u0026 AND 和 || OR 或 ! NOT 非 BETWEEN { }之间 BEGINSWITH检查某个字符串是否以另一个字符串开头 ENDSWITH检查某个字符串是否以另一个字符串结尾 CONTAINS检查某个字符串是否在另一个字符串内部 [c]不区分大小写 [d]不区分发音符号 [cd]不区分以上两项 LIKE 匹配运算符 ","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/:0:0","tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"协议","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/","tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"​ 协议 @protocol创建协议 encodeWithCoder用于接受对象的实例变量并将其转换为NSCoder类的对象 initWithCoder从NSCoder类的对象中提取经过转换的冻结的实例变量并使用它们初始化一个新对象 copyWithZone复制到一块可供分配的内存区域 class所属的类 allocWithZone分配内存并创建一个该类的新对象 @optional协议中的可选方法 @required协议中的必选方法 ","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/:0:0","tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"多视图应用程序","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"多视图应用程序 UITabBarController标签栏界面 UINavigationController导航栏界面 addSubview添加视图，是将view加到所有层的最顶层 insertSubview在索引位置插入视图 initWithNibName: bundle:加载nib文件 removeFromSuperview从父视图删除 beginAnimation: context:声明动画块 setAnimationDuration:动画持续时间 setAnimationCurve:动画曲线 setAnimationTransition:动画转换类型 ","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:0","tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"导航控制器和表视图(一)","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/","tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"​ 导航控制器和表视图(一) UINavigationController 导航控制器 accessoryType 附件类型 navigationController 导航控制器属性 pushViewController: 入栈方法 viewWillAppear: 视图出现时加载 NSIndexPath 属性,索引路径 UITableViewCellAccessoryCheckmark 属性,检查标记(对勾) UITableViewCellAccessoryNone 属性,无标记 deselectRowAtIndexPath 取消选中某行 buttonWithType 按钮格式 setBackgroundImage 设置背景图片 addTarget 添加目标 forControlEvents 按钮事件 accessoryView 附加视图 buttonTapped: 轻击按钮 ","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/:0:0","tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"文件加载和保存","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/","tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"​ 文件加载和保存 date获取当前的时间和日期 dateWithTimeIntervalSinceNow获取与当前时间相隔一定时差的日期 const它限定一个变量不允许被改变 writeToFile:atomically:将属性列表写入文件 arrayWithContentsOfFile读取文件 code编码 decode解码 encodeSomething: forKey:编码方法 decodeSomethingForKey解码方法 NSKeyedArchiver归档 archivedDataWithRootObject创建归档实例 NSKeyedUnarchiver重新创建档案,和归档相反 unarchiveObjectWithData重新创建档案实例 ","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/:0:0","tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"更丰富的用户界面(一)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/","tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(一) resignFirstResponder取消第一响应者状态 UISlider滑块控件 UISegmentedControl分段开关控件 #define定义常量 UISwitch切换开关控件 UITxtField文本控件 { isOn 获取切换开关控件的状态 setOn设置切换开关控件的状态 animated移动方式 YES为缓慢 NO为瞬间 } selectedSegmentIndex分段控件索引 hidden隐藏 { UIActionSheet操作表控件 initWithTitle:初始化操作表 delegate:操作表响应的委托 cancelButtonTitle:取消按钮 destructiveButtonTitle:继续按钮 otherButtonTitles:其它按钮 } ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/:0:0","tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(二)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/","tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"更丰富的用户界面(二) showInView:在视图中显示 view视图 { UIAlertViewDelegate警报委托控件 UIActionSheetDelegate操作表委托控件(在例子中作为协议) actionSheet: didDismissWithButtonIndex:(在例子中作为协议的方法) } buttonIndex 按钮的索引 cancelButtonIndex 取消按钮的索引 { UIAlertView 警报控件 initWithTitle:初始化警报 message:警报内容 delegate:警报响应的委托 cancelButtonTitle:取消按钮 otherButtonTitles:其它按钮 } viewDidLoad视图加载方法 viewDidUnload视图卸载方法 UIImage图像控件 imageNamed: 加载图像文件 UIImageView 图像视图控件 initWithImage: 初始化图像视图 ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/:0:0","tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"特性","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/","tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"​ 特性 @property表示声明了一个新对象的属性，自动声明属性的setter和getter方法 @synthesize 表示创建该属性的访问器 readwrite读写属性 readonly只读 ","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/:0:0","tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"笔记1","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/","tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"​ 笔记1 \\n换行符 new 是alloc和init的结合 double精度是float的两倍 char单个字符 %o 八进制整数 %x十六进制整数 %f浮点计数法 %e科学计数法 %g %a和%f一样 long扩展值域，输出时要在%后添加l long long 特定扩展%后加ll short缩小值域 %后加h unsigned正数(无符号) id NSLog字符%p ","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/:0:0","tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"自动旋转和自动调整大小","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/","tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"​ 自动旋转和自动调整大小 shouldAutorotateToInterfaceOrientation:旋转支持 willAnimateRotationToInterfaceOrientation: duration: 此方法将在旋转开始之后，最后的旋转动画发生之前自动调用 UIInterfaceOrientation界面方向控件 NSTimeInterval间隔时间 frame框架 CGRectMake大小和位置 transform变换 bounds边界 ","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/:0:0","tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"键/值编码","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/","tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"​ 键/值编码 count计数 -valueForKey: 读取方法,以字符串的形式向对象发送消息 -setValue: forKey: 设置方法,以字符串的形式向对象发送消息(设置标量值需要封装数据) -valueForKeyPath: 路径读取方法 -setValue: forKeyPath: 路径设置方法 @运算符,它获取左侧指定的集合,对该集合中的每个对象使用右侧的键路径,然后将结果转换为一个集合 @count计数 @sum求和 @avg求平均值 @min取最小值 @max取最大值 @distinctUnionOfObjects取交集 lastObject方法,最后一个对象 dictionaryWithValuesForKeys它接受一个字符串数组,该数组中的数据成为键,对每个键使用读取方法,然后为键字符串和刚才获得的值构建一个字典. setValuesForKeysWithDictionary批量修改,用字典来修改键值 setNilValueForKey重设nil意义 valueForUndefinedKey:读取未知键 setValue: forUndefinedKey: 设置未知键 ","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/:0:0","tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"2021 ","date":"2020-07-01","objectID":"/milestone/:1:0","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"5月 10日，开始学习《Shark恒零基础百集软件逆向教程》，暂时学完前两期。历时两周。 25日，开始学习《2020DNF》、《2020DOF》、《2021DNF不完整》系列教程。历时5天。 30日，开始学习《英雄联盟LOL》、《亿万僵尸》、《CE WALKer》，历时9天。 ","date":"2020-07-01","objectID":"/milestone/:1:1","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"6月 8日，开始学习《小冷过游戏检测技术》及相关过检测教程，历时4天。期间还看了WOW按键视频。 12日，开始学习《植物大战僵尸》，历时9天。 23日，开始学习《CS》。 27日，开始各种尝试。 ","date":"2020-07-01","objectID":"/milestone/:1:2","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"7月 3日，开始学习《郁金香2020 WOW》，教程未完待续。历时19天。 24日，开始学习《郁金香2019 VS2010》,仍在继续中。 26日，开始利用闲暇时间搭建博客，用于记录笔记及心路历程。尝试搭了5个不同的博客，第一款基于jekyll框架，效果不理想，之后不断摸索。 ","date":"2020-07-01","objectID":"/milestone/:1:3","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"8月 4日，博客最终锁定了Hugo框架LoveIt模板，也就是现在看到的样子。 10日，开始学习《任鸟飞2015》 ","date":"2020-07-01","objectID":"/milestone/:1:4","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"这个地方不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 ","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"content ","date":"0001-01-01","objectID":"/websites/:0:0","tags":null,"title":"网站收藏","uri":"/websites/"}]