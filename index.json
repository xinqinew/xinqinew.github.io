[{"categories":["仪表"],"content":"200道题 1 在干熄焦中，焦炭的显热借助于（ ）回收，并用于生产蒸汽、发电等。 A 惰性气体 B 有机元素 C 无机元素 D 氢氧元素 A 2 干熄后的焦碳与湿熄后的焦碳相比有（ ）的特点。 A 块度大小均匀 B 强度减少 C 裂纹加大 D 强度增加 A 3 干熄炉采用（ ）煤气进行烘炉。 A 脱硫焦炉 B 高炉 C 混合 D 天然气 A 4 为了保证旋转密封阀的严密性采用（ ）方式。 A 充N2 B 充压缩空气 C 充空气 D 充蒸汽 A 5 为了保证旋转密封阀的严密性采用（ ）方式。 A 充N2 B 充压缩空气 C 充空气 D 充蒸汽 A 6 在干熄焦提升机自动运行时（ ）。 A 空气 B 提升机采用中央手动控制 C 提升机采用就地控制 D 提升机采用中央自动控制 A 7 当余热锅炉入口温度高，应采用（ ）。 A 导入N2 B 导入空气 C 增加排焦量 D 减少排焦量 A 8 布袋除尘器的除尘效率（ ）。 A 0.99 B 0.98 C 97% D 0.96 A 9 锅炉破损时，紧急放散阀应（ ）。 A 开 B 关闭 C 隔离 D 充蒸汽 A 10 二次过热器入口的蒸汽温度控制在（ ）。 A 大于饱和蒸汽温度 B 小于饱和温度 C 等于饱和温度 D 蒸汽温度 A 11 汽包正常液位在汽包中心线（ ）处。 A ±100mm B 150mm C 250mm D 300mm A 12 干熄焦锅炉的三大安全附件是指安全阀、水位计、（ ）。 A 压力表 B 温度计 C 液位计 D 流量计 A 13 一次除尘器顶部紧急放散装置，在循环气体中H2含量异常增高（如锅炉炉管破裂）时，排放系统内的蒸汽用。正常情况下，处于（ ）。 A 紧急关闭 B 开启 C 微开 D 微闭 A 14 饱和温度与压力的关系是：压力升高，对应的饱和温度（ ）。 A 升高 B 降低 C 升高 D 降低 A 15 一次过热器导出的饱和蒸汽经减温器后温度控制为（ ）。 A 大于饱和蒸汽温度 B 小于饱和温度 C 等于饱和温度 D 蒸汽温度 A 16 在蒸汽参数保持不变的条件下， 当排焦量一定时， 随着循环风量增加， 蒸汽发生量也相应（ ）。 A 增加 B 变少 C 不变 D 以上均可能 A 17 干熄焦正常生产时，排焦温度应小于（ ）℃。 A 200.0 B 120.0 C 150.0 D 300.0 A 18 在理论上干熄1吨红焦产生（ ）㎏蒸汽。 A 450.0 B 400.0 C 350.0 D 300.0 A 19 测量循环气体中H2含量的仪器是（ ）。 A 热量传导分析仪 B 红外线分析仪 C 磁氧式分析仪 D 气体分析仪 A 20 干熄焦一次除尘原理为（ ）。 A 重力沉降式除尘 B 旋风式除尘 C 布袋式除尘 D 脱硫除尘 A 21 减温减压装置设有（ ），确保管道不超压。 A 安全阀 B 压力表 C 液位计 D 流量计 A 22 氢气（H2）的浓度控制在不大于（）（体积百分比）。 A .3.0% ． B 0.06 C 0.1 D 0.2 A 23 干熄炉最大处理能力（）。 A 175t/h B 170t/h C 165t/h D 185t/h A 24 风机壳体及风机前后的循环气体管道外壁均包岩棉缝毡并外敷水泥隔声。采取隔声措施后，噪声可控制在（）以内。 A 85.0 B 83.0 C 80.0 D 90.0 A 25 温风干燥期间以干熄炉入口温度以（）主要管理温度。 A T2 B T3 C T5 D T4 A 26 干熄炉调节风量每次不超过（）。 A 2000—3000Nm³∕h B 1000—2000Nm³∕h C 2000—2500Nm³∕h D 2000—2500Nm³∕h A 27 锅炉三冲量给水自动调节系统中（）是主信号。 A 锅炉汽包水位 B 给水流量 C 蒸汽流量 D 给水压力 A 28 煤气烘炉期间的主管理温度为预存室温度T5，主要目的是将T5逐渐升至（）左右 A 750℃ B 650℃ C 700℃ D 800℃ A 29 温风干燥期间主要调节手段包括什么() A 低压蒸汽的流量 B 空气导入量 C 循环空气量 D 系统的压力 A 30 泵在运行期间振动或有杂音（）。 A 泵和电机不同心 B 机组螺栓松动 C 轴承是否损坏 D 泵叶轮损坏 A 31 干熄焦装置产生的蒸汽（）。 A 9.81MP（g） B 3.81MP（g） C 0.3MP（g） D 0.6MP（g） A 32 锅炉给水PH值（）。 A 8.0～9.5 B 3.0～4.5 C 4.5～6 D 7～9 A 33 旋转焦罐内只能接一炉焦炭()。 A 约30吨 B 约25吨 C 约20吨 D 约40吨 A 34 （ ）是惰性气体循环系统中的核心设备。 A 循环水泵 B 干熄炉循环风机 C 循环气道 D 排焦装置 B 35 当干熄焦排出装置发生故障需检修时，应采取（ ）措施。 A 降温度降压力 B 保温保压 C 只装焦不排焦 D 升温 B 36 测量循环气体中的O的浓度采用的仪器是（ ）。 A 热量传导计 B 红外线分析仪 C 磁氧分析仪 D 便携式报警仪 B 37 为提高干熄焦的防爆性，不可以采取的措施是（ ）。 A 向系统内充入氮气 B 系统内充入蒸汽 C 向干熄炉增开常用放散阀，提高预存段压力 D 向干熄炉导入空气，烧掉可燃气体 B 38 干熄焦锅炉在升压、降压过程中，锅炉汽包上、下壁温差不宜大于（ ）。 A 40℃ B 50℃ C 45℃ D 60℃ B 39 干熄焦锅炉连排量大小的依据（ ）取决于化验结果。 A 给水 B 锅炉炉水 C 除盐水 D 蒸汽 B 40 在排焦量一定的情况下，蒸汽压力提高将使汽化率（ ）。 A 显著提高 B 降低 C 不受影响 D 影响不大 B 41 干熄焦除尘装置处理后，排放气体含尘量标准为小于（ ）。 A 300mg/m3 B 50mg/m3 C 70mg/m3 D 100mg/m3 B 42 干熄焦锅炉有（ ）种安全附件。 A 2.0 B 3.0 C 4.0 D 5.0 B 43 干熄焦锅炉给水与循环气体进行热交换，（ ）进入干熄炉内循环气体的温度。 A 提高 B 降低 C 不变 D 以上均可能 B 44 循环的风量与转速成（ ）。 A 不变 B 正比 C 反比 D 以上均可能 B 45 干熄炉内最易损坏的部位是（ ）。 A 预存室和斜道 B 斜道和冷却室部位 C 预存室和冷却室 D 斜道和冷却室 B 46 干熄炉入口循环气体中一氧化碳（O）的浓度控制在不大于（ ）（体积百分比）。 A 0.03 B 0.06 C 0.1 D 0.2 B 47 自干熄炉排出的热循环气体的温度约（）。 A 800℃-900℃ B 900℃－980℃ C 1000℃-1100℃ D 900℃-1100℃ B 48 为缩短电机车的操作周期，一台电机车拖带（）焦罐车。 A 一台 B 两台 C 三台 D 四台 B 49 平板闸门安装在干熄炉的底部出口。正常生产时，平板闸门（）。 A 完全关闭 B 完全打开 C 部分打开 D 部分关闭 B 50 旋转密封阀叶片数量（）。 A 10.0 B 12.0 C 11.0 D 9.0 B 51 一次除尘器主要由壳体﹑金属支承构架及砌体构成，工作在（）状态。 A 正压 B 微负压 C 正常 D 负压 B 52 二次除尘器使进入循环风机的气体中粉尘含量小于（）g/m3。 A 0.5 B 1.0 C 0.2 D 2.0 B 53 锅炉给水泵电机的功率是（）。 A 500KW B 630KW C 600KW D 550KW B 54 温风干燥时预存室压力维持微正压（）。 A 1p—2p B 10p—20p C 5p-10p D 3p-4p B 55 煤气烘炉升温标准：整个过程计划用时()天 A 10.0 B 12.0 C 11.0 D 9.0 B 56 从业人员在作业过程中，应当严格遵守本单位的安全生产规章制度和操作规程，服从管理，正确佩戴和使用（）。 A 安全措施 B 劳动防护用品 C 防护工具 D 日常工具 B 57 《安全生产法》确立的安全生产工作机制是 A 生产经营单位负责、行业自律、社会监督、国家监察 B 生产经营单位负责、政府监管、国家监察、中介机构提供服务 C 生产经营单位负责、职工参与、政府监管、行业自律、社会监督 D 生产经营单位负责、职工参与、行业自律，中介机构提供服务 C 58 干熄炉装入红焦后，循环气体H2含量突然升高，一段时间后又恢复正常，基本上可以判断为（）。 A 空气导入量少 B 锅炉炉管泄漏 C 水封槽漏水 D 空气导入量多 C 59 当风速达到（ ）时，应停止提升机装焦作业。 A 10m/s B 15m/s C 20m/s D 25m/s C 60 干熄焦用（ ）作为载体。 A 空气 B O2 C 惰性气体 D 蒸汽 C 61 关于二次除尘器，下列说法不正确的是（ ）。 A 锅炉出来的冷惰性气体，在二次除尘器经旋风分离器再次分离 B 二次除尘器使惰性气体进入风机前的含尘量小于1g／m3 C 二次除尘器安装在干熄槽与锅炉之间 D 钢结构设备，内衬铸石板，下部粉焦出口与粉焦刮板运输机相接，要求设备严密、耐磨损 C 62 当除尘风机停止运行备用系统未投入运行时，此时干熄焦需要用（ ）措施。 A 可以装焦可以排焦 B 停止装焦停止排焦 C 不可以装焦但可以排焦 D 可以装焦停止排焦 C 63 循环气体系统设备主要操作不包括（ ）。 A 循环气体量的变更 B 循环气体成分的控制 C 排焦量的设定 D 锅炉入口循环温度的控制 C 6","date":"2023-04-09","objectID":"/2023/04/200%E9%A2%98/:1:0","series":null,"tags":["仪表"],"title":"200题","uri":"/2023/04/200%E9%A2%98/"},{"categories":["巡检"],"content":"扫码巡检 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:1:0","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"登录(首次必须) ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:0","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"干熄焦 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:1","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"减温减压 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:2","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"干熄焦除尘器 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:3","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"空压制氮单元 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:4","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"消防泵房 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:5","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"汽轮机 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:6","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"备用锅炉房 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:7","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["巡检"],"content":"除盐水 ","date":"2023-03-26","objectID":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/:2:8","series":null,"tags":["扫码巡检"],"title":"扫码巡检","uri":"/2023/03/%E6%89%AB%E7%A0%81%E5%B7%A1%E6%A3%80/"},{"categories":["仪表"],"content":"视频引用 所谓零点迁移，就是为克服在安装过程中，由于变送器取压口与容器取压口不在同一水平线或采用隔离措施后产生的零点偏移，而采取的一种技术措施。 分为无迁移、正迁移、负迁移。 ","date":"2022-08-15","objectID":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/:0:0","series":null,"tags":["仪表","变送器","迁移"],"title":"变送器迁移","uri":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/"},{"categories":["仪表"],"content":"一、无迁移 变送器取压口与容器取压口在同一水平线上。 公式：△P=ρgh 其中h为容器取压口与变送器取压口之间的距离，h=0，所以△P=0，即无迁移 ","date":"2022-08-15","objectID":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/:1:0","series":null,"tags":["仪表","变送器","迁移"],"title":"变送器迁移","uri":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/"},{"categories":["仪表"],"content":"二、正迁移 送器取压口与容器取压口不在同一水平线上。变送器任液位基准面下方h处。 公式：△P=ρgh 其中h为容器取压口与变送器取压口之间的距离，h\u003e0，所以△P\u003e0，即正迁移 ","date":"2022-08-15","objectID":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/:2:0","series":null,"tags":["仪表","变送器","迁移"],"title":"变送器迁移","uri":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/"},{"categories":["仪表"],"content":"三、负迁移 差压式液位变送器，或者变送器取压口与容器取压口不在同一水平线上，变送器在液位基准面上方h处。 差压液位计：双法兰液位计、双室平衡液液位计、 单室平衡液位计等。 公式：△P=-ρgh\u003c0，即负迁移。 ","date":"2022-08-15","objectID":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/:3:0","series":null,"tags":["仪表","变送器","迁移"],"title":"变送器迁移","uri":"/2022/08/%E5%8F%98%E9%80%81%E5%99%A8%E8%BF%81%E7%A7%BB/"},{"categories":["仪表"],"content":"视频引用 ","date":"2022-08-15","objectID":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/:0:0","series":null,"tags":["仪表","料位计"],"title":"放射性料位计","uri":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"测量原理 ","date":"2022-08-15","objectID":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/:1:0","series":null,"tags":["仪表","料位计"],"title":"放射性料位计","uri":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"组成 放射性料位计主要由放射源、按收器(探测器)和显示仪表(转换器）组成。 ","date":"2022-08-15","objectID":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/:2:0","series":null,"tags":["仪表","料位计"],"title":"放射性料位计","uri":"/2022/08/%E6%94%BE%E5%B0%84%E6%80%A7%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"这是我的和利时笔记 ","date":"2022-08-05","objectID":"/2022/08/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["仪表","和利时"],"title":"操作技巧","uri":"/2022/08/%E6%93%8D%E4%BD%9C%E6%8A%80%E5%B7%A7/"},{"categories":["仪表"],"content":"查看所有强制变量 graph TB s[在线]--\u003e e[强制变量表] ","date":"2022-08-05","objectID":"/2022/08/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["仪表","和利时"],"title":"常见问题","uri":"/2022/08/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["仪表"],"content":"忘记密码怎么办 删除这个文件，就不需要密码了，之后可以再添加密码 ","date":"2022-08-05","objectID":"/2022/08/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["仪表","和利时"],"title":"常见问题","uri":"/2022/08/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["仪表"],"content":"一、显示最小或无显示 传感器没有流量信号输出。 原因有电源故障，连接电缆故障，传感器或转换器元件损坏，最小切除流量过大。 工艺原因有液体流动状况改变，工艺管道附着层出现问题。 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:1:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常见故障","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"二、显示最大 除了实际工况超量程外。 仪表自身的原因有：信号回路断路，连接电缆故障，接线错误等，传感器与转换器配套错误，电磁流量计设定错误。 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:2:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常见故障","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"三、偏高或偏低 仪表的零点没有调校设定好，传感器安装位置不符合要求，传感器前后直管段达不到要求，不能满管或液体中含有气泡，传感器电极的绝缘下降。 ![image-20220805214033009](/Users/xinqi/Library/Application Support/typora-user-images/image-20220805214033009.png) ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常见故障","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"四、显示波动 干扰主要有管道上的杂散电流、静电、电磁波、磁场。 电磁流量计自身的原因有：接线端子氧化，电路板接触不良，测量电极受污染，安装垫片安装不当，流量不满管液体中含有气泡，接地不可靠。 接地方式 ​ ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:4:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常见故障","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"一、原理 电磁流量计是根据法拉第电磁感应定律进行流量测量的流量计。 即根据导电流体流过外加磁场时感生的电动势来测量流体流量。 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/:1:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常识","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"二、安装 安装在管路的最低点或者管路的垂直段，测量时确保介质为满管状态 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常识","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"三、注意事项 所测介质为导电介质 测量管道必须满管 前后直管段符合要求 远离电流干扰，空间强电磁波干扰，大型电机磁场干扰，例如电机、变频器、变压器等设备。 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/:3:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常识","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"四、零点校准 前提条件： 介质满管 介质静止 ","date":"2022-08-05","objectID":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/:4:0","series":null,"tags":["仪表","流量计"],"title":"电磁流量计常识","uri":"/2022/08/%E7%94%B5%E7%A3%81%E6%B5%81%E9%87%8F%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"LD语言 LD语言是一种T型图语言，常用于开关量的控制逻辑组态。 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:1:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"MOT2功能块 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:2:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"PIDA功能块 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:3:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"流量累计 flowsum功能块 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:4:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"顺控6 hsscs6功能块 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:5:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"手操器HSVMAN ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:6:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"HSVPID功能块 引脚： ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/:7:0","series":null,"tags":["仪表","和利时"],"title":"和利时CFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6cfc/"},{"categories":["仪表"],"content":"SFC顺序功能图 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/:1:0","series":null,"tags":["仪表","和利时"],"title":"和利时SFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/"},{"categories":["仪表"],"content":"简介 组态理念 SFC用于顺序控制的生产过程，包括生产顺序控制的简单功能，强大的测试和起动功能等。 SFC是实现控制方案的一种组织框架，与程序流程图的功能类似。主要功能是组织控制流程，体现状态的转换，它自身不表示具体的控制操作动作． SFC是通过在图表中设置步骤和转移而配置的，它的布局是用顺序、并行和交替的分支以及回路来建立的。 SFC执行是周期性的，而且各周期互相有关联，除第一个周期外，其它各个周期都是上一个周期的延续。 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/:2:0","series":null,"tags":["仪表","和利时"],"title":"和利时SFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/"},{"categories":["仪表"],"content":"组成元素 步：执行的动作，通过嵌套CFC、LD或ST实现。 并行步：入口条件满足，同时进入两个步执行步动作。 关联步：主步执行的同时激发关联步执行，但与主步之间的运行关系通过限定符来判定。 最小时间：步运行时间的上限值。 最大时间：步运行时间的下限值。 条件：判定步跳出或跳入的逻辑。 并行条件：任一条件满足都会使步跳出或跳入，条件之间呈现“或”关系。 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/:3:0","series":null,"tags":["仪表","和利时"],"title":"和利时SFC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sfc/"},{"categories":["仪表"],"content":"SQC的作用 用于实现对先后动作顺序要求较高的多个工艺设备按序列自动控制。当满足相应动作条件后，程序按照预先设定好的步骤及设定的时间自动执行，直到程控结束。 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sqc/:1:0","series":null,"tags":["仪表","和利时"],"title":"和利时SQC","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6sqc/"},{"categories":["仪表"],"content":"变量 变量类别 VAR_GLOBAL 全局变量 VAR_POU 局部变量 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:1:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"域号 域号 -1 各个域都可以识别 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:2:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"IP IP 128.0.0.80 或129.0.0.80 子网掩码 255.255.0.0 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:3:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"在线数值标志 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:4:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"变量分类 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:5:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"触发器 RS 复位优先 SR 置位优先 HSRS 复位优先 （多了一个反向输出） ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:6:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"时间功能块 TP 普通定时器 HSTP 定宽周期计数器 TON 开延时定时器 HSTON TOF 关延时定时器 HSTOF ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/:7:0","series":null,"tags":["仪表"],"title":"和利时功能块","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%8A%9F%E8%83%BD%E5%9D%97/"},{"categories":["仪表"],"content":"新建图形页面（工程总控中） ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/:1:0","series":null,"tags":["仪表","和利时"],"title":"和利时图形组态","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/"},{"categories":["仪表"],"content":"图形编辑 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/:2:0","series":null,"tags":["仪表","和利时"],"title":"和利时图形组态","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/"},{"categories":["仪表"],"content":"新建图形页面（图形编辑中） 画面宽度 = 屏幕分辨率的宽 - 4 画面高度 = 屏幕分辨率的高 - 104 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/:3:0","series":null,"tags":["仪表","和利时"],"title":"和利时图形组态","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/"},{"categories":["仪表"],"content":"符号库 ","date":"2022-08-05","objectID":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/:4:0","series":null,"tags":["仪表","和利时"],"title":"和利时图形组态","uri":"/2022/08/%E5%92%8C%E5%88%A9%E6%97%B6%E5%9B%BE%E5%BD%A2%E7%BB%84%E6%80%81/"},{"categories":["仪表"],"content":"视频引用 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:0:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常见故障","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"一、膜盒破损、鼓包 现象： 显示为超下限或超量程，上下法兰对空的情况下，零位不准，测量也不准。 原因分析： 腐蚀、膜盒碰撞、压力等级不符合要求、材料选型不对等。 解决方法： 按介质特性选择对应材质的膜盒。 选择高于工作压力等级的膜盒。 避免膜盒受外力撞击。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:1:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常见故障","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"二、毛细管破损 现象： 正压侧毛细管破损，硅油泄露。仪表显示超下限。 负压侧毛细管破损，硅油泄露。仪表显示超量程。 正负压侧都破损，仪表显示偏大或偏小。 原因： 提拉毛细管、物体撞击、高温烫伤等。 解决方法： 移动双法兰时，严禁提拉 毛细管。 双法兰安装完毕后，毛细管需做防护支架。 毛细管远离伴热管线等。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:2:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常见故障","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"三、根部阀堵塞 现象： 仪表显示不准，打开排污阀，无介质流出或少量渗出。 原因： 介质粘稠、易结晶、有杂质颗粒等，容易造成根部阏可能堵塞。 解决方法： 加装冲洗水装置。 定期拆检，清洗。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常见故障","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"四、零点漂移 现象： 在空液位或正负压侧法兰对空的情况下，仪表显示不为零。 原因： 液位计零点漂移 解决方法： 使用手操器进行清零。 必要时进行零点校准。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:4:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常见故障","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"视频引用 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:0:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"一、原理 原理： 双法兰差压液位计，是利用容器内的液位改变时，由液柱产生的静压也相应变化的原理而工作。 双法兰液位计可以测量易结晶、粘稠、颗粒杂质、腐蚀性的介质液位，而且硅油具有很好的阻尼作用。 低压侧：L 负压侧，安装在容器上侧 高压侧：H 正压侧，安装在容器下侧 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:1:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"二、计算（液位、界面） ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"（一）液位计算（液 - 气）: 迁移量、量程 测量范围： 〈迁移量，迁移量＋量程） 其计算公式为： △P=P正-P负=ρgH 计算过程： 迁移量(空液位)： △P0=(P正0+P空)-(P负0+P空)=P正0-P负0=-ρ0gh1-ρ0gh2=-ρ0g(h1+h2)=-ρ0gh 量程(满液位): △P1=(P正1+P空)-P空=P正1=ρ1gh 恨据变送器的安装位置分三种情况： 变送器低于下法兰。 变送器任两法兰之间。 变送器高于上法兰。 小技巧： 不用计算，直接得到迁移量 上下法兰任对空或容器空液位的情况下，变送器的显示值就是迁移量 总结： 1、量程只与两法兰之间的高度h、介质的密度ρ有关。 2、迁移量只与两法兰之间的高度h、硅油密度ρ0有关。 3、量程和迁移量都与变送器的安装位置无关。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:1","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"（二）界面测量 界面指的是两相物料间的界面的高度（位置）。即两相间的接触表南，有固-固、液-液、固-气、固-液和液-气种类型。 同一容器内有两种不同密度的介质，一种密度大（重介质），一种密度小（轻介质）。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:2","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"三、零点标定 两法兰在同一水平面，即传感器正负压侧受到相等的压力，此时变送器的差压值为零。若不为零，则需要零点标定。 标零方法为：按钮标零；手操器标零；机械调零旋钮标零等 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:3:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"四、注意事项 正负压侧法兰不能装反。 双法兰膜盒严禁强力按压、尖硬物体碰撞。 严禁用手提拉毛细管。 毛细管远离伴热管线。 变送器一股安装在低于下法兰或两法兰之间，安装在高于上法兰位置膜盒容易鼓包。 ","date":"2022-08-05","objectID":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:4:0","series":null,"tags":["仪表","液位计"],"title":"双法兰液位计常识","uri":"/2022/08/%E5%8F%8C%E6%B3%95%E5%85%B0%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"一、压力式液位计 工作原理 液体中某一点的静压力与该点到液面的距离成正比。计算公式：P=pgh。其中：P-被测点的压力。-介质密度、g-重力加速度、h-被测点到波面的高度。对己确定的被测介质p、g为常数。 故被测点到液面位置的变化与被测的P压力有关。 投入式液位计 当液位变送器投入到被测液体中某一深度时，传感器受到相应的压力。 压力变送器液位计 液体中某一点的静压力与该点到液面的距离成正比。 注意事项： 适用于测量常压(开口）容器的液位。 不适用于测量易结晶、粘稠、有杂质颗粒的介质。 单法兰液位计 液体中某—点的静压力与该点到液面的距离成正比。 注意事项： 适用于常压（开口）容器的液位测量。 适用于测量易结品、粘稠、有杂质颗粒的介质。（介质过于粘稍、杂质颗粒过多时，可以加装冲洗水装置） ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:1:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"二、差压式液位计 对于密闭容器，由于内部与大气隔绝，容器内的压力可能大于大气压或者小于大气压的情況。容器内压力大小会直接影响所测量的液位，除非对此进行补偿，将差压变送器的低压侧连接到容器顶部就可以做到这一点。所以当要测量密闭容器液位时，必须使用差压变送器。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"差压变送器液位计 低压侧：L（一般安装在容器上侧） 高压侧：H（一般安装在容器下侧） 计算公式： P0=P1-P2= pgH 其中： P0差压值，介质在此高度时所产生的压力 P1高压侧所受压力 P2低压侧所受压力 注意事项 不适用于测量易结晶、粘稠、有杂质颗粒的介质。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:1","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"双法兰液位计 低压侧：L（一般安装在容器上侧） 高压侧：H（一般安装在容器下侧） 注意事项： 适用于压力容器或常压（开口）容器液位测量。 适用于测量易结晶、粘稠、有杂质颗粒的介质。（介质过于粘稠、杂质颗粒过多时，可以加装冲洗水装置） ​ ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:2","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"双室平衡液位计 应用场所 一般用于测量汽包液位，介质为干净的水等 注意事项 三阀组必须正确投运和停运，否则会使负压侧隔离液流失。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:3","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"单室平衡液位计 应用场所 一般用于测量介质为干净水的液位。 注意事项 三阀组必须正确投运和停运，否则会使负压侧隔离液流失。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:2:4","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"三、磁翻板液位计 磁翻板液位计：又叫磁浮子液位计，磁翻柱波位计。 原理： 连通器原理，根据浮力原理和磁性轉合作用研发而成，当被测容器中的液位升降时，浮子内的永久磁钢通过磁耦合 传递到磁翻柱指示面板，使红白翻柱翻年180°，当液位上升时翻柱由白色转为红色，当液位下降时翻柱由红色转 ，面板上红白交界处为容器内液位的实际高度，从而实现液位显示。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:3:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"四、雷达液位计 雷达液位计是基于时间行程原理的测量仪表，雷达波以光速运行，运行时间可以通过电子部件被转换成物位信号。 ，探头发出高频脉冲任空间以光速传播，当脉冲遇到物料表面时反射回来被仪表内的接收器接收，并将距离 信号转化为物位信号。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:4:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"五、浮球液位计 原理： 浮球液位计结构主要基于浮力和静磁场原理设计生产的。带有磁体的浮球，在被测介质中的位置受浮力作用影响。即液位的变化导致磁性浮子位置的变化。浮球中的磁体和传感器（磁簧开关）作用，使串连入电路的元件（如定值电阻）的数量发生变化，进而使仪表电路系统的电学量发生改变。也就是使磁性浮子位置的变化引起电学量的变化。通过检测电学量的变化来反映容器内液位的情况。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:5:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"六、电容式液位计 原理： 电容式液位计是采用测量电容的变化来测量液面的高低的。它是一根金属棒插入盛液容器内，金属棒作为电容的一个极，容器壁作为电容的另一极。两电极问的介质即为液体及其上面的气体。山于液体的介电常数和液面上的介电常数不同，则当液位升高时，介电常数随之加大因而电容量增大。反之当液位下降，介电常数减小，电容量世减小。所以，电容式液位计可通过两电极间的电容量的变化来测量液位的高低。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:6:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"七、音叉振动式液位开关 音叉式液位开关的工作原理是通过安装在音叉基座上的一对压电晶体使音叉在一定共振频率下振动。当音叉与被测介质相接触时，音叉的频率和振幅将改变，这些变化由智能电路水进行检测，处理并将之较换为一个开关信号。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:7:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"八、玻璃板液位计 原理： 玻璃板式液位计是通过法兰与容器连接构成连通器，透过玻璃板可直接读得容器内液位的高度。 ","date":"2022-08-05","objectID":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/:8:0","series":null,"tags":["仪表","液位计"],"title":"液位计常识","uri":"/2022/08/%E6%B6%B2%E4%BD%8D%E8%AE%A1%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"一、堵塞 拆下安装到其它地方测试压力表好坏 检查连接部件，可以小开度慢慢打开根部阀门，看根部阀及连接管是否堵塞，并疏通。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:1:0","series":null,"tags":["仪表","压力表"],"title":"压力表常见故障","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"二、脱落 现象： 无论工艺将压力增大或减小，压力表指针不会变化 检查： 连接部件都正常，拆压力表检查，发现压力表有问题。 进一步拆解压力表： 指针螺丝脱落 连接杆螺丝脱落 放大机构断裂等 原因分析： 泵出口、管道震动的测压点，使明一般压力表，长时间运行会使压力表内螺丝松动脱落，部件震坏等。 预防措施 震动较大的测压点，应安装耐震压力表。并定期对压力表进行恔验检测。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:2:0","series":null,"tags":["仪表","压力表"],"title":"压力表常见故障","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"三、腐蚀 现象 压力表测量不准，同时压力表内有脏污及表壳处有介质泄露。 检查 拆解压力表，发现弹簧管被腐蚀，破损。导致介质泄露到压力表内。 原因分析 在压力表选型时，没有按介质的腐蚀性选择对应材料，所以导致介质对压力表内部腐蚀。 预防措施 压力表在选型时，严格按照介质特性选对应的材料。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:0","series":null,"tags":["仪表","压力表"],"title":"压力表常见故障","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"四、超压 现象 压力表指针在零点柱以下，指针不动。 检查 压力表指针被打翻，不能正常测量。 原因分析 压力表因为没有加装缓冲弯，在投用吋或者高压波对压力表冲击，导致指针瞬间被打翻。 预防措施 加装缓冲装置。 压力波动大的位置选择量程合适的压力表。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:4:0","series":null,"tags":["仪表","压力表"],"title":"压力表常见故障","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"视频引用 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:0:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"一、压力测量 $$ P=F/S $$ P 压力（Pa） F 均匀垂直作用力（N） S 受力面积（m^2^） ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:1:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"二、压力的几种表示形式 被测压力通常可表示为： 绝对压力： 物体承受的实际压力。 表压： 以大气压力为基准，大于或 小于大气压力的压力值。 正/负压： 以大气压力为基准，高于/低 于大气压力的压力。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:2:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"三、原理 压力表通过表内的敏感元件的弹性形变，再由表内机芯的转换机构将压力形变传导至指针，引起指针转动来显示压力。 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:3:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"四、分类 压力表： 以大气压力为基准，用于测量大于 大气压力的仪表。 真空压力表： 以大气压力为基准，用于测量大于和 小于大气压力的仪表。 真空表： 以大气压力为基准，用于测量小于大 气压力的仪表。 压力表又分为： 普通压力表：测量普通介质无腐蚀性等。 不锈钢压力表：可以测量腐蚀性、氧化性等介 质。 耐震压力表：测量有震动设备 氨用压力表：氮专用压力测量（会与铜反应） ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:4:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"五、安装注意事项 ","date":"2022-08-04","objectID":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/:5:0","series":null,"tags":["仪表","压力表"],"title":"压力表常识","uri":"/2022/08/%E5%8E%8B%E5%8A%9B%E8%A1%A8%E5%B8%B8%E8%AF%86/"},{"categories":["仪表"],"content":"雷达料位计 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:0","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"高级功能 密码350015 （选中“信息”，Esc+ok同时按） ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:1","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"阻尼时间 60s ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:2","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"填充速度和排放速度 都是5m/min ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:3","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"盲区 2.9米 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:4","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"窗体跟踪（高级功能） 第一次 窗体跟踪开启 窗口跟踪宽度2米 跟踪时间120秒 第二次 窗体跟踪开启 跟踪宽度2米， 时间改成2000秒 (这样能够延缓炉壁挂料塌料和进料料流导致波动的影响) ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:5","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"虚假回波-编辑 第一次 起始0米 幅值250db 终止3米 幅值250db 第二次 起点18.8米，幅度80， 终点22米，幅度80 第三次 起点14，终点16，幅度均为80 起点18，终点20，幅度均为80 其它： ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:0:6","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"滤波(红线)怎么离回波(绿线)远点？ 服务，回波阈值，滤波抬升，默认是40%，需要调高可以到50%-60% 如果开启了自动增益的话，那么就是实时动态的 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:1:1","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"料位为什么会短暂出现0呢？ 这应该是失波故障E14。 雷达如果照到料流的话，电流信号就成为4mA或低于4mA了，反映在料位上就是0。这只是暂时现象。 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:1:2","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"什么是失波故障？ 接收不到正确的回波 正常的是发射出去一个频率的雷达波，就相应的必须接收到一个相同频率的回波，且必须在预定的阻尼滤波时间内接收到…如果在这时间内因为粉尘漫射导致路径变长，时间超出了没接收到回波，就会出现失波 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:1:3","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"没有进料的时候，料位从4米涨到5米，这种情况怎么解释？ 内部有障碍物吗？如支撑横梁或者拉绳之类的？ 料面不平，存在陡坡，雷达波测到的位置不一定是最高点，而随着底部卸料，可能从陡坡最高点下落下来到被测点，导致料位上涨，存在这种可能性 但是落差超过1米范围的就可能是料流或粉尘干扰，如炉壁挂料倒塌，进入雷达波测量范围内，粉尘存在时间持续超过阻尼滤波时间，从而引起波动 ","date":"2022-07-30","objectID":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/:1:4","series":null,"tags":["仪表","雷达料位计"],"title":"雷达料位计","uri":"/2022/07/%E9%9B%B7%E8%BE%BE%E6%96%99%E4%BD%8D%E8%AE%A1/"},{"categories":["仪表"],"content":"视频引用 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:1:0","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"一、 引线 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:2:0","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"热电偶 两根引线（正极、负极） 四根引线一般为双芯热电偶 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:2:1","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"热电阻 三根引线（使用较多） 两根和四根引线（使用较少） ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:2:2","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"因此： 双引线、有正负标记的为热电偶。 三引线，其中两根线颜色一样，则为热电阻。 双引线或四引线没有特殊标记不好确认 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:2:3","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"二、 型号 WR开头 热电偶 WZ开头 热电阻 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:3:0","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"三、 测量 热电偶：热电效应。 两种不同材料的导体、半导体焊接，所以回路电阻值较小。 热电阻：热阻效应。 电阻值与温度有联系，测温部位为热阻芯，所以回路阻值较大。 测量方法 万用表欧姆档 热电偶 一般在1欧姆左右，直接在热电偶木体量时零点几欧姆，有补偿导线的为一点几欧姆。 热电阻 不同分度号阻值不一样。 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:4:0","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"四、 使用场所 热电偶： 测量温度较高，量程较大。价格略贵。 例如：炉膛温度，锅炉温度等高温场所。 热电阻： 测量温度较低，量程较小。价格便宜。 例如：一般设备测温，低温场所。 ","date":"2022-07-30","objectID":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/:5:0","series":null,"tags":["仪表","温度计"],"title":"区分热电阻与热电偶","uri":"/2022/07/%E5%8C%BA%E5%88%86%E7%83%AD%E7%94%B5%E9%98%BB%E4%B8%8E%E7%83%AD%E7%94%B5%E5%81%B6/"},{"categories":["仪表"],"content":"引用视频 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:0:0","series":null,"tags":["仪表","温度计"],"title":"热电偶常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"一、热电势比实际值小（显示仪表指示值偏低） 热电极短路 找出短路原因，如因潮湿所致，则需要进行干燥； 如因绝缘子损坏所致，则需要更换绝缘子。 热电偶的接线柱处积灰，造成短路 清扫积灰 补偿导线线间短路 找出短路点，加强绝缘或更换补偿导线 热电偶热电极变质 更换新热电偶 补偿导线与热电偶极性接反 重新接正确 补偿导线与热电偶不配套 更换相配套的补偿导线 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:1:0","series":null,"tags":["仪表","温度计"],"title":"热电偶常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"二、 热电势比实际值大 （显示仪表指示值偏高） 热电偶与显示仪表不配套 更换热电偶或显示仪表使之相配套 补偿导线与热电偶不配套 更换补偿导线使之配套 有直流干扰信号进入 排除直流干扰 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:2:0","series":null,"tags":["仪表","温度计"],"title":"热电偶常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"三、 热电热输出不稳定 热电偶接线柱接触不良 将接线柱螺丝拧紧 热电偶测量线路绝缘破损，引起断续短路或接地 找出故障点，修复绝缘 受到电磁干扰 避开干扰或加装保护装置 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:0","series":null,"tags":["仪表","温度计"],"title":"热电偶常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E5%81%B6%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"引用视频 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:1:0","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"计算方法 温度T 阻值R $$ T = （R-100）/0.385 $$ 例如：测得某热电阻阻值为137.5，则温度为 $$ T=(137.5-100)/0.385=97.4 $$ ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:2:0","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"故障处理 原则：根据原理分析，处理故障。 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:0","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"温度无穷大 可能原因： 出现断路，或接线疯子松动。 处理方法： 使用万用表，测量查出断线部位，恢复即可。 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:1","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"温度特别小（负值） 可能原因： 出现短路，或热电阻与温度变送器接线错误。 处理方法： 测量线路，恢复接线；正确连接一次元件和温变的接线方式。 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:2","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"温度比实际小 可能原因： 保护套管内有灰尘、金属屑、积液、接线柱之间有脏污等。 处理方法： 清理杂物，恢复正常。 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:3","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":["仪表"],"content":"温度出现波动 带有温度变送器的，先检查一次元件是否正常。 ","date":"2022-07-30","objectID":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/:3:4","series":null,"tags":["仪表","温度计"],"title":"热电阻常见故障","uri":"/2022/07/%E7%83%AD%E7%94%B5%E9%98%BB%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C/"},{"categories":null,"content":"03-Cycript Cycript是Objective-C++、ES6（JavaScript）、Java等语法的混合物 可以用来探索、修改、调试正在运行的Mac\\iOS APP 官网： http://www.cycript.org/ 文档： http://www.cycript.org/manual/ 通过Cydia安装Cycript，即可在iPhone上调试运行中的APP cycript 开启 cycript -p 进程ID cycript -p 进程名称 取消输入：Ctrl + C 退出：Ctrl + D 清屏：Command + R ","date":"2022-06-27","objectID":"/2022/06/03-cycript/:1:0","series":null,"tags":["iPhone"],"title":"03-Cycript","uri":"/2022/06/03-cycript/"},{"categories":null,"content":"ps命令 安装adv-cmds ps命令是process status的缩写，使用ps命令可以列出系统当前的进程 列出所有的进程 ps –A ps aux 搜索关键词 ps –A | grep 关键词 ","date":"2022-06-27","objectID":"/2022/06/03-cycript/:2:0","series":null,"tags":["iPhone"],"title":"03-Cycript","uri":"/2022/06/03-cycript/"},{"categories":null,"content":"常用语法 UIApp [UIApplication sharedApplication] 定义变量 var 变量名 = 变量值 用内存地址获取对象 #内存地址 ObjectiveC.classes 已加载的所有OC类 查看对象的所有成员变量 *对象 递归打印view的所有子控件（跟LLDB一样的函数） view.recursiveDescription().toString() 筛选出某种类型的对象 choose(UIViewController) choose(UITableViewCell) ","date":"2022-06-27","objectID":"/2022/06/03-cycript/:3:0","series":null,"tags":["iPhone"],"title":"03-Cycript","uri":"/2022/06/03-cycript/"},{"categories":null,"content":"封装Cycript - .cy文件编写 将.cy文件存放到/usr/lib/cycript0.9目录下 在Cycript中引用.cy文件，并使用它提供的接口 全局变量不需要加exports,访问时也不需要加文件名 ","date":"2022-06-27","objectID":"/2022/06/03-cycript/:4:0","series":null,"tags":["iPhone"],"title":"03-Cycript","uri":"/2022/06/03-cycript/"},{"categories":["C++"],"content":"socket编程演示 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"socket() 创建套接字 通过 socket() 函数创建了一个套接字，参数 AF_INET 表示使用 IPv4 地址，SOCK_STREAM 表示使用面向连接的数据传输方式，IPPROTO_TCP 表示使用 TCP 协议。 int socket(int af, int type, int protocol);//linux SOCKET socket(int af, int type, int protocol);//windows //linux int tcp_socket = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字 int udp_socket = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP套接字 //windows SOCKET tcp_socket = socket(AF_INET, SOCK_STREAM, 0); //创建TCP套接字 SOCKET udp_socket = socket(AF_INET, SOCK_DGRAM, 0); //创建UDP套接字 参数： af 为地址族（Address Family），也就是 IP 地址类型，常用的有 AF_INET 和 AF_INET6。AF 是“Address Family”的简写，INET是“Inetnet”的简写。AF_INET 表示 IPv4 地址，例如 127.0.0.1；AF_INET6 表示 IPv6 地址，例如 1030::C9B4:FF12:48AA:1A2B。 type 为数据传输方式，常用的有 SOCK_STREAM 和 SOCK_DGRAM，在《socket是什么意思》一节中已经进行了介绍。 protocol 表示传输协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。可以将 protocol 的值设为 0，系统会自动推演出应该使用什么协议. 返回值： 返回值为 SOCKET 类型，也就是句柄。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"bind() 绑定 通过 bind() 函数将套接字 serv_sock 与特定的IP地址和端口绑定，IP地址和端口都保存在 sockaddr_in 结构体中。 bind() 函数的原型为： int bind(int sock, struct sockaddr *addr, socklen_t addrlen); //Linux int bind(SOCKET sock, const struct sockaddr *addr, int addrlen); //Windows 这里我们使用 sockaddr_in 结构体，然后再强制转换为 sockaddr 类型 接下来不妨先看一下 sockaddr_in 结构体，它的成员变量如下： struct sockaddr_in{ sa_family_t sin_family; //地址族（Address Family），也就是地址类型 uint16_t sin_port; //16位的端口号 struct in_addr sin_addr; //32位IP地址 char sin_zero[8]; //不使用，一般用0填充 }; struct in_addr{ in_addr_t s_addr; //32位的IP地址 }; sockaddr_in6，用来保存 IPv6 地址 struct sockaddr_in6 { sa_family_t sin6_family; //(2)地址类型，取值为AF_INET6 in_port_t sin6_port; //(2)16位端口号 uint32_t sin6_flowinfo; //(4)IPv6流信息 struct in6_addr sin6_addr; //(4)具体的IPv6地址 uint32_t sin6_scope_id; //(4)接口范围ID }; ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"listen()监听 int listen(int sock, int backlog); //Linux int listen(SOCKET sock, int backlog); //Windows sock 为需要进入监听状态的套接字 backlog 为请求队列的最大长度。并发量小的话可以是10或者20。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"accept() 接收请求 accept() 函数用来接收客户端的请求。程序一旦执行到 accept() 就会被阻塞（暂停运行），直到客户端发起请求。 当套接字处于监听状态时，可以通过 accept() 函数来接收客户端请求。它的原型为： int accept(int sock, struct sockaddr *addr, socklen_t *addrlen); //Linux SOCKET accept(SOCKET sock, struct sockaddr *addr, int *addrlen); //Windows 它的参数与 listen() 和 connect() 是相同的： sock 为服务器端套接字 addr 为 sockaddr_in 结构体变量 addrlen 为参数 addr 的长度，可由 sizeof() 求得。 accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，大家注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。 最后需要说明的是：listen() 只是让套接字进入监听状态，并没有真正接收客户端请求，listen() 后面的代码会继续执行，直到遇到 accept()。accept() 会阻塞程序执行（后面代码不能被执行），直到有新的请求到来。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"send()发送数据 int send(SOCKET sock, const char *buf, int len, int flags); sock 为要发送数据的套接字 buf 为要发送的数据的缓冲区地址 len 为要发送的数据的字节数 flags 为发送数据时的选项。 flags 参数一般设置为 0 或 NULL，初学者不必深究。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"connect()发起请求 connect() 向服务器发起请求，服务器的IP地址和端口号保存在 sockaddr_in 结构体中。直到服务器传回数据后，connect() 才运行结束。 connect() 函数用来建立连接，它的原型为： int connect(int sock, struct sockaddr *serv_addr, socklen_t addrlen); //Linux int connect(SOCKET sock, const struct sockaddr *serv_addr, int addrlen); //Windows ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"recv()接收数据 int recv(SOCKET sock, char *buf, int len, int flags); sock 为要接收数据的套接字 buf 为要接收的数据的缓冲区地址 len 为要接收的数据的字节数 flags 为接收数据时的选项。 flags 参数一般设置为 0 或 NULL，初学者不必深究。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"closesocket() 关闭套接字 close() / closesocket() 用来关闭套接字，将套接字描述符（或句柄）从内存清除，之后再也不能使用该套接字，与C语言中的 fclose() 类似。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"shutdown()断开连接 int shutdown(int sock, int howto); //Linux int shutdown(SOCKET s, int howto); //Windows sock 为需要断开的套接字，howto 为断开方式。 howto 在 Windows 下有以下取值： SD_RECEIVE：关闭接收操作，也就是断开输入流。 SD_SEND：关闭发送操作，也就是断开输出流。 SD_BOTH：同时关闭接收和发送操作。 shutdown() 用来关闭连接，而不是套接字，不管调用多少次 shutdown()，套接字依然存在，直到调用 close() / closesocket() 将套接字从内存清除。 close()/closesocket() 会立即向网络中发送FIN包，不管输出缓冲区中是否还有数据，而shutdown() 会等输出缓冲区中的数据传输完毕再发送FIN包。也就意味着，调用 close()/closesocket() 将丢失输出缓冲区中的数据，而调用 shutdown() 不会。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:9:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"WSACleanup()终止 DLL 的使用 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:10:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"DLL的加载 WinSock（Windows Socket）编程依赖于系统提供的动态链接库(DLL)，有两个版本： 较早的DLL是 wsock32.dll，大小为 28KB，对应的头文件为 winsock1.h； 最新的DLL是 ws2_32.dll，大小为 69KB，对应的头文件为 winsock2.h。 使用DLL之前必须把DLL加载到当前程序，你可以在编译时加载，也可以在程序运行时加载，《C语言高级教程》中讲到了这两种加载方式，请猛击：动态链接库DLL的加载：隐式加载(载入时加载)和显式加载(运行时加载)。 这里使用#pragma命令，在编译时加载： #pragma comment (lib, \"ws2_32.lib\") ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:11:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"WSAStartup() 进行初始化 使用DLL之前，还需要调用 WSAStartup() 函数进行初始化，以指明 WinSock 规范的版本，它的原型为： int WSAStartup( WORD wVersionRequested, LPWSADATA lpWSAData ); ws2_32.dll 支持的最高版本为 2.2，建议使用的版本也是 2.2。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:12:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"文件传输 实例：client 从 server 下载一个文件并保存到本地。 编写这个程序需要注意两个问题： 文件大小不确定，有可能比缓冲区大很多，调用一次 write()/send() 函数不能完成文件内容的发送。接收数据时也会遇到同样的情况。 要解决这个问题，可以使用 while 循环，例如： //Server 代码 int nCount; while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) \u003e 0 ){ send(sock, buffer, nCount, 0); } //Client 代码 int nCount; while( (nCount = recv(clntSock, buffer, BUF_SIZE, 0)) \u003e 0 ){ fwrite(buffer, nCount, 1, fp); } 对于 Server 端的代码，当读取到文件末尾，fread() 会返回 0，结束循环。 对于 Client 端代码，有一个关键的问题，就是文件传输完毕后让 recv() 返回 0，结束 while 循环。 Client 端如何判断文件接收完毕，也就是上面提到的问题——何时结束 while 循环。 最简单的结束 while 循环的方法当然是文件接收完毕后让 recv() 函数返回 0，那么，如何让 recv() 返回 0 呢？recv() 返回 0 的唯一时机就是收到FIN包时。 本节以Windows为例演示文件传输功能，Linux与此类似，不再赘述。请看下面完整的代码。 服务器端 server.cpp： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cwinsock2.h\u003e #pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #define BUF_SIZE 1024 int main(){ //先检查文件是否存在 char *filename = \"D:\\\\send.avi\"; //文件名 FILE *fp = fopen(filename, \"rb\"); //以二进制方式打开文件 if(fp == NULL){ printf(\"Cannot open file, press any key to exit!\\n\"); system(\"pause\"); exit(0); } WSADATA wsaData; WSAStartup( MAKEWORD(2, 2), \u0026wsaData); SOCKET servSock = socket(AF_INET, SOCK_STREAM, 0); sockaddr_in sockAddr; memset(\u0026sockAddr, 0, sizeof(sockAddr)); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); sockAddr.sin_port = htons(1234); bind(servSock, (SOCKADDR*)\u0026sockAddr, sizeof(SOCKADDR)); listen(servSock, 20); SOCKADDR clntAddr; int nSize = sizeof(SOCKADDR); SOCKET clntSock = accept(servSock, (SOCKADDR*)\u0026clntAddr, \u0026nSize); //循环发送数据，直到文件结尾 char buffer[BUF_SIZE] = {0}; //缓冲区 int nCount; while( (nCount = fread(buffer, 1, BUF_SIZE, fp)) \u003e 0 ){ send(clntSock, buffer, nCount, 0); } shutdown(clntSock, SD_SEND); //文件读取完毕，断开输出流，向客户端发送FIN包 recv(clntSock, buffer, BUF_SIZE, 0); //阻塞，等待客户端接收完毕 fclose(fp); closesocket(clntSock); closesocket(servSock); WSACleanup(); system(\"pause\"); return 0; } 客户端代码： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWinSock2.h\u003e #pragma comment(lib, \"ws2_32.lib\") #define BUF_SIZE 1024 int main(){ //先输入文件名，看文件是否能创建成功 char filename[100] = {0}; //文件名 printf(\"Input filename to save: \"); gets(filename); FILE *fp = fopen(filename, \"wb\"); //以二进制方式打开（创建）文件 if(fp == NULL){ printf(\"Cannot open file, press any key to exit!\\n\"); system(\"pause\"); exit(0); } WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); SOCKET sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP); sockaddr_in sockAddr; memset(\u0026sockAddr, 0, sizeof(sockAddr)); sockAddr.sin_family = PF_INET; sockAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); sockAddr.sin_port = htons(1234); connect(sock, (SOCKADDR*)\u0026sockAddr, sizeof(SOCKADDR)); //循环接收数据，直到文件传输完毕 char buffer[BUF_SIZE] = {0}; //文件缓冲区 int nCount; while( (nCount = recv(sock, buffer, BUF_SIZE, 0)) \u003e 0 ){ fwrite(buffer, nCount, 1, fp); } puts(\"File transfer success!\"); //文件接收完毕后直接关闭套接字，无需调用shutdown() fclose(fp); closesocket(sock); WSACleanup(); system(\"pause\"); return 0; } 在D盘中准备好send.avi文件，先运行 server，再运行 client： Input filename to save: D:\\recv.avi↙ //稍等片刻后 File transfer success! 打开D盘就可以看到 recv.avi，大小和 send.avi 相同，可以正常播放。 注意 server.cpp 第42行代码，recv() 并没有接收到 client 端的数据，当 client 端调用 closesocket() 后，server 端会收到FIN包，recv() 就会返回，后面的代码继续执行。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:13:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"在socket中使用域名 gethostbyname()域名获取IP struct hostent *gethostbyname(const char *hostname); hostname 为主机名，也就是域名。使用该函数时，只要传递域名字符串，就会返回域名对应的IP地址。 返回的地址信息会装入 hostent 结构体，该结构体的定义如下： struct hostent{ char *h_name; //official name char **h_aliases; //alias list int h_addrtype; //host address type int h_length; //address lenght char **h_addr_list; //address list } 从该结构体可以看出，不只返回IP地址，还会附带其他信息，各位读者只需关注最后一个成员 h_addr_list。下面是对各成员的说明： h_name：官方域名（Official domain name）。官方域名代表某一主页，但实际上一些著名公司的域名并未用官方域名注册。 h_aliases：别名，可以通过多个域名访问同一主机。同一IP地址可以绑定多个域名，因此除了当前域名还可以指定其他域名。 h_addrtype：gethostbyname() 不仅支持 IPv4，还支持 IPv6，可以通过此成员获取IP地址的地址族（地址类型）信息，IPv4 对应 AF_INET，IPv6 对应 AF_INET6。 h_length：保存IP地址长度。IPv4 的长度为4个字节，IPv6 的长度为16个字节。 h_addr_list：这是最重要的成员。通过该成员以整数形式保存域名对应的IP地址。对于用户较多的服务器，可能会分配多个IP地址给同一域名，利用多个服务器进行均衡负载。 hostent 结构体变量的组成如下图所示： 下面的代码主要演示 gethostbyname() 的应用，并说明 hostent 结构体的特性 #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cWinSock2.h\u003e #pragma comment(lib, \"ws2_32.lib\") int main(){ WSADATA wsaData; WSAStartup( MAKEWORD(2, 2), \u0026wsaData); struct hostent *host = gethostbyname(\"www.baidu.com\"); if(!host){ puts(\"Get IP address error!\"); system(\"pause\"); exit(0); } //别名 for(int i=0; host-\u003eh_aliases[i]; i++){ printf(\"Aliases %d: %s\\n\", i+1, host-\u003eh_aliases[i]); } //地址类型 printf(\"Address type: %s\\n\", (host-\u003eh_addrtype==AF_INET) ? \"AF_INET\": \"AF_INET6\"); //IP地址 for(int i=0; host-\u003eh_addr_list[i]; i++){ printf(\"IP addr %d: %s\\n\", i+1, inet_ntoa( *(struct in_addr*)host-\u003eh_addr_list[i] ) ); } system(\"pause\"); return 0; } 运行结果： Aliases 1: www.baidu.com Address type: AF_INET IP addr 1: 61.135.169.121 IP addr 2: 61.135.169.125 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:14:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"select函数I/O多路复用 引用 int select(int maxfdp, fd_set *readset, fd_set *writeset, fd_set *exceptset,struct timeval *timeout); 参数含义: maxfdp：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。 readfds：（可选）指针，指向一组等待可读性检查的套接口。 writefds：（可选）指针，指向一组等待可写性检查的套接口。 exceptfds：（可选）指针，指向一组等待错误检查的套接口。 timeout:用于设置select函数的超时时间，即告诉内核select等待多长时间之后就放弃等待。timeout == NULL 表示等待无限长的时间 readfds数组将包括满足以下条件的套接字： 1有数据可读 2连接已经关闭、重设或终止 3正在请求建立连接的套接字（listfd），此时调用accept函数会直接成功，accept相当于非阻塞的 writefds数组包含满足下列条件的套接字： 1有数据可以发送,此时在此sockfd上调用send,可以向对方发送数据。 2调用connect函数，并连接成功的sockfd 返回值： 当返回为-1时，所有描述符集清0。 当返回为0时，表示超时。 当返回为正数时，表示已经准备好的描述符数。 select（）返回后，在3个描述符集里，依旧是1的位就是准备好的描述符。这也就是为什么，每次用select后都要用FD_ISSET的原因。 select函数实现I/O多路复用，可以用来监视多个描述符，之后我们调用FD_ISSET函数确定具体是哪一个描述符准备好了。 timeval结构体定义如下： struct timeval { long tv_sec; /*秒 */ long tv_usec; /*微秒 */ }; fd_set 相关: int FD_ZERO(fd_set *fdset); //一个 fd_set类型变量的所有位都设为 0 （可理解为清空集合中的所有感兴趣描述符） int FD_CLR(int fd, fd_set *fdset); //清除某个位时可以使用 （可理解为清空集合中的某一个描述符） int FD_SET(int fd, fd_set *fd_set); //设置变量的某个位置位 （可理解为向集合中添加一个描述符） int FD_ISSET(int fd, fd_set *fdset); //测试某个位是否被置位 （可理解为判断一个描述符是否在集合中） 程序流程 绑定、监听….. 创建集合，由于调用select函数时，传入的集合参数在函数返回后可能会改变，因此创建一个集合来保存所有感兴趣的描述符allset，再创建一个集合rset用来作为select的调用参数；再创建一个数组client用来存放所有有效的描述符，并初始化各项为-1； 将监听描述符lfd加入allset，此时最大描述符maxfd = lfd； 创建while循环，将allset赋值给rset，将rset作为读集合参数，调用select函数开始阻塞等待； select函数返回后，先判断监听描述符lfd是否还存在于rset中，判断方式为if(FD_SET(lfd,\u0026rset))。 如果判断为真，说明有新连接，则调用accept函数新连接的文件描述符并存在变量connfd中，然后再将connfd加入allset中和client数组中； 然后处理除监听描述符以外的描述符。遍历client数组，查看有效描述符是否发生了读事件，判断方式为if(FD_SET(client[i],\u0026rset))；如果判断为真，说明有数据传来，就进行read和write操作； 继续下一次循环…. #include \u003ciostream\u003e #include \u003cunistd.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003csys/socket.h\u003e #include \u003carpa/inet.h\u003e using namespace std; #define SERV_IP \"127.1.2.3\" #define SERV_PORT 8888 #define MAX_CONN 1024 int main() { sockaddr_in servaddr,clitaddr; sockaddr_in clit_info[MAX_CONN]; //存放成功連接的客戶端地址信息 int client[1024]; //存放成功連接的文件描述符 char buf[1024]; //讀寫緩衝區 int lfd; //用於監聽 int connfd; //連接描述符 int readyfd; //保存select返回值 int maxfd = 0; //保存最大文件描述符 int maxi = 0; //maxi反映了client中最後一個成功連接的文件描述符的索引 socklen_t addr_len = sizeof(clitaddr);; fd_set allset; //存放所有可以被監控的文件描述符 fd_set rset; FD_ZERO(\u0026allset);//FD_ZERO(fd_set *fdset);将指定的文件描述符集清空 FD_ZERO(\u0026rset); if((lfd = socket(AF_INET,SOCK_STREAM,0)) == -1) { cout\u003c\u003c\"creat socket fault : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } servaddr.sin_family = AF_INET; servaddr.sin_port = htons(SERV_PORT); servaddr.sin_addr.s_addr = inet_addr(SERV_IP); if(bind(lfd,(sockaddr *)\u0026servaddr,sizeof(servaddr)) == -1) { cout\u003c\u003c\"bind fault : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } if(listen(lfd,128) == -1) { cout\u003c\u003c\"listen fault : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } maxfd = lfd; //此時只用監控lfd，因此lfd就是最大文件描述符 //初始化client數組 for(int i=0;i\u003cMAX_CONN;i++)client[i] = -1; FD_SET(lfd,\u0026allset); cout\u003c\u003c\"Init Success ! \"\u003c\u003cendl; cout\u003c\u003c\"host ip : \"\u003c\u003cinet_ntoa(servaddr.sin_addr)\u003c\u003c\" port : \"\u003c\u003cntohs(servaddr.sin_port)\u003c\u003cendl; cout\u003c\u003c\"Waiting for connections ... \"\u003c\u003cendl; while(1) { rset = allset ; //rset作爲select參數時，表示需要監控的所有文件描述符集合，select返回時，rset中存放的是成功監控的文件描述符。因此在select前後rset是可能改變的，所以在調用select前將rset置爲所有需要被監控的文件描述符的集合，也就是allset readyfd = select(maxfd+1,\u0026rset,NULL,NULL,NULL); //服務端只考慮讀的情況 //執行到這裏，說明select返回，返回值保存在readyfd中，表示有多少個文件描述符被監控成功 if(readyfd == -1) { cout\u003c\u003c\"select fault : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; return 0; } if(FD_ISSET(lfd,\u0026rset)) //監聽描述符監控成功，說明有連接請求 { int i=0; connfd = accept(lfd,(sockaddr *)\u0026clitaddr,\u0026addr_len); //處理新連接，此時accept直接可以返回而不用一直阻塞 if(connfd == -1) { cout\u003c\u003c\"accept fault : \"\u003c\u003cstrerror(errno)\u003c\u003cendl; continue ; } cout\u003c\u003cinet_ntoa(clitaddr.sin_addr)\u003c\u003c\":\"\u003c\u003cntohs(clitaddr.sin_port)\u003c\u003c\" connected ... \"\u003c\u003cendl; //成功連接後，就將connfd加入監控描述符表中 FD_SET(connfd,\u0026allset); for(;i\u003cMAX_CONN;i++) { if(client[i] == -1) { client[i] = connfd; clit_info[i] = clitaddr; break; } } if(connfd\u003emaxfd)maxfd = connfd; //更新最大文件描述符 if(i\u003emaxi)maxi = i; readyfd --; if(readyfd == 0)continue; //如果只有lfd被監控成功，那麼就重新select } //處理lfd之外監控成功的文件描述符，進行輪詢 for(int i=0;i\u003c=","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:15:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"基于UDP的服务器端和客户端 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:16:0","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"sendto()发送数据 ssize_t sendto(int sock, void *buf, size_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen); //Linux int sendto(SOCKET sock, const char *buf, int nbytes, int flags, const struct sockadr *to, int addrlen); //Windows sock：用于传输UDP数据的套接字； buf：保存待传输数据的缓冲区地址； nbytes：带传输数据的长度（以字节计）； flags：可选项参数，若没有可传递0； to：存有目标地址信息的 sockaddr 结构体变量的地址； addrlen：传递给参数 to 的地址值结构体变量的长度。 UDP 发送函数 sendto() 与TCP发送函数 write()/send() 的最大区别在于，sendto() 函数需要向他传递目标地址信息。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:16:1","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"recvfrom() 接收数据 ssize_t recvfrom(int sock, void *buf, size_t nbytes, int flags, struct sockadr *from, socklen_t *addrlen); //Linux int recvfrom(SOCKET sock, char *buf, int nbytes, int flags, const struct sockaddr *from, int *addrlen); //Windows sock：用于接收UDP数据的套接字； buf：保存接收数据的缓冲区地址； nbytes：可接收的最大字节数（不能超过buf缓冲区的大小）； flags：可选项参数，若没有可传递0； from：存有发送端地址信息的sockaddr结构体变量的地址； addrlen：保存参数 from 的结构体变量长度的变量地址值。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:16:2","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"UDP回声服务器端 server.cpp： #include \u003cstdio.h\u003e #include \u003cwinsock2.h\u003e #pragma comment (lib, \"ws2_32.lib\") //加载 ws2_32.dll #define BUF_SIZE 100 int main(){ WSADATA wsaData; WSAStartup( MAKEWORD(2, 2), \u0026wsaData); //创建套接字 SOCKET sock = socket(AF_INET, SOCK_DGRAM, 0); //绑定套接字 sockaddr_in servAddr; memset(\u0026servAddr, 0, sizeof(servAddr)); //每个字节都用0填充 servAddr.sin_family = PF_INET; //使用IPv4地址 servAddr.sin_addr.s_addr = htonl(INADDR_ANY); //自动获取IP地址 servAddr.sin_port = htons(1234); //端口 bind(sock, (SOCKADDR*)\u0026servAddr, sizeof(SOCKADDR)); //接收客户端请求 SOCKADDR clntAddr; //客户端地址信息 int nSize = sizeof(SOCKADDR); char buffer[BUF_SIZE]; //缓冲区 while(1){ int strLen = recvfrom(sock, buffer, BUF_SIZE, 0, \u0026clntAddr, \u0026nSize); sendto(sock, buffer, strLen, 0, \u0026clntAddr, nSize); } closesocket(sock); WSACleanup(); return 0; } 代码说明： 第12行代码在创建套接字时，向 socket() 第二个参数传递 SOCK_DGRAM，以指明使用UDP协议。 第18行代码中使用htonl(INADDR_ANY)来自动获取IP地址。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:16:3","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":"UDP回声客户端 client.cpp： #include \u003cstdio.h\u003e #include \u003cWinSock2.h\u003e #pragma comment(lib, \"ws2_32.lib\") //加载 ws2_32.dll #define BUF_SIZE 100 int main(){ //初始化DLL WSADATA wsaData; WSAStartup(MAKEWORD(2, 2), \u0026wsaData); //创建套接字 SOCKET sock = socket(PF_INET, SOCK_DGRAM, 0); //服务器地址信息 sockaddr_in servAddr; memset(\u0026servAddr, 0, sizeof(servAddr)); //每个字节都用0填充 servAddr.sin_family = PF_INET; servAddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); servAddr.sin_port = htons(1234); //不断获取用户输入并发送给服务器，然后接受服务器数据 sockaddr fromAddr; int addrLen = sizeof(fromAddr); while(1){ char buffer[BUF_SIZE] = {0}; printf(\"Input a string: \"); gets(buffer); sendto(sock, buffer, strlen(buffer), 0, (struct sockaddr*)\u0026servAddr, sizeof(servAddr)); int strLen = recvfrom(sock, buffer, BUF_SIZE, 0, \u0026fromAddr, \u0026addrLen); buffer[strLen] = 0; printf(\"Message form server: %s\\n\", buffer); } closesocket(sock); WSACleanup(); return 0; } 先运行 server，再运行 client，client 输出结果为： Input a string: C语言中文网 Message form server: C语言中文网 Input a string: c.biancheng.net Founded in 2012 Message form server: c.biancheng.net Founded in 2012 Input a string: 从代码中可以看出，server.cpp 中没有使用 listen() 函数，client.cpp 中也没有使用 connect() 函数，因为 UDP 不需要连接。 ","date":"2022-04-23","objectID":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/:16:4","series":null,"tags":["C++","Socket"],"title":"C++","uri":"/2022/04/c-socket%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"一. 人物基址及相关属性偏移 CE搜索数值,如血量 OD追基址 龙龙遍历其它偏移 ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:1:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":null,"content":"二. 查找人物状态基址及偏移 CE搜索人物状态 OD追基址 ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:2:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":null,"content":"三. 人物怪物二叉树 CE搜索NPC名字 OD追基址,追到递归,放弃重来 CE搜索怪物血量 OD追基址,追到二叉树,追出树根 根据二叉树特性,在汇编中可推测出关键标志位,怪物ID及怪物对象 在怪物对象下可找到怪物属性(参考人物偏移) ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:3:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":null,"content":"四. DLL显示窗口 创建MFC_DLL( 创建项目 =\u003e MFC动态链接库 在创建DLL内添加窗口 资源视图 =\u003e rc文件右击 =\u003e 添加资源 =\u003e Dialog 添加窗口控件类 dialog窗口右击 =\u003e 添加类(如CMainDialog) 线程创建并显示窗口 创建多线程 创建窗口对象,用new来初始化,用DoModal显示出来 释放new的内存空间 释放dll空间并退出dll //唯一的 CMainDllApp 对象 CMainDllApp theApp; CMainDialog *PMainDialog; DWORD WINAPI _显示窗口(LPARAM lParam) { PMainDialog = new CMainDialog; //用new的方式分配内存空间 PMainDialog-\u003eDoModal(); //以模态化显示 delete PMainDialog; //释放new分配的内存空间 FreeLibraryAndExitThread(theApp.m_HInstance,1); //释放dll空间并退出dll return TRUE; } //CMainDllApp 初始化 BOOL CMainDllApp::InitInstance() { CWinApp::InitInstance(); ::CreateThread(NULL,0,(LPTHREAD_START_ROUTINE)_显示窗口,NULL,0,NULL); return TRUE; } ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:4:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":null,"content":"五. 编写注入器 新建MFC应用 提升扠限 获取进程钥匙: OpenProcessToken() 获取当前进程句柄: GetCurrentProcess(） 查看权限: LookupPrivilegeValue( 设置新权限: AdjustTokenPrivileges() 关闭进程句柄: CloseHandle() void _提权() { //1. 获取进程钥匙 HANDLE 进程_钥匙; if(FALSE == OpenProcessToken(GetCurrentProcess(),//进程句柄=\u003e当前进程 TOKEN_ALL_ACCESS, //所有权限 \u0026进程_钥匙)); //存放钥匙 { MessaseBox(NULL,_T(\"打开进程访问令牌失败!\"),_T(\"错误提示\"),MB_OK); return; } //2.查看进程里面的特权信息 LUID 进程_权限; if(FALSE == LookupPrivilegeValue(NULL,SE_DEBUG_NAME,\u0026进程_权限)) { MessaseBox(NULL,_T(\"查看进程权限信息失败!\"),_T(\"错误提示\"),MB_OK); return; } //3. 调节进程权限 TOKEN_PRIVILEGES 进程_新特权; 进程_新特权.PrivilegCount = 1; //特权个数 进程_新特权.Privileg[0].Attributes = SE_PRIVILEGE_ENABLED; //启用特权 进程_新特权.Privileg[0].Luid = 进程_权限; //将查到的luid存放到luid里面 if(FALSE == AdjustTokenPrivileges(进程_钥匙,FALSE,\u0026进程_新特权,sizeof(进程_新特权),NULL,NULL)) { MessaseBox(NULL,_T(\"打开进程权限失败!\"),_T(\"错误提示\"),MB_OK); return; } //4. 关闭进程句柄 CloseHandle(进程_钥匙); } 开始注入 获取窗口句柄: FindWindow() 根据窗口句柄获取进程ID PID: GetWindowThreadProcessId() 根据PID获取进程句柄: OpenProcess() 在远程进程中申请内存空间: VirtualAllocEx() 在远程进程中写入咱们的DLL地址: WriteProcessMemory() 获取LoadLibraryA()函数地址: GetProcAddress() 在远程进程中创建一个线程: CreateRemoteThread() 清理战场 void _注入辅助() { //1. 查找窗口 HWND 游戏窗口句柄; 游戏窗口句柄 = FindWindow(游戏窗口类名,NULL); if(游戏窗口句柄 == NULL) { MessaseBox(NULL,_T(\"游戏未启动\"),_T(\"错误提示\"),MB_OK); return; } //2. 获取进程ID PID DWORD 进程_PID = 0; GetWindowThreadProcessId(游戏窗口句柄,\u0026进程_PID); if(进程_PID == 0) { MessaseBox(NULL,_T(\"获取进程PID失败\"),_T(\"错误提示\"),MB_OK); return; } //进程: 一个进程中的程序 //一个进程可以有多个窗口 //3. 获取进程句柄 HANDLE 进程_进程句柄 = NULL; 进程_进程句柄 = OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程_PID); if(进程_进程句柄 == NULL) { MessaseBox(NULL,_T(\"获取进程PID失败\"),_T(\"错误提示\"),MB_OK); return; } //4. 在远程进程中申请内存空间 LPVOID 申请空间地址 = NULL; DWORD 申请空间 =256; 申请空间地址 = VirtualAllocEx(进程_进程句柄,NULL,申请空间,MEM_COMMIT,PAGE_READWRITE); if(申请空间地址 == NULL) { MessaseBox(NULL,_T(\"获取进程PID失败\"),_T(\"错误提示\"),MB_OK); return; } //5. 将DLL的路径写入到远程进程中 /* CHAR 当前路径[256]; CHAR DLL路径[256]; GetCurrentDirectoryA(sizeof(当前路径),当前路径); //获取运行目录 strcpy_s(DLL路径,当前路径); strcpy_s(DLL路径,\"\\\\\"); strcpy_s(DLL路径,DLL名); */ SIZE_T 实际写入大小 = 0; CHAR DLL路径[256] = \"C:\\\\Users\\\\Admin\\\\Desktop\\\\MyDll.dll \" if(FALSE == WriteProcessMemory(进程_进程句柄,申请空间地址,DLL路径,strlen(DLL路径)+1,\u0026实际写入大小)) { MessaseBox(NULL,_T(\"DLL写入失败\"),_T(\"错误提示\"),MB_OK); return; } LPTHREAD_START_ROUTINE 函数地址 = NULL; 函数地址 = (LPTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandleA(\"kernel32.dll\"),\"LoadLibraryA\"); //6. 在远程进程中创建一个线程 HANDLE 进程_远程线程句柄 = NULL; 进程_远程线程句柄 = CreateRemoteThread(进程_进程句柄,NULL,0,函数地址,申请空间地址,0,NULL); if(进程_远程线程句柄 == NULL) { MessaseBox(NULL,_T(\"创建远程线程失败\"),_T(\"错误提示\"),MB_OK); return; } WaitForSingleObject(进程_远程线程句柄,0xFFFFFFFF); CloseHandle(进程_远程线程句柄); VirtualFreeEx(进程_进程句柄,申请空间地址,申请空间,MEM_DECOMMIT); CloseHandle(进程_进程句柄); } ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:5:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":null,"content":"六. 实现读取游戏数据 实现读取人物信息 用指针的方式读取内存 //基址管理 #define _人物基址 (DWORD)GetModuleHandleA(\"Game. exe”) +0x3B3E78 #define _背包基址 (DWORD)GetModuleHandleA(\"Game. exe”) +0x3B40F4 //结构管理 struct R_人物屬性 { DWORD 状态; DWORD 最大血值; DWORD 当前蓝值; DWORD 最大藍值; PCHAR 人物名 = \"\"; FLOAT X坐标; FLOAT Y坐标; DWORD dw对象; DWORD 类型; FLOAT 距离; DWORD ID; void _初始化(); } ","date":"2022-02-24","objectID":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/:6:0","series":null,"tags":["夜风来袭"],"title":"C++逆向","uri":"/2022/02/%E5%A4%9C%E9%A3%8E_%E6%9D%A5%E8%A2%AD-c-%E9%80%86%E5%90%91/"},{"categories":["C++"],"content":"for、while、do while三种循环的流程图画法总结（附案例） 循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构，可以看成是一个条件判断语句和一个向回转向语句的组合。 循环结构由三个要素组成，分别为循环变量、循环体和循环终止条件。 循环结构：也称为重复结构，程序中反复执行的一组指令或程序段 循环体：被反复执行的程序段 循环变量：用来控制循环是否继续进行的变量 常见的循环结构有三种，为for循环，while循环，以及do while循环。 ","date":"2022-01-16","objectID":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/:1:0","series":null,"tags":["C++","流程图","循环"],"title":"流程图 - 循环","uri":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"for循环 循环执行步骤： 第一，先进行循环控制变量初始化； 第二，执行循环终止条件，如果判断结果为真，则进入第三步；如果为假则循环终止并退出； 第三，执行循环体； 第四，执行循环控制变量增量，转入第二步。 对应的流程图如下图所示： 上面的描述可能太抽象，为方便大家理解，以“求1到100的和”为例作进一步说明： ","date":"2022-01-16","objectID":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/:2:0","series":null,"tags":["C++","流程图","循环"],"title":"流程图 - 循环","uri":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"while循环 循环执行步骤： 第一，先进行循环控制变量初始化（在while之前）； 第二，判断循环终止条件，如果判断结果为真，则进入第三步；如果为假则不执行循环体； 第三，执行循环体； 第四，执行循环控制变量增量，转入第二步。 对应的流程图如下图所示： 同样以“求1到100的和”为例作进一步说明： ","date":"2022-01-16","objectID":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/:3:0","series":null,"tags":["C++","流程图","循环"],"title":"流程图 - 循环","uri":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"do while循环 循环执行步骤： 第一，先进行循环控制变量初始化（在do while之前）； 第二，执行循环体； 第三，执行循环控制变量增量； 第四，判断循环终止条件，如果判断结果为真，则返回第二步；如果为假则直接退出循环。 对应的流程图如下图所示： 同样以“求1到100的和”为例作进一步说明： 简单来说，while循环和for循环都是先判断表达式，后执行循环体（本质上没太大差别）；而do while循环是先执行循环体后判断表达式。 以上示例图均由亿图图示绘制而成，感兴趣可以体验下▼ \u003e»一键下载 亿图图示 PC版 \u003e»一键体验 亿图图示 在线版 ","date":"2022-01-16","objectID":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/:4:0","series":null,"tags":["C++","流程图","循环"],"title":"流程图 - 循环","uri":"/2022/01/%E6%B5%81%E7%A8%8B%E5%9B%BE-%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"读取整型值 (返回值为从ini配置中读到的整数) UINT GetPrivateProfileInt( LPCTSTR lpAppName, // INI文件中的一个字段名[节名]可以有很多个节名 LPCTSTR lpKeyName, // lpAppName 下的一个键名，也就是里面具体的变量名 INT nDefault, // 如果没有找到指定的数据返回,则把个变量值赋给返回值 LPCTSTR lpFileName // INI文件的路径 ); //实例 int a = GetPrivateProfileInt(_T(\"Global0\"), _T(\"角色\"), 888, _T(\"d:/cfg.ini\")); ","date":"2022-01-13","objectID":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/:1:0","series":null,"tags":["C++"],"title":"ini文件读写","uri":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"读取字符串 （返回值为string的长度(long型),而从ini文件获得的字符串则保留在目的缓冲器中） DWORD GetPrivateProfileString( LPCTSTR lpAppName, // INI文件中的一个字段名[节名]可以有很多个节名（配置文件的section名） LPCTSTR lpKeyName, // lpAppName 下的一个键名，也就是里面具体的变量名（配置文件的key名） LPCTSTR lpDefault, // 如果lpReturnedString为空,则把这个变量赋给lpReturnedString LPTSTR lpReturnedString, // 存放键值的指针变量,用于接收INI文件中键值(数据)的接收缓冲区 DWORD nSize, // lpReturnedString的缓冲区大小 LPCTSTR lpFileName // INI文件的路径 ); //实例 LPTSTR LiMingSex = new WCHAR[6]; GetPrivateProfileString(_T(\"Global0\"), _T(\"组队标志\"), _T(\"\"), LiMingSex, 6, _T(\"d:/cfg.ini\")); ","date":"2022-01-13","objectID":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/:2:0","series":null,"tags":["C++"],"title":"ini文件读写","uri":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"写入字符串 （返回值类型为Long，非零表示成功，零表示失败。会设置GetLastError） BOOL WritePrivateProfileString( LPCTSTR lpAppName, // INI文件中的一个字段名[节名]可以有很多个节名 LPCTSTR lpKeyName, // lpAppName 下的一个键名，也就是里面具体的变量名 LPCTSTR lpString, // 键值,也就是数据 LPCTSTR lpFileName // INI文件的路径 ); //实例 WritePrivateProfileString(_T(\"Global0\"), _T(\"角色1\"), _T(\"888\"), _T(\"d:/cfg.ini\")); ","date":"2022-01-13","objectID":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/:3:0","series":null,"tags":["C++"],"title":"ini文件读写","uri":"/2022/01/ini%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"CreateThread m_AcountManageThread = CreateThread(NULL, NULL, ThreadProc, this, 0, NULL);//创建线程 ","date":"2022-01-11","objectID":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++","多线程"],"title":"多线程","uri":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"AfxBeginThread (MFC专用) //创建线程 大漠的DMInitThread AfxBeginThread(DMInitThread, this, THREAD_PRIORITY_NORMAL, 0, 0, NULL); ","date":"2022-01-11","objectID":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++","多线程"],"title":"多线程","uri":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"_beginthreadex m_hThreadHandle = (HANDLE)::_beginthreadex(NULL, 0, ThreadFunction, this, 0, \u0026m_uThreadID); //创建线程 ","date":"2022-01-11","objectID":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++","多线程"],"title":"多线程","uri":"/2022/01/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"目录 服务端升级为select模型 Socket的select模型 客户端转为Select模型 ","date":"2022-01-08","objectID":"/2022/01/c-select%E5%88%86%E6%9E%901/:1:0","series":null,"tags":["C++"],"title":"C++ select分析1","uri":"/2022/01/c-select%E5%88%86%E6%9E%901/"},{"categories":["C++"],"content":"服务端升级为select模型 ","date":"2022-01-08","objectID":"/2022/01/c-select%E5%88%86%E6%9E%901/:2:0","series":null,"tags":["C++"],"title":"C++ select分析1","uri":"/2022/01/c-select%E5%88%86%E6%9E%901/"},{"categories":["C++"],"content":"Socket的select模型 select( _In_ int nfds, _Inout_opt_ fd_set FAR * readfds, _Inout_opt_ fd_set FAR * writefds, _Inout_opt_ fd_set FAR * exceptfds, _In_opt_ const struct timeval FAR * timeout ); fd_set typedef struct fd_set { u_int fd_count; /* how many are SET? */ SOCKET fd_array[FD_SETSIZE]; /* an array of SOCKETs */ } fd_set; FD_ZERO #define FD_ZERO(set) (((fd_set FAR *)(set))-\u003efd_count=0) 【核心代码】 fd_set fdRead; fd_set fdWrite; fd_set fdExp; //清空集合 FD_ZERO(\u0026fdRead); FD_ZERO(\u0026fdWrite); FD_ZERO(\u0026fdExp); //将socket加入集合 FD_SET(sock, \u0026fdRead); FD_SET(sock, \u0026fdWrite); FD_SET(sock, \u0026fdExp); //将存的通信符加入集合 for (size_t i = 0; i \u003c g_clients.size(); i++) { FD_SET(g_clients[i], \u0026fdRead); } //将select设置为非阻塞模式 timeval timeout = { 0,0 }; //使用select int ret = select(sock + 1, \u0026fdRead, \u0026fdWrite, \u0026fdExp, \u0026timeout); if (ret \u003c 0) { printf(\"客户端已退出，任务结束\\n\"); break; } if (FD_ISSET(sock, \u0026fdRead)) { FD_CLR(sock, \u0026fdRead); //4.accept 接收客户端连接 sockaddr_in clientAddr = {}; int clAddrLen = sizeof(sockaddr_in); SOCKET sockAccpt = INVALID_SOCKET; sockAccpt = accept(sock, (sockaddr*)\u0026clientAddr, \u0026clAddrLen); if (INVALID_SOCKET == sockAccpt) { printf(\"Accept Error\\n\"); } else { printf(\"Accept Success\\n\"); } printf(\"新客户端加入：Socket = %d,IP = %s \\n\", (int)sockAccpt, inet_ntoa(clientAddr.sin_addr)); //将新加入的通信文件描述符加入 g_clients.push_back(sockAccpt); } //处理集合中的文件描述符对应的通信信息 for (size_t i = 0; i \u003cfdRead.fd_count ; i++) { int ret = Processor(fdRead.fd_array[i]); if (-1 == ret) { //出现错误，从动态数组中删除 auto iter = find(g_clients.begin(), g_clients.end(), fdRead.fd_array[i]); if (iter != g_clients.end()) { g_clients.erase(iter); } } } 【完整代码】 #define WIN32_LEAN_AND_MEAN #define _WINSOCK_DEPRECATED_NO_WARNINGS #include \u003cwindows.h\u003e #include \u003cWinSock2.h\u003e #include \u003ccstdio\u003e #include \u003cvector\u003e #pragma comment(lib,\"ws2_32.lib\") enum CMD //命令枚举 { CMD_LOGIN, CMD_LOGIN_RESULT, CMD_LOGOUT, CMD_LOGOUT_RESULT, CMD_NEW_USER_JOIN, CMD_ERROR }; //DataHeader struct DataHeader //数据包头 { short dataLength; short cmd; }; //DataPackage struct Login:public DataHeader //登录 { Login() { dataLength = sizeof(Login); cmd = CMD_LOGIN; } char UserName[32]{}; char PassWord[32]{}; }; struct LoginResult : public DataHeader //登录结果 { LoginResult() { dataLength = sizeof(LoginResult); cmd = CMD_LOGIN_RESULT; lgResult = 0; } int lgResult; }; struct LogOut :public DataHeader //退出登录 { LogOut() { dataLength = sizeof(LogOut); cmd = CMD_LOGOUT; } char UserName[32]{}; }; struct LogOutResult :public DataHeader //退出结果 { LogOutResult() { dataLength = sizeof(LogOutResult); cmd = CMD_LOGOUT_RESULT; lgOutResult = 0; } int lgOutResult; }; struct NewUserJoin :public DataHeader //新加入用户 { NewUserJoin() { dataLength = sizeof(NewUserJoin); cmd = CMD_NEW_USER_JOIN; sockID = 0; } int sockID; }; std::vector\u003cSOCKET\u003e g_clients; int Processor(SOCKET sockAccpt) {//缓冲区 char szRecv[1024] = {}; //读取包头数据 int nLen = recv(sockAccpt, (char*)\u0026szRecv, sizeof(DataHeader), 0); DataHeader* dbHeader = (DataHeader*)szRecv; if (nLen \u003c 0) { printf(\"客户端\u003c%d\u003e已退出，任务结束\\n\", sockAccpt); return -1; } //if(nLen \u003e= sizeof(DataHeader)) switch (dbHeader-\u003ecmd) { case CMD_LOGIN: { recv(sockAccpt, szRecv + sizeof(DataHeader), dbHeader-\u003edataLength - sizeof(DataHeader), 0); Login* login = (Login*)szRecv; printf(\"收到客户端\u003cSocket%d\u003e请求：CMD_LOGIN ，数据长度： %d, UserName = %s, \\ PassWord = %s \\n\", sockAccpt, login-\u003edataLength, login-\u003eUserName, login-\u003ePassWord); //忽略对用户密码进行判断 LoginResult lgRet = {}; send(sockAccpt, (char*)\u0026lgRet, sizeof(LoginResult), 0); } break; case CMD_LOGOUT: { recv(sockAccpt, szRecv + sizeof(DataHeader), dbHeader-\u003edataLength - sizeof(DataHeader), 0); LogOut* logout = (LogOut*)szRecv; printf(\"收到客户端\u003cSocket%d\u003e请求：CMD_LOGOUT ，数据长度： %d, UserName = %s, \\ \\n\", sockAccpt, logout-\u003edataLength, logout-\u003eUserName); //忽略对用户密码进行判断 LogOutResult lgOutRet = {}; send(sockAccpt, (char*)\u0026lgOutRet, sizeof(LogOutResult), 0); } break; default: DataHeader HeaderError = { 0, CMD_ERROR }; send(sockAccpt, (char*)\u0026HeaderError, sizeof(HeaderError), 0); break; } } int main() { WORD ver = MAKEWORD(2, 2); W","date":"2022-01-08","objectID":"/2022/01/c-select%E5%88%86%E6%9E%901/:3:0","series":null,"tags":["C++"],"title":"C++ select分析1","uri":"/2022/01/c-select%E5%88%86%E6%9E%901/"},{"categories":["C++"],"content":"客户端转为Select模型 【主要代码】 fd_set fdRead; //清空集合 FD_ZERO(\u0026fdRead); //将socket加入集合 FD_SET(sockCli, \u0026fdRead); //将select设置为非阻塞模式 timeval timeout = { 0,0 }; //使用select int ret = select(sockCli + 1, \u0026fdRead, NULL, NULL, \u0026timeout); if (ret \u003c 0) { printf(\"select任务结束\\n\"); break; } if (FD_ISSET(sockCli, \u0026fdRead)) { FD_CLR(sockCli, \u0026fdRead); if (-1 == Processor(sockCli)) { printf(\"select任务结束2\\n\"); break; } } 【客户端源码】 #define WIN32_LEAN_AND_MEAN #define _WINSOCK_DEPRECATED_NO_WARNINGS #define _CRT_SECURE_NO_WARNINGS #include \u003cwindows.h\u003e #include \u003cWinSock2.h\u003e #include \u003ccstdio\u003e #pragma comment(lib,\"ws2_32.lib\") enum CMD //命令枚举 { CMD_LOGIN, CMD_LOGIN_RESULT, CMD_LOGOUT, CMD_LOGOUT_RESULT, CMD_NEW_USER_JOIN, CMD_ERROR }; //DataHeader struct DataHeader //数据包头 { short dataLength; short cmd; }; //DataPackage struct Login :public DataHeader //登录 { Login() { dataLength = sizeof(Login); cmd = CMD_LOGIN; } char UserName[32]{}; char PassWord[32]{}; }; struct LoginResult : public DataHeader //登录结果 { LoginResult() { dataLength = sizeof(LoginResult); cmd = CMD_LOGIN_RESULT; lgResult = 0; } int lgResult; }; struct LogOut :public DataHeader //退出登录 { LogOut() { dataLength = sizeof(LogOut); cmd = CMD_LOGOUT; } char UserName[32]{}; }; struct LogOutResult :public DataHeader //退出结果 { LogOutResult() { dataLength = sizeof(LogOutResult); cmd = CMD_LOGOUT_RESULT; lgOutResult = 0; } int lgOutResult; }; struct NewUserJoin :public DataHeader //新加入用户 { NewUserJoin() { dataLength = sizeof(NewUserJoin); cmd = CMD_NEW_USER_JOIN; sockID = 0; } int sockID; }; int Processor(SOCKET sockAccpt) {//缓冲区 char szRecv[1024] = {}; //读取包头数据 int nLen = recv(sockAccpt, (char*)\u0026szRecv, sizeof(DataHeader), 0); DataHeader* dbHeader = (DataHeader*)szRecv; if (nLen \u003c 0) { printf(\"与服务断开，任务结束\\n\"); return -1; } //if(nLen \u003e= sizeof(DataHeader)) switch (dbHeader-\u003ecmd) { case CMD_LOGIN: { recv(sockAccpt, szRecv + sizeof(DataHeader), dbHeader-\u003edataLength - sizeof(DataHeader), 0); Login* login = (Login*)szRecv; printf(\"收到服务端返回数据：CMD_LOGIN ，数据长度： %d,\\n\", dbHeader-\u003edataLength); } break; case CMD_LOGOUT: { recv(sockAccpt, szRecv + sizeof(DataHeader), dbHeader-\u003edataLength - sizeof(DataHeader), 0); LogOut* logout = (LogOut*)szRecv; printf(\"收到服务端返回数据：CMD_LOGOUT ，数据长度： %d \\n\", dbHeader-\u003edataLength); } break; case CMD_NEW_USER_JOIN: { recv(sockAccpt, szRecv + sizeof(DataHeader), dbHeader-\u003edataLength - sizeof(DataHeader), 0); NewUserJoin* newJoin = (NewUserJoin*)szRecv; printf(\"收到服务端返回数据：CMD_NEW_USER_JOIN ，数据长度： %d \\n\", dbHeader-\u003edataLength); } break; default: break; } } int main() { WORD ver = MAKEWORD(2, 2); WSAData dat; WSAStartup(ver, \u0026dat); //1.建立一个socket SOCKET sockCli = socket(AF_INET, SOCK_STREAM, 0); if (INVALID_SOCKET == sockCli) { printf(\"Socket Error\\n\"); } else { printf(\"Socket Success\\n\"); } //2. connect连接服务器 sockaddr_in servAddr = {}; servAddr.sin_family = AF_INET; servAddr.sin_port = htons(5678); servAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); int ret = connect(sockCli, (sockaddr*)\u0026servAddr, sizeof(sockaddr_in)); if (SOCKET_ERROR == ret) { printf(\"Connect Error\\n\"); } else { printf(\"Connect Success\\n\"); } while (true) { fd_set fdRead; //清空集合 FD_ZERO(\u0026fdRead); //将socket加入集合 FD_SET(sockCli, \u0026fdRead); //将select设置为非阻塞模式 timeval timeout = { 0,0 }; //使用select int ret = select(sockCli + 1, \u0026fdRead, NULL, NULL, \u0026timeout); if (ret \u003c 0) { printf(\"select任务结束\\n\"); break; } if (FD_ISSET(sockCli, \u0026fdRead)) { FD_CLR(sockCli, \u0026fdRead); if (-1 == Processor(sockCli)) { printf(\"select任务结束2\\n\"); break; } } printf(\"空闲时间，处理其他业务\\n\"); Login lgin{}; strcpy(lgin.UserName, \"喜羊羊\"); strcpy(lgin.PassWord, \"123456\"); send(sockCli, (const char*)\u0026lgin, sizeof(Login), 0); Sleep(1000); } //7.关闭套接字 closesocket closesocket(sockCli); WSACleanup(); printf(\"结束任务\\n\"); getchar(); return 0; } ","date":"2022-01-08","objectID":"/2022/01/c-select%E5%88%86%E6%9E%901/:4:0","series":null,"tags":["C++"],"title":"C++ select分析1","uri":"/2022/01/c-select%E5%88%86%E6%9E%901/"},{"categories":["C++"],"content":"对象的内存中包含了成员变量，不同的对象占用不同的内存，这使得不同对象的成员变量相互独立，它们的值不受其他对象的影响。例如有两个相同类型的对象 a、b，它们都有一个成员变量 m_name，那么修改 a.m_name 的值不会影响 b.m_name 的值。 可是有时候我们希望在多个对象之间共享数据，对象 a 改变了某份数据后对象 b 可以检测到。共享数据的典型使用场景是计数，以前面的 Student 类为例，如果我们想知道班级中共有多少名学生，就可以设置一份共享的变量，每次创建对象时让该变量加 1。 在C++中，我们可以使用静态成员变量来实现多个对象共享数据的目标。静态成员变量是一种特殊的成员变量，它被关键字static修饰，例如： class Student{ public: Student(char *name, int age, float score); void show(); public: static int m_total; //静态成员变量 private: char *m_name; int m_age; float m_score; }; 这段代码声明了一个静态成员变量 m_total，用来统计学生的人数。 static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象。 static 成员变量必须在类声明的外部初始化，具体形式为： type class::name = value; type 是变量的类型，class 是类名，name 是变量名，value 是初始值。将上面的 m_total 初始化： int Student::m_total = 0; 静态成员变量在初始化时不能再加 static，但必须要有数据类型。被 private、protected、public 修饰的静态成员变量都可以用这种方式初始化。 注意：static 成员变量的内存既不是在声明类时分配，也不是在创建对象时分配，而是在（类外）初始化时分配。反过来说，没有在类外初始化的 static 成员变量不能使用。 static 成员变量既可以通过对象来访问，也可以通过类来访问。请看下面的例子： //通过类类访问 static 成员变量 Student::m_total = 10; //通过对象来访问 static 成员变量 Student stu(\"小明\", 15, 92.5f); stu.m_total = 20; //通过对象指针来访问 static 成员变量 Student *pstu = new Student(\"李华\", 16, 96); pstu -\u003e m_total = 20; 这三种方式是等效的。 **注意：static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问。**具体来说，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存，不了解的读者请阅读《C语言和内存》专题。 下面来看一个完整的例子： #include \u003ciostream\u003e using namespace std; class Student{ public: Student(char *name, int age, float score); void show(); private: static int m_total; //静态成员变量 private: char *m_name; int m_age; float m_score; }; //初始化静态成员变量 int Student::m_total = 0; Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ m_total++; //操作静态成员变量 } void Student::show(){ cout\u003c\u003cm_name\u003c\u003c\"的年龄是\"\u003c\u003cm_age\u003c\u003c\"，成绩是\"\u003c\u003cm_score\u003c\u003c\"（当前共有\"\u003c\u003cm_total\u003c\u003c\"名学生）\"\u003c\u003cendl; } int main(){ //创建匿名对象 (new Student(\"小明\", 15, 90)) -\u003e show(); (new Student(\"李磊\", 16, 80)) -\u003e show(); (new Student(\"张华\", 16, 99)) -\u003e show(); (new Student(\"王康\", 14, 60)) -\u003e show(); return 0; } 运行结果： 小明的年龄是15，成绩是90（当前共有1名学生） 李磊的年龄是16，成绩是80（当前共有2名学生） 张华的年龄是16，成绩是99（当前共有3名学生） 王康的年龄是14，成绩是60（当前共有4名学生） 本例中将 m_total 声明为静态成员变量，每次创建对象时，会调用构造函数使 m_total 的值加 1。 之所以使用匿名对象，是因为每次创建对象后只会使用它的 show() 函数，不再进行其他操作。不过使用匿名对象无法回收内存，会导致内存泄露，在中大型程序中不建议使用。 ","date":"2022-01-08","objectID":"/2022/01/c-static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/:0:0","series":null,"tags":["C++","static","静态成员变量"],"title":"C++ static静态成员变量","uri":"/2022/01/c-static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"},{"categories":["C++"],"content":"几点说明 一个类中可以有一个或多个静态成员变量，所有的对象都共享这些静态成员变量，都可以引用它。 static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。 静态成员变量必须初始化，而且只能在类体外进行。例如： int Student::m_total = 10; 初始化时可以赋初值，也可以不赋值。如果不赋值，那么会被默认初始化为 0。全局数据区的变量都有默认的初始值 0，而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。 静态成员变量既可以通过对象名访问，也可以通过类名访问，但要遵循 private、protected 和 public 关键字的访问权限限制。当通过对象名访问时，对于不同的对象，访问的是同一份内存。 ","date":"2022-01-08","objectID":"/2022/01/c-static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/:1:0","series":null,"tags":["C++","static","静态成员变量"],"title":"C++ static静态成员变量","uri":"/2022/01/c-static%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/"},{"categories":["C++"],"content":"C / C++ 计算程序运行的时间 在学数据结构过程中老师让查看不同算法的运行时间，然后让自己打印运行时间。 想要获取运行时间，计时函数是clock()，数据类型是clock_t，需要头文件是time.h。 也就是说计算一个程序的运行时间，需要获取运行起始时间和终止时间。 clock_t start,end; start = clock(); //需要测试运行时间的程序段 end = clock(); clock()函数： 得到从程序启动到此次函数调用时累计的毫秒数。end−start就是程序段的运行时间。输出即得到程序段调用时累计的毫秒数。 CLOCKS_PER_SEC是标准c的time.h头函数中宏定义的一个常数，表示一秒钟内CPU运行的时钟周期数，用于将clock()函数的结果转化为以秒为单位的量，但是这个量的具体值是与操作系统相关的。 cout\u003c\u003c(double)(end-start)/CLOCKS_PER_SEC; 例如： 写f(x)=∑i=1100x**i/i计算x=1.5时的值： #include\u003ciostream\u003e #include\u003ccmath\u003e #include\u003ctime.h\u003e using namespace std; void F1(double x) { double sum=0; for (int i=1; i\u003c=100; i++) sum += pow(x,i)/i; cout\u003c\u003c\"F1=\"\u003c\u003csum\u003c\u003cendl; } void F2(double x) { double sum=0; for (int i=100; i\u003e0; i--) sum = 1.0/i+sum*x; sum=sum*x; cout\u003c\u003c\"F2=\"\u003c\u003csum\u003c\u003cendl; } int main() { clock_t start,end; double x=1.5; start=clock(); F1(x); end=clock(); cout\u003c\u003c\"F1运行时间\"\u003c\u003c(double)(end-start)/CLOCKS_PER_SEC\u003c\u003cendl; start=clock(); F2(x); end=clock(); cout\u003c\u003c\"F2运行时间\"\u003c\u003c(double)(end-start)/CLOCKS_PER_SEC\u003c\u003cendl; return 0; } 运行结果为： F1=1.2454e+016 F1运行时间0.002 F2=1.2454e+016 F2运行时间0 写了几年的文章了我必须出来吐槽一下。 欢迎各位批评指正不是欢迎张口就来。 质疑可以，查明白了再说话。 CLOCKS_PER_SEC是标准c的time.h头函数中宏定义的一个常数，表示一秒钟内CPU运行的时钟周期数，用于将clock()函数的结果转化为以秒为单位的量，但是这个量的具体值是与操作系统相关的。 绝大多数情况下都是1000！你电脑输出的都是毫秒数！只有少部分情况在linux下是1000000，输出出来是微秒数。 ","date":"2022-01-08","objectID":"/2022/01/c-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4/:0:0","series":null,"tags":["C++"],"title":"C++ 计算程序运行的时间","uri":"/2022/01/c-%E8%AE%A1%E7%AE%97%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"C++ 一个简单的实现HTTP GET和POST请求的类 最近有个项目需要用到HTTP GET和POST请求，但是网上没有找到特别好用的类，就自己写了一个。 这个类除了实现了GET和POST请求，还有对Response中的头部分信息的简单处理。 ","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:1:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"主要参考 代码主要参考 [ C++ 实现 发送HTTP Get/Post请求 ]。 ","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:2:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"头文件 头文件很简单： /*! @file ********************************************************************** \u003cPRE\u003e 模块名 : 文件名 : HttpRequest.h 相关文件 : HttpRequest.cpp 文件实现功能 : Http 请求 作者 : Song 版本 : 1.0 ---------------------------------------------------------------------- 备注 : ---------------------------------------------------------------------- 修改记录 : 日 期 版本 修改人 修改内容 2018/4/10 1.0 Song 创建 \u003c/PRE\u003e ********************************************************************** * 版权所有(c) 2018-2019, 保留所有权利 *********************************************************************/ #pragma once #include \u003cstring\u003e #include \u003cvector\u003e class HttpRequest { public: HttpRequest(const std::string\u0026 ip, int port); ~HttpRequest(void); // Http GET请求 std::string HttpGet(std::string req); // Http POST请求 std::string HttpPost(std::string req, std::string data); // 合成JSON字符串 static std::string genJsonString(std::string key, int value); // 分割字符串 static std::vector\u003cstd::string\u003e split(const std::string \u0026s, const std::string \u0026seperator); // 根据key从Response获取Header中的内容 static std::string getHeader(std::string respose, std::string key); private: std::string m_ip; int m_port; }; ","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:3:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"CPP文件 CPP文件： /*! @file ********************************************************************** \u003cPRE\u003e 模块名 : 文件名 : HttpRequest.cpp 相关文件 : HttpRequest.h 文件实现功能 : Http 请求 作者 : Song 版本 : 1.0 ---------------------------------------------------------------------- 备注 : ---------------------------------------------------------------------- 修改记录 : 日 期 版本 修改人 修改内容 2018/4/10 1.0 Song 创建 \u003c/PRE\u003e ********************************************************************** * 版权所有(c) 2018-2019, 保留所有权利 *********************************************************************/ #include \"HttpRequest.h\" #include \u003cWinSock.h\u003e #include \u003ciostream\u003e #pragma comment(lib, \"ws2_32.lib\") HttpRequest::HttpRequest(const std::string\u0026 ip, int port) : m_ip(ip), m_port(port) { } HttpRequest::~HttpRequest(void) { } // Http GET请求 std::string HttpRequest::HttpGet(std::string req) { std::string ret = \"\"; // 返回Http Response try { // 开始进行socket初始化 WSADATA wData; ::WSAStartup(MAKEWORD(2, 2), \u0026wData); SOCKET clientSocket = socket(AF_INET, 1, 0); struct sockaddr_in ServerAddr = {0}; ServerAddr.sin_addr.s_addr = inet_addr(m_ip.c_str()); ServerAddr.sin_port = htons(m_port); ServerAddr.sin_family = AF_INET; int errNo = connect(clientSocket, (sockaddr*)\u0026ServerAddr, sizeof(ServerAddr)); if(errNo == 0) { // \"GET /[req] HTTP/1.1\\r\\n\" // \"Connection:Keep-Alive\\r\\n\" // \"Accept-Encoding:gzip, deflate\\r\\n\" // \"Accept-Language:zh-CN,en,*\\r\\n\" // \"User-Agent:Mozilla/5.0\\r\\n\\r\\n\"; std::string strSend = \" HTTP/1.1\\r\\n\" \"Cookie:16888\\r\\n\\r\\n\"; strSend = \"GET \" + req + strSend; // 发送 errNo = send(clientSocket, strSend.c_str(), strSend.length(), 0); if(errNo \u003e 0) { //cout \u003c\u003c \"发送成功\" \u003c\u003c endl; } else { std::cout \u003c\u003c \"errNo:\" \u003c\u003c errNo \u003c\u003c std::endl; return ret; } // 接收 char bufRecv[3069] = {0}; errNo = recv(clientSocket, bufRecv, 3069, 0); if(errNo \u003e 0) { ret = bufRecv;// 如果接收成功，则返回接收的数据内容 } else { std::cout \u003c\u003c \"errNo:\" \u003c\u003c errNo \u003c\u003c std::endl; return ret; } } else { errNo = WSAGetLastError(); std::cout \u003c\u003c \"errNo:\" \u003c\u003c errNo \u003c\u003c std::endl; } // socket环境清理 ::WSACleanup(); } catch (...) { return \"\"; } return ret; } // Http POST请求 std::string HttpRequest::HttpPost(std::string req, std::string data) { std::string ret = \"\"; // 返回Http Response try { // 开始进行socket初始化; WSADATA wData; ::WSAStartup(MAKEWORD(2, 2), \u0026wData); SOCKET clientSocket = socket(AF_INET, 1, 0); struct sockaddr_in ServerAddr = {0}; ServerAddr.sin_addr.s_addr = inet_addr(m_ip.c_str()); ServerAddr.sin_port = htons(m_port); ServerAddr.sin_family = AF_INET; int errNo = connect(clientSocket, (sockaddr*)\u0026ServerAddr, sizeof(ServerAddr)); if(errNo == 0) { // 格式化data长度 char len[10] = {0}; sprintf(len, \"%d\", data.length()); std::string strLen = len; // \"POST /[req] HTTP/1.1\\r\\n\" // \"Connection:Keep-Alive\\r\\n\" // \"Accept-Encoding:gzip, deflate\\r\\n\" // \"Accept-Language:zh-CN,en,*\\r\\n\" // \"Content-Length:[len]\\r\\n\" // \"Content-Type:application/x-www-form-urlencoded; charset=UTF-8\\r\\n\" // \"User-Agent:Mozilla/5.0\\r\\n\\r\\n\" // \"[data]\\r\\n\\r\\n\"; std::string strSend = \" HTTP/1.1\\r\\n\" \"Cookie:16888\\r\\n\" \"Content-Type:application/x-www-form-urlencoded\\r\\n\" \"Charset:utf-8\\r\\n\" \"Content-Length:\"; strSend = \"POST \" + req + strSend + strLen + \"\\r\\n\\r\\n\" + data; // 发送 errNo = send(clientSocket, strSend.c_str(), strSend.length(), 0); if(errNo \u003e 0) { //cout\u003c\u003c\"发送成功\\n\"; } else { std::cout \u003c\u003c \"errNo:\" \u003c\u003c errNo \u003c\u003c std::endl; return ret; } // 接收 char bufRecv[3069] = {0}; errNo = recv(clientSocket, bufRecv, 3069, 0); if(errNo \u003e 0) { ret = bufRecv;// 如果接收成功，则返回接收的数据内容 } else { std::cout \u003c\u003c \"errNo:\" \u003c\u003c errNo \u003c\u003c std::endl; return ret; } } else { errNo = WSAGetLastError(); } // socket环境清理 ::WSACleanup(); } catch (...) { return \"\"; } return ret; } // 合成JSON字符串 std::string HttpRequest::genJsonString(std::string key, int value) { char buf[128] = {0}; sprintf(buf, \"{\\\"%s\\\":%d}\", key.c_str(), value); std::string ret = buf; return ret; } // 分割字符串 std::vector\u003cstd::string\u003e HttpRequest::split(const std::string \u0026s, const std::string \u0026seperator) { std::vector\u003cstd::string\u003e result; typedef std::str","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:4:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"使用方法 写了一个简单的控制台程序，用于测试： // test4HTTP.cpp : 定义控制台应用程序的入口点。 // #include \"HttpRequest.h\" #include \u003ciostream\u003e #include \u003cWindows.h\u003e int _tmain(int argc, _TCHAR* argv[]) { HttpRequest httpReq(\"192.168.10.100\", 8888); std::string res = httpReq.HttpGet(\"/getsomething/\"); std::cout \u003c\u003c res \u003c\u003c std::endl; Sleep(1000); res = httpReq.HttpPost(\"/postsomething/\", HttpRequest::genJsonString(\"something\", 100)); std::cout \u003c\u003c res \u003c\u003c std::endl; return 0; } ","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:5:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"几点说明 发送的字符串中，“GET”和“POST”一定要用大写字母，否则会出现出现HTTP 400 错误； POST请求如果有内容（std::string data不为空），“Content-Length”一定要有； 亲测可用； ","date":"2022-01-08","objectID":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/:6:0","series":null,"tags":["C++"],"title":"C++ 实现HTTP GET和POST","uri":"/2022/01/c-%E5%AE%9E%E7%8E%B0http-get%E5%92%8Cpost/"},{"categories":["C++"],"content":"C++:实现socket通信（TCP/IP）实例 ​ 首先声明，博主之前从来没有写过通信方面的东西，这次之所以写这个是因为项目需要，因此本文主要介绍一个使用C++语言及Socket来实现TCP/IP通信的实例，希望可以帮助入门者。 本教程，属于基础教程，针对入门者，如需更深入的功能，自行扩展； IP地址用于确定目标主机，端口号用于确定目标应用程序。 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:1:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"一、什么是TCP/IP？ ​ TCP提供基于IP环境下的数据可靠性传输，事先需要进行三次握手来确保数据传输的可靠性。详细的博主不再赘述，感兴趣的朋友可以去search一下。 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:2:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"二、什么是socket? ​ socket顾名思义就是套接字的意思，用于描述地址和端口，是一个通信链的句柄。应用程序通过socket向网络发出请求或者回应。 ​ socket编程有三种，流式套接字（SOCK_STREAM）,数据报套接字(SOCK_DGRAM),原始套接字(SOCK_RAW),前两者较常用。基于TCP的socket编程是流式套接字。 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:3:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"三、client/server即C/S模式： ​ TCP/IP通信中，主要是进行C/S交互。废话不多说，下面看看具体交互内容： ​ 服务端：建立socket，申明自身的port和IP，并绑定到socket，使用listen监听，然后不断用accept去查看是否有连接。如果有，捕获socket，并通过recv获取消息的内容，通信完成后调用closeSocket关闭这个对应accept到的socket。如果不需要等待任何客户端连接，那么用closeSocket直接关闭自身的socket。 ​ 客户端：建立socket，通过端口号和地址确定目标服务器，使用Connect连接到服务器，send发送消息，等待处理，通信完成后调用closeSocket关闭socket。 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:4:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"四、编程步骤 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:5:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"1、server端 （1）加载套接字库，创建套接字（WSAStartup()/socket()）; #include\u003cwinsock.h\u003e #pragma comment(lib,\"ws2_32.lib\") void initialization(); int main() { //创建套接字 s_server = socket(AF_INET, SOCK_STREAM, 0); } void initialization() { //初始化套接字库 WORD w_req = MAKEWORD(2, 2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req, \u0026wsadata); if (err != 0) { cout \u003c\u003c \"初始化套接字库失败！\" \u003c\u003c endl; } else { cout \u003c\u003c \"初始化套接字库成功！\" \u003c\u003c endl; } //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) { cout \u003c\u003c \"套接字库版本号不符！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"套接字库版本正确！\" \u003c\u003c endl; } //填充服务端地址信息 } （2）绑定套接字到一个IP地址和一个端口上（bind()）; server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(5010); （3）将套接字设置为监听模式等待连接请求（listen()）; //设置套接字为监听状态 if (listen(s_server, SOMAXCONN) \u003c 0) { cout \u003c\u003c \"设置监听状态失败！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"设置监听状态成功！\" \u003c\u003c endl; } cout \u003c\u003c \"服务端正在监听连接，请稍候....\" \u003c\u003c endl; （4）请求到来后，接受连接请求，返回一个新的对应于此次连接的套接字（accept()）; //接受连接请求 len = sizeof(SOCKADDR); s_accept = accept(s_server, (SOCKADDR *)\u0026accept_addr, \u0026len); if (s_accept == SOCKET_ERROR) { cout \u003c\u003c \"连接失败！\" \u003c\u003c endl; WSACleanup(); return 0; } cout \u003c\u003c \"连接建立，准备接受数据\" \u003c\u003c endl; （5）用返回的套接字和客户端进行通信（send()/recv()）; //接收数据 while (1) { recv_len = recv(s_accept, recv_buf, 100, 0); if (recv_len \u003c 0) { cout \u003c\u003c \"接受失败！\" \u003c\u003c endl; break; } else { cout \u003c\u003c \"客户端信息:\" \u003c\u003c recv_buf \u003c\u003c endl; } cout \u003c\u003c \"请输入回复信息:\"; cin \u003e\u003e send_buf; send_len = send(s_accept, send_buf, 100, 0); if (send_len \u003c 0) { cout \u003c\u003c \"发送失败！\" \u003c\u003c endl; break; } } (6)返回，等待另一个连接请求； （7）关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()); //关闭套接字 closesocket(s_server); closesocket(s_accept); //释放DLL资源 WSACleanup(); return 0; ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:5:1","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"2、Client端 （1）加载套接字库，创建套接字（WSAStartup()/socket）; #include\u003cwinsock.h\u003e #pragma comment(lib,\"ws2_32.lib\") void initialization(); int main() { //创建套接字 s_server = socket(AF_INET, SOCK_STREAM, 0); } void initialization() { //初始化套接字库 WORD w_req = MAKEWORD(2, 2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req, \u0026wsadata); if (err != 0) { cout \u003c\u003c \"初始化套接字库失败！\" \u003c\u003c endl; } else { cout \u003c\u003c \"初始化套接字库成功！\" \u003c\u003c endl; } //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) { cout \u003c\u003c \"套接字库版本号不符！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"套接字库版本正确！\" \u003c\u003c endl; } //填充服务端地址信息 } (2)向服务器发出连接请求（connect()）; if (connect(s_server, (SOCKADDR *)\u0026server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) { cout \u003c\u003c \"服务器连接失败！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"服务器连接成功！\" \u003c\u003c endl; } (3)和服务器进行通信（send()/recv()）; //发送,接收数据 while (1) { cout \u003c\u003c \"请输入发送信息:\"; cin \u003e\u003e send_buf; send_len = send(s_server, send_buf, 100, 0); if (send_len \u003c 0) { cout \u003c\u003c \"发送失败！\" \u003c\u003c endl; break; } recv_len = recv(s_server, recv_buf, 100, 0); if (recv_len \u003c 0) { cout \u003c\u003c \"接受失败！\" \u003c\u003c endl; break; } else { cout \u003c\u003c \"服务端信息:\" \u003c\u003c recv_buf \u003c\u003c endl; } } (4)关闭套接字，关闭加载的套接字库（closesocket()/WSACleanup()） //关闭套接字 closesocket(s_server); //释放DLL资源 WSACleanup(); ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:5:2","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"五、Windows下基于VS2017实现的socket简单实例（TCP/IP） ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:6:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"(1)server端代码 #include \"pch.h\" #include\u003ciostream\u003e #include\u003cwinsock.h\u003e #pragma comment(lib,\"ws2_32.lib\") using namespace std; void initialization(); int main() { //定义长度变量 int send_len = 0; int recv_len = 0; int len = 0; //定义发送缓冲区和接受缓冲区 char send_buf[100]; char recv_buf[100]; //定义服务端套接字，接受请求套接字 SOCKET s_server; SOCKET s_accept; //服务端地址客户端地址 SOCKADDR_IN server_addr; SOCKADDR_IN accept_addr; initialization(); //填充服务端信息 server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(5010); //创建套接字 s_server = socket(AF_INET, SOCK_STREAM, 0); if (bind(s_server, (SOCKADDR *)\u0026server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) { cout \u003c\u003c \"套接字绑定失败！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"套接字绑定成功！\" \u003c\u003c endl; } //设置套接字为监听状态 if (listen(s_server, SOMAXCONN) \u003c 0) { cout \u003c\u003c \"设置监听状态失败！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"设置监听状态成功！\" \u003c\u003c endl; } cout \u003c\u003c \"服务端正在监听连接，请稍候....\" \u003c\u003c endl; //接受连接请求 len = sizeof(SOCKADDR); s_accept = accept(s_server, (SOCKADDR *)\u0026accept_addr, \u0026len); if (s_accept == SOCKET_ERROR) { cout \u003c\u003c \"连接失败！\" \u003c\u003c endl; WSACleanup(); return 0; } cout \u003c\u003c \"连接建立，准备接受数据\" \u003c\u003c endl; //接收数据 while (1) { recv_len = recv(s_accept, recv_buf, 100, 0); if (recv_len \u003c 0) { cout \u003c\u003c \"接受失败！\" \u003c\u003c endl; break; } else { cout \u003c\u003c \"客户端信息:\" \u003c\u003c recv_buf \u003c\u003c endl; } cout \u003c\u003c \"请输入回复信息:\"; cin \u003e\u003e send_buf; send_len = send(s_accept, send_buf, 100, 0); if (send_len \u003c 0) { cout \u003c\u003c \"发送失败！\" \u003c\u003c endl; break; } } //关闭套接字 closesocket(s_server); closesocket(s_accept); //释放DLL资源 WSACleanup(); return 0; } void initialization() { //初始化套接字库 WORD w_req = MAKEWORD(2, 2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req, \u0026wsadata); if (err != 0) { cout \u003c\u003c \"初始化套接字库失败！\" \u003c\u003c endl; } else { cout \u003c\u003c \"初始化套接字库成功！\" \u003c\u003c endl; } //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) { cout \u003c\u003c \"套接字库版本号不符！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"套接字库版本正确！\" \u003c\u003c endl; } //填充服务端地址信息 } ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:6:1","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"（2）client端： #include \"pch.h\" #include\u003ciostream\u003e #include\u003cwinsock.h\u003e #pragma comment(lib,\"ws2_32.lib\") using namespace std; void initialization(); int main() { //定义长度变量 int send_len = 0; int recv_len = 0; //定义发送缓冲区和接受缓冲区 char send_buf[100]; char recv_buf[100]; //定义服务端套接字，接受请求套接字 SOCKET s_server; //服务端地址客户端地址 SOCKADDR_IN server_addr; initialization(); //填充服务端信息 server_addr.sin_family = AF_INET; server_addr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); server_addr.sin_port = htons(1234); //创建套接字 s_server = socket(AF_INET, SOCK_STREAM, 0); if (connect(s_server, (SOCKADDR *)\u0026server_addr, sizeof(SOCKADDR)) == SOCKET_ERROR) { cout \u003c\u003c \"服务器连接失败！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"服务器连接成功！\" \u003c\u003c endl; } //发送,接收数据 while (1) { cout \u003c\u003c \"请输入发送信息:\"; cin \u003e\u003e send_buf; send_len = send(s_server, send_buf, 100, 0); if (send_len \u003c 0) { cout \u003c\u003c \"发送失败！\" \u003c\u003c endl; break; } recv_len = recv(s_server, recv_buf, 100, 0); if (recv_len \u003c 0) { cout \u003c\u003c \"接受失败！\" \u003c\u003c endl; break; } else { cout \u003c\u003c \"服务端信息:\" \u003c\u003c recv_buf \u003c\u003c endl; } } //关闭套接字 closesocket(s_server); //释放DLL资源 WSACleanup(); return 0; } void initialization() { //初始化套接字库 WORD w_req = MAKEWORD(2, 2);//版本号 WSADATA wsadata; int err; err = WSAStartup(w_req, \u0026wsadata); if (err != 0) { cout \u003c\u003c \"初始化套接字库失败！\" \u003c\u003c endl; } else { cout \u003c\u003c \"初始化套接字库成功！\" \u003c\u003c endl; } //检测版本号 if (LOBYTE(wsadata.wVersion) != 2 || HIBYTE(wsadata.wHighVersion) != 2) { cout \u003c\u003c \"套接字库版本号不符！\" \u003c\u003c endl; WSACleanup(); } else { cout \u003c\u003c \"套接字库版本正确！\" \u003c\u003c endl; } //填充服务端地址信息 } 注：对于入门级别学习的同学一些使用指导，想要让这俩程序跑起来，如果只有一台电脑，那么只需要在一台电脑上VS中创建两个不同的控制台应用程序，然后把server和client代码分别copy到这俩新建项目的主程序中，直接运行即可。 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:6:2","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"六、运行结果显示 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:7:0","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"（1）server端 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:7:1","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"（2）client端 ","date":"2022-01-08","objectID":"/2022/01/c-socket%E7%94%A8%E6%B3%951/:7:2","series":null,"tags":["C++"],"title":"C++实现socket通信(TCP IP)","uri":"/2022/01/c-socket%E7%94%A8%E6%B3%951/"},{"categories":["C++"],"content":"函数 ","date":"2022-01-08","objectID":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:1:0","series":null,"tags":["C++"],"title":"C++知识点(三)","uri":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"bzero()函数 bzero() 会将内存块（字符串）的前n个字节清零;在网络编程中会经常用到; #include \u003cstring.h\u003e void bzero( void *s, //s为内存（字符串）指针 int n //n 为需要清零的字节数 ); ","date":"2022-01-08","objectID":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:1:1","series":null,"tags":["C++"],"title":"C++知识点(三)","uri":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":["C++"],"content":"setsockopt()函数 引用 setsockopt()函数用于任意类型、任意状态套接口的设置选项值。 #include \u003csys/socket.h\u003e int setsockopt( int socket, //socket是套接字描述符 int level, //设置的选项的级别 int option_name, const void *option_value, size_t ，ption_len ); ","date":"2022-01-08","objectID":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/:1:2","series":null,"tags":["C++"],"title":"C++知识点(三)","uri":"/2022/01/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%89/"},{"categories":null,"content":"我们接着上文继续,如果没有看上文基础的同学建议先看完上文再继续本文章 本文章中均以单机游戏为例,每一种功能仅提供给网络安全工作者反外挂建议和安全对抗方法.请勿用作非法用途 另外提示对于此类游戏安全和反外挂研究,单机和网络游戏的原理毫无区别,区别仅仅在于个别数据网络验证部分 先整理cs1.6数据如下: (属于基础范畴,任鸟飞2020前80课即可轻松搞定这里不赘述) 矩阵地址 hl.exe+1820100//这个暂时先不要管,下文会有详细讲解的地方 高低朝向值 hl.exe+19E10C4 //从低到高 89 到 -89 水平朝向值 hl.exe+19E10C8 // 逆时针 从 0 到 360 朝向值找到以后我们发现水平转一圈 是0-360的变化规律 其中朝向算法需要我们详细分析一下 方法很简单, 把朝向写入0 然后W走路 看看坐标的变化规律发现是X增加其他不变,那么0对应X正轴 把朝向写入90 然后W走路 看看坐标的变化规律发现是Y增加其他不变,那么0对应Y正轴 把朝向写入180 然后W走路 看看坐标的变化规律发现是X减少其他不变,那么0对应X负轴 把朝向写入270 然后W走路 看看坐标的变化规律发现是Y减少其他不变,那么0对应Y负轴 最终得到结果 也就是我们不同朝向的值 人物X坐标:hl.exe+195fe58 人物Y坐标:hl.exe+195fe5C 人物Z坐标:hl.exe+195fe60 周围数组 数组最大数量1F 以下n 通用 0为自己 hl.exe+1B5A5C4+24C*n+0 等于0 数组结束 hl.exe+1B5A5C4+24C*n+190 DWORD ==0 跳过 有可能数组不是顺序存放 对象X坐标 hl.exe+1B5A5C4+24C*n+18C 对象Y坐标 hl.exe+1B5A5C4+24C*n+18C 对象Z坐标 hl.exe+1B5A5C4+24C*n+190 1为土匪 2为警察 hl.exe+62565C+n*68+4E 血量 hl.exe+62565C+n*68+68 死亡标志位 hl.exe+62565C+n*68+60 得到的结果 就可以提供给我们封装数据所用了,这已经足够了 说到这, 我们来聊聊为什么FPS类型的游戏安全性及不高 和 反外挂 主要的2个原因 第一设计简单,数据少,通过上面的需要数据就已经知道了,真的很少 第二个原因是特性导致,透视和自瞄等功能都是服务器无法验证的本地操作 所以加大了反外挂的难度. 那么其实针对于FPS的外挂特征,反外挂可以做的事情也是不少的 第一,加大对周围数据的保护,尤其获取范围,不要在极大范围就像玩家投递全地图数据 第二,对hookd3d的检测应该是比较容易的 第三,对绘制函数的检测,当然如果是窗口的覆盖窗口那是存在一定检测难度的 第四,自瞄准星的数据写入检测 第五,鼠标准星移动轨迹的检测 第六,不定时截图上传 等等 封装数据 封装代码如下,因为这里我都使用了中文命名 相信大家都可以看懂了,如果有什么不懂可以 ,可以找我探讨 struct 朝向结构_2 { float 水平朝向; float 高低朝向; }; struct 对象结构 { float X_j; float Y_j; float Z_j; float X_H; float Y_H; float Z_H; int Hp; BYTE 死亡标志位; BYTE 阵营; 朝向结构_2 角度_j; 朝向结构_2 角度_H; 朝向结构_2 角度差_j; 朝向结构_2 角度差_H; }; class 周围对象 { public: 对象结构 对象列表[0x100]; DWORD 对象数量; public: void 刷新周围数据_Cs(); private: void 计算朝向_Cs(坐标结构_3 目标, 朝向结构_2\u0026 角度, 朝向结构_2\u0026 角度差); }; DWORD Cs_周围基地址 = (DWORD)GetModuleHandleA(“hl.exe”) + 0x1B5A5C4; DWORD Cs_周围基地址2 = (DWORD)GetModuleHandleA(“hl.exe”) + 0x62565C; void 周围对象::刷新周围数据_Cs() { 对象数量 = 0; for (int i = 1; i \u003c 0x20; i++)// 第一个位置空出来 { if ((DWORD)(Cs_周围基地址 + 0x24C * i + 0) == 0)// 直接结束 { break; } if ((DWORD)(Cs_周围基地址 + 0x24C * i + 0x190) == 0)// 碰到空坐标对象 跳过 { continue; } //哪里不懂可以2217777779 探讨 对象列表[对象数量].X_j = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x188); 对象列表[对象数量].Y_j = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x18C); 对象列表[对象数量].Z_j = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x190) - 40; 对象列表[对象数量].X_H = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x188); 对象列表[对象数量].Y_H = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x18C); 对象列表[对象数量].Z_H = (FLOAT)(Cs_周围基地址 + 0x24C * i + 0x190) + 23; 对象列表[对象数量].阵营 = (BYTE)(Cs_周围基地址2 + 0x68 * i + 0x4E); 对象列表[对象数量].Hp = (DWORD)(Cs_周围基地址2 + 0x68 * i + 0x68); 对象列表[对象数量].死亡标志位 = (BYTE) * (DWORD*)(Cs_周围基地址2 + 0x68 * i + 0x60); 坐标结构_3 目标; 朝向结构_2 角度; 朝向结构_2 角度差; 目标.x = 对象列表[对象数量].X_j; 目标.y = 对象列表[对象数量].Y_j; 目标.z = 对象列表[对象数量].Z_j; 计算朝向_Cs(目标, 角度, 角度差); 对象列表[对象数量].角度_j = 角度; 对象列表[对象数量].角度差_j = 角度差; 目标.x = 对象列表[对象数量].X_H; 目标.y = 对象列表[对象数量].Y_H; 目标.z = 对象列表[对象数量].Z_H; 计算朝向_Cs(目标, 角度, 角度差); 对象列表[对象数量].角度_H = 角度; 对象列表[对象数量].角度差_H = 角度差; 对象数量 += 1; } } 朝向值 和角度差的计算过程,根据上面已经得到的朝向数据 我们编写如下代码,为了让理解更简单 这里我分成了4个象限来讲解 如果还是不能完全理解的话,建议翻看我们之前的 关于朝向的课程,当然朝向 有很多种 这里属于最简单的一种 大家可能问算出来的角度差是干什么用的,还记得上篇文章,不用矩阵转换屏幕坐标吗,里面我们是需要用到这个角度差的 void 周围对象::计算朝向_Cs(坐标结构_3 目标, 朝向结构_2\u0026 角度, 朝向结构_2\u0026 角度差) void 周围对象::计算朝向_Cs(坐标结构_3 目标, 朝向结构_2\u0026 角度, 朝向结构_2\u0026 角度差) { FLOAT FOV_x = (FLOAT)((DWORD)GetModuleHandleA(“hl.exe”) + 0x195fe58); FLOAT FOV_y = (FLOAT)((DWORD)GetModuleHandleA(“hl.exe”) + 0x195fe5C); FLOAT FOV_z = (FLOAT)((DWORD)GetModuleHandleA(“hl.exe”) + 0x195fe60); FLOAT 水平朝向 = (FLOAT)((DWORD)GetModuleHandleA(“hl.exe”) + 0x19E10C8); FLOAT 高低朝向 = (FLOAT)((DWORD)GetModuleHandleA(“hl.exe”) + 0x19E10C4); if (目标.x \u003e FOV_x \u0026\u0026 目标.y \u003e= FOV_y)//第一象限 { 角度.水平朝向 = (FLOAT)((double)atan2(目标.y - FOV_y, 目标.x - FOV_x) * 180 / 3.1415); } if (目标.x \u003c= FOV_x \u0026\u0026 目标.y \u003e FOV_y)//第二象限 { 角度.水平朝向 = 180 - (FLOAT)((double)atan2(目标.y - FOV_y, FOV_x - 目标.x) * 180 / 3.1415); } if (目标.x \u003c FOV_x \u0026\u0026 目标.y \u003c= FOV_y)//第三象限 { 角度.水平朝向 = 180 + (FLOAT)((double)atan2(FOV_y - 目标.y, FOV_x - 目标.x) * 180 / 3.1415); } if (目标.x \u003e= FOV_x \u0026\u0026 目标.y \u003c FOV_y)//第四象限 { 角度.水平朝向 = 360 - (FLOAT)((double)atan2(FOV_y - 目标.y, 目标.x - FOV_x) * 180 / 3.1415); } FLOAT 平面距离 = sqrt((目标.x - FOV_x) * (目","date":"2022-01-08","objectID":"/2022/01/fps%E9%AA%A8%E9%AA%BCu3due4%E4%BA%8C/:0:0","series":null,"tags":["飞郁精品帖"],"title":"FPS骨骼,u3d,UE4(二)","uri":"/2022/01/fps%E9%AA%A8%E9%AA%BCu3due4%E4%BA%8C/"},{"categories":["C++"],"content":"GitHub开源 https://github.com/Nomango/configor configor 一个为 C++11 量身打造的轻量级 config 库，轻松完成 JSON 解析和序列化功能，并和 C++ 输入输出流交互。 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:0","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"功能 仅头文件，低接入成本 STL-like，低学习成本 与标准库 io 交互 非侵入式的序列化与反序列化 Unicode与多编码支持（支持char、wchar_t、char16_t和char32_t） 可扩展的输入输出方式 注意：项目仍处于开发状态，可能有不兼容的修改。 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:1","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"关于更名！ 项目此前叫做 jsonxx，现已更名为 configor！ 在保证原有 API 可用的情况下，将在未来支持包括 JSON 在内的各种常见对象存储格式（如 YAML 等）。 如果您之前已经在使用 jsonxx，那么升级到 configor 将非常简单，只需要修改头文件的声明如下： // 替换掉注释中的头文件，改为使用下方的头文件即可 // #include \"jsonxx/json.hpp\" // using namespace jsonxx; #include \"configor/json.hpp\" using namespace configor; ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:2","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"目录 快速上手 取值方式 常用方法和运算符 序列化与反序列化 序列化 反序列化 Unicode与多编码支持 与自定义类型转换 示例代码 常见问题 更多 计划 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:3","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"快速上手 引入 configor 头文件 #include \"configor/json.hpp\" using namespace configor; 使用 C++ 的方式的创建 JSON 对象 使用 operator[] 为 JSON 对象赋值 json j; j[\"number\"] = 1; j[\"float\"] = 1.5; j[\"string\"] = \"this is a string\"; j[\"boolean\"] = true; j[\"user\"][\"id\"] = 10; j[\"user\"][\"name\"] = \"Nomango\"; 使用 std::initializer_list 为 JSON 对象赋值 // 使用初始化列表构造数组 json arr = { 1, 2, 3 }; // 使用初始化列表构造对象 json obj = { { \"user\", { { \"id\", 10 }, { \"name\", \"Nomango\" } } } }; // 第二个对象 json obj2 = { { \"nul\", nullptr }, { \"number\", 1 }, { \"float\", 1.3 }, { \"boolean\", false }, { \"string\", \"中文测试\" }, { \"array\", { 1, 2, true, 1.4 } }, { \"object\", { { \"key\", \"value\" }, { \"key2\", \"value2\" }, }}, }; 使用辅助方法构造数组或对象 json arr = json::array({ 1 }); json obj = json::object({ { \"user\", { { \"id\", 1 }, { \"name\", \"Nomango\" } } } }); ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:4","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"取值方式 判断 JSON 对象的值类型 // 判断 JSON 值类型 bool is_null(); bool is_bool(); bool is_integer(); bool is_float(); bool is_number(); // is_integer() || is_float() bool is_string(); bool is_array(); bool is_object(); JSON 对象的取值与类型转换 通过 get 函数可以直接取值： auto b = j.get\u003cbool\u003e(); // 仅当 j.is_bool() 时可用 auto i = j.get\u003cint\u003e(); // 仅当 j.is_integer() 时可用 auto i = j.get\u003cint64_t\u003e(); // 仅当 j.is_integer() 时可用 auto f = j.get\u003cfloat\u003e(); // 仅当 j.is_float() 时可用 auto d = j.get\u003cdouble\u003e(); // 仅当 j.is_float() 时可用 auto s = j.get\u003cstd::string\u003e(); // 仅当 j.is_string() 时可用 // 对于实现了 config_bind 的自定义数据类型，也可以直接取值 // 详情请参考下方 `JSON 与任意类型的转换` class MyObject; auto myObj = j.get\u003cMyObject\u003e(); 注意：get函数会强校验数据类型（例如整形和浮点数不能自动转换），参数类型与值类型不同时会引发 configor_type_error 异常。 同时 get 支持取出引用和指针类型： j.get\u003cconst std::string\u0026\u003e(); j.get\u003cstd::string\u0026\u003e(); j.get\u003cconst std::string*\u003e(); j.get\u003cstd::string*\u003e(); 通过有参数的 get 函数，可以传入对象引用来取值： int n = 0; if (j.get(n)) { // 成功读取到 n 的值 } else { // 读取 n 值失败 } 通过 as 系列函数可以将数据类型尽可能的转换： bool as_bool(); // 对bool直接返回，对数字类型判断是否非0，对null返回false，对其他类型返回empty() int64_t as_integer(); // 对数字类型直接返回，对bool类型强转，对其他类型抛出 double as_float(); // 对数字类型直接返回，对bool类型强转，对其他类型抛出 std::string as_string(); // 对字符串类型直接返回，对数字类型和bool转换为字符串，对null返回空串，对其他类型抛出 类型转换： // 显式转换 bool b = (bool)j[\"boolean\"]; int i = (int)j[\"number\"]; float d = (float)j[\"float\"]; // 对于实现了 config_bind 的自定义数据类型，也可以直接转换 // 详情请参考下方 `JSON 与任意类型的转换` class MyObject; MyObject myObj = (MyObject)j; MyObject myObj = j; ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:5","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"常用方法和运算符 size \u0026 empty \u0026 clear \u0026 count \u0026 … json arr = json::array({ 1, 2, 3 }); arr.size(); // 3 arr.empty(); // false arr.erase(0); // 第一个元素被删除 arr.clear(); json obj = json::object({ { \"one\", 1 }, { \"two\", 2 } }); obj.size(); // 2 obj.empty(); // false obj.count(\"one\"); // 1 obj.count(\"missing\"); // 0 obj.erase(\"one\"); // one 被删除 obj.clear(); 比较运算符 j[\"boolean\"] == true j[\"number\"] == 1 j[\"number\"] != 2 j[\"number\"] \u003e 0 j[\"float\"] \u003c 3 JSON 对象类型和数组类型的遍历 // 增强 for 循环 for (auto\u0026 j : obj) { std::cout \u003c\u003c j \u003c\u003c std::endl; } // 使用迭代器遍历 for (auto iter = obj.begin(); iter != obj.end(); iter++) { std::cout \u003c\u003c iter.key() \u003c\u003c \":\" \u003c\u003c iter.value() \u003c\u003c std::endl; } ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:6","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"序列化 序列化为字符串 // 序列化为字符串 std::string json_str = j.dump(); // 美化输出，使用 4 个空格对输出进行格式化 std::string pretty_str = j.dump(4, ' '); 序列化到文件 std::ofstream ofs(\"output.json\"); ofs \u003c\u003c j \u003c\u003c std::endl; // 将 JSON 内容输出到文件，并美化 std::ofstream ofs(\"pretty.json\"); ofs \u003c\u003c std::setw(4) \u003c\u003c j \u003c\u003c std::endl; 序列化到输出流 json j; std::cout \u003c\u003c j; // 可以使用 std::setw(4) 对输出内容美化 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:7","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"反序列化 从字符串中解析 json j = json::parse(\"{ \\\"happy\\\": true, \\\"pi\\\": 3.141 }\"); 从文件中读取 std::ifstream ifs(\"sample.json\"); json j; ifs \u003e\u003e j; 从用户输入中读取 json j; std::cin \u003e\u003e j; ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:8","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"Unicode与多编码支持 configor 具有完备的 unicode 支持，同時支持 char、wchar_t、char16_t和char32_t。 对于 wchar_t 类型，可使用下面的别名来使用宽字符版本： json // char wjson // wchar_t 宽字符版本示例代码： wjson j = wjson::parse(L\"{ \\\"name\\\": \\\"中文测试\\\" }\"); std::wstring str = j[L\"name\"].get\u003cstd::wstring\u003e(); 对 char16_t 和 char32_t 字符类型需要使用下面的别名 struct u16json_args : json_args { using char_type = char16_t; }; struct u32json_args : json_args { using char_type = char32_t; }; // char16_t using u16json = configor::basic_config\u003cu16json_args\u003e; // char32_t using u32json = configor::basic_config\u003cu32json_args\u003e; 由于C++标准库并不支持 char16_t 和 char32_t 的IO流，在不同的平台和编译器上可能会有不同表现。 对于 Clang 编译器来说，您可能需要自己实现 std::ctype\u003cchar16_t\u003e 和 std::ctype\u003cchar32_t\u003e 才能让 configor 正常工作。 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:9","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"与自定义类型转换 将自定义类型与 JSON 绑定 configor 提供了 JSON_BIND 宏，可以用一行代码快速完成 json 绑定： struct User { int user_id; std::string user_name; JSON_BIND(User, user_id, user_name); // 将 user_id 和 user_name 字段绑定到 json }; // 对私有成员变量同样适用 class User { private: int user_id; std::string user_name; public: JSON_BIND(User, user_id, user_name); // 将 user_id 和 user_name 字段绑定到 json }; 与 JSON 绑定后，可以方便的将自定义类型与 JSON 进行转换： json j; User user; // 将 User 转换为 json j = user; // 将 json 转换为 User user = (User)j; 同时会默认支持 User 的智能指针、std::vector\u003cUser\u003e、std::map\u003cstd::string, User\u003e 等类型的自动转换。 例如，下面的代码是正确的： std::vector\u003cstd::shared_ptr\u003cUser\u003e\u003e user_list; json j = user_list; // 可以正确处理复合类型的转换 对于第三方库的类型，由于无法侵入式的在其内部声明 JSON_BIND，可以通过特化实现 config_bind 类，非侵入式的绑定到 JSON。 特化实现 config_bind 的例子： // 用户类 struct User { int user_id; std::string user_name; }; // 与 json 绑定 namespace configor { template \u003c\u003e struct config_binder\u003cUser\u003e { static void to_config(json\u0026 j, const User\u0026 v) { j = { { \"user_id\", v.user_id }, { \"user_name\", v.user_name } }; } static void from_config(const json\u0026 j, User\u0026 v) { j[\"user_id\"].get(v.user_id); j[\"user_name\"].get(v.user_name); } }; } 将自定义类型以 JSON 格式与输入输出流交互 使用 json::wrap 函数可以让任意类型实现序列化与反序列化，并与输入输出流交互 std::stringstream s; // 把 obj 序列化，并输入到 s 流中 s \u003c\u003c json::wrap(obj); // 从 s 流中读取，并把 obj 反序列化 s \u003e\u003e json::wrap(obj); ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:10","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"示例代码 实现自定义User类的序列化与反序列化 #include \u003cstring\u003e #include \u003ciostream\u003e #include \u003csstream\u003e #include \u003cconfigor/json.hpp\u003e using namespace configor; // 用户类 struct User { int user_id; std::string user_name; JSON_BIND(User, user_id, user_name); }; int main(int argc, char** argv) { std::stringstream s(\"{\\\"user_id\\\": 10001, \\\"user_name\\\": \\\"John\\\"}\"); // 解析json内容，并反序列化到user对象 User user; s \u003e\u003e json::wrap(user); // 序列化user对象并输出 std::cout \u003c\u003c json::wrap(user) \u003c\u003c std::endl; // {\"user_id\":10001,\"user_name\":\"John\"} return 0; } 一个HTTP接口的伪代码 ![example](/Users/xinqi/Library/Mobile Documents/iCloud~md~obsidian/Documents/content/posts/C++/assets/example.png) ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:11","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"常见问题 Q: 抛出异常 config deserialization error: unexpected token ’end_of_input' A: 往往是读取文件失败导致的，请检查文件路径是否正确。 Q: Windows 下中文乱码 A: 这是由于在中文环境下，Visual Studio 和 Windows 终端使用的编码都是 gb2312，而 configor 仅支持 unicode。 Visual Studio 使用 utf-8 非常困难，建议直接忽略编码，对中文不做处理： using namespace configor; // 使用 encoding::ignore 忽略编码 json j = json::parse\u003cencoding::ignore\u003e(\"{\\\"chinese\\\":\\\"一些带有中文的JSON字符串\\\"}\"); std::cout \u003c\u003c j.dump\u003cencoding::ignore\u003e() \u003c\u003c std::endl; 或使用自定义的json类： struct my_json_args : configor::json_args { // 使用 encoding::ignore 忽略编码 template \u003ctypename _CharTy\u003e using default_encoding = configor::encoding::ignore\u003c_CharTy\u003e; }; using json = configor::basic_config\u003cmy_json_args\u003e; Q: 如何保证 JSON 序列化时按 key 的插入顺序输出？ A: configor 内部使用 std::map 存储 kv 对象，默认是按 key 的字符串大小排序的。 建议用第三方库替换 std::map，比如 nlohmann/fifo_map，然后声明 fifo_json 替换 json 来保证插入序 struct fifo_json_args : json_args { template \u003cclass _Kty, class _Ty, class... _Args\u003e using object_type = nlohmann::fifo_map\u003c_Kty, _Ty, _Args...\u003e; }; // fifo_json 是按插入序排列的 using fifo_json = configor::basic_config\u003cfifo_json_args\u003e; ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:12","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"更多 若你需要将 JSON 解析和序列化应用到非 std::basic_stream 流中，可以通过实现自定义 oadapter 和 iadapter 的方式。 一个 oadapter 的例子： struct myadapter : public oadapter { // 实现 write 接口，写入一个字符 virtual void write(const char ch) override { // 直接输出到屏幕 std::cout \u003c\u003c ch; } }; // 使用方式 myadapter ma; oadapterstream os{ ma }; j.dump(os); // 将 json j 序列化输出到屏幕上 一个 iadapter 的例子： struct myadapter : public iadapter { // 实现 read 接口，读取一个字符 virtual char read() override { // 直接从用户输入读取字符，读到换行符结束 char ch = std::cin.get(); if (ch == '\\n') return std::char_traits\u003cchar\u003e::eof(); return ch; } }; // 使用方式 myadapter ma; iadapterstream is{ ma }; json j = json::parse(is); // 读取用户输入，并反序列化 详细内容请参考 json_stream.hpp ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:13","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"计划 完全的 unicode 支持 单测覆盖率达到 85% 以上 支持注释 支持 json 和自定义类型的隐式转换（has_to_json限定） optional 返回值的支持（作为模板参数并允许替换） 错误信息完善 SAX工具 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:14","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"鸣谢 感谢 nlohmann 的 JSON for Modern C++ 项目，本仓库的许多概念和灵感都来源于此。 ","date":"2022-01-08","objectID":"/2022/01/json%E8%AF%BB%E5%86%99/:1:15","series":null,"tags":["C++"],"title":"json读写","uri":"/2022/01/json%E8%AF%BB%E5%86%99/"},{"categories":["C++"],"content":"C++ array(STL array)容器用法详解 http://c.biancheng.net/view/6688.html ","date":"2022-01-08","objectID":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:0:0","series":null,"tags":["C++","STL","Array"],"title":"std::array容器用法","uri":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"引用 在使用该容器之前，代码中需引入 \u003carray\u003e 头文件，并默认使用 std 命令空间，如下所示： #include \u003carray\u003e using namespace std; ","date":"2022-01-08","objectID":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:1:0","series":null,"tags":["C++","STL","Array"],"title":"std::array容器用法","uri":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"创建 array 容器的方式 创建具有 10 个 double 类型元素的 array 容器： std::array\u003cdouble, 10\u003e values; 由此，就创建好了一个名为 values 的 array 容器，其包含 10 个浮点型元素。 但是，由于未显式指定这 10 个元素的值，因此使用这种方式创建的容器中，各个元素的值是不确定的（array 容器不会做默认初始化操作）。 在 array\u003cT,N\u003e 类模板中，T 用于指明容器中的存储的具体数据类型，N 用于指明容器的大小，需要注意的是，这里的 N 必须是常量，不能用变量表示。 通过如下创建 array 容器的方式，可以将所有的元素初始化为 0 或者和默认元素类型等效的值： std::array\u003cdouble, 10\u003e values {}; 使用该语句，容器中所有的元素都会被初始化为 0.0。 当然，在创建 array 容器的实例时，也可以像创建常规数组那样对元素进行初始化： std::array\u003cdouble, 10\u003e values {0.5,1.0,1.5,,2.0} 可以看到，这里只初始化了前 4 个元素，剩余的元素都会被初始化为 0.0。 ","date":"2022-01-08","objectID":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:2:0","series":null,"tags":["C++","STL","Array"],"title":"std::array容器用法","uri":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"成员函数及功能 成员函数 功能 begin() 返回指向容器中第一个元素的随机访问迭代器。 end() 返回指向容器最后一个元素之后一个位置的随机访问迭代器，通常和 begin() 结合使用。 rbegin() 返回指向最后一个元素的随机访问迭代器。 rend() 返回指向第一个元素之前一个位置的随机访问迭代器。 cbegin() 和 begin() 功能相同，只不过在其基础上增加了 const 属性，不能用于修改元素。 cend() 和 end() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crbegin() 和 rbegin() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 crend() 和 rend() 功能相同，只不过在其基础上，增加了 const 属性，不能用于修改元素。 size() 返回容器中当前元素的数量，其值始终等于初始化 array 类的第二个模板参数 N。 max_size() 返回容器可容纳元素的最大数量，其值始终等于初始化 array 类的第二个模板参数 N。 empty() 判断容器是否为空，和通过 size()==0 的判断条件功能相同，但其效率可能更快。 at(n) 返回容器中 n 位置处元素的引用，该函数自动检查 n 是否在有效的范围内，如果不是则抛出 out_of_range 异常。 front() 返回容器中第一个元素的直接引用，该函数不适用于空的 array 容器。 back() 返回容器中最后一个元素的直接应用，该函数同样不适用于空的 array 容器。 data() 返回一个指向容器首个元素的指针。利用该指针，可实现复制容器中所有元素等类似功能。 fill(val) 将 val 这个值赋值给容器中的每个元素。 array1.swap(array2) 交换 array1 和 array2 容器中的所有元素，但前提是它们具有相同的长度和类型。 除此之外，C++ 11 标准库还新增加了 begin() 和 end() 这 2 个函数，和 array 容器包含的 begin() 和 end() 成员函数不同的是，标准库提供的这 2 个函数的操作对象，既可以是容器，还可以是普通数组。当操作对象是容器时，它和容器包含的 begin() 和 end() 成员函数的功能完全相同；如果操作对象是普通数组，则 begin() 函数返回的是指向数组第一个元素的指针，同样 end() 返回指向数组中最后一个元素之后一个位置的指针（注意不是最后一个元素）。 另外，在 头文件中还重载了 get() 全局函数，该重载函数的功能是访问容器中指定的元素，并返回该元素的引用。 #include \u003ciostream\u003e //需要引入 array 头文件 #include \u003carray\u003e using namespace std; int main() { std::array\u003cint, 4\u003e values{}; //初始化 values 容器为 {0,1,2,3} for (int i = 0; i \u003c values.size(); i++) { values.at(i) = i; } //使用 get() 重载函数输出指定位置元素 cout \u003c\u003c get\u003c3\u003e(values) \u003c\u003c endl; //如果容器不为空，则输出容器中所有的元素 if (!values.empty()) { for (auto val = values.begin(); val \u003c values.end(); val++) { cout \u003c\u003c *val \u003c\u003c \" \"; } } } 注意，代码中的 auto 关键字，可以使编译器自动判定变量的类型。运行这段代码，输出结果为： 3 0 1 2 3 ","date":"2022-01-08","objectID":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:3:0","series":null,"tags":["C++","STL","Array"],"title":"std::array容器用法","uri":"/2022/01/stdarray%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"更详细的教程 https://www.nhooo.com/cpp/cpp-map.html 本篇將介紹如何使用 C++ std map 以及用法，C++ std::map 是一個關聯式容器，關聯式容器把鍵值和一個元素連繫起來，並使用該鍵值來尋找元素、插入元素和刪除元素等操作。 map 是有排序關聯式容器，即 map 容器中所有的元素都會根據元素對應的鍵值來排序，而鍵值 key 是唯一值，並不會出現同樣的鍵值 key，也就是說假設已經有一個 鍵值 key 存在 map 裡，當同樣的鍵值 key 再 insert 資料時，新的資料就會覆蓋掉原本 key 的資料。 map 的實作方式通常是用紅黑樹(red-black tree)實作的，這樣它可以保證可以在O(log n)時間內完成搜尋、插入、刪除，n為元素的數目。 以下內容將分為這幾部分， map 常用功能 map 初始化 map 容器插入元素與存取元素 map 容器的迴圈遍歷 使用 string 當 key 鍵值, int 當 value 資料的 map 範例 使用 string 當 key 鍵值, 自定義類別或自定義結構當 value 資料的 map 範例 刪除 map 指定的元素 清空 map 容器 判斷 map 容器是否為空 要使用 map 容器的話，需要引入的標頭檔：\u003cmap\u003e ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:1:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"map 常用功能 C++ map 是一種關聯式容器，包含「key鍵值/value資料」成對關係 元素存取 operator[]：存取指定的[i]元素的資料 迭代器 begin()：回傳指向map頭部元素的迭代器 end()：回傳指向map末尾的迭代器 rbegin()：回傳一個指向map尾部的反向迭代器 rend()：回傳一個指向map頭部的反向迭代器 容量 empty()：檢查容器是否為空，空則回傳true size()：回傳元素數量 max_size()：回傳可以容納的最大元素個數 修改器 clear()：刪除所有元素 insert()：插入元素 erase()：刪除一個元素 swap()：交換兩個map 查找 count()：回傳指定元素出現的次數 find()：查找一個元素 ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:2:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"map 初始化 接下來說說怎麼初始化 c++ map 容器吧！ 先以 int 當 key, string 當 value 的 map 為範例， 以一個班級的學生編號為例，一個編號會對應到一個學生，這邊先以學生姓名作示範， 所以會寫成std::map\u003cint, std::string\u003e studentMap這樣 std::map 宣告時要宣告兩個變數類型， map.first：第一個稱為(key)鍵值，在 map 裡面，(key)鍵值不會重複 map.second：第二個稱為(key)鍵值對應的數值(value) map 容器初始化的寫法如下， std::map\u003cint, std::string\u003e studentMap; studentMap.insert(std::pair\u003cint, std::string\u003e(1, \"Tom\")); studentMap.insert(std::pair\u003cint, std::string\u003e(7, \"Jack\")); studentMap.insert(std::pair\u003cint, std::string\u003e(15, \"John\")); 或者像陣列的方式一樣 std::map\u003cint, std::string\u003e studentMap; studentMap[1] = \"Tom\"; studentMap[7] = \"Jack\"; studentMap[15] = \"John\"; 或者這樣初始化更專業一點 std::map\u003cint, std::string\u003e studentMap = { {1, \"Tom\"}, {2, \"Jack\"}, {3, \"John\"} }; ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:3:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"map 容器插入元素與存取元素 刚刚在初始化部分已经有示范过了，map 容器插入元素有两种写法， 第一种是使用中括号 [] 的方式来插入元素，很像阵列的写法，例如：map[key] = value，如果该 key 值已经存在则 value 会被更新成新的数值，范例如下， std::map\u003cint, std::string\u003e studentMap; studentMap[1] = \"Tom\"; ... studentMap[1] = \"John\"; 另一种是使用 map.insert() 成员函式来插入元素， 那这个 map.insert() 方式跟上面中括号 [] 的方式有什么不同呢？ 差别在于如果 key 值已经存在的话，使用中括号 [] 的方式会将新资料覆盖旧资料， 而使用 map.insert() 的方式会回传插入的结果，该 key 值存在的话会回传失败的结果， 检查 map.insert() 的插入结果方式如下， std-map.cpp// g++ std-map.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e int main() { std::map\u003cint, std::string\u003e studentMap; studentMap.insert(std::pair\u003cint, std::string\u003e(1, \"Tom\")); std::pair\u003cstd::map\u003cint, std::string\u003e::iterator, bool\u003e retPair; retPair = studentMap.insert(std::pair\u003cint, std::string\u003e(1, \"Tom\")); if (retPair.second == true) std::cout \u003c\u003c \"Insert Successfully\\n\"; else std::cout \u003c\u003c \"Insert Failure\\n\"; return 0; } 要取得某 key 键值元素的话可以这样写，或者看下节遍历整个 map 容器 std::cout \u003c\u003c \"name: \" \u003c\u003c studentMap[1] \u003c\u003c \"\\n\"; ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:4:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"map容器的大小 size() map\u003cchar, int\u003e m; cout \u003c\u003c \"map的初始大小 = \" \u003c\u003c m.size() \u003c\u003c endl; ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:5:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"map 容器的回圈遍历 回圈遍历 map 容器的方式有几种，以下先介绍使用 range-based for loop 来遍历 map 容器， 这边故意将 id 不按顺序初始化或者插入，先初始化 1、3、2 key 键值的元素， 之后再插入 5 和 4 key 键值的元素，然后我们再来观察看看是不是 map 会将其排序， std-map2.cpp// g++ std-map2.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e int main() { std::map\u003cint, std::string\u003e studentMap = { {1, \"Tom\"}, {3, \"John\"}, {2, \"Jack\"} }; studentMap[5] = \"Tiffany\"; studentMap[4] = \"Ann\"; for (const auto\u0026 s : studentMap) { std::cout \u003c\u003c \"id: \" \u003c\u003c s.first \u003c\u003c \", name: \" \u003c\u003c s.second \u003c\u003c \"\\n\"; } return 0; } 输出内容如下，从这个输出结果发现是 key 键值由小到大排列，所以 map 容器里面真的是会帮你排序的， 在插入元素的同时会根据键值来进行排序， id: 1, name: Tom id: 2, name: Jack id: 3, name: John id: 4, name: Ann id: 5, name: Tiffany 使用前向迭代器，输出结果跟上列相同， for (std::map\u003cint, std::string\u003e::iterator it = studentMap.begin(); it != studentMap.end(); it++) { // or // for (auto it = studentMap.begin(); it != studentMap.end(); it++) { std::cout \u003c\u003c \"id: \" \u003c\u003c (*it).first \u003c\u003c \", name: \" \u003c\u003c (*it).second \u003c\u003c \"\\n\"; } 使用反向迭代器的例子，如果嫌 iterator 迭代器名称太长的话可以善用 auto 关键字让编译器去推导该变数类型， // for (std::map\u003cint, std::string\u003e::reverse_iterator it = studentMap.rbegin(); it != studentMap.rend(); it++) { // or for (auto it = studentMap.rbegin(); it != studentMap.rend(); it++) { std::cout \u003c\u003c \"id: \" \u003c\u003c (*it).first \u003c\u003c \", name: \" \u003c\u003c (*it).second \u003c\u003c \"\\n\"; } 反向迭代器的輸出結果如下，反著印出來， id: 5, name: Tiffany id: 4, name: Ann id: 3, name: John id: 2, name: Jack id: 1, name: Tom ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:6:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"使用 string 当 key 键值, int 当 value 资料的 map 范例 这个范例跟之前的范例相反，我们试着用 string 当作 key 键值，int 当 value，看看是不是也可以这样使用， 所以会写成 std::map\u003cstd::string, int\u003e 这样，完整范例如下， std-map3.cpp// g++ std-map3.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e int main() { std::map\u003cstd::string, int\u003e map = { {\"Tom\", 1}, {\"Jack\", 2}, {\"Ann\", 4} }; for (const auto\u0026 n : map) { std::cout \u003c\u003c \"key: \" \u003c\u003c n.first \u003c\u003c \" value: \" \u003c\u003c n.second \u003c\u003c \"\\n\"; } map[\"Tiffany\"] = 5; map[\"John\"] = 3; std::cout \u003c\u003c map[\"John\"] \u003c\u003c \"\\n\"; std::cout \u003c\u003c map[\"Tiffany\"] \u003c\u003c \"\\n\"; for (const auto\u0026 n : map) { std::cout \u003c\u003c \"key: \" \u003c\u003c n.first \u003c\u003c \" value: \" \u003c\u003c n.second \u003c\u003c \"\\n\"; } return 0; } 输出内容如下，可以发现印出来的顺序是按照学生姓名的顺序， key: Ann value: 4 key: Jack value: 2 key: Tom value: 1 3 5 key: Ann value: 4 key: Jack value: 2 key: John value: 3 key: Tiffany value: 5 key: Tom value: 1 ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:7:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"使用 string 当 key 键值, 自定义类别或自定义结构当 value 资料的 map 范例 如果要在 value 栏位放入自定义 struct 或 自定义 class 的话，可以参考下面这个范例， 那个宣告就会是 std::map\u003cstd::string, Class/Struct\u003e 这样子写， std-map4.cpp// g++ std-map4.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e struct Student { int id; std::string name; int age; }; int main() { std::map\u003cstd::string, Student\u003e studentMap; studentMap[\"Tom\"] = {1, \"Tom\", 18}; studentMap[\"Ann\"] = {4, \"Ann\", 20}; studentMap[\"Jack\"] = {2, \"Jack\", 16}; for (const auto\u0026 m : studentMap) { std::cout \u003c\u003c \"name: \" \u003c\u003c m.first \u003c\u003c \" id: \" \u003c\u003c m.second.id \u003c\u003c \" age: \" \u003c\u003c m.second.age \u003c\u003c \"\\n\"; } return 0; } 輸出內容如下： name: Ann id: 4 age: 20 name: Jack id: 2 age: 16 name: Tom id: 1 age: 18 ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:8:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"刪除 map 指定的元素 刪除 map 指定的元素要使用 erase()， std-map5.cpp// g++ std-map5.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e int main() { std::map\u003cint, std::string\u003e studentMap; studentMap[1] = \"Tom\"; studentMap[7] = \"Jack\"; studentMap[15] = \"John\"; studentMap.erase(1); for (const auto\u0026 m : studentMap) { std::cout \u003c\u003c m.first \u003c\u003c \" \" \u003c\u003c m.second \u003c\u003c \"\\n\"; } return 0; } 結果如下， 7 Jack 15 John 那如果 map 刪除不存在的元素會發生什麼事呢？ std-map6.cpp// g++ std-map6.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cmap\u003e int main() { std::map\u003cint, std::string\u003e studentMap; studentMap[1] = \"Tom\"; studentMap[7] = \"Jack\"; studentMap[15] = \"John\"; auto ret = studentMap.erase(1); std::cout \u003c\u003c ret \u003c\u003c \"\\n\"; for (const auto\u0026 m : studentMap) { std::cout \u003c\u003c m.first \u003c\u003c \" \" \u003c\u003c m.second \u003c\u003c \"\\n\"; } ret = studentMap.erase(2); std::cout \u003c\u003c ret \u003c\u003c \"\\n\"; for (const auto\u0026 m : studentMap) { std::cout \u003c\u003c m.first \u003c\u003c \" \" \u003c\u003c m.second \u003c\u003c \"\\n\"; } return 0; } map 刪除不存在的元素並不會造成什麼 crash 這種嚴重問題，他反而會回傳一個數量告訴你它刪除了多少個元素，以這個例子來說 erase(1) 是刪除了 1 個元素，erase(2) 是刪除了 0 個元素，結果如下， 1 7 Jack 15 John 0 7 Jack 15 John map erase() 刪除元素還有另外兩種用法，有興趣的可以看這一篇。 ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:9:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"清空 map 容器 要清空 map 容器的的話，要使用 clear()， std::map\u003cint, std::string\u003e studentMap; studentMap.insert(std::pair\u003cint, std::string\u003e(1, \"Tom\")); studentMap.insert(std::pair\u003cint, std::string\u003e(7, \"Jack\")); studentMap.insert(std::pair\u003cint, std::string\u003e(15, \"John\")); studentMap.clear(); ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:10:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"判斷 map 容器是否為空 要判斷 map 是否為空或是裡面有沒有元素的話，可以用 empty()，寫法如下， std::map\u003cint, std::string\u003e studentMap; studentMap.clear(); if (studentMap.empty()) { std::cout \u003c\u003c \"empty\\n\"; } else { std::cout \u003c\u003c \"not empty, size is \"\u003c\u003c studentMap.size() \u003c\u003c\"\\n\"; } 參考 std::map - cppreference.com https://en.cppreference.com/w/cpp/container/map map - C++ Reference http://www.cplusplus.com/reference/map/map/ Map in C++ Standard Template Library (STL) - GeeksforGeeks https://www.geeksforgeeks.org/map-associative-containers-the-c-standard-template-library-stl// C/C++ - Map (STL) 用法與心得完全攻略 | Mr. Opengate https://mropengate.blogspot.com/2015/12/cc-map-stl.html [教學]C++ Map(STL)詳細用法 @ 一個小小工程師的心情抒發天地 http://dangerlover9403.pixnet.net/blog/post/216833943 C++ STL map 的小筆記 @ 伊卡洛斯之翼 http://kamory0931.pixnet.net/blog/post/119251820 C++中的STL中map用法详解 - Boblim - 博客园 https://www.cnblogs.com/fnlingnzb-learner/p/5833051.html 程式扎記: [C++ 範例代碼] 使用 STL 的 map 操作範例 http://puremonkey2010.blogspot.com/2010/08/c-stl-map.html 其它相關文章推薦 如果你想學習 C++ 相關技術，可以參考看看下面的文章， C/C++ 新手入門教學懶人包 std::multimap 用法與範例 std::unordered_map 用法與範例 std::vector 用法與範例 std::deque 介紹與用法 std::queue 用法與範例 ","date":"2022-01-08","objectID":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/:11:0","series":null,"tags":["C++"],"title":"std::map用法","uri":"/2022/01/stdmap%E5%AE%B9%E5%99%A8%E7%94%A8%E6%B3%95/"},{"categories":["C++"],"content":"一、高级接口 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"多线程启动函数std::async() async()的作用在于将其获取到的函数立即在一个新的线程内进行异步启动。也就是一个线程启动函数。其形式如下： std::async(func1) //无参数形式 向async()传递启动函数，并且传入启动函数的参数： void func1(int arg1,int arg2) { std::cout\u003c\u003carg1\u003c\u003cstd::endl; std::cout\u003c\u003carg2\u003c\u003cstd::endl; } std::async(func1,arg1,arg2) //向函数func1传递arg1,arg2; ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:1","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"线程返回结果std::future std::async()会返回一个std::future object类型的返回值，在std::future object中，我们可以取得线程返回值或异常信息。此外，std::future object类型的特化与线程函数的返回值一致。形式如下： void func1(int A = 0); int func2(); int main() { std::future\u003cvoid\u003e func1_res(std::async(print_A,10)); //func1返回类型为void，future object的类型也为void std::future\u003cint\u003e func2_res(std::async(print_B)); //func2返回类型为int，future object的类型也为int } 指定std::async()的发射策略(launch strategy) std::async的策略主要有两个： std::launch::async : 立即尝试启动异步调用，如果在此处无法进行调用时，会返回一个std::system_error std::launch::deferred : 延缓线程的启动，直到我们手动调用future::get()时，线程才会启动。 示例如下： #include \u003cfuture\u003e #include \u003cctime\u003e #include \u003ciostream\u003e #include \u003cWindows.h\u003e void func1() { std::cout \u003c\u003c \"func1 start!\" \u003c\u003c std::endl; } void func2() { std::cout \u003c\u003c \"func2 start!\" \u003c\u003c std::endl; } int main() { //f1在这里就启动了，输出func1 start! std::future\u003cvoid\u003e f1(std::async(std::launch::async, func1)); //f2在这里由于发射策略的原因，并没有启动 std::future\u003cvoid\u003e f2(std::async(std::launch::deferred, func2)); Sleep(3000); std::cout \u003c\u003c \"3 seconds later!\" \u003c\u003c std::endl; //三秒之后，由于调用future::get()，线程f2启动，输出func2 start! f2.get(); return 0; } ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:2","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"共享变量std::shared_future shared_future 简单说来，其实就是一个可以多次调用 其成员函数get()的object。 由于std::future的成员函数get()只能够调用一次，第二次调用的时候会出现不可预期的行为（实际上就会报错或者完全不会有任何动作）。但是，很多时候，我们希望一个线程可以被多个线程利用，这个时候，std::share_future就横空出世了！ #include \u003cfuture\u003e #include \u003ciostream\u003e #include \u003cstring\u003e #include \u003cthread\u003e #include \u003cstdexcept\u003e #include \u003cexception\u003e using namespace std; int func1() { std::cout \u003c\u003c \"Read Number: \"; int num; std::cin \u003e\u003e num; if (!std::cin) { throw runtime_error(\"no number read\"); } return num; } void addOne(std::shared_future\u003cint\u003e SfObject) { int num = SfObject.get(); num += 1; std::cout \u003c\u003c num \u003c\u003c std::endl; } int main() { std::shared_future\u003cint\u003e f = std::async(func1); auto f1 = std::async(addOne, f); auto f2 = std::async(addOne, f); f1.get(); f2.get(); return 0; } 可以看到上面这段代码中，std::shared_future f 的成员函数 std::get()被多次调用。假如我们将share_future object 换为futureobject时，甚至无法通过编译。 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:3","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"二、低级接口 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"多线程启动函数Class std::thread Class std::thread的调用接口与std::async()颇为显示，一起看一下下面这个实例： #include \u003ciostream\u003e #include \u003cthread\u003e void Print(int num) { std::cout \u003c\u003c \"this is thread: \"\u003c\u003c num \u003c\u003c std::endl; } int main() { std::thread t1(Print, 1); //创建线程1 std::thread t2(Print, 2); //创建线程2 t1.join(); //等待线程1结束 t2.join(); //等待线程2结束 std::cout \u003c\u003c \"this is main thread \"\u003c\u003c std::endl; return 0; } 可以看到，在线程创建和传参上，Class thread 和 std::async()的手法都颇为类似。只不过一个是类，一个是函数。 但是，两者也有颇多地方有较大差异： 1、Class thread 没有发射策略，只要我们实例化Class thread的对象，系统就会尝试启动目标函数，如果无法启动目标函数，就会抛出std::system_error并携带差错码resource_unavailable_try_again。 2、Class thread并不提供处理线程结果的接口 3、必须对线程的状态进行声明，等待其结束（join()）或直接卸载（detach()） 4、如果main()函数结束了，所有线程会被直接终止 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:1","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"线程返回结果std::promise 待补充。。 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:2","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"线程池Class packaged_task Class packaged_task实现了运行我们自由控制启动线程的启动时间，可以用于实现线程池。 让我们直接来看一个例子吧： #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cstring\u003e #include \u003cchrono\u003e #include \u003cfuture\u003e #include \u003cWindows.h\u003e void func1() { std::cout \u003c\u003c \"creating thread……\" \u003c\u003c std::endl; } int main() { std::packaged_task\u003cvoid()\u003e task(func1); //这里创建thread task,但是不会立即启动线程 std::cout \u003c\u003c \"Sleep for 3 seconds\" \u003c\u003c std::endl; Sleep(3000); //sleep3秒，当然，这里可以改成任何你需要的操作 task(); //3秒后启动线程 return 0; } 好的到目前为止，关于线程的启动和创建过程的内容到这里就基本结束了，接下来，我们以一张图作为这部分的结束。 ​ ​ (图源：《C++标准库》（侯捷译） ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:3","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"三、互斥量与锁(Mutex \u0026 Lock) 首先，我们得先理解为什么会出现互斥量这种需求。其实，在上面，有一段代码是在线程中输出一段字符串，我们看看看到，由于线程的启动都是同时的，所以两个不同的线程会同时对一个命令窗口输出字符，这样就会导致一种不可预计的情况，如图： ​ 可以看到，字符的输出并没有按照我们的预期。那么，当我们有一个变量mutex，同时在多个线程中会被使用，其中线程A在线程B对mutex进行修改的过程中，同时又对mutex进行修改，那么，不可预期的事情便会发生。 所以，我们需要互斥量的出现。同时，我们需要对会被多个线程调用的变量的修改过程进行上锁（Lock），保证上锁过程中线程对资源的独占，才能避免多线程同时对某个变量进行修改，而导致不可预期的事情发生。 还是以上面的字符输出代码为例，我们要怎么修改才能得到我们预期的输出呢? 答案很简单，那就是对字符输出的过程进行上锁（lock），输出结束时解锁（unlock）。看代码吧！ #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cmutex\u003e std::mutex mut;//声明互斥量 void Print(int num) { mut.lock();//对输出过程进行上锁 std::cout \u003c\u003c \"this is thread: \"\u003c\u003c num \u003c\u003c std::endl; mut.unlock();//解锁 } int main() { std::thread t1(Print, 1); std::thread t2(Print, 2); t1.join(); t2.join(); std::cout \u003c\u003c \"this is main thread \"\u003c\u003c std::endl; return 0; } 这样修改之后，就能得到我们想要得到的输出效果： 就是这样，我们对多线程处理的公共部分，进行上锁，使得线程独占资源，便可以使得资源在线程修改的这段时间内不被别的线程使用。但是，随着应用锁（Lock）的场景越来越多，我们也有了更多不同的需求，所以就发展出了各种不同的锁。同时也会出现一些问题。 (各种Mutex及其功能) （Mutex Class 的操作函数） 接下来我们讲一下几个重要的Lock的方式 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"1、Class lock_guard 最简单的锁形式就是Mutex.Lock(),这个方法简单好用，但是有很多时候，人们会忘记将其解锁（Mutex.unlock()）,所以出现了lock_guard的这种自动解锁的方法。Class lock_guard是在声明时，自动上锁，在离开作用域之后自动析构解锁。 我们看一下接口： #include \u003ciostream\u003e #include \u003cthread\u003e #include \u003cmutex\u003e std::mutex mut; void Print(int num) { std::cout \u003c\u003c \"this is thread_unlock: \" \u003c\u003cnum\u003c\u003c std::endl;//未上锁 { std::lock_guard\u003cstd::mutex\u003e lg(mut);//上锁 std::cout \u003c\u003c \"this is thread: \" \u003c\u003c num \u003c\u003c std::endl; }//超出作用域，自动解锁 } int main() { std::thread t1(Print, 1); std::thread t2(Print, 2); t1.join(); t2.join(); std::cout \u003c\u003c \"this is main thread \" \u003c\u003c std::endl; return 0; } 上面的代码在没有上锁的字符输出过程中就串行了。 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:1","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"2、Class unique_lock 相对于Class lock_guard 来说，Class unique_lock 的特殊之处在于，可以让我们指定“何时”以及“如何”锁定和结果Mutex，此外，在Class unique_lock中，我们甚至可以用owns_lock()或bool()来查询目前Mutex是否会被锁住。 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:2","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"四、条件变量（Condition Variable） 在多线程的实际应用中，我们总有需要某个线程等待另外一个线程的处理结果。当然，最简单粗暴的方法自然就是设置一个全局的bool ReadyFlag，在 ReadyFlag 状态发生变化是，线程进行处理。 但是这样做有比较明显的弊端，举个栗子来说明这个问题吧~ bool ReadyFlag{False}; void thread1() { …………//大段处理代码，需要一定时间。 ReadyFlag = true; //满足条件，ReadyFlag状态变为true } void thread2() { if(ReadyFlag) { …………//大段处理代码 } } 可以看到在thread1函数中，当我们处理大段代码时，thread2中一直针对目标条件进行轮询，这样会耗费大量的资源。 实际上，我们希望得到的效果是： thread1 在处理完大量操作后，ReadyFlag的状态改变，达到满足 thread2 的启动条件，然后 thread1 将thread2 进行唤醒。 这就是条件变量（Condition Variable）存在的意义。 先来看一下Class Condition Variable的成员函数： 下面我们来看一个例子实际体会一下吧。 #include \u003ccondition_variable\u003e #include \u003cmutex\u003e #include \u003cfuture\u003e #include \u003ciostream\u003e bool readyFlag; std::mutex readyMutex; std::condition_variable readyCondVar; void thread1() { std::cout \u003c\u003c \"\u003cReturn\u003e\" \u003c\u003c std::endl; std::cin.get(); { std::lock_guard\u003cstd::mutex\u003e lg(readyMutex); readyFlag = true; } readyCondVar.notify_one();//条件成立，唤醒等待者 } void thread2() { { std::unique_lock\u003cstd::mutex\u003e ul(readyMutex); readyCondVar.wait(ul, [] {return readyFlag; });//等待条件变量的状态 } std::cout \u003c\u003c \"Done!\" \u003c\u003c std::endl; } int main() { auto f1 = std::async(std::launch::async, thread1); auto f2 = std::async(std::launch::async, thread2); return 0; } 使用条件变量（Condition Variable）进行这样的线程之间的通信等待，就可以放弃轮询操作，节省CPU的资源和时间。 好的，到这里为止，我对于C++多线程的总结就做到这里吧~感觉写了很多了。但是实际上，这些都只是一些皮毛，只能教会我们如何去使用多线程，对于多线程的应用和各种问题（比如我们常听到的“死锁”问题等）都没有深入探究，这些等我以后有空了再来谈吧。各位，如果看到有啥错误的地方，也请大家都能指出来，共同进步~ 此外，我还推荐大家有空想学习多线程的，可以去看看《C++标准库》（侯捷译）这本书，里面对多线程的调用有极为详细的讲解。谢谢大家，看到这里。 ","date":"2022-01-08","objectID":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":["C++"],"title":"stl 多线程","uri":"/2022/01/stl-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"VS Code 搭建 C++ 开发环境（Mac 环境） ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:1:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"准备 搭建之前需要先安装 clang，在 Mac 上有两种方法进行 clang 的安装： 在 AppStore 上安装 Xcode，clang 会在 Xcode 安装时自动安装 在命令行终端上执行 xcode-select --install 进行安装 安装完可通过在命令行终端上输入 clang -v 验证 clang 安装是否成功 $ clang -v Apple clang version 11.0.3 (clang-1103.0.32.62) Target: x86_64-apple-darwin19.6.0 Thread model: posix InstalledDir: /Library/Developer/CommandLineTools/usr/bin 复制代码 ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:2:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"安装 VS Code 从 VS Code 官网下载 VS Code 双击进行安装 ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:3:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"VS Code 插件安装 想要运行 C++ 程序需要先安装 C/C++ 插件，打开 VS Code，进入插件扩展（快捷键 Command + Shift + X ），搜索 C/C++ 插件进行安装 看不懂英文的，可以再安装一个中文插件 `Chinese (Simplified) Language Pack for Visual Studio Code ，安装方法跟安装 C/C++ 插件一样，把搜索词换成 Chinese` 就可以了 插件安装完成需要重启 VS Code 使其生效 ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:4:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"构建运行第一个 C++ 程序 使用以下步骤创建一个项目目录firstProject，并使用 VS Code 打开 $ mkdir firstProject $ cd firstProject $ code . 复制代码 创建 main.cpp 文件，文件代码如下 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"hello world!\" \u003c\u003c endl; return 0; } 复制代码 按 Command + Shift + P 打开命令行面板，输入 tasks，选择 Tasks:Configure Task 生成 tasks.json 配置文件 这里选择 C/C++:clang build active file 模版，选其他模版也没关系，在下面覆盖也行 VS Code 会自动在 .vscode 目录下生成 tasks.json 配置文件 将文件内容修改为 { \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"build\", \"command\": \"clang++\", \"args\": [ \"-o\", \"main\", // 执行文件名称 \"main.cpp\", // 需要执行的源文件 \"-g\", \"-v\" ], \"type\": \"shell\", \"presentation\": { \"echo\": true, \"reveal\": \"always\", \"panel\": \"shared\" }, \"problemMatcher\": { \"owner\": \"cpp\", \"fileLocation\": [ \"relative\", \"${workspaceRoot}\" ], \"pattern\": { \"regexp\": \"^(.*):(\\\\d+):(\\\\d+):\\\\s+(warning|error):\\\\s+(.*)$\", \"file\": 1, \"line\": 2, \"column\": 3, \"severity\": 4, \"message\": 5 } } } ] } 复制代码 接下来按 Command + Shift + B 对源文件进行编译，编译完成后，会在项目路径下生成 main 文件，使用 ./main 即可执行 ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:5:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"项目调试 如果需要对项目进行进行 debug，则需要先生成 launch.json 文件并对其做相应的配置 按 Command + Shift + D 进入到运行界面 点击 创建 launch.json 文件，选择 C++(GDB/LLDB) 同样的，会在 .vscode 文件夹下创建 launch.json 文件 修改 launch.json 文件内容为 { \"version\": \"2.0.0\", \"configurations\": [ { \"name\": \"C++ Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceRoot}/main\", // main 跟 tasks.json 中的执行文件名称配置一致 \"preLaunchTask\": \"build\", \"internalConsoleOptions\": \"openOnSessionStart\", \"logging\": { \"moduleLoad\": false, \"programOutput\": true, \"trace\": false }, \"showDisplayString\": false, \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${workspaceRoot}\", \"environment\": [], \"externalConsole\": false, // set true to enable keyboard input \"osx\": { \"MIMode\": \"lldb\" } } ]} 复制代码 在 cout 语句打上断点，然后点击运行按钮即可进行 debug 参考：Build and Debug C++ on Visual Studio Code for Mac 到此，使用 VS Code 进行 C++ 项目环境的搭建就完成啦，如果觉得对你有帮助的话可以关注我的公众号huangxy，不定时分享一些技术文章 ","date":"2022-01-08","objectID":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/:6:0","series":null,"tags":["C++"],"title":"VSCode搭建C++开发环境Mac","uri":"/2022/01/vscode%E6%90%AD%E5%BB%BAc-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83mac/"},{"categories":["C++"],"content":"遍历文件夹下的文件 #include \u003cstdio.h\u003e #include \u003cio.h\u003e #include \u003cstring\u003e int main() { //目标文件夹路径 std::string inPath = \"C:\\\\Program Files\\\\*\";//遍历文件夹下的所有文件 //用于查找的句柄 win10用long long或者intptr_t，win7用long就可以了 long long handle; struct _finddata_t fileinfo; //第一次查找 handle = _findfirst(inPath.c_str(),\u0026fileinfo); if(handle == -1) return -1; do { //找到的文件的文件名 printf(\"%s\\n\", fileinfo.name); } while (!_findnext(handle,\u0026fileinfo)); _findclose(handle); system(\"pause\"); return 0; } ","date":"2022-01-08","objectID":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/:1:0","series":null,"tags":["C++"],"title":"遍历文件","uri":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"遍历文件夹下的指定类型文件 #include \u003cstdio.h\u003e #include \u003cio.h\u003e #include \u003cstring\u003e int main() { //目标文件夹路径 std::string inPath = \"E:\\\\image\\\\image\\\\*.jpg\";//遍历文件夹下的所有.jpg文件 //用于查找的句柄 win10用long long或者intptr_t，win7用long就可以了 long long handle; struct _finddata_t fileinfo; //第一次查找 handle = _findfirst(inPath.c_str(),\u0026fileinfo); if(handle == -1) return -1; do { //找到的文件的文件名 printf(\"%s\\n\", fileinfo.name); } while (!_findnext(handle,\u0026fileinfo)); _findclose(handle); system(\"pause\"); return 0; } ","date":"2022-01-08","objectID":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/:2:0","series":null,"tags":["C++"],"title":"遍历文件","uri":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"遍历文件夹中的图片并重新按顺序命名输出 遍历文件夹中的图片，将读取到的图片重新按顺序命名输出；同时创建文件名列表（txt或dat文件）。 #include \u003cstdio.h\u003e #include \u003cio.h\u003e #include \u003cstring\u003e #include \u003ciostream\u003e #include \u003cfstream\u003e #include\u003copencv2/opencv.hpp\u003e using namespace std; using namespace cv; int main() { _finddata_t FileInfo; //读取图片所在的路径 string inPath = \"E:\\\\image\\\\face\\\\negitive\\\\img\\\\\"; string strfind = inPath + \"*\"; //用于查找的句柄 win10用long long或者intptr_t，win7用long就可以了 long long Handle = _findfirst(strfind.c_str(), \u0026FileInfo); char filename[300]; Mat src; int k = 0; //输出txt文件（路径列表）所在的路径 ofstream outfile(\"E:\\\\bg.txt\", ofstream::app); //输出dat文件（路径列表）所在的路径 //ofstream outfile(\"E:\\\\bg.dat\", ofstream::app); if (Handle == -1L) { cerr \u003c\u003c \"can not match the folder path\" \u003c\u003c endl; exit(-1); } //namedWindow(\"input\", WINDOW_AUTOSIZE); do{ //判断是否有子目录 if (FileInfo.attrib \u0026 _A_SUBDIR) { if ((strcmp(FileInfo.name, \".\") != 0) \u0026\u0026 (strcmp(FileInfo.name, \"..\") != 0)) { inPath += FileInfo.name; cout \u003c\u003cinPath\u003c\u003cendl; } } else { cout \u003c\u003cinPath\u003c\u003cFileInfo.name\u003c\u003cendl; //读取图片所在的路径 string path = \"E:/image/face/negitive/img/\" + (string)FileInfo.name; src = imread(path); //显示读取的图片 //imshow(\"input\", src); //输出文件的路径 sprintf_s(filename,\"E:/image/face/negitive/img0/%d.jpg\",k); //将读取到的图片重新按顺序命名输出 imwrite(filename, src); outfile\u003c\u003c\"img/\"\u003c\u003ck\u003c\u003c\".jpg\\n\"; k++; waitKey(1); } } while (_findnext(Handle, \u0026FileInfo) == 0); _findclose(Handle); return 0; } ","date":"2022-01-08","objectID":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/:3:0","series":null,"tags":["C++"],"title":"遍历文件","uri":"/2022/01/%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"error C4996 注意：在图上标记的地方输入/D\" ***** \" 其中****所代表的内容是你编译后调试信息中提示的 use _CRT_SECURE_NO_WARNINGS 。 提示use什么就填入什么。 ","date":"2022-01-08","objectID":"/2022/01/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":["C++"],"title":"常见问题","uri":"/2022/01/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Reveal Reveal是一款调试iOS程序UI界面的神器 官网：https://revealapp.com 下载：https://revealapp.com/download/ 建议下载至少Reveal4版本，支持USB连接调试，速度快。低版本的只能WiFi连接调试 ","date":"2022-01-07","objectID":"/2022/01/04-reveal/:1:0","series":null,"tags":["iPhone"],"title":"04-Reveal","uri":"/2022/01/04-reveal/"},{"categories":null,"content":"调试环境配置 iPhone上安装Reveal Loader 软件源：http://apt.so/codermjlee 不要安装其他源的版本，有可能不支持新版Reveal 找到Mac的Reveal中的RevealServer文件，覆盖iPhone的/Library/RHRevealLoader/RevealServer文件 重启SpringBoard或者重启手机，可以在iPhone上输入终端命令 重启SpringBoard：killall SpringBoard 重启手机：reboot ","date":"2022-01-07","objectID":"/2022/01/04-reveal/:2:0","series":null,"tags":["iPhone"],"title":"04-Reveal","uri":"/2022/01/04-reveal/"},{"categories":null,"content":"逆向APP的思路 界面分析 Cycript、Reveal 代码分析 对Mach-O文件的静态分析 MachOView、class-dump、Hopper Disassembler、ida等 动态调试 对运行中的APP进行代码调试 debugserver、LLDB 代码编写 注入代码到APP中 必要时还可能需要重新签名、打包ipa ","date":"2022-01-07","objectID":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/:1:0","series":null,"tags":["iPhone"],"title":"05-初识Mach-O","uri":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/"},{"categories":null,"content":"class-dump 顾名思义，它的作用就是把Mach-O文件的class信息给dump出来（把类信息给导出来），生成对应的.h头文件 官方地址：http://stevenygard.com/projects/class-dump/ 下载完工具包后将class-dump文件复制到Mac的/usr/local/bin目录，这样在终端就能识别class-dump命令了 常用格式 class-dump -H Mach-O文件路径 -o 头文件存放目录 -H表示要生成头文件 -o用于制定头文件的存放目录 ","date":"2022-01-07","objectID":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/:2:0","series":null,"tags":["iPhone"],"title":"05-初识Mach-O","uri":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/"},{"categories":null,"content":"Hopper Disassmbler Hopper Disassmbler能够将Mach-O文件的机器语言代码反编译成汇编代码、OC伪代码或者Swift伪代码 常用快捷键 Shift + Option + X 找出哪里引用了这个方法 ","date":"2022-01-07","objectID":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/:3:0","series":null,"tags":["iPhone"],"title":"05-初识Mach-O","uri":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/"},{"categories":null,"content":"命令行工具 file：查看Mach-O的文件类型 file 文件路径 otool：查看Mach-O特定部分和段的内容 ","date":"2022-01-07","objectID":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/:4:0","series":null,"tags":["iPhone"],"title":"05-初识Mach-O","uri":"/2022/01/05-%E5%88%9D%E8%AF%86mach-o/"},{"categories":null,"content":"CButton 详情 Name 描述 CButton：： GetCheck 抓取按钮控制项的检查状态。 CButton：： GetCheck 抓取选项按钮或核取方块的检查状态。 int GetCheck() const; 传回值 值 意义 BST_UNCHECKED 按钮状态为未核取。 BST_CHECKED 按钮状态为已核取。 BST_INDETERMINATE 按钮状态是不定的 (只有在按钮具有 BS_3STATE 或 BS_AUTO3STATE 样式) 时才适用。 ","date":"2022-01-07","objectID":"/2022/01/cbutton/:1:0","series":null,"tags":null,"title":"CButton","uri":"/2022/01/cbutton/"},{"categories":null,"content":" 公共方法 说明 CWnd::EnableWindow 启用或禁用鼠标和键盘输入。 CWnd::IsWindowEnabled 确定是否针对鼠标和键盘输入启用窗口。 ","date":"2022-01-07","objectID":"/2022/01/cwnd/:0:0","series":null,"tags":null,"title":"CWnd","uri":"/2022/01/cwnd/"},{"categories":null,"content":"越狱iOS必备神器Flex使用指南-屏蔽越狱检测的破解利器 什么是Flex？ ​ Flex是越狱iOS上Cydia商店里的一个插件，看似普通的插件，却有着强大的动态修改手机APP运行逻辑的功能，就像Android系统中的Xposed一样，通过制作编写、配置一个Flex的小插件，可以动态修改越狱iOS上APP运行时的执行代码逻辑。 ​ 但Flex的插件制作要比Xposed的插件制作更为简单。 ​ Xposed插件的编写需要在外部对APK进行反编译破解，甚至脱壳，打开AndroidStudio等开发软件进行代码编写，生成插件apk安装在手机上，在Xposed框架中激活，重启手机后方可生效。 ​ 而Flex插件的编写，说是编写，其实说配置更准确。Flex支持直接对Mach-o进行反编译，得到Object-C源码头文件，让用户直接选中要hook的类和方法名，配置篡改某个方法传入的参数和固定方法的返回值，从而达到修改APP执行逻辑的目的。使其生效的话，只需打开开关，重启APP即可生效。 ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:1:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"安装Flex 添加官方源：http://getdelta.co/安装Flex3即可。 我安装的是雷锋源的Flex 3 b92版本，机器是iPhoneXr,12.4.1 ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:2:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"Flex功能模板说明 主要看下图说明： 在个人中心的账号中，有免费账号和付费账号，免费账号的限制是每天只能下载2个云端的插件，分享一个别人的共享账号：sundasheng521@qq.com 7758521a 没有功能限制： ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:3:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"插件制作教程 ​ 以“中国建设银行”为例，屏蔽其越狱检测。建行在越狱的手机上会安全提示，且点击按钮之后退出APP： 打开Flex，点击右上角的“+”，选中建设银行，来到界面： 点击“Add Units”，来到建设的执行程序列表： 这里，我们选择主程序，点击之后，会有Processing字眼，是Flex对Mach-o进行dump源码头的处理，完成之后，最右边出现“\u003e”，我们再点击就来到了类和函数的区域： 通过分析建行对越狱的检测特征：弹窗提示+点击退出。那我们就尝试搜索“退出”：exitApp： 选中之后，返回到原来的页面： 点击进去查看编辑： 2个方法的分析是一样的，也就说只要我们将这2个方法的Return设置为pass-through跳过不执行，建设银行就会在用户点击按钮的时候，不发生退出操作： ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:4:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"Flex对于函数的传参和返回类型 目前Flex仅仅支持对Object-C类型的类和函数进行动态修改，支持编辑的具体类型有NSString（输入一个字符串，比如提示语、界面语等）、 NSNumer（一个数字，比如金币数、钻石数等）、 NSDate（日期，比如VIP到期日期等）、 UIColor（颜色，选择颜色等）、 Bool（TRUE/FALSE，是否为VIP等） Id（泛型，可以自定义类型） ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:5:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"怎么快速定位要修改的函数 A.通过抓包分析，精准定位需要修改的请求参数的值： https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1174501 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1004614 B.借助前人经验，通过通用的修改方法得到自己的破解需求： https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=999009 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1401213 C.通过中英文对照，模糊搜索可能需要修改的地方，比如： 屏蔽越狱检测：jailbroken root cydia 等 屏蔽退出：exit quit illegal等 解锁：lock 水印：water 是否购买/vip：vip buy pay等。 相关的博文： https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1092971 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=1003260 https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=615555 D.进阶精准溯源法，通过高阶的分析，比如IDA、Hopper、FlexTool等精准分析出要修改的函数，进而进行hook： https://www.52pojie.cn/thread-1174141-1-1.html https://mp.weixin.qq.com/s/OVgfyY0jgRSZKfAKxCGxfg END 往期推荐: 值得收藏 |解决99%的手机APP抓包问题 涵盖安卓/iOS客户端 打造属于自己的Android破解脱壳机，其实只需100块 爬取 58 同城房产数据，犯非法获取计算机信息系统数据罪：3 人被判 一款轻便小巧的网络验证的安装及快速购买阿里云教程| 造福小白 看我如何一步步干掉盗取通讯录+盗摄的裸聊App |渗透技术 欢迎关注微信公众号：『掌玩小子』讨论更多技术： ","date":"2022-01-07","objectID":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/:6:0","series":null,"tags":["iPhone"],"title":"Flex屏蔽越狱检测","uri":"/2022/01/flex%E5%B1%8F%E8%94%BD%E8%B6%8A%E7%8B%B1%E6%A3%80%E6%B5%8B/"},{"categories":null,"content":"FPS类型游戏的设计研究和游戏安全,反外挂研究 学习这套课程的基础包含少量的汇编知识和编程知识, 一定的数学知识和内存知识 基础建立在 任鸟飞2020课程 前100课的前提下即毫无压力的学习. 当然我们要从最简单的概念开始学习,请勿急躁 这个课题本着最简单易懂,从本质完全解析的态度,所以有任何细节不懂,哪怕是三角函数,都可以找我探讨 向量 可能大家问为什么要学习向量, 原因是向量是矩阵的元素,而矩阵是帮助我们快速计算的朋友 所以就算不能完全掌握,了解一下是必要的. 指具有大小和方向的量. 一维向量,例如 1 对应的就是从0到1的向量,大小是1,方向X正轴方向 我们说向量只有大小和方向, 不存在其他属性,所以 一维向量 1 也可以表示 从1到2 从-1到0 向量可以进行算数运算的.例如 1+1 =2 2个大小是1,方向X正轴方向的向量 相加等于1个大小是2,方向X正轴方向的向量 1*3 = 3 给向量放大3倍 二维向量,例如 2,3 书写格式为[2,3] 对应的是 从原点0,0 到 坐标 2,3 的向量, 大小就需要计算了 根据三角函数,大小等于 sqrt(22+33) ,同样这也是计算 二维空间2点的距离公式 (三角函数:直角三角形,斜边的平方 = 底边平方+高平方 , 知道任意2边可以计算出另外一个边的长度) 距离 = sqrt((X1-x2)(X1-x2)+(y1-y2)(y1-y2)); 方向如图所示,我们下面再讲 向量只有大小和方向,同样二维向量 [2,3] 也可以表示 从3,0到5,3 ,可以任意位置开始 二维向量也可以进行算数运算. 例如 [2,3]+[2,1] = [4,4] 向量的乘法 [2,3]*[3,3] = 6+9= 15 向量的内积 向量的减法可以把空间2点的绝对坐标转化为相对坐标 [X1,Y1] - [X2,Y2]= [X1-X2, Y1 - Y2],相当于把向量移动到原点 三角函数角度的问题 在游戏图像计算中角度是必不可少的部分 例如 我们知道了,如下三角形 高为3 底边为2 那么tanA = 3/2 我们想求A的角度怎么办呢? C++给我们提供API函数 A = atan(3,2); 这样就计算出来 A的角度了 不过atan()的返回值是弧度,我们如果想转为真正的角度 还是需要转换的 什么是弧度呢?你可以简单的理解为 正常角度如果是0-180的话 弧度就是 0- π 那么 atan(3,2) *180 / π 就把弧度转换成角度了 最终 A = atan(3,2)*180 / π; 另外一种情况, 知道了角度,想求边长 例如一个向量[?,5] 角度是东偏北 60度 我们怎么计算向量值呢? 很简单, tan 60 = 5/底边 底边 = 5/ tan60,当然这里的角度参数也是弧度 ,如果你的是真实角度,我们又要把角度转换成弧度 最终 底边 = 5 / tan (60*π/180) ; 其他的 sin cos 也是同理,我们不是学习数学,所以暂时了解即可,后面用到再说. 三维向量 例如 2,1,3 格式[2,1,3] 向量写成行 或则列都可以 行向量 [2,1,3] 列向量 [ 2 1 3 ] 三维向量对应的是三维空间 2,1,3对应的是x,y,z (注: 三维坐标系,很多书本是Y 为高度轴,切记X,Y,Z只是个符号,你可以起名叫a b c 也没问题 调转一下坐标系X,就变成了Y ,所以没有区别,不要死记名字,按照自己习惯来) [2,1,3]就是从原点到坐标2,1,3的向量 大小计算就更加复杂一点了 先看懂下图的辅助线 根据三角函数,向量的大小等于 sqrt(11+22+3*3) ,同样这也是计算 三维空间2点的距离公式 距离 = sqrt((X1-x2)(X1-x2)+(y1-y2)(y1-y2)+(z1-z2)*(z1-z2)); 而方向不再单纯是一个角度了,他包含水平角度 和 高低角度,这个我们后面再讲 向量的减法可以把三维空间2点的绝对坐标转化为相对坐标 [X1,Y1,Z1] - [X2,Y2,Z2]= [X1-X2, Y1 - Y2,Z1-Z2],相当于把向量移动到原点 同样三维向量也可以进行 加法 乘法等运算 例如[X1,y1,z1] * [1,2,3] = X1+y12+z13 向量的内积 到这里是不是对几何和线性代数的基础知识不再陌生了,其实就这点东西,很简单. 矩阵 为什么要学习矩阵,对于我们研究的课题来说,就是为了方便计算以及精准计算的,当然你可以不用. 多个向量组合成一个矩阵 矩阵可以看做一个特殊的向量，而向量也可以看做一个特殊的矩阵。 只有一行的矩阵 为行向量 行矩阵 只有一列的矩阵 为列向量 列矩阵 格式为 行*列 例如 3*3 矩阵: 1 2 3 5 7 1 2 2 1 例如 3*4 矩阵 1 2 3 5 5 7 1 1 2 2 1 2 同形矩阵 可以相加减(毕竟如果不是同型的话,没有办法对应相加减 这很好理解) 稍微有点难度的是矩阵相乘除 那么大家要注意的是: 1.矩阵是 多个向量的组合,矩阵的乘除就是 向量的乘除,而不是单独元素的乘除 2.两个矩阵相乘,用第一个矩阵的行 乘 第二个矩阵的列的方式 计算 由于使用方法的区别 AB != BA 而且 A* 不同的矩阵 结果可能相同 3.计算结果的存放 例如 2个2*2 矩阵相乘 第一行*第一列 放到 第一行第一列 第一行*第二列 放到 第一行第二列 第二行*第一列 放到 第二行第一列 第二行*第二列 放到 第二行第二列 a1 a2 乘 b1 b2 = a1b1 + a2b3 a1b2 + a2b4 a3 a4 b3 b4 a3b1 +a4b3 a3b2 + a4b4 mn 矩阵 和 ij 矩阵 由于是行 *列 所以 mn 矩阵一行的元素 要和 ij 矩阵一列的元素 必须相同 也就是 n == i 主要满足这个条件就可以相乘 否则不可以 矩阵特性 矩阵对于我们来说就是为了方便计算而生,并不是无可取代 举个例子 只有对角线为1 其他都是0的矩阵 单位矩阵 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 任何矩阵乘以 单位矩阵都为原来矩阵 把 1换成2 就是 放大2倍 比你一个元素一个元素的*2方便很多吧? 矩阵取一列 1 0 0 X 乘 0 = X 取X Y Z 向量 0 1 0 Y 0 Y 0 0 1 Z 0 Z 0 0 0 1 1 1 单独放大某个元素 X 0 0 0 乘 0 = 0 Z 扩大10倍 0 Y 0 0 0 0 0 0 Z 0 10 10Z 0 0 0 1 1 1 矩阵的乘法可以实现很多的功能 看起来是不是很方便,很强大?! 不借助矩阵把游戏坐标转换成屏幕坐标 无论是在窗口上绘制窗体,还是画各种方框,最核心的功能就是在于如何把游戏坐标也就是世界坐标转换成屏幕坐标. 这里我们先不借助于强大好用的矩阵,单纯用几何算法转换一下坐标 图看起来有点乱,我们慢慢来 这是游戏 上方俯视的平面图: 如果有不懂可以加我Q2217777779,会尽力帮助解答 1.水平可视角度 一般为90度, 也就是FOV 或则第一人称视角 但是这个值只是约值,可能不精准也是导致后面不精准的原因之一 2.我们准星一直在屏幕正中心的,所以向前做一个垂线,左右各45度 3.我们把三角形补全,等腰三角形的斜边就是我们的可视范围,任何游戏中的物品 敌人和我们的连线只有和这个斜边有交单才会显示到我们的屏幕中 如图中敌人和我们连线 焦点就是红色圆圈 4.角度A 可以根据具体朝向值简单分析出来,后面数据分析的时候再说 5.红色圆圈 在 AB 这条线上的位置 就是敌人在我们屏幕X坐标的等比例位置 所以这样就可以计算出来 屏幕坐标X了 tanA = X差/ (AB/2); 那么 X差 = tanA*(AB/2); X差/(AB/2) = 屏幕坐标差/ (分辨率_宽度/2) 继续替换 tanA = 屏幕坐标差/ (分辨率_宽度/2) 角度还要转换一下成弧度 最终 屏幕坐标差 = tan(A*π/180) *(分辨率_宽度/2); 屏幕坐标 = 屏幕坐标差 + 分辨率_宽度/2; int 水平差 = (int)(tan(水平角度差 * 3.1416 / 180) * ((m_分辨率宽) / 2)); 屏幕坐标.x = (float)(m_分辨率宽 / 2 + 水平差); 屏幕坐标.y 也是同样的计算方法,不过屏幕宽高是不相同的,所以可视角也是有区别的 屏幕分辨率_高/屏幕分辨率_宽 = 高低可视角度 / 水平可视角度 int 高度差 = (int)(tan(高低角度差 * 3.1416 / 180) * ((m_分辨率宽) / 2));// 这里也是m_分辨率宽 因为可视角度不是45了,而是分辨率计算出来的角度 屏幕坐标.y = (float)(m_分辨率高 / 2 + 高度差); 最终代码如下: bool 绘制::世界坐标转屏幕坐标_非矩阵(坐标结构_2\u0026 屏幕坐标, FLOAT 水平角度差, FLOAT 高低角度差) { 取窗口信息(); FLOAT 高低可视角度 = (FLOAT)((double)atan2(m_分辨率高, m_分辨率宽)*180/3.1415); if (fabs(水平角度差) \u003e 45 || fabs(高低角度差) \u003e 高低可视角度) { return false;// 不在屏幕范围内 } int 水平差 = (int)(tan(水平角度差 * 3.1416 / 180) * ((m_分辨率宽) / 2)); 屏幕坐标.x = (float)(m_","date":"2022-01-07","objectID":"/2022/01/fps%E6%B8%B8%E6%88%8F%E7%BB%98%E5%88%B6%E4%B8%80/:0:0","series":null,"tags":["飞郁精品帖"],"title":"FPS游戏绘制(一)","uri":"/2022/01/fps%E6%B8%B8%E6%88%8F%E7%BB%98%E5%88%B6%E4%B8%80/"},{"categories":null,"content":"lua基本语法 Lua 学习起来非常简单，我们可以创建第一个 Lua 程序！ ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"打印输出 print(\"Hello World\") ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"单行注释 两个减号是单行注释: -- ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"多行注释 两个减号是单行注释: --[[ 多行注释 多行注释 --]] ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:3","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"变量名称 Lua 标示符用于定义一个变量，函数获取其他用户定义的项。标示符以一个字母 A 到 Z 或 a 到 z 或下划线 _ 开头后加上 0 个或多个字母，下划线，数字（0 到 9）。 最好不要使用下划线加大写字母的标示符，因为Lua的保留字也是这样的。 Lua 不允许使用特殊字符如 @, $, 和 % 来定义标示符。 Lua 是一个区分大小写的编程语言。因此在 Lua 中 Nspirit 与 nspirit 是两个不同的标示符。以下列出了一些正确的变量名称： 案例 mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal 关键词不可以被用来定义变量名称 关键词 and break do else elseif end false for function if in local nil not or repeat return then true until while goto 一般约定，以下划线开头连接一串大写字母的名字（比如 _VERSION）被保留用于 Lua 内部全局变量。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:4","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"全局变量 在默认情况下，变量总是认为是全局的。 全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的全局变量也不会出错，只不过得到的结果是：nil。 print(b) --\u003e nil b=10 print(b) --\u003e 10 如果你想删除一个全局变量，只需要将变量赋值为nil。 b = nil print(b) --\u003e nil ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:5","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"局部变量 只需要在变量名称前 加一个 local，该全局变量就会变为局部变量 local x = 10 ; 局部变量值在作用域 范围内有效 什么是域？ 比如当前lua文件，或者当前function 内,还是不懂请进入QQ群内，讨论咨询。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:1:6","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"数据类型 Lua 是动态类型语言，变量不要类型定义,只需要为变量赋值。 值可以存储在变量中，作为参数传递或结果返回。 Lua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、thread 和 table。 类型 描述 nil 这个最简单，只有值nil属于该类，表示一个无效值（在条件表达式中相当于false）。 boolean 包含两个值：false和true。 number 表示双精度类型的实浮点数 function 由 C 或 Lua 编写的函数 userdata 表示任意存储在变量中的C数据结构 thread 表示执行的独立线路，用于执行协同程序 table Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字、字符串或表类型。在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。 实例 print(type(\"Hello world\")) --\u003e string print(type(10.4*3)) --\u003e number print(type(print)) --\u003e function print(type(type)) --\u003e function print(type(true)) --\u003e boolean print(type(nil)) --\u003e nil print(type(type(X))) --\u003e string ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"nil （空） nil 类型表示一种没有任何有效值，它只有一个值 – nil，例如打印一个没有赋值的变量，便会输出一个 nil 值： print(type(a)) --\u003e nil 对于全局变量和 table，nil 还有一个\"删除\"作用，给全局变量或者 table 表里的变量赋一个 nil 值，等同于把它们删掉，执行下面代码就知： tab1 = { key1 = \"val1\", key2 = \"val2\", \"val3\" } for k, v in pairs(tab1) do print(k .. \" - \" .. v) end tab1.key1 = nil for k, v in pairs(tab1) do print(k .. \" - \" .. v) end nil 作比较时应该加上双引号 “： type(X) --\u003e nil type(X)==nil --\u003e nil type(X)==\"nil\" --\u003e true ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"boolean （布尔） boolean 类型只有两个可选值：true（真） 和 false（假），Lua 把 false 和 nil 看作是 false，其他的都为 true，数字 0 也是 true: print(type(true)) print(type(false)) print(type(nil)) if false or nil then print(\"至少有一个是 true\") else print(\"false 和 nil 都为 false\") end if 0 then print(\"数字 0 是 true\") else print(\"数字 0 为 false\") end 以上代码执行结果 boolean boolean nil false 和 nil 都为 false 数字 0 是 true ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"number （数字） Lua 默认只有一种 number 类型 – double（双精度）类型（默认类型可以修改 luaconf.h 里的定义），以下几种写法都被看作是 number 类型： print(type(2)) --\u003e number print(type(2.2)) --\u003e number print(type(0.2)) --\u003e number print(type(2e+1)) --\u003e number print(type(0.2e-1)) --\u003e number print(type(7.8263692594256e-06)) --\u003e number ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:3","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"string （字符串） 字符串由一对双引号或单引号来表示。 string1 = \"this is string1\" string2 = 'this is string2' 也可以用 2 个方括号 “[[]]” 来表示\"一块\"字符串。 html = [[ \u003chtml\u003e \u003chead\u003e\u003c/head\u003e \u003cbody\u003e \u003ca href=\"http://www.nspirit.cn/\"\u003e节点精灵\u003c/a\u003e \u003c/body\u003e \u003c/html\u003e ]] print(html) 在对一个数字字符串上进行算术操作时，Lua 会尝试将这个数字字符串转成一个数字: print(\"2\" + 6) --\u003e8.0 print(\"2\" + \"6\") --\u003e8.0 print(\"2 + 6\") --\u003e 2 + 6 print(\"-2e2\" * \"6\") --\u003e -1200.0 print(\"error\" + 1) --\u003e -- stdin:1: attempt to perform arithmetic on a string value -- stack traceback: -- stdin:1: in main chunk -- [C]: in ? 以上代码中\"error” + 1执行报错了，字符串连接使用的是 .. ，如： print(\"a\" .. 'b') --\u003eab print(157 .. 428) --\u003e157428 使用 # 来计算字符串的长度，放在字符串前面，如下实例： len = \"www.nspirit.cn\" print(#len) --\u003e 14 print(#\"www.nspirit.cn\") --\u003e14 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:4","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"table （表） 在 Lua 里，table 的创建是通过\"构造表达式\"来完成，最简单构造表达式是{}，用来创建一个空表。也可以在表里添加一些数据，直接初始化表: -- 创建一个空的 table local tbl1 = {} -- 直接初始表 local tbl2 = {\"apple\", \"pear\", \"orange\", \"grape\"} Lua 中的表（table）其实是一个\"关联数组\"（associative arrays），数组的索引可以是数字或者是字符串。 a = {} a[\"key\"] = \"value\" key = 10 a[key] = 22 a[key] = a[key] + 11 for k, v in pairs(a) do print(k .. \" : \" .. v) end -- 脚本执行结果为： --\u003e key : value --\u003e 10 : 33 不同于其他语言的数组把 0 作为数组的初始索引，在 Lua 里表的默认初始索引一般以 1 开始。 --实例 local tbl = {\"apple\", \"pear\", \"orange\", \"grape\"} for key, val in pairs(tbl) do print(\"Key\", key) end -- 脚本执行结果为： --\u003e Key 1 --\u003e Key 2 --\u003e Key 3 --\u003e Key 4 table 不会固定长度大小，有新数据添加时 table 长度会自动增长，没初始的 table 都是 nil。 a3 = {} for i = 1, 10 do a3[i] = i end a3[\"key\"] = \"val\" print(a3[\"key\"]) print(a3[\"none\"]) -- 执行结果为： --\u003e val --\u003e nil ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:5","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"function (函数) 在 Lua 中，函数是被看作是\"第一类值（First-Class Value）\"，函数可以存在变量里: function factorial1(n) if n == 0 then return 1 else return n * factorial1(n - 1) end end print(factorial1(5)) factorial2 = factorial1 print(factorial2(5)) -- 输出结果为： --\u003e 120 --\u003e 120 function 可以以匿名函数（anonymous function）的方式通过参数传递: function testFun(tab,fun) for k ,v in pairs(tab) do print(fun(k,v)); end end tab={key1=\"val1\",key2=\"val2\"}; testFun(tab, function(key,val)--匿名函数 return key..\"=\"..val; end ); --输出结果 --\u003e key1 = val1 --\u003e key2 = val2 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:6","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"thread （携程） 在节点精灵中 不生效，已用java thread 做代替 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:7","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"userdata (自定义数据类型) userdata 是一种用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型，可以将任意 C/C++ 的任意数据类型的数据（通常是 struct 和 指针）存储到 Lua 变量中调用。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:2:8","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"变量 变量在使用前，需要在代码中进行声明，即创建该变量。 编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。 Lua 变量有三种类型：全局变量、局部变量、表中的域。 Lua 中的变量全是全局变量，哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。 局部变量的作用域为从声明位置开始到所在语句块结束。 变量的默认值均为 nil。 a = 5 -- 全局变量 local b = 5 -- 局部变量 function joke() c = 5 -- 全局变量 local d = 6 -- 局部变量 end joke() print(c) --\u003e 5 print(d) --\u003e nil do local a = 6 -- 局部变量 b = 6 -- 对局部变量重新赋值 print(a,b); --\u003e 6 6 end print(a,b) --\u003e 5 6 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"赋值语句 赋值是改变一个变量的值和改变表域的最基本的方法。 a = \"hello\" .. \"world\" t.n = t.n + 1 Lua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的值会依次赋给左边的变量。 a, b = 10, 2*x --\u003c\u003e a=10; b=2*x 遇到赋值语句Lua会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值： x, y = y, x -- swap 'x' for 'y' a[i], a[j] = a[j], a[i] -- swap 'a[i]' for 'a[j]' 当变量个数和值的个数不一致时，Lua会一直以变量个数为基础采取以下策略： -- a. 变量个数 \u003e 值的个数 按变量个数补足nil -- b. 变量个数 \u003c 值的个数 多余的值会被忽略 a, b, c = 0, 1 print(a,b,c) --\u003e 0 1 nil a, b = a+1, b+1, b+2 -- value of b+2 is ignored print(a,b) --\u003e 1 2 a, b, c = 0,0,0 print(a,b,c) --\u003e 0 nil nil 多值赋值经常用来交换变量，或将函数调用返回给变量： a, b = f() --f()返回两个值，第一个赋给a，第二个赋给b。 -- 应该尽可能的使用局部变量，有两个好处： -- 1.避免命名冲突。 -- 2.访问局部变量的速度比全局变量更快。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:3:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"索引 对 table 的索引使用方括号 []。Lua 也提供了 . 操作。 t[i] t.i – 当索引为字符串类型时的一种简化写法 gettable_event(t,i) – 采用索引访问本质上是一个类似这样的函数调用 site = {} site[\"key\"] = \"www.nspirit.cn\" print(site[\"key\"]) --\u003e www.nspirit.cn print(site.key) --\u003e www.nspirit.cn ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:3:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"循环 很多情况下我们需要做一些有规律性的重复操作，因此在程序中就需要重复执行某些语句。 一组被重复执行的语句称之为循环体，能否继续重复，决定循环的终止条件。 循环结构是在一定条件下反复执行某段程序的流程结构，被反复执行的程序被称为循环体。 循环语句是由循环体及循环的终止条件两部分组成的。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"while 循环 Lua 编程语言中 while 循环语句在判断条件为 true 时会重复执行循环体语句。 a=10 while( a \u003c 20 ) do print(\"a 的值为:\", a) a = a+1 end ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:4:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"for 循环 for i=10,1,-1 do print(i) end --打印数组a的所有值 a = {\"one\", \"two\", \"three\"} for i, v in ipairs(a) do print(i, v) end ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:4:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"流程控制 Lua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时执行指定程序代码，在条件为 false 时执行其他指定代码。 控制结构的条件表达式结果可以是任何值，Lua认为false和nil为假，true和非nil为真。 要注意的是Lua中 0 为 true： if(0) then print(\"0 为 true\") end ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"if 语句 Lua if 语句 由一个布尔表达式作为条件判断，其后紧跟其他语句组成。 --[ 定义变量 --] a = 10; --[ 使用 if 语句 --] if( a \u003c 20 ) then --[ if 条件为 true 时打印以下信息 --] print(\"a 小于 20\" ); end print(\"a 的值为:\", a); ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:5:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"if else 语句 以下实例用于判断变量 a 的值： a = 100; --[ 检查条件 --] if( a \u003c 20 ) then --[ if 条件为 true 时执行该语句块 --] print(\"a 小于 20\" ) else --[ if 条件为 false 时执行该语句块 --] print(\"a 大于 20\" ) end print(\"a 的值为 :\", a) Lua if 语句可以与 elseif…else 语句搭配使用, 在 if 条件表达式为 false 时执行 elseif…else 语句代码块，用于检测多个条件语句。 Lua if…elseif…else 语句语法格式如下： if( 布尔表达式 1) then --[ 在布尔表达式 1 为 true 时执行该语句块 --] elseif( 布尔表达式 2) then --[ 在布尔表达式 2 为 true 时执行该语句块 --] elseif( 布尔表达式 3) then --[ 在布尔表达式 3 为 true 时执行该语句块 --] else --[ 如果以上布尔表达式都不为 true 则执行该语句块 --] end ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:5:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"函数 在Lua中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，也可以用来计算一些值。 Lua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如print()函数可以将传入的参数打印在控制台上。 Lua 函数主要有两种用途： 1.完成指定的任务，这种情况下函数作为调用语句使用； 2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"函数定义 optional_function_scope function function_name( argument1, argument2, argument3..., argumentn) function_body return result_params_comma_separated end optional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local。 function_name: 指定函数名称。 argument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。 function_body: 函数体，函数中需要执行的代码语句块。 result_params_comma_separated: 函数返回值，Lua语言函数可以返回多个值，每个值以逗号隔开。 以下实例定义了函数 max()，参数为 num1, num2，用于比较两值的大小，并返回最大值： function max(num1, num2) if (num1 \u003e num2) then result = num1; else result = num2; end return result; end -- 调用函数 print(\"两值比较最大值为 \"..max(10,4)) --\u003e 两值比较最大值为 10 print(\"两值比较最大值为 \"..max(5,6)) --\u003e 两值比较最大值为 6 Lua 中我们可以将函数作为参数传递给函数，如下实例： myprint = function(param) print(\"这是打印函数 - ##\"..param..\"##\") end function add(num1,num2,functionPrint) result = num1 + num2 -- 调用传递的函数参数 functionPrint(result) end myprint(10) -- myprint 函数作为参数传递 add(2,5,myprint) --输出结果 -- 这是打印函数 - ## 10 ## -- 这是打印函数 - ## 7 ## Lua函数可以返回多个结果值，比如string.find，其返回匹配串\"开始和结束的下标\"（如果不存在匹配串返回nil）。 s, e = string.find(\"www.nspirit.cn\", \"nspirit\") print(s..','..e); -- \u003e 5,11 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:6:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"可变参数 Lua 函数可以接受可变数目的参数，和 C 语言类似，在函数参数列表中使用三点 … 表示函数有可变的参数。 function average(...) result = 0 local arg={...} --\u003e arg 为一个表，局部变量 for i,v in ipairs(arg) do result = result + v end print(\"总共传入 \" .. #arg .. \" 个数\") return result/#arg end print(\"平均值为\",average(10,5,3,4,5,6)) -- 以上代码执行结果为： -- 总共传入 6 个数 -- 平均值为 5.5 我们也可以通过 select(\"#\",…) 来获取可变参数的数量: function average(...) result = 0 local arg={...} for i,v in ipairs(arg) do result = result + v end print(\"总共传入 \" .. select(\"#\",...) .. \" 个数\") return result/select(\"#\",...) end print(\"平均值为\"..average(10,5,3,4,5,6)) 有时候我们可能需要几个固定参数加上可变参数，固定参数必须放在变长参数之前: function fwrite(fmt, ...) ---\u003e 固定的参数fmt return print(string.format(fmt, ...)) end fwrite(\"nspirit\\n\") ---\u003efmt = \"nspirit\", 没有变长参数。 fwrite(\"%d%d\\n\", 1, 2) ---\u003efmt = \"%d%d\", 变长参数为 1 和 2 通常在遍历变长参数的时候只需要使用 {…}，然而变长参数可能会包含一些 nil，那么就可以用 select 函数来访问变长参数了：select(’#’, …) 或者 select(n, …) select(’#’, …) 返回可变参数的长度。 select(n, …) 用于返回从起点 n 开始到结束位置的所有参数列表。 调用 select 时，必须传入一个固定实参 selector(选择开关) 和一系列变长参数。如果 selector 为数字 n，那么 select 返回参数列表中从索引 n 开始到 结束位置的所有参数列表，否则只能为字符串 #，这样 select 返回变长参数的总数。 function f(...) a = select(3,...) --\u003e从第三个位置开始，变量 a 对应右边变量列表的第一个参数 print (a) end f(0,1,2,3,4,5) -- 输出结果 -- 2 do function foo(...) for i = 1, select('#', ...) do --\u003e获取参数总数 local arg = select(i, ...); --\u003e读取参数，arg 对应的是右边变量列表的第一个参数 print(\"arg:\".. arg); end end foo(1, 2, 3, 4); end -- 输出结果 -- 1 -- 2 -- 3 -- 4 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:6:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"运算符 运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。Lua提供了以下几种运算符类型： 算术运算符 关系运算符 逻辑运算符 其他运算符 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"算术运算符 操作符 描述 实例 + 加法 A + B 输出结果 30 - 减法 A - B 输出结果 -10 * 乘法 A * B 输出结果 200 / 除法 B / A 输出结果 2 % 取余 B % A 输出结果 0 ^ 乘幂 A^2 输出结果 100 - 负号 -A 输出结果 -10 a = 21 b = 10 c = a + b print(\"Line 1 - c 的值为 \".. c ) c = a - b print(\"Line 2 - c 的值为 \".. c ) c = a * b print(\"Line 3 - c 的值为 \".. c ) c = a / b print(\"Line 4 - c 的值为 \".. c ) c = a % b print(\"Line 5 - c 的值为 \".. c ) c = a^2 print(\"Line 6 - c 的值为 \".. c ) c = -a print(\"Line 7 - c 的值为 \".. c ) --输出结果为 -- Line 1 - c 的值为 31 -- Line 2 - c 的值为 11 -- Line 3 - c 的值为 210 -- Line 4 - c 的值为 2.1 -- Line 5 - c 的值为 1 -- Line 6 - c 的值为 441.0 -- Line 7 - c 的值为 -21 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"关系运算符 下表列出了 Lua 语言中的常用关系运算符，设定 A 的值为10，B 的值为 20： 操作符 描述 实例 == 等于，检测两个值是否相等，相等返回 true，否则返回 false (A == B) 为 false。 ~= 不等于，检测两个值是否相等，不相等返回 true，否则返回 false (A ~= B) 为 true。 \u003e 大于，如果左边的值大于右边的值，返回 true，否则返回 false (A \u003e B) 为 false。 \u003c 小于，如果左边的值大于右边的值，返回 false，否则返回 true (A \u003c B) 为 true。 \u003e= 大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false (A \u003e= B) 返回 false。 \u003c= 小于等于， 如果左边的值小于等于右边的值，返回 true，否则返回 false (A \u003c= B) 返回 true。 我们可以通过以下实例来更加透彻的理解关系运算符的应用： a = 21 b = 10 if( a == b ) then print(\"Line 1 - a 等于 b\" ) else print(\"Line 1 - a 不等于 b\" ) end if( a ~= b ) then print(\"Line 2 - a 不等于 b\" ) else print(\"Line 2 - a 等于 b\" ) end if ( a \u003c b ) then print(\"Line 3 - a 小于 b\" ) else print(\"Line 3 - a 大于等于 b\" ) end if ( a \u003e b ) then print(\"Line 4 - a 大于 b\" ) else print(\"Line 5 - a 小于等于 b\" ) end -- 修改 a 和 b 的值 a = 5 b = 20 if ( a \u003c= b ) then print(\"Line 5 - a 小于等于 b\" ) end if ( b \u003e= a ) then print(\"Line 6 - b 大于等于 a\" ) end -- 脚本输出： -- Line 1 - a 不等于 b -- Line 2 - a 不等于 b -- Line 3 - a 大于等于 b -- Line 4 - a 大于 b -- Line 5 - a 小于等于 b -- Line 6 - b 大于等于 a ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"逻辑运算符 下表列出了 Lua 语言中的常用逻辑运算符，设定 A 的值为 true，B 的值为 false： 操作符 描述 实例 and 逻辑与操作符。 若 A 为 false，则返回 A，否则返回 B。 (A and B) 为 false。 or 逻辑或操作符。 若 A 为 true，则返回 A，否则返回 B。 (A or B) 为 true。 not 逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。 not(A and B) 为 true。 我们可以通过以下实例来更加透彻的理解逻辑运算符的应用： a = true b = true if ( a and b ) then print(\"a and b - 条件为 true\" ) end if ( a or b ) then print(\"a or b - 条件为 true\" ) end print(\"---------分割线---------\" ) -- 修改 a 和 b 的值 a = false b = true if ( a and b ) then print(\"a and b - 条件为 true\" ) else print(\"a and b - 条件为 false\" ) end if ( not( a and b) ) then print(\"not( a and b) - 条件为 true\" ) else print(\"not( a and b) - 条件为 false\" ) end --输出 -- a and b - 条件为 true -- a or b - 条件为 true ---------分割线--------- -- a and b - 条件为 false -- not( a and b) - 条件为 true ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:3","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"其他运算符 操作符 描述 实例 .. 连接两个字符串 a..b ，其中 a 为 “Hello \" ， b 为 “World”, 输出结果为 “Hello World”。 # 一元运算符，返回字符串或表的长度。 #“Hello” 返回 5 我们可以通过以下实例来更加透彻的理解连接运算符与计算表或字符串长度的运算符的应用： a = \"Hello \" b = \"World\" print(\"连接字符串 a 和 b \", a..b ) print(\"b 字符串长度 \",#b ) print(\"字符串 Test 长度 \",#\"Test\" ) print(\"节点精灵网址长度 \",#\"www.nspirit.cn\" ) -- 以上程序执行结果为： -- 连接字符串 a 和 b Hello World -- b 字符串长度 5 -- 字符串 Test 长度 4 -- 菜鸟教程网址长度 14 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:4","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"运算符优先级 从高到低的顺序： ^ not - (unary) * / % + - .. \u003c \u003e \u003c= \u003e= ~= == and or 除了 ^ 和 .. 外所有的二元运算符都是左连接的。 a+i \u003c b/2+1 \u003c--\u003e (a+i) \u003c ((b/2)+1) 5+x^2*8 \u003c--\u003e 5+((x^2)*8) a \u003c y and y \u003c= z \u003c--\u003e (a \u003c y) and (y \u003c= z) -x^2 \u003c--\u003e -(x^2) x^y^z \u003c--\u003e x^(y^z) 我们可以通过以下实例来更加透彻的了解 Lua 语言运算符的优先级： a = 20 b = 10 c = 15 d = 5 e = (a + b) * c / d;-- ( 30 * 15 ) / 5 print(\"(a + b) * c / d 运算值为 :\"..e ) e = ((a + b) * c) / d; -- (30 * 15 ) / 5 print(\"((a + b) * c) / d 运算值为 :\"..e ) e = (a + b) * (c / d);-- (30) * (15/5) print(\"(a + b) * (c / d) 运算值为 :\"..e ) e = a + (b * c) / d; -- 20 + (150/5) print(\"a + (b * c) / d 运算值为 :\"..e ) --输出结果 -- (a + b) * c / d 运算值为 : 90.0 -- ((a + b) * c) / d 运算值为 : 90.0 -- (a + b) * (c / d) 运算值为 : 90.0 -- a + (b * c) / d 运算值为 : 50.0 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:7:5","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"字符串 字符串或串(String)是由数字、字母、下划线组成的一串字符。 Lua 语言中字符串可以使用以下三种方式来表示： 单引号间的一串字符。 双引号间的一串字符。 [[ 与 ]] 间的一串字符。 以上三种方式的字符串实例如下： string1 = \"Lua\" print(\"\\\"字符串 1 是\\\"\"..string1) string2 = 'nspirit.com' print(\"字符串 2 是\"..string2) string3 = [[\"Lua 教程\"]] print(\"字符串 3 是\"..string3) -- \"字符串 1 是\" Lua -- 字符串 2 是 nspirit.cn -- 字符串 3 是 \"Lua 教程\" ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"转义字符 转义字符用于表示不能直接显示的字符，比如后退键，回车键，等。如在字符串转换双引号可以使用 “\"\"。 所有的转义字符和所对应的意义： 转义字符 意义 ASCII码值（十进制） \\a 响铃(BEL) 007 \\b 退格(BS) ，将当前位置移到前一列 008 \\f 换页(FF)，将当前位置移到下页开头 012 \\n 换行(LF) ，将当前位置移到下一行开头 010 \\r 回车(CR) ，将当前位置移到本行开头 013 \\t 水平制表(HT) （跳到下一个TAB位置） 009 \\v 垂直制表(VT) 011 \\ 代表一个反斜线字符’'' 092 ' 代表一个单引号（撇号）字符 039 \" 代表一个双引号字符 034 \\0 空字符(NULL) 000 \\ddd 1到3位八进制数所代表的任意字符 三位八进制 \\xhh 1到2位十六进制所代表的任意字符 二位十六进制 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"字符串操作 Lua 提供了很多的方法来支持字符串的操作： 字符串全部转为大写字母。 res = string.upper(\"abcde\"): print(res) --\u003e ABCDE 字符串全部转为小写字母。 res = string.lower(\"AbCe\"): print(res) --\u003e abce 在字符串中替换。 string.gsub(mainString,findString,replaceString,num) mainString 为要操作的字符串， findString 为被替换的字符，replaceString 要替换的字符，num 替换次数（可以忽略，则全部替换），如： string.gsub(\"aaaa\",\"a\",\"z\",3); -- zzza 3 在一个指定的目标字符串 str 中搜索指定的内容 substr，如果找到了一个匹配的子串，就会返回这个子串的起始索引和结束索引，不存在则返回 nil。 以下实例查找字符串 “Lua” 的起始索引和结束索引位置： string.find(\"Hello Lua user\", \"Lua\", 1) --\u003e 7 9 字符串反转 string.reverse(arg) res = string.reverse(\"Lua\") print(res) --\u003e auL 返回一个类似printf的格式化字符串 string.format(…) res = string.format(\"the value is:%d\",4) print(res) --\u003ethe value is:4 char 将整型数字转成字符并连接， byte 转换字符为整数值(可以指定某个字符，默认第一个字符)。 res = string.char(97,98,99,100) print(res) --\u003e abcd res = string.byte(\"ABCD\",4) print(res) --\u003e 68 res = string.byte(\"ABCD\") print(res) --\u003e 65 计算字符串长度。 string.len(arg) res = string.len(\"abc\") print(res) 返回字符串string的n个拷贝 string.rep(string, n) string.rep(\"abcd\",2) --\u003e abcdabcd 链接两个字符串 .. print(\"www.nspirit.\"..\"cn\") --\u003e www.nspirit.cn 回一个迭代器函数，每一次调用这个函数，返回一个在字符串 str 找到的下一个符合 pattern 描述的子串。如果参数 pattern 描述的字符串没有找到，迭代函数返回nil。 for word in string.gmatch(\"Hello Lua user\", \"%a+\") do print(word) end -- 输出结果 -- Hello -- Lua -- user string.match()只寻找源字串str中的第一个配对. 参数init可选, 指定搜寻过程的起点, 默认为1。 在成功配对时, 函数将返回配对表达式中的所有捕获结果; 如果没有设置捕获标记, 则返回整个配对字符串. 当没有成功的配对时, 返回nil。 string.match(\"I have 2 questions for you.\", \"%d+ %a+\") --\u003e 2 questions string.format(\"%d, %q\", string.match(\"I have 2 questions for you.\", \"(%d+) (%a+)\")) --\u003e 2, \"questions\" ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"字符串截取 字符串截取使用 sub() 方法。 string.sub() 用于截取字符串，原型为： string.sub(s, i [, j]) 参数说明： s：要截取的字符串。 i：截取开始位置。 j：截取结束位置，默认为 -1，最后一个字符。 -- 字符串 local sourcestr = \"prefix--nspiritgoogletaobao--suffix\" print(\"\\n原始字符串\".. string.format(\"%q\", sourcestr)) -- 截取部分，第4个到第15个 local first_sub = string.sub(sourcestr, 4, 15) print(\"\\n第一次截取\".. string.format(\"%q\", first_sub)) -- 取字符串前缀，第1个到第8个 local second_sub = string.sub(sourcestr, 1, 8) print(\"\\n第二次截取\".. string.format(\"%q\", second_sub)) -- 截取最后10个 local third_sub = string.sub(sourcestr, -10) print(\"\\n第三次截取\".. string.format(\"%q\", third_sub)) -- 索引越界，输出原始字符串 local fourth_sub = string.sub(sourcestr, -100) print(\"\\n第四次截取\".. string.format(\"%q\", fourth_sub)) ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:3","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"字符串格式化 Lua 提供了 string.format() 函数来生成具有特定格式的字符串, 函数的第一个参数是格式 , 之后是对应格式中每个代号的各种数据。 由于格式字符串的存在, 使得产生的长字符串可读性大大提高了。这个函数的格式很像 C 语言中的 printf()。 以下实例演示了如何对字符串进行格式化操作： 格式字符串可能包含以下的转义码: %c - 接受一个数字, 并将其转化为ASCII码表中对应的字符 %d, %i - 接受一个数字并将其转化为有符号的整数格式 %o - 接受一个数字并将其转化为八进制数格式 %u - 接受一个数字并将其转化为无符号整数格式 %x - 接受一个数字并将其转化为十六进制数格式, 使用小写字母 %X - 接受一个数字并将其转化为十六进制数格式, 使用大写字母 %e - 接受一个数字并将其转化为科学记数法格式, 使用小写字母e %E - 接受一个数字并将其转化为科学记数法格式, 使用大写字母E %f - 接受一个数字并将其转化为浮点数格式 %g(%G) - 接受一个数字并将其转化为%e(%E, 对应%G)及%f中较短的一种格式 %q - 接受一个字符串并将其转化为可安全被Lua编译器读入的格式 %s - 接受一个字符串并按照给定的参数格式化该字符串 为进一步细化格式, 可以在%号后添加参数. 参数将以如下的顺序读入: (1) 符号: 一个+号表示其后的数字转义符将让正数显示正号. 默认情况下只有负数显示符号. (2) 占位符: 一个0, 在后面指定了字串宽度时占位用. 不填时的默认占位符是空格. (3) 对齐标识: 在指定了字串宽度时, 默认为右对齐, 增加-号可以改为左对齐. (4) 宽度数值 (5) 小数位数/字串裁切: 在宽度数值后增加的小数部分n, 若后接f(浮点数转义符, 如%6.3f)则设定该浮点数的小数只保留n位, 若后接s(字符串转义符, 如%5.3s)则设定该字符串只显示前n位. string1 = \"Lua\" string2 = \"Tutorial\" number1 = 10 number2 = 20 -- 基本字符串格式化 print(string.format(\"基本格式化 %s %s\",string1,string2)) -- 日期格式化 date = 2; month = 1; year = 2014 print(string.format(\"日期格式化 %02d/%02d/%03d\", date, month, year)) -- 十进制格式化 print(string.format(\"%.4f\",1/3)) 其他例子 string.format(\"%c\", 83) -- 输出S string.format(\"%+d\", 17.0) -- 输出+17 string.format(\"%05d\", 17) -- 输出00017 string.format(\"%o\", 17) -- 输出21 string.format(\"%u\", 3.14) -- 输出3 string.format(\"%x\", 13) -- 输出d string.format(\"%X\", 13) -- 输出D string.format(\"%e\", 1000) -- 输出1.000000e+03 string.format(\"%E\", 1000) -- 输出1.000000E+03 string.format(\"%6.3f\", 13) -- 输出13.000 string.format(\"%q\", \"One\\nTwo\") -- 输出\"One\\ -- Two\" string.format(\"%s\", \"monkey\") -- 输出monkey string.format(\"%10s\", \"monkey\") -- 输出 monkey string.format(\"%5.3s\", \"monkey\") -- 输出 mon ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:4","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"字符与整数相互转换 -- 字符转换 -- 转换第一个字符 print(string.byte(\"Lua\")) -- 转换第三个字符 print(string.byte(\"Lua\",3)) -- 转换末尾第一个字符 print(string.byte(\"Lua\",-1)) -- 第二个字符 print(string.byte(\"Lua\",2)) -- 转换末尾第二个字符 print(string.byte(\"Lua\",-2)) -- 整数 ASCII 码转换为字符 print(string.char(97)) --[[ 输出如下： 76 97 97 117 117 a --]] ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:5","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"匹配模式 Lua 中的匹配模式直接用常规的字符串来描述。 它用于模式匹配函数 string.find, string.gmatch, string.gsub, string.match。 你还可以在模式串中使用字符类。 字符类指可以匹配一个特定字符集合内任何字符的模式项。比如，字符类 %d 匹配任意数字。所以你可以使用模式串 %d%d/%d%d/%d%d%d%d 搜索 dd/mm/yyyy 格式的日期： s = \"Deadline is 30/05/1999, firm\" date = \"%d%d/%d%d/%d%d%d%d\" print(string.sub(s, string.find(s, date))) --\u003e 30/05/1999 下面的表列出了Lua支持的所有字符类： 单个字符(除 ^$()%.[]*+-? 外): 与该字符自身配对 .(点): 与任何字符配对 %a: 与任何字母配对 %c: 与任何控制符配对(例如\\n) %d: 与任何数字配对 %l: 与任何小写字母配对 %p: 与任何标点(punctuation)配对 %s: 与空白字符配对 %u: 与任何大写字母配对 %w: 与任何字母/数字配对 %x: 与任何十六进制数配对 %z: 与任何代表0的字符配对 %x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对 [数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对 当上述的字符类用大写书写时, 表示与非此字符类的任何字符配对. 例如, %S表示与任何非空白字符配对.例如，’%A’非字母的字符: local a,b= string.gsub(\"hello, up-down!\", \"%A\", \".\") print(a..b) --\u003ehello..up.down.4 数字4不是字符串结果的一部分，他是gsub返回的第二个结果，代表发生替换的次数。 在模式匹配中有一些特殊字符，他们有特殊的意义，Lua中的特殊字符如下： ( ) . % + - * ? [ ^ $ ‘%’ 用作特殊字符的转义字符，因此 ‘%.’ 匹配点；’%%’ 匹配字符 ‘%’。转义字符 ‘%‘不仅可以用来转义特殊字符，还可以用于所有的非字母的字符。 单个字符类匹配该类别中任意单个字符； 单个字符类跟一个 ‘*’， 将匹配零或多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘+’， 将匹配一或更多个该类的字符。 这个条目总是匹配尽可能长的串； 单个字符类跟一个 ‘-’， 将匹配零或更多个该类的字符。 和 ‘*’ 不同， 这个条目总是匹配尽可能短的串； 单个字符类跟一个 ‘?’， 将匹配零或一个该类的字符。 只要有可能，它会匹配一个； %n， 这里的 n 可以从 1 到 9； 这个条目匹配一个等于 n 号捕获物（后面有描述）的子串。 %bxy， 这里的 x 和 y 是两个明确的字符； 这个条目匹配以 x 开始 y 结束， 且其中 x 和 y 保持 平衡 的字符串。 意思是，如果从左到右读这个字符串，对每次读到一个 x 就 +1 ，读到一个 y 就 -1， 最终结束处的那个 y 是第一个记数到 0 的 y。 举个例子，条目 %b() 可以匹配到括号平衡的表达式。 %f[set]， 指 边境模式； 这个条目会匹配到一个位于 set 内某个字符之前的一个空串， 且这个位置的前一个字符不属于 set 。 集合 set 的含义如前面所述。 匹配出的那个空串之开始和结束点的计算就看成该处有个字符 ‘\\0’ 一样。 模式： 模式 指一个模式条目的序列。 在模式最前面加上符号 ‘^’ 将锚定从字符串的开始处做匹配。 在模式最后面加上符号 ‘$’ 将使匹配过程锚定到字符串的结尾。 如果 ‘^’ 和 ‘$’ 出现在其它位置，它们均没有特殊含义，只表示自身。 捕获： 模式可以在内部用小括号括起一个子模式； 这些子模式被称为 捕获物。 当匹配成功时，由 捕获物 匹配到的字符串中的子串被保存起来用于未来的用途。 捕获物以它们左括号的次序来编号。 例如，对于模式 “(a*(.)%w(%s*))” ， 字符串中匹配到 “a*(.)%w(%s*)” 的部分保存在第一个捕获物中 （因此是编号 1 ）； 由 “.” 匹配到的字符是 2 号捕获物， 匹配到 “%s*” 的那部分是 3 号。 作为一个特例，空的捕获 () 将捕获到当前字符串的位置（它是一个数字）。 例如，如果将模式 “()aa()” 作用到字符串 “flaaap” 上，将产生两个捕获物： 3 和 5 。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:8:6","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"表 table table 是 Lua 的一种数据结构用来帮助我们创建不同的数据类型，如：数组、字典等。 Lua table 使用关联型数组，你可以用任意类型的值来作数组的索引，但这个值不能是 nil。 Lua table 是不固定大小的，你可以根据自己需要进行扩容。 Lua也是通过table来解决模块（module）、包（package）和对象（Object）的。 例如string.format表示使用\"format\"来索引table string。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:9:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"table(表)的构造 构造器是创建和初始化表的表达式。表是Lua特有的功能强大的东西。最简单的构造函数是{}，用来创建一个空表。可以直接初始化数组: -- 初始化表 mytable = {} -- 指定值 mytable[1]= \"Lua\" -- 移除引用 mytable = nil -- lua 垃圾回收会释放内存 当我们为 table a 并设置元素，然后将 a 赋值给 b，则 a 与 b 都指向同一个内存。如果 a 设置为 nil ，则 b 同样能访问 table 的元素。如果没有指定的变量指向a，Lua的垃圾回收机制会清理相对应的内存。 以下实例演示了以上的描述情况： -- 简单的 table mytable = {} print(\"mytable 的类型是 \"..type(mytable)) mytable[1]= \"Lua\" mytable[\"wow\"] = \"修改前\" print(\"mytable 索引为 1 的元素是 \".. mytable[1]) print(\"mytable 索引为 wow 的元素是 \", mytable[\"wow\"]) -- alternatetable和mytable的是指同一个 table alternatetable = mytable print(\"alternatetable 索引为 1 的元素是 \".. alternatetable[1]) print(\"mytable 索引为 wow 的元素是 \".. alternatetable[\"wow\"]) alternatetable[\"wow\"] = \"修改后\" print(\"mytable 索引为 wow 的元素是 \".. mytable[\"wow\"]) -- 释放变量 alternatetable = nil print(\"alternatetable 是 \".. alternatetable) -- mytable 仍然可以访问 print(\"mytable 索引为 wow 的元素是 \".. mytable[\"wow\"]) mytable = nil print(\"mytable 是 \".. mytable) -- 输出结果是 --[[ mytable 的类型是 table mytable 索引为 1 的元素是 Lua mytable 索引为 wow 的元素是 修改前 alternatetable 索引为 1 的元素是 Lua mytable 索引为 wow 的元素是 修改前 mytable 索引为 wow 的元素是 修改后 alternatetable 是 nil mytable 索引为 wow 的元素是 修改后 mytable 是 nil ]]-- ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:9:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"table 操作 以下列出了 Table 操作常用的方法： table.concat (table [, sep [, start [, end]]]): concat是concatenate(连锁, 连接)的缩写. table.concat()函数列出参数中指定table的数组部分从start位置到end位置的所有元素, 元素间以指定的分隔符(sep)隔开。 table.insert (table, [pos,] value): 在table的数组部分指定位置(pos)插入值为value的一个元素. pos参数可选, 默认为数组部分末尾. table.maxn (table) 指定table中所有正数key值中最大的key值. 如果不存在key值为正数的元素, 则返回0。(Lua5.2之后该方法已经不存在了,本文使用了自定义函数实现) table.remove (table [, pos]) 返回table数组部分位于pos位置的元素. 其后的元素会被前移. pos参数可选, 默认为table长度, 即从最后一个元素删起。 table.sort (table [, comp]) 对给定的table进行升序排序。 table 连接 我们可以使用 concat() 输出一个列表中元素连接成的字符串: fruits = {\"banana\",\"orange\",\"apple\"} -- 返回 table 连接后的字符串 print(\"连接后的字符串 \"..table.concat(fruits)) -- 指定连接字符 print(\"连接后的字符串 \"..table.concat(fruits,\", \")) -- 指定索引来连接 table print(\"连接后的字符串 \"..table.concat(fruits,\", \", 2,3)) --[[ 输出结果 连接后的字符串 bananaorangeapple 连接后的字符串 banana, orange, apple 连接后的字符串 orange, apple ]]-- 插入和移除 以下实例演示了 table 的插入和移除操作: fruits = {\"banana\",\"orange\",\"apple\"} -- 在末尾插入 table.insert(fruits,\"mango\") print(\"索引为 4 的元素为 \"..fruits[4]) -- 在索引为 2 的键处插入 table.insert(fruits,2,\"grapes\") print(\"索引为 2 的元素为 \"..fruits[2]) print(\"最后一个元素为 \",fruits[5]) table.remove(fruits) print(\"移除后最后一个元素为 \"..fruits[5]) -- 输出结果 --[[ 索引为 4 的元素为 mango 索引为 2 的元素为 grapes 最后一个元素为 mango 移除后最后一个元素为 nil ]]-- table 排序 以下实例演示了 sort() 方法的使用，用于对 Table 进行排序： fruits = {\"banana\",\"orange\",\"apple\",\"grapes\"} print(\"排序前\") for k,v in ipairs(fruits) do print(k..v) end table.sort(fruits) print(\"排序后\") for k,v in ipairs(fruits) do print(k..v) end --输出结果 --[[ 排序前 1 banana 2 orange 3 apple 4 grapes 排序后 1 apple 2 banana 3 grapes 4 orange ]]-- ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:9:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"迭代器 迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。 在 Lua 中迭代器是一种支持指针类型的结构，它可以遍历集合的每一个元素。 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:10:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"泛型 for 迭代器 泛型 for 在自己内部保存迭代函数，实际上它保存三个值：迭代函数、状态常量、控制变量。 泛型 for 迭代器提供了集合的 key/value 对，语法格式如下： --遍历所有内容,包括键值 for k, v in pairs(t) do print(k, v) end 上面代码中，k, v为变量列表；pairs(t)为表达式列表。 查看以下实例: --遍历下标内容,不包括键值 array = {\"Google\", \"Runoob\"} for key,value in ipairs(array) do print(key.. value) end --输出结果 --[[ 1 Google 2 Runoob ]]-- ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:10:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"模块 、 在节点精灵 中 require 函数可以加载其他文件中的lua代码 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:11:0","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"加载路径 在节点精灵里，所有文件加载必须填写绝对路径。 根目录 为 ‘/’ 如图 ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:11:1","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"文件层级加载相关 相同层级的文件加载如下 -- mian.lua -- a.lua --在mian.lua 中 如下就可以加载a.lua文件了 require('a') 不同层级的文件加载 -- mian.lua -- a(这是文件夹) -- b.lua（这是a文件夹中的文件） --在mian.lua 中 如下就可以加载b.lua文件了 require('a/b') ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:11:2","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"多重加载 在节点精灵中， 可以在lua文件中 require 其他文件 --文件结构如下： -- mian.lua -- a.lua -- b.lua --在mian.lua 中 加载a.lua 在a.lua 中可以加载 b.lua mian.lua 中如下 require('a') a.lua 中如夏 require('b') ","date":"2022-01-07","objectID":"/2022/01/lua%E5%9F%BA%E7%A1%80/:11:3","series":null,"tags":["Lua"],"title":"Lua","uri":"/2022/01/lua%E5%9F%BA%E7%A1%80/"},{"categories":null,"content":"编译Lua 流程如下： 从lua的官方下载网址上获取当前最新版lua-5.3.5.tar.gz，然后解压生成lua-5.3.5目录并放在桌面上。 lua-5.3.5目录下的配置文件中有参数命令让使用者动态修改，所以配置文件使用默认设置即可。常见的配置文件如下： Makefile文件中定义怎样安装lua以及将lua安装到哪里。 src/Makefile中定义怎样编译lua。 src/luaconf.h中定义lua的特性，允许拥有哪些功能等。 打开终端定位到lua-5.3.5目录中，然后执行make macosx命令进行编译。编译成功时会在src目录下生成lua(解析并执行lua源码和字节码)，luac(将lua源码生成对应字节码)以及liblua.a(在c/c++中引入lua)三个文件；此时执行make test命令时会运行lua解释器并打印其版本。如图所示： ","date":"2022-01-07","objectID":"/2022/01/lua-mac%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["Lua"],"title":"Lua Mac编译和安装","uri":"/2022/01/lua-mac%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"安装Lua 流程如下： 打开终端定位到lua-5.3.5目录，然后执行安装命令既可以将编译后的lua发布到指定的安装目录下。 常见的安装命令如下： “make install\"命令可以将编译后的lua发布到Makefile中定义的默认安装路径下。 “make install INSTALL_TOP=绝对路径\"命令可以将编译后的lua发布到指定INSTALL_TOP参数值的安装路径下。如图所示： 安装目录结构如下所示： share目录下存放的是第三方共享库文件。 man目录下存放的是lua解释器和luac字节码生成器的操作文档。 lib目录下存放的是包含lua功能的库文件，用来内嵌到c/c++文件中。 include目录下存放的是包含lua功能的头文件，用来内嵌到c/c++文件中。 bin目录下存放的是用来解释并执行lua源码和字节码的lua执行文件，以及用来将lua源码生成字节码的luac执行文件。 将lua和luac执行文件添加到当前用户的环境变量中；然后在终端使用lua -v以及luac -v来验证是否可以使用lua和luac可执行文件。 用户的环境变量设置如图所示： 终端使用lua和luac命令如图所示： 参考网址： 1.http://www.lua.org/manual/5.3/readme.html#other ","date":"2022-01-07","objectID":"/2022/01/lua-mac%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/:2:0","series":null,"tags":["Lua"],"title":"Lua Mac编译和安装","uri":"/2022/01/lua-mac%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"正则表达式 . 任意字符 %a 字母 %c 控制字符 %d 数字 %l 小写字母 %p 标点字符 %s 空白符 %u 大写字母 %w 字母和数字 %x 十六进制数字 %z 代表0的字符 上面字符类的大写形式表示小写所代表的集合的补集。例如, '%A'非字母的字符: 特殊字符 '%' 用作特殊字符的转义字符 '%.' 匹配 . '%%' 匹配字符 '%' 用'[]'匹配字符集中的字符一次 '[%w_]' 匹配字母数字和下划线 '[01]' 匹配二进制数字 '[%[%]]'匹配一对方括号 在'[]'中使用连字符'-' '%d' 表示 '[0-9]'； '%x' 表示 '[0-9a-fA-F]' '[0-7]' 表示 '[01234567]' 在'[]'开始处使用 '^' 表示其补集： '[^0-7]' 匹配任何不是八进制数字的字符； '[^\\n]' 匹配任何非换行符户的字符。 '[^%s]' == '%S' 模式修饰符 ^ 匹配字符串开头 $ 匹配字符串结尾 + 匹配前一字符1次或多次 * 匹配前一字符0次或多次,最长匹配 - 匹配前一字符0次或多次,最短匹配 ? 匹配前一字符0次或1次 ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"查找 ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"string.find(s, pattern [, init [, plain]]) s : 需要进行查找的字符串 pattern : 需要匹配的正则表达式 init : 搜索的起始位置 plain : 默认为false，true时关闭匹配正则模式 将查找目标模板在给定字符串中出现的位置，找到返回起始和结束位置，没找到返回nil 注：find 的第二个参数使用了某种匹配模式， 并且模式串里面带括号，那么表示会“捕捉”括号括起来的模式匹配到的字符串，并且作为返回值，从第三个返回值开始返回所有匹配 print(string.find(\"hello, world\", \"%s\", 2)) =\u003e 7 7 print(string.find(\"hello, world\", \"%s\", 8) =\u003e nil print(string.find(\"hello, world\", \"%s\", 0, true) =\u003e nil print(string.find(\"hello, world\", \" \", 0, true)) =\u003e 7 7 -- 其中%1表示拷贝匹配到的第一个内容，同样的%n来拷贝匹配到的第n个内容 print(string.find(\"abc \\\"it's a cat\\\"\", \"([\\\"'])(.-)%1\")) =\u003e 5 16 \" it's a cat ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:1","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"string.match(s, pattern [, init]) s : 需要进行查找的字符串 pattern : 需要匹配的正则表达式 init : 搜索的起始位置 将查找目标模板在给定字符串中出现的匹配字符，如果没有，返回nil print(string.match(\"hello, world\", \"%S%s%S\")) =\u003e , w print(string.match(\"hello, world\", \"%S%s%S\", 8)) =\u003e nil print(string.match(\"hello, world\", \"(hello), world\")) =\u003e hello 注：如果pattern中有用（）起来的，那么只返回（）中的内容,如果多个括号，返回多个值 print(string.match(\"hello, world\", \"(hello), (world)\")) =\u003e hello world -- 其中%1表示拷贝匹配到的第一个内容，同样的%n来拷贝匹配到的第n个内容 print(string.match(\"abc \\\"it's a cat\\\"\", \"([\\\"'])(.-)%1\")) =\u003e \" it's a cat ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:2","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"string.gmatch (s, pattern) s : 需要进行查找的字符串 pattern : 需要匹配的正则表达式 返回一个迭代器函数，每一次调用这个函数，返回一个在字符串s找到的下一个符合pattern描述的子串。 local str = \"hello, world\" local iter = string.gmatch(str, \"%S\") for w, v in iter do print(w) end =\u003e h e l l o , w o r l d ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:3","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"替换 ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:0","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"string.gsub (s, pattern, repl [,m]) s : 需要进行查找的字符串 pattern : 需要匹配的正则表达式 repl : 需要替换成的字符串 [, m] : 只看s的前m个字符 将pattern中匹配到的字符串替换成repl字符串，repl可以是string，也可以是个函数，或是table，如果是函数，就会用捕获的内容作为参数调用该函数，将返回的内容作为替换字符串。如果是table，则用捕获的内容为key去取table的值来作为替换字符串,如果不存在，就不做替换 返回值 ： 替换后的字符串， 替换的次数 注：把源字符串当做gsub的第一个参数传入后，方法执行并不会修改源字符串，需要重新赋值接收才能获取到修改后的字符串 local str = \"hello, world\" print(string.gsub(str, \"hello\", \"hi\")) =\u003e hi, world 1 local str = \"hello, world\" print(string.gsub(str, \".\", function(pattern) if pattern == \"l\" then return \"abc\" end return pattern end)) =\u003e heabcabco, worabcd 12 function expand(s) return string.gsub(s, \"$(%w+)\", _G) end name = \"Lua\"; status = \"great\" print(expand(\"$name is $status, isn't it?\")) =\u003e Lua is great, isn't it? 2 ","date":"2022-01-07","objectID":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/:3:1","series":null,"tags":["Lua","正则表达式"],"title":"Lua正则表达式","uri":"/2022/01/lua%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"基础 搭建服务器 Linux or Windows 掌握html 掌握css 掌握js 搜索后台模版 数据库 网络通信 ","date":"2022-01-07","objectID":"/2022/01/lua%E4%B8%AD%E6%8E%A7/:1:0","series":null,"tags":["Lua"],"title":"lua中控","uri":"/2022/01/lua%E4%B8%AD%E6%8E%A7/"},{"categories":null,"content":"服务器端 server.lua ","date":"2022-01-07","objectID":"/2022/01/lua%E4%B8%AD%E6%8E%A7/:2:0","series":null,"tags":["Lua"],"title":"lua中控","uri":"/2022/01/lua%E4%B8%AD%E6%8E%A7/"},{"categories":null,"content":"安装Homebrew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:1:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"安装 wget brew install wget 删除用brew uninstall wget ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:2:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"安装 lua5.3 brew install lua 删除用brew uninstall lua ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:3:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"坑1：lua5.4 与 mobdebug 存在兼容性问题 不能使用 lua5.4，lua5.4现在对 mobdebug 兼容有问题。 # 如果使用 brew install lua ，会自动安装最新版本 brew install lua@5.3 brew link lua@5.3 # 此时会自动link，进行下一步之前，先检查一下lua环境是不是ok了 ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:3:1","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"安装 luarocks 参考：https://ttys3.dev/post/lua/luarocks-install-and-setup/ brew install luarocks -v 删除用brew uninstall luarocks ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:4:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"坑2：brew install luarocks 安装版本不对 不能使用 brew install luarocks ，他会自己安装基于 lua5.4 的 luarocks。 官方安装文档：https://github.com/luarocks/luarocks/wiki/Installation-instructions-for-Unix # 下载 wget https://luarocks.org/releases/luarocks-3.7.0.tar.gz tar zxpf luarocks-3.7.0.tar.gz ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:4:1","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"坑3：官方文档指令不能直接使用 官方文档说应该用 ./configure --with-lua-include=/usr/local/include ，但实际不能加 --with-lua-include=/usr/local/include ，这会导致 lua 依赖的路径错误。 可能会产生类似 Failed finding Lua header files. You may need to install them or configure LUA_INCDIR 的错误。 出现这种错误的原因还是 --with-lua-include=/usr/local/include 后边跟的这个路径不对，在我的环境中，应该为 --with-lua-include=/usr/local/opt/lua@5.3/include/lua5.3 。 在不指定这个参数的时候，会自动检测路径，未来避免出错，最好还是不要指定，除非系统里装了多版本的 lua 。 cd luarocks-3.7.0 ./configure 此时会提示： * Type make and make install: to install to /usr/local as usual. * Type make bootstrap: to install LuaRocks into /usr/local as a rock. 让我们在 make \u0026\u0026 make install 和 make bootstrap 之间选择，此处推荐 make bootstrap make bootstrap ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:4:2","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"安装 luacheck、luasocket ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:5:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"坑4：rock tree 与安装 scope 在上一步安装完之后，会有类似以下输出： Configuration: Lua: Version : 5.3 Interpreter: /usr/local/bin/lua5.3 (ok) LUA_DIR : /usr/local (ok) LUA_BINDIR : /usr/local/bin (ok) LUA_INCDIR : /usr/local/opt/lua@5.3/include/lua5.3 (ok) LUA_LIBDIR : /usr/local/opt/lua@5.3/lib (ok) Configuration files: System : /usr/local/etc/luarocks/config-5.3.lua (ok) User : /Users/eric/.luarocks/config-5.3.lua (ok) Project : /tmp/luarocks-3.7.0/./.luarocks/config-5.3.lua (ok) Rocks trees in use: /tmp/luarocks-3.7.0/./lua_modules (\"project\") /Users/eric/.luarocks (\"user\") /usr/local (\"system\") 其中： Lua 指出 lua 依赖相关路径 Configuration files 指出了配置文件路径 Rocks trees in use 指出了安装 lua_modules 时的目标根路径，后边括号里的 \"project\"、\"user\"、\"system\" ，是指不同的 scope，使用 luarocks install xxx 时应该格外注意安装的 scope 是否正确。 像上边这个输出显示，project scope 是在 /tmp 下的一个路径，所以如果安装到这里的话，项目目录可能就找不到包。 这里应该格外注意的是：Rocks trees 是一个树状结构，这里边显示的是根路径，真实的安装目录应该是 Rocks trees 和 lib_modules_path 拼起来。 以system scope 为例， 运行指令 luarocks ，获得以下输出： ➜ luarocks …… …… …… Rocks trees in use: /Users/eric/.luarocks (\"user\") /usr/local (\"system\") 可知，luarocks 的system scope 中的 Rocks tree 路径为 /usr/local 运行 luarocks config --scope user lib_modules_path ，获得以下输出： ➜ luarocks config --scope user lib_modules_path /lib/lua/5.3/ 可知，luarocks 的system scope 中的lib_modules_path 为 /lib/lua/5.3/ 此时如果要安装到 system scope ，这会安装到 /usr/local/lib/lua/5.3/ 运行 lua -e 'require \"abc\"' ，获得以下输出： lua: (command line):1: module 'abc' not found: no field package.preload['abc'] no file '/usr/local/share/lua/5.3/abc.lua' no file '/usr/local/share/lua/5.3/abc/init.lua' no file '/usr/local/lib/lua/5.3/abc.lua' no file '/usr/local/lib/lua/5.3/abc/init.lua' no file './abc.lua' no file './abc/init.lua' no file '/usr/local/lib/lua/5.3/abc.so' no file '/usr/local/lib/lua/5.3/loadall.so' no file './abc.so' 上面输出的这些路径就是 lua 查找 package 时会检索的目录，应该保证 Rocks tree 和 lib_modules_path 拼接后的路径可以被 lua 检索到。 如果 lib_modules_path 路径不对，可以通过下面的指令进行配置： luarocks config --scope user lib_modules_path /lib/lua/5.3/ 一切就绪，安装 luacheck 和 luasocket luarocks install luacheck luarocks install luasocket 运行 lua -e 'require \"socket\"' ，如果没有报错，说明安装成功。 删除用luarocks remove luasocket ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:5:1","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"使用 EmmyLua MobDebug 进行 debug 基本所有的 Lua debug 工具都基于 MobDebug ，像 EmmyLua 、 LuaPanda 。 IDEA 系列 IDE 推荐使用 EmmyLua ，vscode 编辑器推荐使用 LuaPanda 。 IDEA 中的 EmmyLua 插件已经集成了 MobDebug 。 使用 EmmyLua 中的 MobDebug 的方式，EmmyLua的文档里有很简略说明， 详见： https://emmylua.github.io/run.html#get-ready ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:6:0","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"step.1. 目录结构 ➜ tree . └── src ├── dev1.lua └── mobdebug.lua 需要将 src 标为 Sources（源 根），显示为蓝色。 从 https://github.com/pkulchenko/MobDebug 下载 MobDebug 项目， 将 MobDebug/src/mobdebug.lua 放到项目 src 目录面。 ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:6:1","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"step.2. 创建运行配置 ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:6:2","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"step.3. 创建 debug 配置 ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:6:3","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"step.4. 进行debug 先点击 debug按钮 运行 Lua Remote（MobDebug）效果如下图 再点击运行按钮运行 dev1.lua，成功进入 debug 模式 ","date":"2022-01-07","objectID":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/:6:4","series":null,"tags":["Lua"],"title":"macOS lua debug 环境搭建避坑指南","uri":"/2022/01/macos-lua-debug-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"给MFC中的控件添加我们想要的控件热键，在动手之前，必须清楚，热键分为local的和global的， 其中local的职能在当前程序有焦点（被激活）时有效，而global的，则无论什么时候都有效，测试local的要优先于global的，就是如果当前激活窗口的快捷键与未激活窗口的快捷键重叠，当前激活窗口优先响应。另外还包括menu，button。 自然而然，创建热键的方法也有多种，不同的创建方法创建的热键作用范围不一定相同。应该根据需求合理的选择自己的方法。 ","date":"2022-01-07","objectID":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/:0:0","series":null,"tags":["MFC","快捷键","热键"],"title":"MFC 控件添加热键","uri":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/"},{"categories":null,"content":"方法一： 打开对话框资源，选择指定控件的属性–\u003e在caption项中你定义的名字后添加（\u0026Y）。这样就可以实现热键。其中Y表示你要制定的快捷按键，我选的是Y，按下ALT+Y即可执行这个控件。 该方式热键只有当FOCUS在控件上时才起作用，算是局部热键。 ","date":"2022-01-07","objectID":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/:1:0","series":null,"tags":["MFC","快捷键","热键"],"title":"MFC 控件添加热键","uri":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/"},{"categories":null,"content":"方法二： 在资源视图中添加资源，选择\"Accelerator\"选项新建即可； 打开新建的文件夹下的\"IDR_ACCELERATOR1\"中编辑，其中包括ID、修饰符、键、类型。ID中选择你要添加快捷键的菜单、按钮的ID编号，修饰符中选择你是否要使用组合键，如：Alt、Alt+Shift等等，键中选择你要使用什么样的虚拟键码，类型中选择VK形式或者是ASCII形式。 在你的对话框的头文件中添加快捷键变量，如HACCEL m_hAcc； 在你的对话框的源文件的OnInitDialog函数中加载快捷键，如： HACCEL m_hAcc=LoadAccelerators(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDR_ACCELERATOR1)); 重载函数PreTranslateMessage，使用类向导，重载虚函数PreTranslateMessage，如： BOOL CAutoToolDlg::PreTranslateMessage(MSG* pMsg) { if (WM_KEYFIRST\u003c=pMsg-\u003emessage\u0026\u0026pMsg-\u003emessage\u003c= WM_KEYLAST) { HACCEL hAccel=m_hAcc; if (hAccel \u0026\u0026 ::TranslateAccelerator(m_hWnd, hAccel, pMsg)) return TRUE; } return CDialogEx::PreTranslateMessage(pMsg); } 通过以上5个步骤基本上即可对工程中的菜单或者按钮添加热键。 ","date":"2022-01-07","objectID":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/:2:0","series":null,"tags":["MFC","快捷键","热键"],"title":"MFC 控件添加热键","uri":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/"},{"categories":null,"content":"方法三： 使用WM_HOTKEY。 在对话框头文件中： afx_msg LRESULT OnHotKey(WPARAM wParam,LPARAM lParam); afx_msg void OnDestroy(); 在对话框CPP文件中： BEGIN_MESSAGE_MAP(CYourDlg, CDialog) ON_MESSAGE(WM_HOTKEY,OnHotKey) ON_WM_DESTROY() END_MESSAGE_MAP() hotkey对应映射： LRESULT CYourDlg::OnHotKey(WPARAM wParam,LPARAM lParam) { if（wParam==IDC_XXX） OnYourFunction(); //ToDo: add function return 0; } 注册热键： BOOL CYourDlg::OnInitDialog() { ::RegisterHotKey(GetSafeHwnd(), IDC_XXX, MOD_ALT, 'D');//注册热键alt+D（D必须大写） } 记得销毁： void CYourDlg::OnDestroy() { ::UnregisterHotKey(GetSafeHwnd(),IDC_XXX);//销毁热键 } 另外一篇参考：http://lty2154216.blog.163.com/blog/static/17982629320117129491666/ ","date":"2022-01-07","objectID":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/:3:0","series":null,"tags":["MFC","快捷键","热键"],"title":"MFC 控件添加热键","uri":"/2022/01/mfc-%E6%8E%A7%E4%BB%B6%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%94%AE/"},{"categories":null,"content":" TCHAR pStr[] = _T(\"this is a test!\"); void* p = (void*)pStr; TRACE(_T(\"pStr is %s\\n\"), pStr); //后台输出 ASSERT(NULL == pStr); //条件为假提示1234 @err,hr表示当前线程的GetLastError()的结果，不加hr只显示错误码 pStr,10表示显示数组的前10个字符 p,su表示把p做为unicode字符串显示，不加u是ansi编码 TRACE用于不适合谈MessageBox的位置 ASSERT只在debug版中有用 其它辅助窗口，可以在VS-\u003eDebug-\u003eWindows打开 ","date":"2022-01-07","objectID":"/2022/01/mfc%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/:0:0","series":null,"tags":["MFC"],"title":"MFC调试技巧","uri":"/2022/01/mfc%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"登录 终端输入 ssh 账户名@服务器主机地址 ssh root@192.168.1.2 ssh mobile@192.168.1.2 默认密码: alpine ","date":"2022-01-07","objectID":"/2022/01/openssh/:1:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"退出 exit ","date":"2022-01-07","objectID":"/2022/01/openssh/:2:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"常用账户 root和mobile root 最高权限 $HOME是/var/root mobile 普通权限账户 $HOME是/var/mobile ","date":"2022-01-07","objectID":"/2022/01/openssh/:3:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"修改密码 passed与passwd mobile ","date":"2022-01-07","objectID":"/2022/01/openssh/:4:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"查看SSH版本 cd /etc/ssh ls -l cat ssh_config #客户端 cat sshd_config #服务端 有Protocol 2代表是ssh 2版本 ","date":"2022-01-07","objectID":"/2022/01/openssh/:5:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"建立安全连接 客户端 ~/.ssh/known_hosts 服务器端 公钥: /etc/ssh/ssh_host_rsa_key.pub 私钥: /etc/ssh/ssh_host_rsa_key 删除公钥信息 ssh-keygen -R ip 或者打开known_hosts文件手动进行删除 vim ~/.ssh/known_hosts ","date":"2022-01-07","objectID":"/2022/01/openssh/:6:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"认证方式(免密登陆) 密码认证 密钥认证 客户端 公钥: ~/.ssh/id_rsa.pub 私钥: ~/.ssh/id_rsa 服务器 授权文件 ~/.ssh/authorized_keys 客户端生成公钥及私钥 ssh-keygen一路敲回车即可 将公钥内容追加到服务器授权文件的尾部 ssh-copy-id root@192.168.1.2 ","date":"2022-01-07","objectID":"/2022/01/openssh/:7:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"远程拷贝 拷贝公钥至服务器 scp ~/.ssh/id_rsa.pub root@192.168.1.2:~/.ssh 追加至授权文件尾部 cat id_rsa.pub \u003e\u003e authorized_keys 删除公钥 rm ~/id_rsa.pub ","date":"2022-01-07","objectID":"/2022/01/openssh/:8:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"文件权限 chmod 755 ~ chmod 755 ~/.ssh chmod 644 ~/.ssh/authorized_keys ","date":"2022-01-07","objectID":"/2022/01/openssh/:9:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"端口 默认22 可以查看/etc/ssh/sshd_config的port字段 ","date":"2022-01-07","objectID":"/2022/01/openssh/:10:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"USB登录 usbmixd 的使用 下载usbmixd软件包（主要用到python脚本 tcprelay.py) https://cgit.sukimashita.com/usbmuxd.git/snapshot/usbmuxd-1.0.8.tar.gz 或者 https://github.com/xinqinew/pic/raw/main/other/usbmuxd-1.0.8.tar 将iphone的22端口映射到本地10010端口 在usbmixd目录执行tcprelay.py脚本 python tcprelay.py -t 22:10010 登录本地的10010端口 ssh root@localhost -p 10010 或者 ssh root@127.0.0.1 -p 10010 ","date":"2022-01-07","objectID":"/2022/01/openssh/:11:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"USB传输文件 scp -P 10010 ~/.ssh/id_rsa.pub root@localhost:~ ","date":"2022-01-07","objectID":"/2022/01/openssh/:12:0","series":null,"tags":["iPhone"],"title":"OpenSSH","uri":"/2022/01/openssh/"},{"categories":null,"content":"有阵子没有更新这个主题，可能让大家误认为已经结束了，其实除了这一篇，后续还会有一些。 还是尽量本着善始善终的原则，我要把这个主题给讲完，并且在结束的时候一定会让大家知道的。 通过大家的反馈来看，这个系列确实也帮助到了不少的人，另外我自己在这个过程中，也对 VS Debug 的使用有了更加系统的认识。 其实，VS Debug 的功能很多，多的超乎想象，所以有很多平时不太常用的功能我就不在这里介绍了，写进教程中的都是我和周围的人在日常工作中能够经常使用到的功能。 本次教程介绍 VS 的远程调试方法（C++）。 什么是远程调试？ 我们平时，特别是自学的新手在刚一开始的时候，都是本地编译、本地调试，本机编译好的程序就直接在本机执行。 但是有些情况下，你本机编译好的程序，需要放到另一台机器（目标机）上运行。 此时，你可以在本地的 VS 环境中，对运行在目标机上的程序进行 远程调试。 C# 项目和 http://ASP.NET web 服务器的远程调试方法略有不同，本文不做讲解。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:0:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"1. 原理 目标机： 负责执行目标程序。安装和运行远程工具 （Remote Debugger），等待来自开发机的连接请求。 开发机： 将编译好的程序部署到目标机器上执行。配置 VS 工程，建立与目标机的连接，开始远程调试。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:1:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"2. 环境要求 目标机必须满足： Windows 7 以后或者 Windows Server 2008 Service Pack 2 以后。 网络必须满足： 目标机和开发机必须通过网络、工作组、家庭组连接，或者通过网线直连。不支持 Internet 连接。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:2:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"3. 安装 Remote Debugger 首先，要在目标机器上安装远程调试工具，有两种方法。 方法一： 从微软官网下载远程工具。 注意，一定要安装与 VS 版本和目标机操作系统匹配的远程工具。 例如，你用的是 VS2017，就要下载 VS2017 版的远程工具，另外，还要考虑目标机操作系统位数，是 32 位就要安装 32 位远程工具，是 64 位就要安装 64 位远程工具。 下载地址从这里找吧： Remote debugging in Visual Studio 方法二： 这是一个更为简单的方法。 在你本地的 VS 安装目录下找到 msvsmon.exe，此文件就是 Remote Debugger。 它的位置在： Program Files\\Microsoft Visual Studio 15.0\\Common7\\IDE\\Remote Debugger\\x86\\msvsmon.exe Program Files\\Microsoft Visual Studio 15.0\\Common7\\IDE\\Remote Debugger\\x64\\msvsmon.exe 可以共享该目录，在目标机上直接运行 Share Folder 中的 msvsmon.exe 即可。 也可以把 msvsmon.exe 所在的整个目录 Copy 到目标机上。 这里同样需要注意，要与目标机的操作系统位数匹配。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:3:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"4. 配置 Remote Debugger 这一步还是在目标机上。 所在登陆账户，一定要拥有管理员权限。 打开安装好的 Remote Debugger (msvsmon.exe)，首次打开时，会出现配置窗口，提醒配置一些参数。 只需要配置一次，再次打开时，不会弹出该窗口。 如果你不清楚你的网络连接方式，比较保险的做法是把所有框都勾选上。 点击配置远程调试按钮之后，会出现如下窗口，代表 Remote Debugger 正在等待来自开发机的连接。 这里可以点击 Tools \u003e Options 菜单，做一些额外的参数配置。 有时可能会由于防火墙或者认证等原因，导致连接不上的问题，最极端的方法是完全关闭它们。虽然官方出于安全考虑，并不建议这么做。 假如你确定网络没有任何风险，那么可以关闭两边机器的防火墙。上面窗口中，也可以选择无认证方式。 最大空闲时间设置为 0 代表永远不会超时，一直处于等待状态。 TCP/IP 端口号这里默认给出的是 4022，你可以更改，但一般无需这样做。 关于默认端口号，不同的 VS 版本，是不同的，具体如下。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:4:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"5. 配置 VS 工程 这一步是对开发机的配置。 在 VS 工程中，打开项目属性，点击调试选项卡，切换到远程 Windows 调试器。 对列出的一些参数进行配置。 这里： C:\\remotetemp\\mymfc.exe 为目标机上需要执行的程序。 如果要带参数的话，可以在远程命令参数中配置。 C:\\remotetemp 为目标机可执行程序所在的目录。 DDXVM6812 为目标机器名称。 如果在目标机 Remote Debugger 中设置了无认证的连接方式，这里同样要选则无认证的远程访问。 配置好后，点击确定。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:5:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"6. 开始远程调试 将本地机器 VS 编译好的可执行程序部署到目标机上。 一切就绪之后，就可以开启远程调试了。 在 VS 工程中想要查看的代码处设置断点，然后点击上方的**远程调试器，**即可建立与目标机的连接。 注意，此时目标机上的 Remote Debugger 一定要处于等待连接状态。 连接之后，目标机上的 Remote Debugger 显示已连接，可执行程序开始在目标机上运行。 开发机上 VS 中的断点将被击中，此时就可以开始远程调试了，操作跟本地调试没有差别。 远程调试的步骤基本就这些，希望能给大家理清了思路。 ","date":"2022-01-07","objectID":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/:6:0","series":null,"tags":null,"title":"从 0 到 1 学习 Visual Studio Debug 之五：远程调试","uri":"/2022/01/%E4%BB%8E-0-%E5%88%B0-1-%E5%AD%A6%E4%B9%A0-visual-studio-debug-%E4%B9%8B%E4%BA%94%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/"},{"categories":null,"content":"提高工作效率的工具 Alfred 便捷搜索 工作流 XtraFinder 增强型Finder iTerm2 完爆Terminal的命令行工具 Go2Shell 从Finder快速定位到命令行工具 ","date":"2022-01-07","objectID":"/2022/01/%E5%B7%A5%E5%85%B7/:1:0","series":null,"tags":["iPhone"],"title":"工具","uri":"/2022/01/%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"脚本中有微信、一键新机相关的代码将会被冻结 不支持的功能 [os.execute 执行 shell 命令](https://helpdoc.touchsprite.com/dev_docs/32/5.html?h=不支持 iOS 小精灵) [命令：强制重启触动服务](https://helpdoc.touchsprite.com/dev_docs/23/11.html?h=不支持 iOS 小精灵) 已内置的插件 cloudOcr.so TSLib sz ts ","date":"2022-01-07","objectID":"/2022/01/%E5%B0%8F%E7%B2%BE%E7%81%B5/:0:0","series":null,"tags":["Lua"],"title":"小精灵","uri":"/2022/01/%E5%B0%8F%E7%B2%BE%E7%81%B5/"},{"categories":null,"content":"越狱 ","date":"2022-01-07","objectID":"/2022/01/%E8%B6%8A%E7%8B%B1/:1:0","series":null,"tags":["iPhone"],"title":"越狱","uri":"/2022/01/%E8%B6%8A%E7%8B%B1/"},{"categories":null,"content":"在线越狱 http://jbme.cf ","date":"2022-01-07","objectID":"/2022/01/%E8%B6%8A%E7%8B%B1/:1:1","series":null,"tags":["iPhone"],"title":"越狱","uri":"/2022/01/%E8%B6%8A%E7%8B%B1/"},{"categories":null,"content":"本地越狱 https://sideloadly.io/ U0安装器 https://altstore.io U0安装器 https://taurine.app U0安装器 itunes备份路径 ~/Library/application support/mobilesync 自动安装路径 /var/root/Media/Cydia/AutoInstall iCloud 路径 /private/var/mobile/Library/Mobile Documents/com~apple~CloudDocs file:///private/var/mobile/Library/Mobile%20Documents/iCloud~com~xxx~aaa/Documents ","date":"2022-01-07","objectID":"/2022/01/%E8%B6%8A%E7%8B%B1/:1:2","series":null,"tags":["iPhone"],"title":"越狱","uri":"/2022/01/%E8%B6%8A%E7%8B%B1/"},{"categories":null,"content":"常用源 apt.saurik.com 官方作者源 apt.thebigboss.org/repofiles/cydia 官方自带 apt.autotouch.net autotouch官方源 apt.cydiakk.com autotouch破解源 captinc.me Batchomatic插件备份源 apt.grbl.store 平刷源 samgisaninja.github.io/test/ 平刷源 cydia.hackulo.us apt.178.com apt.if0rce.com apt.feng.com cydia.crazydoraemon.com apt.25pp.com fairylabs.com/wp-content/cydia/ 流量监视源 cydia.xsellize.com 源 apt.chinasnow.net apt.sbtools.me 烧饼辅助Cydia源地址 apt.82flex.com 流量监视源 cydia.china3gpp.com 电信源 apt.youyuanapp.com IAPCrazy内购 apt.touchsprite.com 触动精灵 http://apt.abcydia.com/read-1203.html 雷峰源 http://apt.enduniverse.com/cydia AFC2 ios10 fix evasi0n.com https://xinqinew.yourepo.com/ 我的源 http://apt.so/1767298 我的源 http://apt.so/kuaidial7 私人ibackground 后台backgoround (rocketBootstrap必装) ","date":"2022-01-07","objectID":"/2022/01/%E8%B6%8A%E7%8B%B1/:2:0","series":null,"tags":["iPhone"],"title":"越狱","uri":"/2022/01/%E8%B6%8A%E7%8B%B1/"},{"categories":null,"content":"常用插件 Apple File Conduit “2” ( afc2 afc2add) 必备 AppSync Unified (安装破解软件的必须安装) 必备 iFile或Filza（修改系统文件必备程序） 必备 OpenSSH SSH远程登录 源apt.saurik.com Hestia 全局绕过越狱检测 cydiakk中文源 Succession 平刷 1.4.16~b4 KernBypass内核级屏蔽 datameter 流量监视 weetrackdata7 for notification 流量监测 facetimeaudio Commcenter patch for IOS7 更改运营商配置 FlipControlCenter 快捷开关 Gps tryLandGps ipad工具移植 feelsiri tetherme 个人热点 swirlysms free 收短信 weeflashlight 通知中心手电筒插件 IAP Cracker 内购 IAPfree 内购 Auto3G 在锁屏的时候，自动关闭3g信号，以节省更多电量[ios5兼容] EZDecline 锁屏挂电话 Activator (手势) Appstore加速补丁 Barrel 3D （改变翻页的方式，大概15种左右，有的确实很炫，几乎必装，增加新鲜感的利器） BlurriedNC background （通知中心半透明插件） BiteSMS （一款iPhone上使用最多的一款Cydia插件，它强大的短信管理功能，包括锁屏界面直接回复/发送短信、定时发短信、自动回复短信、短信加密等等，都让原本就十分单薄的系统短信软件变得更加的不堪一击） Gridlock（使你的图标可以随意摆放，愿意放哪就放哪。几乎是美化必备的插件） KuaiDial（归属地显示，开短信会闪退，关闭短信功能即可使用） killBackground(一键关闭所有程序 killBackground中文汉化包 ) Move2 unlock (改变锁屏样式 NetMeter (查看流量，通知中心显示流量，必须配合NetMeterWidget使用) WeeStats Widget（在通知菜单中添加例如注销，重启，亮度之类的快捷方式） WidgetTask for Notification（将你的后台移动到通知中心，无需双击HOME了） WinterBoard (主题工具 GNetMirror 流量显示 udid faker 伪造 3g unrestrictor 5 3g突破wifi 以下软件可以在apt.weiphone.com和***中找到 【1】Activator (多手势控制) 【2】afc2 （服务补丁） 【3】SBSettings （快接开关插件） 【4】AppSync for IOS5.0+ （允许安装破解软件补丁） 【5】AskToCall （防止误打电话发信息的） 【6】BlurriedNCBackground （通知中心透明插件） 【7】Cydia installer （补丁） Cydia Translations （补丁） 【8】Five lcon Dock （dock放置五个图标） 【9】Gridlock （随意放置图标） 【10】Net Meter (流量统计) 【11】WidgetTask for Notificati（将后台程序移动到通知中心） 【12】F^nq1ang补丁+appstore下载加速（F^nq1ang与下载整合到一起的补丁） 【13】iFile （文件管理工具） 【15】folder enhancer cracked （透明文件夹） 【13】360安全卫士 【14】百度输入法 【15】FolderEnhancer (可以使你建立的文件可以放得下几百个图标文件） 【16】Seepfx (这个是锁屏效果.很好看.有多种效果. 不可缺少的插） 【17】Barrel (3D界面,可以使你的翻动图表的时候翻动出各种的形状出来) 【18】ischeduler （全自动飞行，自动启动程序，自动短信） 【19】FaceBreak汉化版 （3G打视频电话补丁、突破WIFI限制，达到网络互通的目的）** 越狱后第一时间添加了XBMC官方源: http://mirrors.xbmc.org/apt/ios/ 安装正式稳定版，然后为了尝新又下载了最新的测试版更新 http://mirrors.xbmc.org/nightlies/darwin/ios/ swirlysms free可以让ipad收短信 Ncsettings+SpringTomize+Zephyr取代 Chinese calendar pro 通知中心日历 Youproxy 一键翻墙 wifi钥匙官方源apt.lianwifi.com 账号13209234222 密码15596048591 修改UDID ispoofs ifaker udid faker iGrimace，ispoofs，iRubbish，ProtectID。 流量 http://apt.feng.com/banxia cracktool 破解插件 iGrimace http://www.igrimace.com ifacker 收费插件免费下 https://cydiadownloader.tk 过越狱检测 nouberjailbreak flex2 越狱恢复 iLEX RAT、Semi-Restore cydia.myrepospace.com/ilexinfo Cydia Impactor 入狱 微商助手 apt.aor.so/wshzhshapp app.so/wshzhshapp ","date":"2022-01-07","objectID":"/2022/01/%E8%B6%8A%E7%8B%B1/:3:0","series":null,"tags":["iPhone"],"title":"越狱","uri":"/2022/01/%E8%B6%8A%E7%8B%B1/"},{"categories":null,"content":"我用#CSDN#这个app发现了有技术含量的博客，小伙伴们求同去《CString 应用操作指南【转】》, 一起来围观吧 https://blog.csdn.net/wallwind/article/details/6599125?utm_source=app\u0026app_version=4.21.1 这篇文章包括以下内容： CString 对象的连接 格式化字符串（包括 int 型转化为 CString ） CString 型转化成 int 型 CString 型和 char* 类型的相互转化 char* 转化成 CString CString 转化成 char* 之一：使用LPCTSTR强制转化 CString 转化成 char* 之二：使用CString对象的GetBuffer方法 CString 转化成 char* 之三: 和控件的接口 CString 型转化成 BSTR 型； BSTR 型转化成 CString 型； VARIANT 型转化成 CString 型； 载入字符串表资源； CString 和临时对象； CString 的效率； 总结 这篇文章包括以下内容： CString 对象的连接 格式化字符串（包括 int 型转化为 CString ） CString 型转化成 int 型 CString 型和 char* 类型的相互转化 char* 转化成 CString CString 转化成 char* 之一：使用LPCTSTR强制转化 CString 转化成 char* 之二：使用CString对象的GetBuffer方法 CString 转化成 char* 之三: 和控件的接口 CString 型转化成 BSTR 型； BSTR 型转化成 CString 型； VARIANT 型转化成 CString 型； 载入字符串表资源； CString 和临时对象； CString 的效率； 总结 ","date":"2022-01-03","objectID":"/2022/01/cstring%E6%8C%87%E5%8D%97/:0:0","series":null,"tags":null,"title":"CString指南","uri":"/2022/01/cstring%E6%8C%87%E5%8D%97/"},{"categories":null,"content":"项目中常用的D3D黑屏优化讲解和源码分享,DX系列的游戏都可以用 诸多工作室在项目测试功能稳定后，为了更高效率的 榨干电脑性能 尽可能的多开会选择将画面黑屏，零渲染！！今天我们来拆解分析实现原理和方案 大部分游戏画面渲染基本用的都是DX系列 除了DX9 现在很多游戏也用到了DX11 他们版本有差异 在逆向程序员眼里区别不大。 通过OD就可以查看游戏加载 了哪些模块，很多游戏都有加载d3d9.dll或者d3d11.dll 这也说明了 他们在正向开发过程中用到了 D3D进行了渲染。所以 也就可以在这些模块 里HOOK 劫持修改他的渲染函数 在他的最后一步直接给他渲染成纯黑 从而实现黑屏优化的效果 渲染过程可以大概分为 BeginScene开始渲染 EndScene结束渲染 Present显示后置缓冲的动画 当然 这个过程其实可以给大家每个函数细节分析。这个就放到咱们的课程视频里面了。重点是我们去HOOK Present这个函数 Present函数会最终等待所有绘制命令结束并将结果从back buffer拷贝到front buffer。渲染到游戏窗口 技术难度也不高 无非就是要定位到这个虚函数 然后HOOK一个新的函数替换他 并且在执行完Clear函数在执行原来的Present函数。完整的代码就在公众号里面输入 黑屏优化 获取把 效果如下 微尘网络安全 专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术 公众号 ","date":"2021-12-29","objectID":"/2021/12/d3d%E9%BB%91%E5%B1%8F%E4%BC%98%E5%8C%96/:1:0","series":null,"tags":["辅助精品帖"],"title":"D3D黑屏优化","uri":"/2021/12/d3d%E9%BB%91%E5%B1%8F%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"xdbg的简介 Xllydbg(简称xdbg)和OD的用法和界面都是很像的,由于网络安全的发展,OD无法满足大部分人的需要了,更多的人习惯对xdbg进行处理,来达到正常调试的目的. 从官网下载一款xdbg,安装后双击下图的exe程序,可以打开32位的xdbg xdbg的初始设置 打开xdbg并随便附加一款程序,我们先来对xdbg进行一些设置,这些设置更多是针对64位的程序的 我们在选项中点选择选项,可以看到事件设置 这里的断点没有特殊需求可以全部取消, 然后在异常中添加区间为0-0xFFFFFFFF,保证不会被\"异常一\"干扰,当然如果出现了\"异常二\"则说明程序已经崩溃了. 在反汇编界面,我们可以把高亮和0x前缀加上,这样操作起来更加方便. 然后在选项-外观中选择字体 我们可以根据自己的需求和显示器的分辨率来对字体大小进行修改,保证能够完整的看到代码和其他的信息. 做完以上的设置,我们就可以正常的进行操作了 xdbg和OD的区别 由于xdbg和OD的主要操作方式都是类似的,所以我们主要看一下二者的区别 1.1 xdbg的命令行插件不是很完善,所以我们跟多是采用dump或者ctrl+G来进行数据窗口跟随,并且在数据窗口右键进行下断点,或者查看不同的数据类型等操作 1.2 在xdbg的反汇编窗口中点右键,我们发现布局和OD有很大的不同 这里缺少了一些OD中有的内容,比如查看注释,真正的查看注释是在上面菜单栏的\"视图\"-“注释\"中查看,也可以直接点图中的按钮 还有一些功能的位置也发生了变化,比如查找常量,这个功能在下面的\"搜索\"中 这个搜索是有范围的,我们可以通过不同的范围去查找常量,命令等等 1.3 xdbg的分析代码和OD也有一些不同,我们可以在代码段中点击\"A\"来对局部代码进行分析,这一点要比OD方便的多 1.4 xdbg还有函数调用的参数窗口,可以在函数断下时查看参数值,这一点也比OD方便一些,不过实用性并不强 1.5 当我们学习一段时间后还会发现,xdbg有一个OD无法比拟的优势,就是他可以查看的寄存器非常多,比如xmm和ymm寄存器 这些寄存器在OD中是无法查看的,虽然OD也识别这些寄存器的指令,但是并没有对其数值及进行显示. 1.6 xdbg的调用堆栈,和OD中的\"K\"功能在界面上还是有一点小差别的 xdbg需要完善的功能 当然xdbg也有一些不是很完善的功能,比如在堆栈窗口中无法对数值进行查找,只能复制到文档中查找. xdbg的执行到返回,值能执行到retn,无法像OD一样自带F8步进 xdbg和OD各有利弊,相信在未来几年,xdbg的功能也会越来越完善,也建议大家能够掌握这两种调试器的使用方法,以便于后面的学习. ","date":"2021-12-24","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B32-xdbg%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E8%AE%BE%E7%BD%AE/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】32 - xdbg的认识与设置","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B32-xdbg%E7%9A%84%E8%AE%A4%E8%AF%86%E4%B8%8E%E8%AE%BE%E7%BD%AE/"},{"categories":null,"content":"上一节课,给大家介绍OD的一些基本的使用方法,当然OD不仅仅只有这些功能和指令,这节课咱们就来更深入的了解一下OD 对命令行插件进行操作 首先我们来了解一下数据窗口的命令行插件都支持哪些命令 之前说了DD是在数据窗口中查看一个地址,其实这只是将数据用堆栈格式转存,是不是和堆栈窗口的结构很像?其实还有一个命令是dump,他和dd的效果是类似的 还有几种转存方式我们来看下 DA,转存为反汇编代码 DB,转存为十六进制字节格式 DC,用ASCII转存 还有很多很多,下面我们就不截图了,简单来说下 DU,用UNICODE型转存 DW,用十六进制字词格式转存,也就是WORD型 BP,进行条件中断 BC,清除断点 MR,内存访问断点 MW,内存写入断点 MD,清除内存断点 HR,硬件访问断点 HW,硬件写入断点 HE,硬件执行断点 HD,清除硬件断点 我们前期学习常用的命令就只有这些,更多的命令大家可以到网上搜索一下,还有很多很多 对数据窗口进行操作 我们在数据窗口中随便找一个数据,点右键 在这里,可以对数据进行二进制编辑,复制等操作, 这个功能主要是用于一次性复制和写入一些较长的内存数据 还可以对某个地址以某个数据类型下断点 我们可以看到,这里可以下5种断点,而硬件访问和写入可以下3种数据类型的断点, 如果我们用xllydbg调试64位的程序,还会多出一个QWORD的访问类型,这个我们放到后面去说 还有一些其他常用功能,比如修改,数据窗口中跟随等等,这些就是数据窗口的主要操作方式 反汇编窗口 反汇编窗口主要体现的是内存的代码段,我们先点击alt+E,或者点击上面的\"E\"按钮 可以来到模块窗口,我们直接选择代码所在的模块双击,可以调到模块所在代码段 来到这个界面以后点击ctrl+A可以分析整个模块的代码,这个过程根据模块大小需要不同的时间. 在反汇编窗口中点右键,可以看到很多选项,对代码段大部分的操作都可以在这里实现,比如 右键-查找可以用来查找注释,常量,命令,二进制字串等信息 在断点中也可以设置F2断点,条件断点,硬件执行断点等等 根据OD加载的插件不同,我们能够使用的功能也会有一些变化. 调用堆栈窗口 当我们对一个地址下F2断点后,可以点击菜单下面的 来查看函数的调用关系 如何取看这个窗口我们会在后面课程中讲解 以上就是初学者需要了解的一些OD的使用技巧,更加深入的内容我们会在后面的课程中一一介绍 ","date":"2021-12-23","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B31-od%E6%9B%B4%E5%A4%9A%E6%8A%80%E5%B7%A7/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】31 - OD更多技巧","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B31-od%E6%9B%B4%E5%A4%9A%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"调用cmd来执行响应的命令，windows实际上也给了一些接口，但是有些在执行某些命令的时候，却不能够执行，比如 winsat。 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"system 这个命令使用 VS 的同学一定不陌生 当我们想要执行某个命令或打开某个程序时 system(\"calc\"); 注：该函数是阻塞的 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:1:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"WinExec WinExec(\"ipconfig\", SW_SHOWNORMAL); //第二个参数表示显示cmd命令框 注：该函数是非阻塞的，也就是说，当输入的命令需要长时间来执行时，程序并不会等待执行结果，而是直接往下运行 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:2:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"ShellExecute 上述两种执行cmd的方法比较少用。 先看这个这个函数原型，共有六个参数 HINSTANCE ShellExecuteA( HWND hwnd, //指定父窗口，一般为NULL LPCSTR lpOperation, //打开方式 LPCSTR lpFile, //要打开的文件，要执行的程序 LPCSTR lpParameters, //参数 LPCSTR lpDirectory, //缺省目录，一般为NULL INT nShowCmd //命令框打开方式 ); 各个参数含义： HWND hwnd 指定父窗口句柄(通常为NULL) LPCSTR lpOperation 指定动作，表示打开Filename的方式： open 正常打开 runas 以管理员身份打开 print 打印Filename指定的文件 explore 表示浏览由FileName参数指定的文件夹 find 从lpDirectory指定的目录开始搜索 edit 启动编辑器并打开文档进行编辑 LPCSTR lpFile, 表示要打开的文件，比如cmd.exe，calc(计算器) LPCSTR lpParameters, 打开程序所执行的参数 LPCSTR lpDirectory, 缺省目录，一般为NULL INT nShowCmd 命令框打开方式 SW_HIDE（0）隐藏窗口并激活另一个窗口。 SW_MAXIMIZE（3）最大化指定的窗口。 SW_MINIMIZE（6）最小化指定的窗口并激活z顺序中的下一个顶级窗口。 SW_RESTORE（9）激活并显示窗口。如果窗口最小化或最大化，Windows会将其恢复到原始大小和位置。应用程序应在还原最小化窗口时指定此标志。 SW_SHOW（5）激活窗口并以当前大小和位置显示它。 SW_SHOWDEFAULT（10）根据启动应用程序的程序传递给CreateProcess函数的STARTUPINFO结构中指定的SW_标志设置show状态。应用程序应该使用此标志调用ShowWindow来设置其主窗口的初始显示状态。 SW_SHOWMAXIMIZED（3）激活窗口并将其显示为最大化窗口。 SW_SHOWMINIMIZED（2）激活窗口并将其显示为最小化窗口。 SW_SHOWMINNOACTIVE（7）将窗口显示为最小化窗口。活动窗口保持活动状态。 SW_SHOWNA（8）以当前状态显示窗口。活动窗口保持活动状态。 SW_SHOWNOACTIVATE（4）显示最近大小和位置的窗口。活动窗口保持活动状态。 SW_SHOWNORMAL（1）激活并显示一个窗口。如果窗口最小化或最大化，Windows会将其恢复到原始大小和位置。应用程序应在首次显示窗口时指定此标志。 最常用的几个：SW_SHOWNORMAL(正常显示)、SW_HIDE(隐藏) 例子： ShellExecute(NULL, \"runas\", \"cmd\", \"/c ipconfig \u003e\u003e D:\\\\disk.txt\", NULL, SW_SHOWNORMAL); 含义：以管理员身份运行cmd，执行ipconfg命令，将输出重定向到C:\\disk.txt中，命令框正常显示 注：和WinExec一样，该函数也是非阻塞的 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:3:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"阻塞式调用ShellExecute SHELLEXECUTEINFO ShExecInfo = { 0 }; ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO); ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS; ShExecInfo.hwnd = NULL; ShExecInfo.lpVerb = \"runas\"; ShExecInfo.lpFile = \"cmd\"; ShExecInfo.lpParameters = \"/c winsat disk \u003e\u003e D:\\\\disk.txt\"; ShExecInfo.lpDirectory = NULL; ShExecInfo.nShow = SW_HIDE; ShExecInfo.hInstApp = NULL; ShellExecuteEx(\u0026ShExecInfo); WaitForSingleObject(ShExecInfo.hProcess, INFINITE); 每个参数的含义和ShellExecute都一样。其中上述命令参数中 /c： /c 是执行完命令后关闭命令窗口。 /k 是执行完命令后不关闭命令窗口。 但上述方法却不是万能的，有些命令在cmd中可以执行，但如果按照上述方法打开cmd就不能执行，比如 winsat，会出现winsat不是内部命令或可执行文件 的错误。那是因为应用程序发生了重定向 原因链接 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:4:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"使用CreatProcess(最好使用这个) bool RunCmdAndOutPutRedirect(const std::string \u0026outPutFile, const std::string \u0026cmd, bool wait = false) { cout\u003c\u003c \"outPutFile:\" \u003c\u003c outPutFile \u003c\u003c \" cmd:\" \u003c\u003c cmd \u003c\u003c \" wait:\" \u003c\u003c wait; STARTUPINFOA si; PROCESS_INFORMATION pi; SECURITY_ATTRIBUTES sa; sa.nLength = sizeof(sa); sa.lpSecurityDescriptor = NULL; sa.bInheritHandle = TRUE; HANDLE handle = CreateFileA(outPutFile.c_str(), FILE_APPEND_DATA, FILE_SHARE_WRITE | FILE_SHARE_READ, \u0026sa, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL); if (!handle) { cout \u003c\u003c \"CreateFile failed:\" \u003c\u003c GetLastError(); return false; } memset(\u0026si, 0, sizeof(STARTUPINFO)); memset(\u0026pi, 0, sizeof(PROCESS_INFORMATION)); si.cb = sizeof(STARTUPINFO); si.dwFlags |= STARTF_USESTDHANDLES; si.wShowWindow = SW_HIDE; si.hStdInput = NULL; si.hStdError = NULL; si.hStdOutput = handle; if (!CreateProcessA(NULL, (LPSTR)cmd.c_str(), NULL, NULL, TRUE, CREATE_NO_WINDOW, NULL, NULL, \u0026si, \u0026pi)) { cout \u003c\u003c \"CreateProcess failed:\" \u003c\u003c GetLastError(); return false; } if (wait) { WaitForSingleObject(pi.hProcess, INFINITE); } cout \u003c\u003c \"WaitForSingleObject finish return:\" \u003c\u003c GetLastError(); CloseHandle(handle); CloseHandle(pi.hThread); CloseHandle(pi.hProcess); return true; } void Task() { PVOID oldValue = NULL; if (Wow64DisableWow64FsRedirection(\u0026oldValue)) { string filePath = \"D:\\\\diak.txt\"; string cmd = \"winsat disk\"; RunCmdAndOutPutRedirect(filePath, cmd, true); //true表示阻塞调用 } else { LOG_WARN \u003c\u003c \"重定向失败：\" \u003c\u003c GetLastError(); } if (Wow64RevertWow64FsRedirection(oldValue) == FALSE) { return; } } ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:5:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"如何调用winsat(解决应用程序重定向问题) 需要调用windows的两个函数: Wow64DisableWow64FsRedirection() Wow64RevertWow64FsRedirection() PVOID oldValue = NULL; if (Wow64DisableWow64FsRedirection(\u0026oldValue)) { //ShellExecute(NULL, \"runas\", \"cmd\", \"/c winsat disk \u003e\u003e D:\\\\disk.txt\", NULL, SW_SHOWNORMAL); //执行cmd命令 SHELLEXECUTEINFO ShExecInfo = { 0 }; ShExecInfo.cbSize = sizeof(SHELLEXECUTEINFO); ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS; ShExecInfo.hwnd = NULL; ShExecInfo.lpVerb = \"runas\"; ShExecInfo.lpFile = \"cmd\"; ShExecInfo.lpParameters = \"/k winsat disk \u003e\u003e D:\\\\disk.txt\"; ShExecInfo.lpDirectory = NULL; ShExecInfo.nShow = SW_HIDE; ShExecInfo.hInstApp = NULL; ShellExecuteEx(\u0026ShExecInfo); WaitForSingleObject(ShExecInfo.hProcess, INFINITE); } if (Wow64RevertWow64FsRedirection(oldValue) == FALSE) { return; } 就很好的解决了重定向的问题。 Wow64DisableWow64FsRedirection() 主要是为了关闭重定向 Wow64RevertWow64FsRedirection() 主要是为了恢复重定向 这两个函数一定要成对出现，关闭完成任务后一定要记得恢复。要不然会对其他的产生一定的影响。 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:6:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"任务计划程序 实际上，调用cmd还有另外一种方法，就是使用任务计划程序。这种方法也可以解决上面重定向的问题，但使用起来会比较麻烦一些。 ","date":"2021-12-21","objectID":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/:7:0","series":null,"tags":null,"title":"C++ 调用cmd的几种方法","uri":"/2021/12/c-%E8%B0%83%E7%94%A8cmd%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"CMap 类别 详情 语法 描述 CMap::GetStartPosition 传回第一个元素的位置。 CMap::GetNextAssoc 取得下一个反覆运算的元素。 CMap::Lookup 查阅对应至指定索引键的值。 CMap::RemoveKey 移除由键指定的元素。 CMap::SetAt 将元素插入到映射中;如果找到匹配的键，则替换现有元素。 ","date":"2021-12-21","objectID":"/2021/12/cmap/:1:0","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"举例如下： ","date":"2021-12-21","objectID":"/2021/12/cmap/:2:0","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"1、定义一个CMAP，向这个CMAP中增加数据项（键-值对）。 CMap\u003cCString, LPCTSTR, CString, LPCTSTR\u003em_ItemMap; CString strKey = _T(\"\"), str = _T(\"\"); int i; for(i = 0; i \u003c 5; i++) { strKey.Format(\"%d\", i); //这个是键 str.Format(\"A%d\", i); //键对应的值 m_ItemMap.SetAt(strKey, str); } ","date":"2021-12-21","objectID":"/2021/12/cmap/:2:1","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"2、遍历整个CMAP的常用方法。 POSITION pos = m_ItemMap.GetStartPosition(); while(pos) { m_ItemMap.GetNextAssoc(pos, strKey, str); cout\u003c\u003c strKey\u003c\u003c \":\"\u003c\u003c str\u003c\u003c endl; } ","date":"2021-12-21","objectID":"/2021/12/cmap/:2:2","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"3、在CMAP中查找相应的数据项。 CString pReset; if(m_ItemMap.Lookup(\"1\", pReset)) { cout\u003c\u003cpReset\u003c\u003cendl; } ","date":"2021-12-21","objectID":"/2021/12/cmap/:2:3","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"完整例子 class Point { public: Point() { m_x = 0; m_y = 0; } Point(int x, int y) { m_x = x; m_y = y; } public: int m_x; int m_y; }; typedef CMap\u003cconst char*, const char*, Point, Point\u0026\u003e CMapPnt; //请在使用之前定义 int main() { Point elem1(1, 100), elem2(2, 200), elem3(3, 300), point; CMapPnt mp; // insert 3 elements into map， #1 mp.SetAt(\"1st\", elem1); mp.SetAt(\"2nd\", elem2); mp.SetAt(\"3th\", elem3); // search a point named \"2nd\" from map #2 mp.Lookup(\"2nd\", point); printf(\"2nd: m_x: %d, m_y: %d\\n\", point.m_x, point.m_y); // insert a new pair into map #3 Point elem4(4, 400); mp[\"4th\"] = elem4; cout\u003c\u003c\"count: \"\u003c\u003cmp.GetCount()\u003c\u003cendl; // traverse the entire map #4 size_t index = 0; const char* pszKey; POSITION ps = mp.GetStartPosition(); while( ps ) { mp.GetNextAssoc(ps, pszKey, point); printf(\"index: %d, m_x: %d, m_y: %d\\n\", ++index, point.m_x, point.m_y); } return 0; } 代码中，我已经给出了一些注释，我同样建议读者们，用英文在代码中注释，这样的好处实在是太多了。尤其在代码需要在不同编码的操作系统上调试的时候。 对于CMap这个类，我不得不着重啰嗦一下的是：遍历操作以及取下标【】操作，当然还有那个令很多人困惑不已的ARG_KEY到底应该如何选择的问题。 遍历，看注释#4，至于POSITION的含义，请在本空间，查看其它文章。先使用GetStartPosition()函数获得表头的位置，然后，我们可以使用GetNextAssoc函数来遍历。GetNextAssoc(POSITION\u0026 rNextPosition, KEY\u0026 rKey, VALUE\u0026 rValue)函数的参数值得说明一下，大家看到，3个参数都是引用，而第一个是rNextPosition，顾名思义，在函数返回之后，它将会指像下一个元组，当然这是在表还未遍历完的时候，否则，它将被置为空（NULL）。 【】，利用下标取元素的这个操作符，在CMap中被重载，用来返回指定Key值数据的引用，不过在注释#3处，对于先取\"4th\"这个Point的引用然后赋值的用法，看起来，似乎有点聪明过了头，因为在这之前，我们还没有插入\"4th\"所对应的元组，但是，程序却能正常的运行！为什么？其实，这样的用法是十分正确的，因为CMap毕竟不是数组，它是没有边界的，当CMap在获得一个它无法查询到的Key值的时候，它会将这个Key以及一个空的数据类型追加到Hash表中去，从而保证了上面的程序可以无误的运行。 我们已经说过，ARG_KEY是作为类型参数传入CMap的，但并不是任何类型都可以作为ARG_KEY传入的。为什么？看样子，这次不得不简单的说说Hash表的散列函数了。每个Hash表，总会使用一些散列函数，用来查找Key所对应的Value，理想状态下，我们当然希望Hash表，就是一个数组，虽然这不可能，不过这样理解，可以帮助我们更好的理解Hash表的物理结构，就让我们暂时把它看成一个数组吧。数组总是使用下标来直接获取元素的存储地址，而下标，显然应该是个非负整数，从而Hash表，也应该具备这样的特性，至少必须存在某种算法可以使传入的Key可以直接的转化为一个非负的整数，这也就是ARG_KEY的选择标准。从而对象、引用无论如何都不应该作为ARG_KEY成为CMap的类型参数，而int、unsigned int、指针以及地址就成为了ARG_KEY的常用类型参数，其实也就是那些类似于整型的数据类型。常常看到一些人在用CMap的时候，试图使用CString作为CMap中ARG_KEY的类型参数，这是应该被纠正的方向性错误，但有些人似乎会理直气壮的反驳我，因为他们发现类型参数KEY是可以使用CString的，这很奇怪吗？我说过KEY不能使用CString吗？之所以KEY可以使用CString而ARG_KEY却用的是LPCTSTR，那是因为CString重载了operator==(const char*)这个判等操作符，当CMap从Hash表中获得KEY之后，它会将ARG_KEY与KEY直接相比较。真正存于CMap内部的是KEY，也就是CString。这也就是为什么，我们经常会看到CMap被实化成CMap\u003cCString, LPCTSTR/相当于const char，非Unicode情况下*/, CString，CString\u0026\u003e这样的一个四不像实化类的原因，至于CMap的效率优化问题，我们会在以后的文章中继续与大家探讨。 CMap的确是个很不错的数据结构，尤其在你建立一个字典的时候。比如idealsoft的含义是\"曳光科技\"，这就是一个元组，也就是一个Pair，Key是\"idealsoft\"，而Value是\"曳光科技\"。 ","date":"2021-12-21","objectID":"/2021/12/cmap/:2:4","series":null,"tags":["CMap"],"title":"CMap","uri":"/2021/12/cmap/"},{"categories":null,"content":"基地址和动态地址是一对好基友,他们相隔十万八千里,却紧密联系着 他们不用像唐僧取经一样翻山越岭,经历九九八十一难,因为他们有一种如同月光宝盒一样的交通工具, 我们叫它偏移 这节课我们就用CE来查找基地址和偏移的表达式 ","date":"2021-12-20","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】23 - CE找偏移表达式","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"1.1 扫描表达式 何为偏移?简单来说偏移就是两个地址之间内存距离,他的单位是字节. 当然并不是说所有的地址之间的偏移都是有意义的, 就好比两个城市之间没有直达的交通工具,你只能通过其他城市进行中转一样 而这个中转的过程,我们就叫它偏移表达式 我们来到教案游戏的第三层,在这一层里有很多的怪物,我们要通过攻击这些怪物来找到人物血量和基地址的偏移表达式. 打开CE,扫描4byte的1000 得到的60个结果,我们需要进一步过滤,打一个怪试试 怪挂了,剩余960的血量,CE过滤一下,只得到了一个结果 在这个地址上点右键,选择Find out what accesses this address选项,我们可以看到访问这个地址的所有代码 当然这只是当前这个状态访问的代码,如果我们做一些其他的动作,比如打怪等等,还会有更多的代码显示出来 这里我们可以看到,访问最频繁的是第一个代码,共有288次,这句代码的意义就是将寄存器eax里面存放的值传递给寄存器ecx,我们做一个了解即可,后面还会做详细讲解. 我们可以任意选择一条代码去继续分析,前提是逗号左右两边的寄存器不能一样,比如mov ecx,[ecx] 我们选择第一条,双击,或者点击, 可以得到当前所有寄存器的数值 这里的eax就是我们要继续分析的地址,他的值是0xDC6070,由于这一条是没有偏移的,所以这个值和我们查找访问代码的地址是一样的, 我们直接用CE继续扫描0xDC6070,这里要注意的是,扫描十六进制地址必须要勾选16进制 这里得到的结果较多,我们需要ctrl+A选中全部,并点击 全部拉到下面来 接下来我们对这30多个地址挨个查找访问代码,找出有访问代码的地址 在对第三个地址访问的时候得到了两条带有0x14偏移的代码 我们任选一条地址进行双击或者点击 可以得到当前状态所有寄存器的值 我们要的是edx的值,等于0xD55A70 现在我们的偏移表达式变为了[[0xD55A70+14]] 这个[ ]代表着读地址里的值 接下来我们再次用CE扫描0xD55A70, 只得到了一个结果 对这个地址进行访问以后,可以得到一个+FC的偏移 此时表达式为[[[0xEA4D88+FC]+14]] 重复的操作得到第一条中edx的值,并在CE中进行扫描, 问题出现, 这一次没有扫描到任何结果 出现这种结果的情况有很多,我们尝试用之前学过的将快速扫描取消试一下 这里得到了一个不能被4整除的地址(PS:这是heart老师特意设计的一个小小的坑,你能想到么?) 继续查找访问这个地址的代码吧 可以得到一个+5的偏移,同样选择第一条,获取到eax的值为0xE959D0 现在的偏移表达式变成了[[[[0xE959D0+5]+FC]+14]] 还没到基地址,继续扫描 这次得到了一个绿色的地址 此时我们可以将偏移表达式写为[[[[[B9FB1C]+5]+FC]+14]] 这个绿色的地址我们暂时将它看成是基地址,我们需要后面用OD去进行验证才能确定 当然这个地址已经不会随着游戏重启而改变了 如果这个地址每次游戏启动都会变化,那么我们也可以用模块+偏移的形式来表示,比如: [[[[[网络安全学院.exe+79FB1C]+5]+FC]+14]] ","date":"2021-12-20","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】23 - CE找偏移表达式","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"1.2 测试表达式 接下来,我们用CE去测试一下这个表达式是否正确(这里悄悄的换一下官方的CE,没有乱码) 点击Add Address Manually, 点击 再点击 添加偏移 这里一共有5层偏移,所以要添加4次 可以正常的显示人物血量了,说明我们的表达式是没有问题的 接下来大家可以用这个方法试试找到人物的坐标,层数等数据了 ","date":"2021-12-20","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】23 - CE找偏移表达式","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B23-ce%E6%89%BE%E5%81%8F%E7%A7%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"categories":null,"content":"基地址 每一次程序启动,内存都会重新分配,我们在CE中扫描的地址大多会发生改变,但也有一些是不会随着游戏重启而变化的,这里面就有一部分是基地址. 基地址是相对静态的,我们所说的基地址不变,只是说这个地址不会变,他指向的内容的意义通常也是不变的,但是指向的数值大多会随着程序重启而变化. 内存的角度和程序的角度看基地址 基地址在程序中的本质是全局变量 如果我们在CE中取扫描一个数值,可以发现有一部分结果是绿色的 这些绿色的地址,往往就是基地址,他们是不会随着程序重启而发生变化的 我们选中这些地址并双击,将他们提取到下面的列表中,并且在列表中双击 下面的地址,可以看到他们是由\"XXXX.exe+xxxx\"表示的. 这个XXXX.EXE是模块名,这个值代表的是模块句柄,很多32位程序的主模块都是固定不变的,即0x400000,当然也有很多的模块是随着程序重启而变化的. 无论是否变化,我们使用GetModuleHandleA(“模块名”) 获取即可 基地址也是模块范围内的地址 ","date":"2021-12-19","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】21 - 基地址和动态地址","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/"},{"categories":null,"content":"偏移 把存储单元的实际地址与其所在段的段地址之间的距离称为段内偏移，也称为“有效地址或偏移量”。 简单点说,就是一个内存地址相对于另外一个内存地址的距离,这距离的单位是字节 内存地址A+偏移=内存地址b 例如 0x50000 和 0x50050 的偏移就是 0x50 再比如前面我们提到的基地址是由模块句柄+“一个值\"得来的,其实这\"一个值\"就是基地址相对于模块句柄的偏移, 而且在程序不更新的前提下,这个值是不会变化的. ","date":"2021-12-19","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】21 - 基地址和动态地址","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/"},{"categories":null,"content":"动态地址 在我们扫描教案小游戏的人物血量后,可以得到一个地址 当我们重新启动游戏后,发现这个地址失效了 这里显示的是”??\",这种就是动态地址,他所代表的含义并不是固定的 那么如果遇见动态地址,我们怎么处理呢? 我们需要找到这个地址的偏移与所在的基地址, 例如[基地址]+偏移（当然也可能更多层偏移） 这里的基地址我们用了一个中括号括起来,他代表的是读基地址里面的值,也就是我们后面会讲到的指针,这里有一个简单的了解即可. ","date":"2021-12-19","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】21 - 基地址和动态地址","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B21-%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%92%8C%E5%8A%A8%E6%80%81%E5%9C%B0%E5%9D%80/"},{"categories":null,"content":"PROCESSENTRY32 存放快照进程信息的结构体 头文件 #include\"tlhelp32.h\" ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"CreateToolhelp32Snapshot函数 获取系统中正在运行的进程信息，线程信息等。 详细内容见此 HANDLE WINAPI CreateToolhelp32Snapshot( _In_ DWORD dwFlags, //用来指定“快照”中需要返回的对象，可以是TH32CS_SNAPPROCESS等 _In_ DWORD th32ProcessID //一个进程ID号，用来指定要获取哪一个进程的快照，当获取系统进程列表或获取 当前进程快照时可以设为0 ); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Process32First 进程获取函数(第一个) 当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后，我们可以利用process32First函数来获得第一个进程的句柄。 BOOL WINAPI Process32First( HANDLE hSnapshot,//_in 从CreateToolhelp32Snapshot 返回的句柄。 LPPROCESSENTRY32 lppe//_out 指向PROCESSENTRY32结构的指针。 ); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Process32Next 进程获取函数(下一个) 当我们利用函数CreateToolhelp32Snapshot()获得当前运行进程的快照后,我们可以利用Process32Next函数来获得下一个进程的句柄。 BOOL WINAPI Process32Next( __in HANDLE hSnapshot, //从CreateToolhelp32Snapshot 返回的句柄。 __out LPPROCESSENTRY32 lppe //指向PROCESSENTRY32结构的指针。 ); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"strcpy 字符串比较 用于ANSI标准字符串 这是用于ANSI标准字符串的函数(如string和char *)，此函数接受两个字符串缓冲区做为参数，如果两个字符串是相同的则返回零。否则若第一个传入的字符串的值大于第二个字符串返回值将会大于零，若传入的第一个字符串的值小于第二个字符串返回值将小于零。 char *strcpy(char *strDestination, const char *strSource); //实例 char *ch=\"翔翔糖糖\"; if(strcmp(ch,\"翔翔糖糖\")==0) { undefined //字符串相等 } else { undefined //字符串不相等 } ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"wcscpy 字符串比较 用于Unicode标准字符串 它的使用方法和strcmp相同，它用来比较两个Unicode字符串是否相等(如wstring和wchar_t *)。 wcscpy()即为strcpy()的宽字符版本，与_T类似的 wchar_t *wcscpy(wchar_t *strDestination, const wchar_t *strSource); //实例 wchar_t *ch=L\"翔翔糖糖\"; if(wcscmp(ch,L\"翔翔糖糖\")==0) { undefined //字符串相等 } else { undefined //字符串不相等 } ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"_tcscmp 字符串比较 _tcscpy 在编译时会根据条件被替换 如果是 ANSI工程,则使用 strcpy 如果是UNICODE工程，则使用wcscpy。 #ifdef UNICODE #define _tcscpy wcscpy #else #define _tcscpy strcpy #endif ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"EnumWindows 枚举顶层窗口 该函数枚举所有屏幕上的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。回调函数返回FALSE将停止枚举，否则EnumWindows函数继续到所有顶层窗口枚举完为止。 //函数原型 BOOL WINAPI EnumWindows( _In_ WNDENUMPROC lpEnumFunc,//为回调函数 _In_ LPARAM lParam //传递给回调函数 ); //回调函数原型 BOOL CALLBACK EnumWindowsProc( HWND hwnd, //枚举到的窗口句柄 LPARAM lParam //EnumWindows传递过来的参数 ); EnumWindows中的参数：lpEnumFunc回调函数，lParam参数传递给回调函数的lParam。回调函数中的参数：hwnd枚举到的窗口句柄，lParam为EnumWindows传递过来的参数。 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"EnumChildWindows 枚举子控件 功能：枚举指定控件下的所有子控件，并将子控件句柄传送给应用程序定义的回调函数，回调函数返回FALSE将停止枚举，否则一直到所有子控件枚举完为止。 //函数原型： BOOL EnumChildWindows( HWND hWndParent, //为目标控件所在的父控件句柄 WNDENUMPROC lpEnumFunc, //为回调函数 LPARAM lParam //传递给回调函数 ); //回调函数原型： BOOL CALLBACK EnumChildProc( HWND hwnd, //枚举到的子控件句柄 LPARAM lParam //EnumChildWindows传递过来的参数 ); EnumChildWindows中的参数：hWndParent为目标控件所在的父控件句柄；lpEnumFunc为回调函数；lParam传递给回调函数。回调函数中的参数：hwnd枚举到的子控件句柄，lParam为EnumChildWindows传递过来的参数。 如果hWndParent参数为NULL，则此函数等效于EnumWindows。 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:9:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"SetTimer 设置定时器 SetTimer( 1, //定时器ID 5000, //时间 NULL //调用的函数 ); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:10:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"KillTimer 关闭定时器 KillTimer(1);//定时器编号 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:11:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"AfxExtractSubString 分割字符串(MFC专用) //原型 BOOL AfxExtractSubString( CString\u0026 rString, //保存输出的子字符串 LPCTSTR lpszFullString, //待分割的字符串 int iSubString, //提取的子字符串的序号，从0开始。假如你想提取第3段，该参数就输入2 TCHAR chSep //用于分割的字符，默认的是'\\n'　);//返回值: 分割成功，就返回TRUE；iSubString越界，则返回FALSE //实例 CString str = _T(\"abc45,78ea,679u,368\"); CString strSub; AfxExtractSubString(strSub, (LPCTSTR)str, 0, ',');　// strSub的内容为abc45 AfxExtractSubString(strSub, (LPCTSTR)str, 3, ',');　// strSub的内容为368 注意：用于分割的只能是字符，不能是字符串。 多个字符使用_tcstok函数。 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:12:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"AfxBeginThread 启动线程(MFC专用) CWinThread* AfxBeginThread( AFX_THREADPROC pfnThreadProc, //指向工作线程的控制函数。 指针不能为 NULL 。 LPVOID pParam, //要传递到控制函数的参数。 int nPriority = THREAD_PRIORITY_NORMAL, //要为线程设置的优先级。 UINT nStackSize = 0, //指定新线程堆栈的大小（以字节为单位） DWORD dwCreateFlags = 0, //指定控制线程创建的其他标志。 LPSECURITY_ATTRIBUTES lpSecurityAttrs = NULL); //指向一个 SECURITY_ATTRIBUTES 结构，该结构指定线程的安全特性 //返回值:指向新创建的线程对象的指针; NULL 如果发生失败，则为。 [MFC 大漠.xmind](../../../../../../iCloud~net~xmind~brownieapp/Documents/辅助/脚本/MFC 大漠.xmind) ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:13:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"PostMessage 发送消息(不等待直接返回) 在窗口的消息队列中放置一条消息，然后返回而不等待相应的窗口处理该消息。 BOOL PostMessage( UINT message, //指定要发布的消息。 WPARAM wParam = 0, //指定其他消息信息 LPARAM lParam = 0); //指定其他消息信息 //返回值: 如果发送消息成功，则为非零值;否则为0。 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:14:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"_beginthread, _beginthreadex 创建线程(通用) 详情 uintptr_t _beginthread( // NATIVE CODE void( __cdecl *start_address )( void * ), unsigned stack_size, void *arglist ); uintptr_t _beginthread( // MANAGED CODE void( __clrcall *start_address )( void * ), unsigned stack_size, void *arglist ); uintptr_t _beginthreadex( // NATIVE CODE void *security,//指向 SECURITY_ATTRIBUTES 结构的指针， unsigned stack_size,//新线程的堆栈大小或 0。 unsigned ( __stdcall *start_address )( void * ),//启动开始执行新线程的例程的地址 void *arglist,//要传递到新线程的参数列表，或 NULL 。 unsigned initflag,//控制新线程的初始状态的标志。 unsigned *thrdaddr//指向接收线程标识符的 32 位变量。 ); uintptr_t _beginthreadex( // MANAGED CODE void *security, unsigned stack_size, unsigned ( __clrcall *start_address )( void * ), void *arglist, unsigned initflag, unsigned *thrdaddr ); //返回值 如果成功，则这些函数中的每一个都会返回一个句柄到新创建的线程 //实例 m_hThreadHandle = (HANDLE)::_beginthreadex(NULL,0,ThreadFunction,this,0,\u0026m_uThreadID); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:15:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"_endthread、_endthreadex 终止线程 详情 void _endthread( void ); void _endthreadex( unsigned retval //线程退出代码。 ); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:16:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"WaitForSingleObject 线程等待 详情 csdn DWORD WaitForSingleObject( [in] HANDLE hHandle, //需要等待线程的句柄 [in] DWORD dwMilliseconds //超时时间 一直等待用INFINITE ); //返回值 //有三种返回类型 //WAIT_OBJECT_0, 表示等待的对象有信号（对线程来说，表示执行结束）； //WAIT_TIMEOUT, 表示等待指定时间内，对象一直没有信号（线程没执行完）； //WAIT_ABANDONED 表示对象有信号，但还是不能执行 一般是因为未获取到锁或其他原因 //实例 if (WaitForSingleObject(m_hThreadHandle, INFINITE) == WAIT_TIMEOUT)//线程等待,可延时等待或者一直等待INFINITE { return false; } 实例 // ConsoleApplication1.cpp : 定义控制台应用程序的入口点。 // #include \"stdafx.h\" #include \"stdio.h\" #include \"windows.h\" #include \u003ciostream\u003e using namespace std; int i = 0; DWORD WINAPI FunProc(LPVOID lpParameter); DWORD WINAPI FunProc(LPVOID lpParameter) { for (; i \u003c 10; i++) { if (!(i % 10)) cout \u003c\u003c endl; else cout \u003c\u003c i \u003c\u003c endl; } return 0; } void main() { cout \u003c\u003c i \u003c\u003c endl; HANDLE hThread; hThread = CreateThread(NULL, 0, FunProc, NULL, 0, NULL); DWORD dwRet = WaitForSingleObject(hThread, 1); if (dwRet == WAIT_OBJECT_0) { cout\u003c\u003c \"创建的线程执行结束\" \u003c\u003c endl; } if (dwRet == WAIT_TIMEOUT) { cout\u003c\u003c \"等待超时\" \u003c\u003c endl; } if (dwRet == WAIT_ABANDONED) { cout\u003c\u003c \"Abandoned\" \u003c\u003c endl; } CloseHandle(hThread); system(\"pause\"); } 输出结果有两种: 这就是未能等到线程结束信号量的等待时间就耗光了。我们也可以将WaitForSingleObject的第二个参数设置为 INFINITE，就可以一直等待。 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:17:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"ASSERT(false) 断点 debug模式才生效 详情 //原型 assert( expression //评估为非零 (true) 或 0 (false) 的纯量运算式 (包括指标运算式)。 ); void _assert( char const* message, //要显示的讯息。 char const* filename, //判断提示失败之原始程式档的名称。 unsigned line //判断提示失败之原始程式档中的行号。 ); void _wassert( wchar_t const* message, wchar_t const* filename, unsigned line ); //返回值: 当结果为false时，列印诊断资讯并中止程式。 //实例 ASSERT(false);//断点，debug模式才生效 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:18:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"纪元时间 time_t epoch_time = time(nullptr); cout \u003c\u003c \"Epoch time: \" \u003c\u003c epoch_time \u003c\u003c endl; ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:19:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"SafeDelete 释放指针 有析构函数的在析构函数中释放 没有的在类视图消息属性中释放 SafeDelete(m_pOp); ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:20:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"GetTickCount() 系统开启到现在的时间 单位,毫秒 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:21:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"类型转换 atoi—ASCII to integer,将字符串转换成整形，从数字或正负号开始转换，一直到非数字为止 itoa—integer to ASCII–将整形转换成字符串 atof—ascii to float–字符串转换成浮点型 atol—ascii to long—字符串转换成长整形 gcvt—浮点型转换成字符串（四舍五入） strtod—字符串转换成浮点型 strtol—字符串转换成长整形 strtoul–字符串转换成无符号长整形 toascii—将整形转换成合法的ASCII码字符 _ttoi—可以将CString转换成整形 _itot_s—将int转换成char* float n; char *str = \"12345.67\"; n = atoi(str); //将字符串转换成整形 CWnd * pWnd = (CWnd*)GetDlgItem(IDC_EDIT4) ; CString strValue ; pWnd-\u003eGetWindowText(strValue) ; strValue.Replace(_T(\"sec\"), _T(\"\")) ; int iValue = _ttoi(strValue) ;//将Cstring转换成int TCHAR buffer[7] ; _itot_s(iValue, buffer, 3, 10) ;//将int转换成char* strValue.Format(_T(\"%s\")) ;//将char*转换成CString strValue = strValue + _T(\"sec\") ;//CString实现字符串相加 ","date":"2021-12-17","objectID":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:22:0","series":null,"tags":["“API函数”"],"title":"非常用API函数","uri":"/2021/12/%E9%9D%9E%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["待整理"],"content":" AutoTool 4.9/AutoTool/struct.h shadowrocket https://jiaocheng.dandaner.com/ssr/ping-guo-ios 定时读内存 暂停和恢复 无需越狱！使用iGG修改器修改游戏数据 C++ 版本的 YoloV5 封装库 This is the official YOLOv5 🚀 notebook by Ultralytics Custom Training with YOLOv5 使用darknet识别点选验证码详细过程（附带源码） ","date":"2021-12-16","objectID":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/:0:0","series":null,"tags":["待整理"],"title":"待整理内容","uri":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/"},{"categories":["待整理"],"content":"待转md 使用GitLab保存订阅文件 如何将其他文件迁移到Notion中？将文档导入Notion教程 如何使用 Notion 制作个人网站？ OpenGL和Imgui整合入门 OpenGL和ImGui整合入门（二） OpenGL和ImGui整合入门（三） ","date":"2021-12-16","objectID":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/:1:0","series":null,"tags":["待整理"],"title":"待整理内容","uri":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/"},{"categories":["待整理"],"content":"待看教程 逆向 非虚拟机 【精品逆向课 十天学会破解-哔哩哔哩】https://b23.tv/YSsuDo 【浴血凤凰 2019 dnf-哔哩哔哩】 https://b23.tv/XpG6ZT 【若水过驱动-哔哩哔哩】 https://b23.tv/5TeBlC 【2019年过游戏TP驱动保护+绝地BE检测+工具-哔哩哔哩】 https://b23.tv/5ixW03 【易语言(E语言)基础课程-哔哩哔哩】https://b23.tv/YwcmR4 ","date":"2021-12-16","objectID":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/:2:0","series":null,"tags":["待整理"],"title":"待整理内容","uri":"/2021/12/%E5%BE%85%E6%95%B4%E7%90%86/"},{"categories":null,"content":"[在前面的课中 我们讲了常量和变量 这里我们讲下变量的作用域 和 局部变量 全局变量 全局静态变量 局部静态变量 在讲到这些之前 还需要了解下程序的内存分配问题 ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"一、程序的内存分配 一个由C/C++编译的程序占用的内存分为以下几个部分： 1、栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 2、堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于链表。 3、全局区（静态区）（static）— 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。程序结束后有系统释放 4、文字常量区 — 常量字符串就是放在这里的。 程序结束后由系统释放。 5、程序代码区 — 存放函数体的二进制代码。 好了进入正题！ ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"二、作用域 接下来我们讲到的第一个 是作用域 首先还是从字面意思去理解 因为遇到一个专用名词 其字面意思 肯定或多或少能体现出其功能的特性 好了废话不多说 1.首先作用域关键在于一个\"域\"字的体现 2.联想到了“区域”“范围”等词 3.通俗点来讲就是 对变量限制了作用范围 4.这里首先介绍下 { } 花括号 ，这个就是用来限制齐变量的作用范围的 5.想必大家在之前的代码中 就有所接触到了 由于这里作用域不能单方面的用代码去体现出其作用 我们还需要配合以下知识点去配合讲解 所以开始讲第二个知识点 局部变量 ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"三、局部变量 main函数 中{} 我们之前定义的变量 就限制在这个区域中. 如果出了这个区域 变量申请的内存控件就被系统回收了—称为局部变量. void main() { int a=1; } 看下比较官方的介绍： 局部变量也只有局部作用域，它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。 ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"四、 全局变量 简单来讲,把整个程序的运行周期作为一个限定变量的有效区域 —称为全局变量.这种是不需要{}来说明作用域,如果不初始化则会自动初始化为0.当程序结束.这些变量才会被系统回收. 看下比较官方的介绍： 全局变量具有全局作用域.全局变量只需在一个源文件中定义,就可以作用于所有的源文件. 当然,其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量. extern 在之前讲常量和变量提及到过 ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"4.1 例如 a.cpp #include “b.h” int g_a=1; void main() { Test(); printf(“g_a=%d\\n”,g_a); } b.h void Test(); b.cpp int g_a=1; void Test() { g_a=2; } 编译出现错误 原因：对同一个变量名多重定义了,因为g_a是全局变量,那么怎么引用同一个变量呢？ 之前讲过,使用extern.我们改进下. b.cpp源文件使用extern extern int g_a;//只需要声明一次就行了 . 申明之前也讲过,表示告诉编译器 我们这个变量在别的文件中被定义过了 切记！！ b.cpp extern int g_a; void Test() { g_a=2; } ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:4:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"五、全局静态变量 和上面的全局变量同理 但是是限制变量在定义这个变量的源文件中 看下比较官方的介绍： 静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。 a.cpp文件 static int g_a=1; void main() { Test(); printf(“a.h =\u003e g_a=%d\\n”,g_a); } b.cpp文件 static int g_a=1; void Test() { g_a=2; printf(“b.h =\u003e g_a=%d\\n”,g_a); } 发现编译成功！ 因为是全局静态变量 他们被限制在了 被定义的文件中 说明这2个变量虽然名字一样 但是是不同的变量 因为他们的内存地址就不是同一个 切记！！！ ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"六、局部静态变量 上面讲到过局部变量是用{}来限制作用域的,同时这个局部静态又多了一个静态的属性,到底是什么意思呢？ 静态变量的含义就是把变量放在静态区, 同时又用{}限制了作用域. 也就是说如果没有静态属性,局部变量本应该离开{}限制的作用域后就会释放变量,但是这里多了一个静态属性就不会释放,当多次调用相同函数的时候这个变量会一直存在,所以这个变量就从原来拥有释放变量的功能从而变成了这个局部静态变量只能在这个{}作用域内被引用. 我们看看下面的例子就明白了 void add(int a,int b) { static int c = 0;//局部静态变量 c=a + b + c; printf(“c=%d \\n”,c); } void main() { add(1, 2); add(2, 3); } 观察结果 第一次调用add()函数的时候变量c等于3，当第二次调用add()函数的时候变量c由于第一次调用被赋值等于了3，所有会从3开始，也产生了3+2+3=8的结果 ","date":"2021-12-08","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/:6:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】20 - 局部变量和全局变量","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B20-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"常用hook方式 JMP指令型hook RET指令型hook Detours库hook ","date":"2021-12-06","objectID":"/2021/12/hook/:1:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"JMP与CALL 公式 目标地址 = 当前指令地址 +指令长度 + 偏移量 偏移量 = 目标地址 - 当前指令地址 - 指令长度 776101EC E9 C9950200 // 776101EC为当前地址 // E9 为JMP // C9950200 为偏移 逆序 // 776397BA = 776101EC + 5 + 000295C9 ","date":"2021-12-06","objectID":"/2021/12/hook/:2:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"跨进程hook //跨进程hook 动态打补丁 OpenProcess //打开进程 获取进程权限的句柄 WriteProcessMemory //跨进程写入进程 VirtualAllocEx //跨进程分配内存 VirtualProtectEx //修改内存页面属性 JMP 跳转指令公式 目标偏移 = 目标地址 - 5 - 当前指令地址 //5是指令长度 (近跳为2) #include \u003ciostream\u003e #include \u003cWindows.h\u003e BYTE gbuf_0040100A[] = { 0xE9, 0x77, 0x08, 0x00, 0x00, 0x90 }; BYTE gbuf_00401886[] = { 0x53, 0x51, 0x8B, 0xD8, 0x8B, 0x45, 0x08, 0x8B, 0x4D, 0x0C, 0x0F, 0xAF, 0xC1, 0x8B, 0xCB, 0x03, 0xC8, 0x90, 0x89, 0x4D, 0xFC, 0x59, 0x5B, 0x8B, 0x4D, 0xFC, 0xE9, 0x6B, 0xF7, 0xFF, 0xFF, 0x00 }; int main() { std::cout \u003c\u003c \"Hello World!\\n\"; //获取目标进程句柄 DWORD pid = 0, oldProtect1 = 0, oldProtect2=0; printf(\"请手动输入进程pid\"); scanf_s(\"%d\", pid); HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS, 0, pid); //更改页面属性为 PAGE_EXECUTE_READWRITE VirtualProtectEx(hp, (PVOID)0x0040100A, 32, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); VirtualProtectEx(hp, (PVOID)0x00401886, 32, PAGE_EXECUTE_READWRITE, \u0026oldProtect2); //写入hook代码 //memcpy_s((BYTE*)0x0040100A,6, gbuf_0040100A,6);//本地hook //memcpy_s((BYTE*)0x00401886,32, gbuf_00401886, 32); WriteProcessMemory(hp, (BYTE*)0x0040100A, gbuf_0040100A, 6,\u0026pid); WriteProcessMemory(hp, (BYTE*)0x00401886, gbuf_00401886, 32, \u0026pid); //恢复原页面属性 VirtualProtectEx(hp, (PVOID)0x0040100A, 32, oldProtect1, \u0026oldProtect1); VirtualProtectEx(hp, (PVOID)0x00401886, 32, oldProtect2, \u0026oldProtect2); } //DLL HOOK补丁 //更完美一些的可以考虑 劫持一个DLL VirtualProtect //修改内存页面属性 指针操作 写入代码即可 写完可以考虑恢复内存页面属性 ","date":"2021-12-06","objectID":"/2021/12/hook/:3:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"DLL版 动态HOOK // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e int myAdd(int a, int b) { int num = a + b + a * b; printf(\"%d+%d+%d*%d=%d \\r\\n\", a, b, a, b, num); return num; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: { //写入4字节 偏移 call 12345678 偏移量 = 目标地址 - 当前指令地址 - 指令长度 //0006121C E8 57442E12 //call 12345678 DWORD 目标地址 = (DWORD)myAdd; DWORD 偏移 = 目标地址 - 5 - 0x0006121C; //向0x0006121D 4字节偏移 //更改页面属性为 PAGE_EXECUTE_READWRITE DWORD oldProtect1 = 0; BOOL br = VirtualProtect((PVOID)0x0006121D, 8, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); //8 为4字节 //写入偏移 DWORD *poffset = (DWORD*)0x0006121D; *poffset = 偏移; poffset[0] = 偏移; //恢复原页面属性 br = VirtualProtect((PVOID)0x0006121D, 8, oldProtect1, \u0026oldProtect1); break; } case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ","date":"2021-12-06","objectID":"/2021/12/hook/:4:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"MFC DLL 动态HOOK与UNHOOK 显示到编辑窗口中 hook.cpp #include \"pch.h\" #include \"HOOK.h\" #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #include \"CPAGE1.h\" extern CPAGE1 pg1; DWORD baseAdress1 = 0x009C121C; DWORD baseAdress2 = baseAdress1 + 1; int myAdd(int a, int b) { AFX_MANAGE_STATE(AfxGetStaticModuleState()); DWORD tid = GetCurrentThreadId(); printf(\"MyAdd所在线程tid=%d \\r\\n\", tid); CString strtmp; strtmp.Format(\"a=%d,b=%d \\r\\n\", a, b); pg1.m_edt_str += strtmp; //注意多线程冲突 pg1.SendMessage(WM_USER + 2, 222, 333); //变量同步到窗口 需要重写WindowProc int num = a + b + a * b; printf(\"%d+%d+%d*%d=%d \\r\\n\", a, b, a, b, num); return num; } void hook() { //写入4字节 偏移 call 12345678 偏移量 = 目标地址 - 当前指令地址 - 指令长度 //0084121C E8 57442E12 //call 12345678 DWORD 目标地址 = (DWORD)myAdd; DWORD 偏移 = 目标地址 - 5 - baseAdress1; //向0x0084121D 4字节偏移 //更改页面属性为 PAGE_EXECUTE_READWRITE DWORD oldProtect1 = 0; BOOL br = VirtualProtect((PVOID)baseAdress2, 8, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); //8 为4字节 //写入偏移 DWORD *poffset = (DWORD*)baseAdress2; *poffset = 偏移; poffset[0] = 偏移; //恢复原页面属性 br = VirtualProtect((PVOID)baseAdress2, 8, oldProtect1, \u0026oldProtect1); return; } void unhook() { //向0x0084121D 4字节偏移 //更改页面属性为 PAGE_EXECUTE_READWRITE DWORD oldProtect1 = 0; BOOL br = VirtualProtect((PVOID)baseAdress2, 8, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); //8 为4字节 //写入偏移 DWORD *poffset = (DWORD*)baseAdress2; *poffset = 0xFFFFFF5F; //恢复原页面属性 br = VirtualProtect((PVOID)baseAdress2, 8, oldProtect1, \u0026oldProtect1); return; } hook.h #pragma once class HOOK { }; void hook(); void unhook(); 主程序源文件 MFC_HOOK_DLL.cpp 关键部分 // 唯一的 CMFCHOOKDLLApp 对象 CMFCHOOKDLLApp theApp; #include \"CPAGE1.h\" CPAGE1 pg1; // CMFCHOOKDLLApp 初始化 DWORD WINAPI showDlg(PVOID arglist) { AFX_MANAGE_STATE(AfxGetStaticModuleState()); DWORD tid = GetCurrentThreadId(); printf(\"showDlg所在线程tid=%d \\r\\n\", tid); pg1.DoModal(); //显示窗口 return 1; } BOOL CMFCHOOKDLLApp::InitInstance() { CWinApp::InitInstance(); //写HOOK 显示窗口 ::CreateThread(0, 0, showDlg, 0, 0, 0); return TRUE; } Dlg源文件 CPAGE1.cpp 关键部分 // CPAGE1 消息处理程序 #include \"HOOK.h\" void CPAGE1::OnBnClickedButton1Hook() { hook(); UpdateData(FALSE); //变量同步到窗口 // TODO: 在此添加控件通知处理程序代码 } void CPAGE1::OnBnClickedButton2Unhook() { unhook(); UpdateData(FALSE); //变量同步到窗口 // TODO: 在此添加控件通知处理程序代码 } //pg1.SendMessage(WM_USER + 2, 222, 333); LRESULT CPAGE1::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) { // TODO: 在此添加专用代码和/或调用基类 if (message==WM_USER+2 \u0026\u0026 wParam ==222 \u0026\u0026 lParam ==333) { UpdateData(FALSE); //更新变量到窗口 DWORD tid = GetCurrentThreadId(); printf(\"WindowProc所在线程tid=%d \\r\\n\", tid); } return CDialogEx::WindowProc(message, wParam, lParam); } CPAGE1.h #pragma once // CPAGE1 对话框 class CPAGE1 : public CDialogEx { DECLARE_DYNAMIC(CPAGE1) public: CPAGE1(CWnd* pParent = nullptr); // 标准构造函数 virtual ~CPAGE1(); // 对话框数据 #ifdef AFX_DESIGN_TIME enum { IDD = IDD_DIALOG1 }; #endif protected: virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV 支持 DECLARE_MESSAGE_MAP() public: afx_msg void OnBnClickedButton1Hook(); afx_msg void OnBnClickedButton2Unhook(); afx_msg void OnEnChangeEdit1(); // EDIT1 m_edt_str CString m_edt_str; virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam); }; ","date":"2021-12-06","objectID":"/2021/12/hook/:5:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"动态hook游戏组包 hook.cpp #include \"pch.h\" #include \"HOOK.h\" #include \u003cstdio.h\u003e #include \u003cWindows.h\u003e #include \"CPAGE1.h\" extern CPAGE1 pg1; DWORD baseAdress1 = 0x009C121C; DWORD baseAdress2 = baseAdress1 + 1; int myAdd(int a, int b) { AFX_MANAGE_STATE(AfxGetStaticModuleState()); DWORD tid = GetCurrentThreadId(); printf(\"MyAdd所在线程tid=%d \\r\\n\", tid); CString strtmp; strtmp.Format(\"a=%d,b=%d \\r\\n\", a, b); pg1.m_edt_str += strtmp; //注意多线程冲突 pg1.SendMessage(WM_USER + 2, 222, 333); //变量同步到窗口 需要重写WindowProc int num = a + b + a * b; printf(\"%d+%d+%d*%d=%d \\r\\n\", a, b, a, b, num); return num; } void 取数据函数() { } UINT_PTR send_off5 = ((UINT_PTR)(LoadLibraryA(\"Gane.exe\"))) + 0x351E75; //裸汇编 __declspec(naked)void hookSend() { //取出想要的数据 //还原指令 //跳转到Game.exe+351E75 __asm { call 取数据函数 //还原代码 push ebp mov ebp, esp push - 1 jmp send_off5 } } BYTE jmpCode[5] = { 0xE9,0,0,0,0 }; //偏移=目标地址-5-当前地址 void hook() { //写入4字节 偏移 call 12345678 偏移量 = 目标地址 - 当前指令地址 - 指令长度 //0084121C E8 57442E12 //call 12345678 DWORD HOOK地址 = send_off5 - 5; //当前指令地址 DWORD 目标地址 = (DWORD)hookSend; DWORD 偏移 = 目标地址 - 5 - HOOK地址; //组装jmpCode DWORD*pJMP = (DWORD*)(jmpCode + 1); pJMP[0] = 偏移; //向0x0084121D 4字节偏移 //更改页面属性为 PAGE_EXECUTE_READWRITE DWORD oldProtect1 = 0; BOOL br = VirtualProtect((PVOID)HOOK地址, 8, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); //8 为4字节 //写入5字节jmpCode memcpy((char*)HOOK地址, jmpCode, 5); //恢复原页面属性 br = VirtualProtect((PVOID)baseAdress2, 8, oldProtect1, \u0026oldProtect1); return; } void unhook() { //向0x0084121D 4字节偏移 //更改页面属性为 PAGE_EXECUTE_READWRITE DWORD oldProtect1 = 0; BOOL br = VirtualProtect((PVOID)baseAdress2, 8, PAGE_EXECUTE_READWRITE, \u0026oldProtect1); //8 为4字节 //写入偏移 DWORD *poffset = (DWORD*)baseAdress2; *poffset = 0xFFFFFF5F; //恢复原页面属性 br = VirtualProtect((PVOID)baseAdress2, 8, oldProtect1, \u0026oldProtect1); return; } ","date":"2021-12-06","objectID":"/2021/12/hook/:6:0","series":null,"tags":["飞郁2019","hook"],"title":"Hook","uri":"/2021/12/hook/"},{"categories":null,"content":"微尘游戏逆向攻防—LXL角色信息详细分析 今天 我们来分析下LXL的角色信息， 首先我们以攻击力下手，对游戏稍有了解也能知道 大概率是浮点。 附加ce,搜索浮点型，两者之间的数值 买件加攻击力的装备，再次搜索得到攻击力地址 双击地址拖入下面区域，选中地址按f5,ce下个访问断点 出现这个窗口，打开od附加程序，进入程序空间，在代码区域，ctrl+g 搜索上图的00aac421 我们找到了一个数组，esi是下标索引，我们只能追edi, edi来自ecx ,ecx来自上一层，下个f2断点，ctrl+f9返回上一层， ecx来自edi,继续往上找 发现在函数头部来自ecx,下个f2断点，ctrl+f9返回上一层 ecx来自[esi+8c],esi来自ecx,下个f2断点，ctrl+f9返回上一层 ecx来自[esi] ,esi来自eax,eax来自[3523bf8]就找到基地址了 整个面板都可以通过i来遍历，具体大家自己看 但是我通过拼接地址发现地址不对，后来发现这里也有循环，而属性版面的地址在38位置，因此公式改为[[[3523bf8]+38]+8c] +i*8 因为是个数组，这38也不靠谱，目前我就看看见了有时候在2c的位置，有时候在3c的位置，大家可以自己找找其他基地址 微尘网络安全专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术公众号 ","date":"2021-12-05","objectID":"/2021/12/lxl%E8%A7%92%E8%89%B2%E4%BF%A1%E6%81%AF%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["辅助精品帖"],"title":"LXL角色信息详细分析","uri":"/2021/12/lxl%E8%A7%92%E8%89%B2%E4%BF%A1%E6%81%AF%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/"},{"categories":null,"content":"游戏逆向攻防—LXL视距分析 微尘网络安全 今天 我们来分析下LXL的视距，首先来理解下什么叫做视距。可以理解成视角高度，咱们也叫视野距离。就是咱们在玩游戏的时候，按鼠标滚轮的时候视野距离的改变。 咱们在找数据的时候 第一要素：变化！！ 改变这个值用CE去搜，首先呢是类型既然是距离 肯定是大概率是浮点了 然后通过鼠标滚轮的改变 多次搜索，可以找到 2个满足条件的值 改变鼠标中键最大和最小的视距 分别是1000-2250，然后呢 我们尝试修改这2个地址发现如下： 1 第一个数值我们改了之后会被修正，第二个改了之后 游戏里面的视距也会跟着改变 2最小视距的确是1000每次，小于1000改了都没反应，但是最大视距可以达到12250 ，其实也很好解释，这不就是裁判视角嘛！！ 加载od， ctrl+G 搜索 第二值，下个访问断点，会发现大部分代码被变形，马爸爸的游戏基本都尿性，分析不到有用的数据， 我们可以ctrl+G 搜索 第一值，下个访问断点， 断点处直接就能看到基地址， [[1C6A1B8]+C]+26C 就是视距。反外挂建议：HOOK相关内存读取函数 公众号 微尘网络安全专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术 ","date":"2021-12-05","objectID":"/2021/12/lxl%E8%A7%86%E8%B7%9D%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["辅助精品帖"],"title":"LXL视距分析","uri":"/2021/12/lxl%E8%A7%86%E8%B7%9D%E5%88%86%E6%9E%90/"},{"categories":null,"content":"GetDlgItem 获取控件对象 根据继承关系，有如下几类： CWindow::GetDlgItem HWND GetDlgItem( intnID)const; /* 说明—— 参数 nID：接收消息的控件的标识； 返回值：标识所标记的控制窗口句柄 */ CWnd::GetDlgItem CWnd* GetDlgItem ( intnID) const; void CWnd::GetDlgItem( int nID, HWND *phWnd) const; /* 说明—— 参数 nID：接收消息的控件的标识； 参数phWnd:子类窗口的指针； 返回值：标识所标记的控件（或子类窗口）的指针； */ //Example // Uses GetDlgItem to return a pointer to a user interface control. CEdit* pBoxOne; pBoxOne = (CEdit*) GetDlgItem(IDC_EDIT1); GotoDlgCtrl(pBoxOne); Windows SDK HWND GetDlgItem( HWNDhDlg, // handle to dialog box intnIDDlgItem// control identifier ); /* 参数说明： hDlg：标识含有控件的对话框。 nlDDlgltem：指定将被检索的控件标识符。 返回值：如果函数调用成功则返回值为给定控件的窗口句柄。如果函数调用失败，则返回值为NULL，表示为一个无效的对话框句柄或一个不存在的控件。若想获得更多错误信息，请调用GetLastError函数。 */ ","date":"2021-12-05","objectID":"/2021/12/mfc%E6%8E%A7%E4%BB%B6/:1:0","series":null,"tags":["飞郁2019","MFC"],"title":"MFC控件","uri":"/2021/12/mfc%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"控件常用函数 { CWnd *pbtn1 = (CWnd*)GetDlgItem(IDC_BUTTON1); //获取控件对象 TRACE(\"pbtn1 = %p \\r\\n \", pbtn1); //debug中输出 pbtn1-\u003eSetWindowTextW(L\"三三三\"); //设置控件标题 方法1 pbtn1-\u003eSetWindowTextW(_T(\"二二二\")); //设置控件标题 方法2 pbtn1-\u003eEnableWindow(false); // 激活/不激活 控件 RECT r1 = { 0 }; //定义范围变量 pbtn1-\u003eGetWindowRect(\u0026r1); //取得范围值,并赋给参数r1 } ","date":"2021-12-05","objectID":"/2021/12/mfc%E6%8E%A7%E4%BB%B6/:2:0","series":null,"tags":["飞郁2019","MFC"],"title":"MFC控件","uri":"/2021/12/mfc%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"传奇永恒更新X64人物结构分析网络安全外挂与反外挂 X64游戏辅助汇编封包 反调试 微尘网络安全 最近传奇永恒更新X64位游戏了，人气还挺不错，所以咱们也去探索了下 首先分析下他的人物结构 用ce x64 搜索血量值，经过被怪物攻击筛选剩下2个 修改两值，发现第一个的值跟随第二个值变化，我们打开xdbg64,附加游戏 下硬件断点，跳到 得到[rcx+1ac],追rcx 得到[[rdi+56c]+1ac],追rdi 来自于rax，来自于call， rax来自与数组[[[0x7ff7e064d018]+rcx*8]+0x56c]+1ac 体力值；本来以为很简单 没想到还是比较复杂的 那就静下心来好好分析！ rcx=[[[0x7ff7e0ffd2ac]]+1c] (取dword)值 [[[0x7ff7e064d018]+ [[[0x7ff7e0ffd2ac]]+1c] (取dword)值 *8]+0x56c]+1ac 当然这里有一个二叉数结构遍历周围，周围怪物都在里面，要仔细分析 由于这里分析挺费劲的，那我们先换别的路线 我们可以重下硬件断点，这里有多个地方可以断，寻找一个简单的结构 向上追rsi 向上追rdx，下断点ctrl+f9 ctrl+f8 来自这个call 直接追rcx，这个结构没发现什么有用的东西 [[[rcx+0x71c]+0x248]+0x65c]+1ac 进入这个call，找rax来源 这找到了基地址 [[[0x7ff7e0ffcb50+0x71c]+0x248]+0x65c]+1ac 3c是16进制，十进制是60就是血量，这个偏移只能偏移到自己 没有周围结构，我们还要继续寻找结构，回头看来 相当的复杂，我们这篇就先说到这里，下一篇在揭晓答案 了解更多游戏逆向 微信尽在公众号微尘游戏逆向 如有侵权 请联系删除 ","date":"2021-12-05","objectID":"/2021/12/%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E6%9B%B4%E6%96%B0x64%E4%BA%BA%E7%89%A9%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["辅助精品帖"],"title":"传奇永恒更新X64人物结构","uri":"/2021/12/%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E6%9B%B4%E6%96%B0x64%E4%BA%BA%E7%89%A9%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"天龙hJ线程发包处理方法如何跳出线程发包 微尘网络安全 谈到封包，大家第一就想要去找明文包，因为 有了明文包 基本所有的功能call全部都可以找到和实现了，但是现在很多端游都是线程发包的，遇到这个问题 很多人都不知道怎么解决了 那今天就说下这个问题，如何跳出线程找到明文包 以天龙hj为例: 首先OD 加载游戏，CTRL+G 跳转到ws2_32.send 如下图 然后 send 头部下断，观察堆栈窗口 第二个参数 就是 即将send出去的数据，既然知道了他是线程发包 那首先观察发现 这个数据地址是一直不变 那说明什么 ？ 说明 是别的线程往这个地址里面写入数据的 所以呢 我们应该在这个地址下写入断 如下图 运行后 如下图 就到了这个地方 也就跳出来了 也可以看到明文内容，往上反几层也就到了公共call的地方了。当然很多游戏是需要跳好几次的，要具体看 想要了解很多游戏逆向相关的知识 欢迎关注微信公众号：微尘网络逆向 ","date":"2021-12-05","objectID":"/2021/12/%E5%A4%A9%E9%BE%99hj%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85/:0:0","series":null,"tags":["辅助精品帖"],"title":"辅助精品贴","uri":"/2021/12/%E5%A4%A9%E9%BE%99hj%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85/"},{"categories":null,"content":"理解FPS游戏中的矩阵方框透视自瞄 微尘网络安全 初识矩阵 其实矩阵是线性代数里面的说法 矩阵（Matrix）是一个按照长方阵列排列的复数或实数集合 [1] ，最早来自于方程组的系数及常数所构成的方阵。这一概念由19世纪英国数学家凯利首先提出。 类似： 矩阵的乘法： 向量 搞清楚FPS里的矩阵 首先要先理解向量 1 向量是表述一个点的运动方向和大小的 这其实是向量转为矩阵的一个过程 相机FOV 咱们看到的是一个二维的屏幕，而游戏里面是一个真实的 三维立体的世界，那游戏是怎么做到的呢？那就有了FOV这个东西诞生了， 主要分为三种fov类型 horizontal fov 16:9 (overwatch, farcry, pubg) horizontal fov 4:3 (csgo, apex legend) vertical fov(战地系列，彩6围攻） 高fov会使你感觉人物移动速度更快，看到的东西更广（屏幕显示更多东西），敌人也会变小，让你感觉后坐力也似乎变小（不是真正变小，但会给人这种感觉）这种感觉。 低fov反之。 理论上说高fov可能会对电脑性能要求更高，但一般游戏其实不会感觉到有帧数影响。 就是用一个相机拍个照 那你通过屏幕看到的不就是二维的了 2咱们知道向量只是表述一个坐标点的方向和大小 ，但是在游戏世界中，当我作为一个玩家看向一个物体 或者说一个敌人的时候 我该如何表达他的 坐标？水平朝向？垂直朝向？角度？，这时候 我们就会用到33 或者44 或者更大的矩阵 来描述 敌人的状态 FPS矩阵 上面说了这么多 其实我们要找的就是相机FOV的矩阵，我们知道了相机的矩阵，也就是知道了相机的坐标角度 朝向 等等，或者说 这个相机处于这个三维空间的 一个什么位置朝向，然后用矩阵来和敌人的坐标进行运算，就可以知道敌人在这个三维世界的位置 朝向 角度了，可能大家会说我都知道他坐标了 直接就能算出来了 没必要这么花里胡哨。但其实 咱们还要画出他的方框的，所以 你没相机矩阵 是没法准确的画出方框的 想要系统的学习或者理解可以去关注下 可以领逆向相关的电子书 逆向工具 还有每周更新技术文章 ","date":"2021-12-05","objectID":"/2021/12/%E7%90%86%E8%A7%A3fps%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E6%96%B9%E6%A1%86%E9%80%8F%E8%A7%86%E8%87%AA%E7%9E%84/:0:0","series":null,"tags":["辅助精品帖"],"title":"理解FPS游戏中的矩阵方框透视自瞄","uri":"/2021/12/%E7%90%86%E8%A7%A3fps%E6%B8%B8%E6%88%8F%E4%B8%AD%E7%9A%84%E7%9F%A9%E9%98%B5%E6%96%B9%E6%A1%86%E9%80%8F%E8%A7%86%E8%87%AA%E7%9E%84/"},{"categories":null,"content":"逆向入门噩梦之堆栈（软件安全攻防反汇编反调试） 微尘网络安全 什么是堆栈 其实 堆 和 栈是2个概念 ，在内存中 堆是在有一段存放的空间的 x86当中 大概占1M左右。而栈呢是 每次准备进入call 之前在内存中开辟的一段地址空间。我们说的堆栈其实指得是栈 ，就像我们说土狗 他是狗 ，说老婆饼 他是饼 一样的意思 在计算机领域，堆栈是一个不容忽视的概念，堆栈是一种数据结构。堆栈都是一种数据项按序排列的数据结构 为什么要学习堆栈 经常有学员来问咱们这个问题 ，这个这么复杂这么难，我为啥要学他！！ 可以跳过嘛 咱们在实战当中 经常要求分析代码 正向程序员写代码肯定是多层调用的 10几层call 更是常有的事，不学习堆栈 你都没发追数据了，而且你对程序的结构 内存的理解程度是一个很大的缺失部分，没有这样的理解 恐怕后面是很难往下学习的 拆解堆栈 如上 一个最简单的c++的 加法函数，咱们看他的反汇编代码 这里有个细节要注意一下 我们发现他参数压入堆栈的顺序 是从右往左的 那他为啥不是从左往右呢，这里其实涉及到函数调用约定的问题，咱们后面的课程都有讲到的，这里 从右向左压栈，不是规定，也不是因为栈先进后出的特性。在《c和指针》中已经说明了从右向左压栈的原因，这样可以保证生成汇编语言时这些参数相对于BP指向的栈位置的偏移量是固定的。 C方式参数入栈顺序（从右至左）的好处就是可以动态变化参数个数。 我们在进入call内部去看 第一步 把ebp压栈 第二部 mov ebp,esp 第三部 提升堆栈空间，用来存放本层call的局部变量 第四部 保存各个寄存器，因为接下来本层call就要使用这些寄存器了，先把他压入栈中 第五部 执行本层call的代码了 咱们在来继续看后面的 第六步 还原寄存器 因为本层call的代码执行完了 寄存器的任务也完成了，就把刚进来时候的寄存器的值从堆栈里面弹出来吧，因为咱们要出去 返回到之前的堆栈空间了去了 咱们进来时候寄存器是啥样 出去的时候 还得啥样 需要还原回来 不然寄存器就崩溃了 第七步 任务完成了 咱们把刚进call时候开辟的堆栈空间也拉下来 还原回来 第八步 mov esp ,ebp 同样是还原回来 第九步 弹出ebp 同上 第十步 ret回上一层了 这样就完美的 走完了一个call了，从进入call 到出call 寄存器 堆栈地址并没发生任何变化，就跟没进去过一样 不留下一片云彩。其中还是有好几个细节要注意的，大家需要自己做一遍才能深刻体会！ 微尘网络安全专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术公众号 ","date":"2021-12-05","objectID":"/2021/12/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%99%A9%E6%A2%A6%E4%B9%8B%E5%A0%86%E6%A0%88/:0:0","series":null,"tags":["辅助精品帖"],"title":"逆向入门噩梦之堆栈","uri":"/2021/12/%E9%80%86%E5%90%91%E5%85%A5%E9%97%A8%E5%99%A9%E6%A2%A6%E4%B9%8B%E5%A0%86%E6%A0%88/"},{"categories":null,"content":"注入专题二:远线程注入CreateRemoteThread–论注入的多种方式 微尘网络安全 01远线程注入 今天 咱们来聊聊远线程注入，这种注入方式也是最常见 最方便的一种方式，他的原理是通过 使用 API CreateRemoteThread 这个函数来实现往某个程序里面注入一个线程。成功后 咱们就可以把被注入程序当成自己家了。但是也是有缺点的，有可能检测你代码段的地址位置，你是自己独立启动的线程，和正常走的流程肯定是不一样的。 02实现代码 HANDLE CreateRemoteThread( [in] HANDLE hProcess, //目标进程句柄 [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL [in] SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M [in] LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址(目标进程代码地址) [in] LPVOID lpParameter, //线程参数 [in] DWORD dwCreationFlags, //线程的创建标志 [out] LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); 上面是API原型 第一个参数 传入进程句柄 第二个参数 可以传入安全描述符的结构体的，所有内核对象的通性，当然也可以NULL 第三个参数 栈空间大小，可以默认0 第四个参数 填写要注入的函数地址 第五个参数 函数的参数 第六个参数 标志位相关 第七个参数 线程ID 说到底 注入其实就是这个API 调用一下就实现了，但是大家可以先去思考一个问题 ：我们是在A程序里面 写CreateRemoteThread函数的，那我们填写的函数地址和参数都是A程序里面的。 但是创建线程之后呢？ 这个线程是要在B程序里面执行的。B程序 怎么能够获取到A空间地址里面的函数地址和内容呢？ 解决了这个问题 远线程注入 这个事情就算是搞定了！！！ 1 进程句柄 没啥好说的把。。。可以用OpenProcess获取 窗口类目 标题 句柄啥的 各种方式都可以获取到 2.VirtualAllocEx 这个函数是在目标程序里面申请一段内存空间，然后用WriteProcessMemory写入 目的是为了存放咱们远线程的参数的 也就是为了存放我们要注入的是哪个DLL呀 3.我们启动的这个线程的函数地址就是Loadlibrary ，这个函数就是加载DLL 并且运行他，他是在kernel32.dll里面的，所以所有的程序都是有他的函数地址的 4 用完记得还原释放 这也是最轻松的方式了 核心代码也就这么些行 理解有问题的话可以来找我要源码或者和我探讨 公众号：微尘网络安全 专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术 感兴趣的人多我会继续更新此系列，把每种注入方式都讲一遍 并且附上源码 ","date":"2021-12-05","objectID":"/2021/12/%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A2%98%E4%BA%8C%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5createremotethread--%E8%AE%BA%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["辅助精品帖"],"title":"注入专题二:远线程注入CreateRemoteThread--论注入的多种方式","uri":"/2021/12/%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A2%98%E4%BA%8C%E8%BF%9C%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5createremotethread--%E8%AE%BA%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"注入专题一:钩子注入SetWindowsHookEx–论注入的多种方式 微尘网络安全 01DLL注入方式 外挂的注入方式有很多种，针对不同场景需求使用不同方式，咱们就来搞个专题 探讨下。dll一旦成功注入进目标进程，就可以随意读写 目标进程的内存（比如读取血量或者修改某些值或者地址从而实现某些变态功能或者HOOK）还可以调用call 注入自己的代码等等 。消息钩子、远程进程注入、入口点注入等等。注入方式可谓十几种，大家感兴趣的话支持一下。下此继续更新此系列 02钩子注入 今天我们讲的是钩子注入，算是比较简单的一种了。但是网上看了一遍 都有很多错误的写法 而且基本都是全局的钩子，咱们今天重点来讲下针对目标进程的钩子注入，很多外挂也是用这种方式来做界面控制台的收费端的 首先我们来看下SetWindowsHookExA这个 api HHOOK SetWindowsHookExA( [in] int idHook, [in] HOOKPROC lpfn, [in] HINSTANCE hmod, [in] DWORD dwThreadId ); 参数1： 表示你要HOOK的消息类型 是键盘还是鼠标 还是其他的 参数2：HOOK的消息回调函数 参数3：目标的句柄 参数4：目标的线程ID 了解了API后 我们来思考几个问题： 1钩子注入的流程 2参数2的 消息回调函数是哪个进程的，是不是应该是目标进程的消息回调，总不能是咱们注入程序的把 3既然是目标程序的，我们如何获取他的消息回调函数 以上三个问题解决了，咱们就可以实现局部钩子注入了 03钩子注入流程 钩子注入流程是这样的： 1 在要被注入的dll 里面写好消息回调函数 并且写个导出函数 2注入程序：用loadlibrary() 加载一次 要被注入的dll 从而获取到模块句柄 GetProcAddress可以获取到导出函数的地址 这样就可以取到要被注入的dll 里面的回调函数的地址了。 这样的方式 咱们就可以在目标程序内部实现键盘注入 比如按HOME 呼出界面。 而不是全局钩子了 核心代码也就这么些行 理解有问题的话可以来找我要源码或者和我探讨 微尘网络安全专注分享网络安全 x64 c++ 逆向 反汇编 反调试 HOOK 注入 封包 内存等技术公众号 感兴趣的人多我会继续更新此系列，把每种注入方式都讲一遍 并且附上源码 ","date":"2021-12-05","objectID":"/2021/12/%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A2%98%E4%B8%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5setwindowshookex--%E8%AE%BA%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["辅助精品帖"],"title":"注入专题一:钩子注入SetWindowsHookEx--论注入的多种方式","uri":"/2021/12/%E6%B3%A8%E5%85%A5%E4%B8%93%E9%A2%98%E4%B8%80%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5setwindowshookex--%E8%AE%BA%E6%B3%A8%E5%85%A5%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"学生：上节课骷髅老师搜索数据搜索太快了，我还没看清楚呢，他就扫完了，拦都拦不住他啊！ 老师：我都拦不住他呀，他是早产儿。 学生：这和早产儿有啥关系啊？ 老师：他妈都没拦住他，我能拦住吗？ 接着上一课， 过第二列黄色钥匙以后。 神秘老头告诉我们，血量地址还有第二个， 但是我们只扫描到了一个，为什么呢？ 有三种可能，第一种加密，第二种数据类型不对，不是DWORD类型。第三种歪指针，即不是048C结尾的指针。 而如果我们勾选上快速扫秒4，那么只会扫描048C结尾的指针 技巧1：快速扫描的原理(歪指针) 这里面我们不勾选快速扫描 再扫描可以扫描到2个学地址了 NPC问我们偏移表达式是什么？ 这里不用会追表达式，因为是歪偏移,所以只有一个歪偏移表达式 直接就是答案，选择3 CE扫描浮点型 来到最后的位置，墙被赌死了，我们过不去 那么怎么办呢？只能瞬移过去 我们尝试了各种数据类型 DWORD FLOAT DOUBLE 等等 都扫描不到 只能说明数据是加密的 那么我们通过未知初始值，然后来回改变，最终找到了结果，原来是显示坐标除以100 修改瞬移过墙 这样我们就通过这关了 到了第5层发现楼梯都没有了，神秘老头提示我们要穿越楼层 这里大家可以下载软件 自己尝试哦 到了第6层 ，我们看到有如下提示： 这个提示告诉我们 游戏的主模块句柄是 00400000 也就是加载的开始位置是 00400000 大小是 007BB000 那么在这个范围内的地址都是基地址 我们如果想扫描基地址的时候 直接扫描这个范围 在该位置修改即可 当然有的时候我们觉得扫描所有地址卡的话，也可以人为 分几块区域扫描 也是可以的。 ","date":"2021-12-04","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B19-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】19 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B19-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"1.打开CE Cheat Engine是网络安全数据分析的一款很重要的工具,我们可以在官网下载他的最新版本https://www.cheatengine.org/#google_vignette 当然也可以使用课程推荐的修改版本 在CE下载并安装好之后,我们在文件夹里找到以下exe文件,双击打开 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"2.附加进程 打开CE之后,我们将弹出的其他界面都关闭掉,只留下以下窗口 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"3. 初始扫描选项 成功附加之后,我们就可以对程序进行扫描了 这里需要注意的是两者之间和未知初始值. 两者之间如果要扫描负数的话一定要记住负数的绝对值越大数值越小 这种扫描方式是不可能有结果,很多同学在这里会出错 而使用位置初始值进行扫描的时候,可能会因为程序过大,导致扫描时间很长,后期过滤也比较麻烦,所以要谨慎使用这种方式 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"4. 扫描类型 选择了初始扫描选项之后,我们需要选择一下扫描的数据类型, 不同的数据,都会有常用的数据类型,我们要具体情况具体分析 CE中扫描的数据类型有如下几种 这里的数据类型在前面的课程中都讲过了,就不一一翻译了,最后三个分别是字节数组,所有类型,分组扫描 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"5. 不同类型的扫描方式 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"5.1 byte-word-dword-qword,也就是byte,2byte,4byte,8byte的扫描方法 整数型的扫描是最常见的,不过由于数据长度不同,所以在选择的时候还是需要斟酌的 比如扫描一个标志位,通常会使用byte型,扫描一个不太大的数量就可以使用word型,扫描一个32位地址需要用dword型,而qword型应用并不是很常用,通常只在扫描64位地址时使用 下面我们来搜索一下教案小游戏的人物血量 在CE中搜索4字节的1000 得到101个结果,打一个怪物,血量还剩960,在CE中点Next Scan,再次扫描 只得到了一个结果,再次砍怪验证一下,发现这个地址存放的就是我们的血量 这就是4字节的扫描,是不是很简单? ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:5:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"5.2 float,double的扫描方法 浮点型和双浮点型的扫描与整数型的扫描是类似的,唯一不同的就是它们的扫描结果是有精确范围的, 比如我们扫描一个100 这里可以得到很多的结果,甚至还有99和101,但是绝不会出现98和102 再比如我们扫描一个100.5 这里会精确的小数点后1位,也就是说结果是在100.5上下浮动不超过0.1 所以当我们扫描一个只显示为整数的浮点数的时候,往往采用两者之间,比如100我们就扫描99-101, 这是比较稳妥的方式,当然,以现在CE的扫描结果来看,我们直接扫描100也没有什么问题 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:5:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"5.3 改变扫描到的数值可以达到特殊的效果 在一些程序中,数据并不是校验的非常严格,甚至没有任何的校验,这时我们通过CE就可以对其中的部分数据进行修改, 比如在这款教案游戏中当我们打到图中的位置时,就不能继续前进了,因为血量不够了 我们可以对之前扫描到的结果进行修改来达到过关的条件 是不是很有趣?这只是CE最基本的功能之一,下节课鸟哥会给大家讲CE的一些特别的使用技巧 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:5:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"5.4 String和字节数组,也就是Array of byte的扫描方法咱们放到后面来系统的讲 ","date":"2021-12-03","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/:5:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】18 - CE基础和扫描","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B18-ce%E5%9F%BA%E7%A1%80%E5%92%8C%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":"不知道有没有同学发现之前几节都是在讲关于数据 那么有的同学会问 计算机是怎么处理操作运算这些数据的呢？ 好的 这节课就讲解C语言运算符 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"一、运算符 1.首先我们来看看C语言有哪几种运算符,先了解下 2.算数运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 其他运算符(sizeof 三目运算符) 3.这些运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。 4.是不是想迫切的知道这些运算符怎么使用呢？ 5.下面我们先介绍算数运算符 关系运算符 逻辑运算符 ,其他运算符我们后面的章节再讲 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"二、算数运算符+ - * / % ++ – ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.1.+ 加号 int i1 = 1; int i2 = 2; int i3 = i1 + i2; printf(\"i3=%d \\n\",i3); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.2. - 减号 int i4 = i2 - i1; printf(\"i4=%d \\n\", i4); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.3.* 乘号 int i5 = i2 * i1; printf(\"i5=%d \\n\", i5); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.4. / 除号 int i6 = i2 / i1; printf(\"i6=%d \\n\", i6); 2.4.1 除数 不能为0 int i7 = 3;//2 +1 int i8 = 0; int i9 = i7 / i8;//错误 因为除数不能为0 printf(\"i9=%d\",i9); 我们编译观察下,是否报异常 发现会报错, 因为除数不能为0 2.4.2 注意类型会影响到结果 //int类型 int i7 = 3;//2 +1 int i8 = 2; int i10 = i7 / i8; //1.5 printf(\"i10=%d \\n\", i10);//1 //float类型 float f7 = 3; float f8 = 2; float f10 = f7 / f8; //1.5 printf(\"f10=%f \\n\", f10);//1.5 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.5. % 取余数 int i11 = i7 % i8; printf(\"i11=%d \\n\", i11); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:5","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.6.++ 自加1 int i1=1; printf(\"前 i1=%d \\n\", i1); i1++;// i1=i1+1; printf(\"后 i1=%d \\n\", i1); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:6","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"2.7. – 自减1 int i2=1; printf(\"前 i2=%d \\n\", i2); i2--;// i1=i2-1; printf(\"后 i2=%d \\n\", i2); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:2:7","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"三、关系运算符== != \u003e \u003e= \u003c \u003c= 3.1 == 等于 = 赋值 ==等于 3.2 != 不等于 3.3 \u003e 大于 3.4 \u003e= 大于等于 3.5 \u003c 小于 3.6 \u003c= 小于等于 3.7 例如 int i13 = 9; int i14 = 10; if (i13 == i14)// 相等 返回真 否则返回假 { //执行这里 printf(\"i13 等于 i14 \\n\"); } else//i13 != i14 { printf(\"i13 不等于 i14 \\n\"); if(i13 \u003e 14) { //执行这里 printf(\"i13 大于 i14 \\n\"); } else if(i13 \u003c 14) { //执行这里 printf(\"i13 大于 i14 \\n\"); } } 备注: if else if 是用来判断表达式的真假,用于流程控制,这个后面我们会讲解. ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"四、逻辑运算符\u0026\u0026 || 4.1 \u0026\u0026 与 同真 结果为真 否则为假 4.2 || 或 有一个为真 结果就为真 4.3 ! 反 真变假 假变成真 BOOL b1 = FALSE; BOOL b2 = FALSE; printf(\"!b1为:%d\\n\",!b1); printf(\"b1 || b2 为:%d\\n\",b1 || b2); printf(\"b1 \u0026\u0026 b2 为:%d\\n\",b1 \u0026\u0026 b2); ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】17 - 操作符运算符","uri":"/2021/12/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B17-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":null,"content":"骷髅 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/:1:0","series":null,"tags":["飞郁精品帖"],"title":"飞郁2019课程目录","uri":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"跨进程读写内存 2019年10月18日——跨进程读写内存 2019年10月21日——窗口相关的API，字符集，常用类型 2019年11月4日——OD软件的使用技巧 2019年11月5日——OD 追数据技巧 以及 断点的种类 2019年11月6日——OD寻找数据 2019年11月7日——堆栈ESP EBP 应用详解 2019年11月8日——堆栈实例 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/:2:0","series":null,"tags":["飞郁精品帖"],"title":"飞郁2019课程目录","uri":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"飞郁2019 2019年11月11日——数组逆向分析 2019年11月12日——数组嵌套 测试1 2019-11-18 跨进程分配内存 注入代码(远程注入) 20191118-远程注入代码(跨进程注入) 20191119-跨进程注入调用多个参数的CALL 数组指针 20191120-初识DLL(win32DLL) 20191120-跨进程注入DLL 20191121-MFC DLL 认识 20191121-MFC DLL 认识1 20191121-跨进程注入带窗口的MFC-DLL 20191122-MFC 控件使用 20191122-C++中 类与 对象的简单概念 20191125-MFC常用控件类的常用成员函数 20191125-MFC常用控件绑定变量 发包函数和功能函数 11月27日.线程发包 11月28日.明文收发包,半脱机的实现 11月29日.WSARecv及链表 测试 2019-12-09 HOOK代码 的原理 与简单示例(2) 2019-12-10 DLL版动态HOOK 代码 示例 2019-12-11 MFCDLL动态HOOK与UNHOOK 2019-12-11 DLL动态HOOK 数据 显示到窗口上 2019-12-12 动态HOOK 游戏组包函数 2019-12-12 动态HOOK 游戏组包函数2 2019-12-13 detours hook发包 2019-12-13 hook 并输出 调试信息 浮点数指令，和call 取对象 2020-64位汇编 2020.1.7-x64 过保护注入DLL 2020.1.7-绕过保护注入 2020.1.8-A 完善 过保护注入DLL功能 2020.1.8-B x64游戏寻路测试 2020.1.9-A 分析明文包 参数 2020.1.9-B 根据明文包 分析喊话组包 技能组包 2020.1.9-B2 根据明文包 分析喊话组包 技能组包 2020.1.10-A hook 游戏封包分析 2020-0113-A x64游戏(天刀) 编写代码 2020-0113-B x64游戏 HOOK抓包 解密包 过 2020-0114-A HexStr与Bytes转换解密封包 2020-0114-B 深度解密封包 2020-0115A-C++访问LUA堆栈 与参数 2020-0115B-C++访问LUA里的变量 2020-0116A-LUA 变量 函数 循环 等基础知识 2020-0116B-C++访问LUA里函数和变量 2020-0117A-调用 游戏的LUA接口 2020-0117B-LUA调用 C++接口（模拟游戏寻路) ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/:3:0","series":null,"tags":["飞郁精品帖"],"title":"飞郁2019课程目录","uri":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"郁金香 191028-判断语句与条件表达式 191028-while循环 191029-遍历窗口与子窗口 191029-遍历特定窗口的子窗口 191030-for循环 191030-C函数的 常规格式 191031-函数的设计运用示例 191031-多个源文件里,函数与变量相互引用 191101-跨进程读写基址偏移(读) 相关函数封装 191101-跨进程读写(写)相关函数封装 测试1 2019-11-18 跨进程分配内存 注入代码(远程注入) 20191118-远程注入代码(跨进程注入) 20191119-跨进程注入调用多个参数的CALL 数组指针 20191120-初识DLL(win32DLL) 20191120-跨进程注入DLL 20191121-MFC DLL 认识 20191121-MFC DLL 认识1 20191121-跨进程注入带窗口的MFC-DLL 20191122-MFC 控件使用 20191122-C++中 类与 对象的简单概念 20191125-MFC常用控件类的常用成员函数 20191125-MFC常用控件绑定变量 2019-12-09 HOOK代码 的原理 与简单示例 2019-12-09 HOOK代码 的原理 与简单示例(2) 2019-12-10 动态HOOK 代码 示例1 2019-12-10 DLL版动态HOOK 代码 示例 2019-12-11 MFCDLL动态HOOK与UNHOOK 2019-12-11 DLL动态HOOK 数据 显示到窗口上 2019-12-12 动态HOOK 游戏组包函数 2019-12-12 动态HOOK 游戏组包函数2 2019-12-13 detours hook发包 2019-12-13 hook 并输出 调试信息 2020.1.6- 64位汇编 64位函数注入测试 2020.1.7-x64 过保护注入DLL 2020.1.7-绕过保护注入 2020.1.8-A 完善 过保护注入DLL功能 2020.1.8-B x64游戏寻路测试 2020.1.9-A 分析明文包 参数 2020.1.9-B 根据明文包 分析喊话组包 技能组包 2020.1.9-B2 根据明文包 分析喊话组包 技能组包 2020.1.10-A hook 游戏封包分析 2020.1.10-B 为64位 游戏 HOOK 准备数据 2020-0113-A x64游戏HOOK 抓包 解密包 2020-0113-B x64游戏 HOOK抓包 解密包 2020-0114-A HexStr与Bytes转换解密封包 2020-0114-B 深度解密封包 2020-0115A-C++访问LUA堆栈 与参数 2020-0115B-C++访问LUA里的变量 2020-0116A-LUA 变量 函数 循环 等基础知识 2020-0116B-C++访问LUA里函数和变量 2020-0117A-调用 游戏的LUA接口 2020-0117B-LUA调用 C++接口（模拟游戏寻路) 2020-218-1-x64驱动入口点 初识驱动 002-调试虚拟机 加载测试自己的驱动 2020-218-3 虚拟机里安装win7系统 2020.219-004-配置windbg与虚拟机 双机调试 2020.219-005-配置windbg 常用断点指令 2020-220-006-创建驱动设备对象 2020-220-007-为驱动设备对象绑定符号链接 2020-221-008-访问驱动设备及IRP事件处理 2020-221-009-打开驱动对象 r3与R0 通信 2020-222-010 驱动的加载与卸载 2020.224-011 进程监控 2020.224-012 驱动中通过PID获取EPROCES 2020.225-013 阻止特定进程创建 2020.225-013 阻止特定进程创建2 2020-226 游戏主线任务设计1 ","date":"2021-12-01","objectID":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/:4:0","series":null,"tags":["飞郁精品帖"],"title":"飞郁2019课程目录","uri":"/2021/12/%E9%A3%9E%E9%83%812019%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"前面讲到了数据类型讲到过字符数组 有的同学对 数组 还不太理解 那么今天我们讲解的是 数组 和 字符串以及一些编码 好了 开始我们的讲解 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"一、数组 首先我们讲解数组 那么什么是数组呢？ 我们把数组 这2个字拆开理解 1.“数”：数据 2.“组”：编组 编制成一个组 一个队伍 3.合起来就是：把一些相同类型的数据编制到一个组里 方便管理 写法: 数据类型 变量名[数组成员数大小]; 数据类型 变量名[数组成员数大小]={0};//初始化版本 int iArray[7];//没有初始化 int iArray[7]={0};//初始化为0 int iArray[7]={1,2,3,4,5,6,7};//初始化值 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"1.1 数组的初始化 int iArray1[10];//没有初始化 int iArray2[10]={0};//初始化 int iArray3[]={1,2,3};//省略写法 自动推到出成员个数 1.1.1 注意: int iArray2[10]={0};//初始化 这里虽然只有一个0,但是他的作用就是把10个int类型的数组全部清空为0(我们一般把清空默认为0,也可以为其他值). 调试看下变化情况 经过“{0}”初始化后, 我们观察内存 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"1.2. 数组下标访问数组成员 和 赋值数组成员 int iArray[10]={0}; printf(\"%d\\n\",iArray[0]); iArray[0]=1; printf(\"%d\\n\",iArray[0]); ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"1.3 访问下标最大范围 从0开始到最大成员减1,杜绝访问下标冲突,引起的访问冲突异常 int iArray[10]={0}; printf(\"%d\\n\",iArray[0]); iArray[0]=1; printf(\"%d\\n\",iArray[0]); //iArray[10]=1;//错误 会报异常 访问冲突 //iArray[9]=1;//正确 其实上面我们讲到的是1维数组 那么有二维数组 吗？那么三维呢？ 多维呢？ 肯定是有的 基本写法是 每多一个维度 就要多加一个[数量] 这里我们稍微的知道有这些东西就行了 不便多讲,以后会逐步加深难度 int iArray[10][10]={0};//相当于10行10列 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"二、注意事项 1.从索引0开始访问 访问全部数据. 2.要初始化 避免一些乱码. 3.防止数据下标越界 引起访问冲突. 4.数组成员的地址是连续的 线性关系. 5.数组成员的初始化 看内存窗口中比较初始化前后数据变化 结合上面的图讲解起内存地址是连续的 线性关系. 6.数组变量名就是一个地址. 7.定义数组大小的时候必须是一个常量,不能是变量,也就是说在我们编译的时候必须明确指定数组的大小. ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"三、字符串 在讲到数据类型的时候我们已经讲到过了字符串,这里我们再简单的看看 字符串顾名思义就是把多个字符“串”在一起就成了字符串 其实也很好理解 数组也就是把多个数据紧紧的排列在一起 同时在C语言中定义字符串是以\\0为结束标志,也就是说当读内存的时候一个字节一个字节的读知道遇到\\0为止 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"3.1 例如 char cc[5]={'H','e','a','r','t','\\0'};//注意要用单引号来表示字符类型哦 我们这里打印下看看 void main() { char cc[6]={'H','e','a','r','t','\\0'};//注意表示字符串的话 要'\\0'结尾哦 printf(\"cc = %s\\n \",cc);//%s表示 输出的值的类型是 字符串类型 printf(\" char cc[6] 大小=%d\\n\",sizeof(cc));//其实也就是6个字符表示的一个字符串 system(\"pause\");//暂停的意思 以免控制台消失 } ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"四、字符串编码简介 讲了字符串 我们这里就要简单的说下字符串编码问题 现在主流的编码有 ascii unicode utf-8 big5 他们都是按照某种规范去编制字符的 有的是 一个字符 一个字节表示 有的是2个 甚至是3个 多个的情况都有 这里简单的讲下 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"4.1 ASCII char c[2]={'a','b'};//查看ascii表 一个字节来表示 观察内存 我们可以观察到61,62 都挨着一起,我们的字符“a”就是用0x61来表示的,这是遵循了ASCII表 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"4.2. UNICODE 我们再来看看unicode编码的形式 wchar wc[2]={'a','b'};//我们看内存 是2个字节表示的 继续观察内存 发现每一个字符占2个字节，这样编码是为了扩展更多的字符,因为ASCII每一个字符只占一个字节,我们知道一个字节最大值的表示范围在0到255,也就是最多只能表示256个字符,但是unicode就不一样了 ,它每一个字符占2个字节,也就是说2个字节最大表示范围在0到65535,一共可以存65536个字符. ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"4.3 其他编码 utf-8 和 big5 由于代码有些超纲 这里不便多讲 后面也会给同学们细细道来 不要着急 其实他们的原理都差不多 后面bird老师给带领大家对编码有进一步的认识 ","date":"2021-11-29","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】16 - 数组和字符串","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B16-%E6%95%B0%E7%BB%84%E5%92%8C%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":null,"content":"一、强制转换类型 1.从名字上来理解关键在于类型转换中“转换“二字的理解 2.想必大家也能理解 其实就是 一种类型转换为另一种类型 3.类型转换分为: 显示转换 和 隐示转换 4.区别在于 显示需要再变量名前加(需要转换的类型名) 而隐示转换是不需要加的 会自动根据定义的类型自动转换 5.虽然说是自动转换 但是也要做注意 可不是任何类型都可以任意转换的哦 ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"二、强制转换注意事项 1.转换的类型 和 被转换的类型 的数据宽度 2.数据类型 ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"三、显示转换 ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"3.1 有符号和无符号在数据宽度 基本类型相同的转换 void main() { unsigned char a =198 ; char b = (char)a; printf(\"a: %d\\n\",a); printf(\"b: %d\\n\",b); system(\"pause\"); } ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"3.2 数据宽度不同的情况转换 类型不是可以随意强制转换的，数据宽度要相同 否则会丢失数据 除非特意安排 void main() { int a = 0x12345678; char b = (char)a; printf(\"a: %d\\n\", a); printf(\"b: %d\\n\", b); system(\"pause\"); } ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"3.3 数据类型不同 但 数据宽度相同的 转换 3.3.1 float转int void main() { float a = 333.33; int b = (int)a; printf(\"a: %f\\n\", a); printf(\"b: %d\\n\", b); system(\"pause\"); } 我们会看到当float类型转int类型,小数部分会省略,这里注意可不是四舍五入哦！ 3.3.2 int转float void main() { int a = 333; float b = (float)a; printf(\"a: %d\\n\", a); printf(\"b: %f\\n\", b); system(\"pause\"); } 继续发现当int类型转float类型,会在后面多出6个0成为浮点数也就是小数 ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"3.4 字符串和数字之间的转换 上面的数据类型转换都是数字之间的转换,那么如果字符串和数字之间的转换能直接强制转换得到我们想要的结果吗？答案肯定是否定的. 例如: void main() { char name[6]={'1','2','3','4','5','\\0'}; int nameID=(int)name; printf(\"a: %s\\n\", name); printf(\"b: %d\\n\", nameID); system(\"pause\"); } 虽然能编译成功,但是结果完全不是我们想要的,会导致得到很多不确定的值. 所以我们要确保类型能正确的转换. 那么我们的字符串就不能转换成数字吗？答案也是否定的, 当然能转换,只是需要一个转换函数,atoi();类似这样的类型转换函数C/C++有很多库函数,这里就不一一列举了.我们改进下刚才的代码. void main() { char name[6]={'1','2','3','4','5','\\0'}; int nameID=atoi(name); printf(\"a: %s\\n\", name); printf(\"b: %d\\n\", nameID); system(\"pause\"); } 看！我们得到了我们想要的数字了！ ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"3.5 总结 \\1. 类型转换要考虑 类型的宽度 和 类型种类. \\2. 不要随意转换类型,我们必须确保我们能知道最后的结果.例如：数据截断导致的丢失数据(除非在特定的场合下). \\3. 使用类型转换函数能够转换强制转换不能够直接转换的类型. ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:3:5","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"四、隐示转换 1.其实上面讲到了显示转换,这个隐示转换就一回事了,只是隐示转换不需要在变量名加(需要被转换类型) 2.但是要特别注意的就是我们必须要明确知道编译器是怎么自动判断转换的是什么类型. 3.比如 void main() { int a = 0x12345678; char b = a; printf(\"a: %d\\n\", a); printf(\"b: %d\\n\", b); system(\"pause\"); } ","date":"2021-11-26","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】15 - 强制转换类型","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B15-%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"一、原码 反码 补码 从不同的角度去看情况,往往会得到不同的结果,在前面的课程我们举得例子都是正数,没有看到负数,难道计算机没有负数一说？当然不是,在讲有符号 和 无符号的时候 我们需要了解一下计算机是怎么存储数据. ","date":"2021-11-24","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】14 - 有符号和无符号区别","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/"},{"categories":null,"content":"1.1 原码 补码 反码 计算的二进制数据有3种表现形式分别为:原码 补码 反码. 首先我们看到原码是可以理解的,例如:以1个字节计算,10的原码是:0000 1010 那为什么会有补码和反码的存在呢？这是由于CPU的关系,等会我们再细致讲解. 我们的计算机在内存中其实存放二进制数据的形式是补码. 之前的课程中我们讲到的例子全是正数没有用到过负数. 其实计算机的类型会分为有符号类型(正/负号)和无符号类型(正号没有负号),一般我们的正号是可以省略的. 它们均可以在类型名前加\"unsigned\"关键字表示为无符号,默认不加这个关键字就是有符号类型, ","date":"2021-11-24","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/:1:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】14 - 有符号和无符号区别","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/"},{"categories":null,"content":"1.2 符号位和数值位 原码 补码 反码三种形式均有符号位和数值位两部分, 1.2.1 符号位: 符号位 0 表示正数,符号位 1 表示负数. 1.2.2 数值位: 三种表示形式各不相同,这样也是有原因的,因为使用补码,可以将符号位和数值域统一处理. 加法和减法也可以统一处理(因为CPU只有加法器,而没有减法器). 补码与原码相互转换,其运算过程是相同的,不需要额外的硬件电路。 1.2.3 原码怎么计算得到补码呢? 原码的绝对值 1.直接将二进制按照正负数的形式得到原码后取绝对值后翻译成二进制就可以了. 反码 2.位依次按位取反就可以得到了. 补码 3.反码 +1 就得到补码. 注意:正数的原码、反码、补码相同. 1.2.4 例如: unsigned char a = 198; char b = -58; printf(\"%d\\r\\n\",b);//内存中存198 return 1; 最高位1表示负数,数值位表示值 1.原码取绝对值:1011 1010 (原码) =\u003e -58 =\u003e -011 1010 =\u003e|58| =\u003e |-011 1010| =\u003e 0011 1010 2.按位取反:0011 1010 =\u003e 1100 0101 3.反码+1遵循逢二进一:1100 0110 +1 =\u003e 0xC6 这就得到了我们变量b在内存中存的补码值为0xC6. 所以这就解释了为什么我们看变量a,b的内存值都是0xC6. 1.2.5 有符号无符号总结： 1.符号位 0 表示正数,符号位 1 表示负数. 2.正数的原码就等于补码. 3.负数的原码不等于补码. 4.补码等于原码取绝对值转换成二进制然后取反再加1得到的. 5.所以仅仅从内存看值 是无法确定是有符号还是无符号的,计算机是识别不了的,需要编译器操作一系列指令来识别. 1.2.6 为什么用补码储存呢？ 有的人会问用原码多好还能直接看出来 其实并不然,计算机有时候还并不是那么智能的 CPU只会加法并不会减法所以才是补码存储也就是说CPU只有加法器并没有减法器 我们来看看正数的补码 和 负数的补码 相加是不是得到了正确的结果呢? 1.2.7.例如： 10+(-2)=8? 看看计算机的计算流程 正数10的补码等于原码： 0000 1010 负数-2的补码不等于原码： 这里要计算出补码 1000 0010 取绝对值 0000 0010 取反 1111 1101 +1得到补码 1111 1110 计算机验证下就是等于-2 由于CPU只有加法器 我们就把2个补码相加 0000 1010 1111 1110 逢二进一等于 0000 1000 验证下是不是等于8？ 计算是对的 所以明白了吗？？ ","date":"2021-11-24","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/:1:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】14 - 有符号和无符号区别","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/"},{"categories":null,"content":"二、有符号 无符号 1.经过上面的讲解 我们在来理解一下 有符号 和 无符号 2.观察下面代码 并编译 显示 3.我们观察内存中 这2个变量的值 4.发现一样 ！！再回忆下上面我们讲到的负数的补码 是不是就迎刃而解了 5.顿时恍然大悟的感觉 #include \u003cstdio.h\u003e void main() { unsigned char a =198 ; char b = -58; printf(“a: %d\\n”,a); printf(“a: %d\\n”,b); system(“pause”); } 我们这里面发现 a和b 的输出是不同的 我们到内存中看看情况 发现a和b 在内存中是相同的，都是C6 是否有符号不会影响他在内存中的存放方式呢？相信经过上面的讲解大家也知道怎么回事了. 因为内存中只有0和1 表示不了正负的 都是人为规定的 无符号范围 0 —- 255 有符号范围 0 —-127 和 -128—- -1 为什么这样 ？ 人为规定的！ 经过上面讲解原码 反码 补码的时候知道了为什么都是C6的原因. 这里我们还需要知道无符号的198是怎么转为有符号-58的. 其实很简单,我们只需要, -128 +（198-128） = -58 . 这里给大家画了一张图 以便大家去理解这个公式的由来： ","date":"2021-11-24","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】14 - 有符号和无符号区别","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E5%92%8C%E6%97%A0%E7%AC%A6%E5%8F%B7%E5%8C%BA%E5%88%AB/"},{"categories":null,"content":"一个小数,无论是单精度的float型还是双精度的double型,在内存中都会储存为三个部分,即符号位,指数位,尾数 符号位就是小数的正负,0代表正数,1代表负数 那指数位是什么呢? 其实小数在内存中都是以科学计数法去存放的,而指数位则用来存放科学计数法的指数数据,一会我们再细说 尾数用来存放科学计数法后的尾数,也就是小数部分 听起来是不是有些懵?不要紧,咱们举一个例子就明白了 比如我们有一个float型的8.25,要计算出他在内存中是如何存放的 首先将其转化为二进制 整数部分的转化我们之前已经讲过了,主要采用的是除法 而小数部分则需要用乘法, 0.25*2=0.5 记0 0.5*2=1.0 记1 于是小数部分为0.01 所以8.25=(1000.01)2 大家可以思考下,如果是8.3转成二进制会是什么样子呢? 下面将1000.01转成科学计数法,得到1.00001*103 首先是符号位,float型小数的符号位存放在0-31位的最高位也就31位,由于是正数,所以计0 然后是指数位,float型小数指数位为23-30位,起始值是127,也就是(0111 1111)2,代表0次幂 1次幂则用1000 0000表示 那么3次幂表示为1000 0010 最后是尾数,也就是剩下的0-22位,用来表示小数位,即00001000000000000000000 然后我们将这三部分拼起来,即01000001000001000000000000000000 转成16进制为0x41040000 以上是float型数据在内存中的存放方式,double型的存放方式是与其类似的 不同的是double型的指数起始值是1023,占用52-62这11位,而尾数则占用0-51这52位,算上符号位一共是64位 大家可以尝试着写一个double型的数据来算一算哦。 这里面我们说的第几位 实际都是我们转换成4字节以后的位数 不是内存中真实的位置 只要简单了解规则即可 为什么所有的小数转换成DWORD型都长的很像呢?这就要从指数位说起了。 我们以float型为例,如果指数是负数或者0,那么他的指数位通常表现为011xxxxx, 如果是正数指数位则表现为100xxxxx 如果算上前面的符号位,那么前面4位可能为0011,0100,1011,1100,转化成16进制则为3,4,B,C 所以说小数转换为DWORD型之后都长的很像 算一算以下float型数据在内存中是如何储存的,写出计算过程,并转化为DWORD型 6.125 15.5 2 0.25 0.3 10.005 算算以下double数据在内存中是如何储存的,写出计算过程,并转化为QWORD型 5.0625 1 ","date":"2021-11-23","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B13-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】13 - 浮点数内存中的储存方式","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B13-%E6%B5%AE%E7%82%B9%E6%95%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"还记得之前的课程，变量在内存中，看到是反着排列的吗？ 当时我们没有深究这个问题 但是我们现在学习内存了，就有疑惑了 为什么 4字节数据是反着排列的呢？ 原因是， 实际上在内存中，没有正反之分，都是按一字节 一字节顺序排列的 ，只是我们要按照什么方式去拿。 例如上图 内存中就是 78 56 34 12 而我们拿的时候 是从后面开始拿放在高位而已 变成0x12345678 但是整数类型，为什么是反着拿呢？而不是 正着拿，变成0x78563412呢？ 实际上根本原因是，设计者为了短类型数据兼容转换成长类型数据（小端）， 人为规定的储存方式而已。 我们分别到内存中去观察 char word 和dword的数值 例如1，内存中分别对应的是 char 01 word 01 00 dword 01 00 00 00 所以无论你什么宽度，内存中都是第一个字节里放了1个01 但是问题来了，读的时候怎么读？ 1,100,1000000？ 当然不对，一个鸡蛋无论放到大篮子还是小篮子里都是1 那么就要注意读取的时候的方法 01 00 00 00 如果按照 char 取读就是 01 如果按照 WORD 去读就是 0001 如果按照 DWORD 去读就是 00000001 这样就数据类型兼容了。 所以才给我们造成一种反着存放的错觉。 来个简单的题目 4字节 99999 666666在内存中字节集是怎么存放的？ 99999转成16进制是 0x0001869F 拆分成字节 就是 00 01 86 9F 而在内存中真实的存放顺序就是：9f 86 01 00 同理 666666 在内存中的真实存放顺序就是： 2A 2C 0A 00 同样大家可以到教案软件中，进行推箱子的顺序排列锻炼 如下图： ","date":"2021-11-22","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B12-%E6%95%B4%E6%95%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】12 - 整数内存中的储存方式","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B12-%E6%95%B4%E6%95%B0%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"不同的数据在内存中的存放方式是不同的 我们说内存中每一位只存放了0和1，用来表示整数很容易，那怎么表示小数怎么表示？文字符号呢？这就需要不同的存放方式，用正确的方式也就是数据类型读取数据才能得到正确的值。 例如小数型的1.23，如果我们用整数的形式去读取他就不是1.23了。 如下图： 你可以猜结果会是1，毕竟1.23小数 硬转成整数的话，应该是1。 但是这和我们现实生活中是不一样的，内存中存放不同类型的数据储存方式是不同的，比如小数点，负数这些东西他是没有办法直接存放的，要有一个另外的规则。 （在我们以后逆向工具搜索数据的时候，首先要注意的也是他的数据类型） ","date":"2021-11-21","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】11 - 字符内存中的储存方式","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"字符的储存方式 char字符型，一个字节宽度 如果说 char a=65； 和 char a=‘A’; 两句代码是相同的你相信吗？ 看下例子： 为什么呢？ 这就是编码，用一字节可以表示256个符号，一字节范围 0-255。 但是一般用不到， 128个符号足够了，我们键盘才几十个符号。 这就是ASCII编码 也就是文字符号的储存方式。 可是中文不像英文那样几十个符号就可以表示，中文汉字有几万个，那么我们就需要复杂的编码表。 是这样设计的 ，把127个符号以后的符号用作表示汉字的一半前127保留原来的含义，这样2字节表示一个汉字，就有了万种左右的组合。 但是这只是基本的情况够用 ，还是不能表示全部的汉字，那么就又有了GBK GB18030 等等的拓展 以及其他的编码。 例如unicode utf-8 等编码，当然其他地区也可以有自己的编码。 一般如果外服软件和游戏我们出现乱码，往往原因不是这三种编码 ，我们的系统里没有字库。 例子台湾big5。 ","date":"2021-11-21","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】11 - 字符内存中的储存方式","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"习题+考核 1.定义两个字符分别等于’F’和’B’,并用无符号整数型输出二者的和 2.分别打印出以下字符的ASCII码,‘1’,‘a’,‘F’,’!’ 3.分别打印出以下数字对应的字符,49,50,59,60,69,70 4.打印出大写字符F和小写字母f的ascii码,计算出他们的差值 ","date":"2021-11-21","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】11 - 字符内存中的储存方式","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B11-%E5%AD%97%E7%AC%A6%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%82%A8%E5%AD%98%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"E:\\课程资料\\2021.7在线班 课程\\A001-游戏辅助技术(初级班)\\视频 的目录 001-C,C++程序入口点.flv 002-C,C++函数,转义字符.flv 003-C,C++调用Windows系统API接口.flv 004-C,C++ char,short,int,LPCTSTR与sizeof运算符.flv 005-C,C++ 利用Windows API 操作游戏窗口.flv 006-C,C++ 利用Windows API 获取进程PID.flv 007-C,C++读取目标进程内存数据.flv 008-C,C++读取目标内存数据 读4字节.flv 009-CE分析基址偏移-精确数值.flv 010-CE分析基址偏移-未知初始值.flv 011-C,C++32位和64位进程读写多级基址偏移示例.flv 012-C,C++32位和64位进程内存数据读写函数接口.flv 012-C,C++32位和64位进程内存数据读写函数接口.mp4 012-C,C++32位和64位进程内存数据读写函数接口_重录.flv 013-X86环境使用汇编MOV,SUB,ADD指令.flv 014-X64环境masm汇编asm文件.flv 015-push和pop指令与栈的关系.flv 016-call指令与ret指令对栈的影响.flv 017-x86环境 常见的六种参数调用约定传递与平栈.flv 018-x64环境 常见的六种参数调用约定传递与平栈.flv 019-C,C++条件表达式,逻辑运算符与判断语句.flv 020-汇编指令test,cmp,jmp,jz,jnz.flv 021-C,C++循环语句与控制语句.flv 022-汇编条件转移指令与循环.flv 023-C,C++用代码注入器调用CALL.flv 024-C,C++用代码,跨进程调用CALL.flv 025-创建一个简单的MFC程序并为Button关联单击事件.flv 026-MFC动态链接库与注入DLL.flv 027-在目标进程分配内存写入代码.flv 028-向目标进程注入代码加载DLL.flv 029-分析角色对象的属性.flv 030-C,C++编写代码读取对象属性值.flv 031-C,C++输入输出重定向.flv 032-C,C++定时器与主线程.flv 033-基址偏移分析复习.flv 034-分析角色信息复习.flv 035-周末复习答疑.flv 036-C,C++简单认识MFC消息机制.flv 037-C,C++MFC的编辑框控件和CEdit类.flv 038-C,C++在游戏空间加载DLL模块.flv 039-用CE和x32dbg分析寻路CALL,认识float类型.flv 040-C,C++浮点数,浮点数组与寻路CALL测试代码.flv 041-C,C++创建多个线程.flv 042-C,C++FS段与多线程TEB的关系.flv 043-用xdbg和CE分析寻路功能的ECX参数与角色对象.flv 044-C,C++为寻路功能编写完整的代码.flv 045-C,C++数组与循环,汇编中数组访问方式.flv 046-利用xdbg和CE分析力量敏捷耐力智力精神力.flv 047-用xdbg和CE分析角色名字基址偏移.flv 048-编写代码读取角色力量敏捷智力精神力和名字等.flv 049-初级班主要知识点总结整理.flv 050-初级班主要知识点总结整理完结.flv 2021.7游戏辅助技术初级班大纲.txt ","date":"2021-11-20","objectID":"/2021/11/%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E6%8A%80%E6%9C%AF%E5%88%9D%E7%BA%A7%E7%8F%AD-%E8%A7%86%E9%A2%91-%E7%9A%84%E7%9B%AE%E5%BD%95/:0:0","series":null,"tags":["郁金香精品帖"],"title":"游戏辅助技术(初级班) 视频 的目录","uri":"/2021/11/%E6%B8%B8%E6%88%8F%E8%BE%85%E5%8A%A9%E6%8A%80%E6%9C%AF%E5%88%9D%E7%BA%A7%E7%8F%AD-%E8%A7%86%E9%A2%91-%E7%9A%84%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"E:\\课程资料\\2021.6在线班 课程\\B002-游戏外挂技术(中级班)\\视频 的目录 001-C++的类和对象.flv 002-C++的基类和派生类.mp4 003-用代码读取utf8名字.flv 004-1-用CE和xdbg分析对象名字 -补充.flv 004-用CE和xdbg分析对象名字.flv 005-虚函数指针与虚函数表.flv 006-用CE和xdbg分析对象数组.flv 007-C,C++链表结构 typedef struct关键字.flv 008-用CE和xdbg分析对象数组链表部分.flv 009-C,C++遍历游戏怪物数组.flv 010-C,C++遍历游戏对象链表.flv 011-C,C++xdbg条件断点,修改遍历代码.flv 012-分析快捷栏数组与快捷栏使用call.flv 013-C,C++写快捷栏使用call测试代码.flv 014-C,C++挂接游戏主线程运行函数.flv 015-C,C++测试遍历怪物列表的代码.flv 016-C,C++主线程代码传递复杂参数的实现.flv 017-C,C++struct结构与主线返回多个数值.flv 018-用ce,xdbg分析对象坐标并写代码测试.flv 019-用ce,xdbg分析选中对象功能并写代码测试.flv 020-C,C++代码移植与写代码测试选中对象功能.flv 021-C,C++遍历计算怪物距离.flv 022-C,C++遍历计算最近怪物并选中.flv 023-用ce,xdbg分析技能call.flv 024-C,C++写代码调用测试技能call.flv 025-C,C++命名空间namespace.flv 026-C,C++类静态成员.flv 027-ce,xdbg分析喊话CALL.flv 028-为喊话CALL写测试代码.flv 029-ce,xdbg分析明文封包,解密包,组包,发包-90%的功能都在这里了.flv 030-C,C++物品使用组包 写代码测试.flv 031-C,C++模板的简单使用示例.flv 032-C,C++编写主线调用函数模板,方便快捷的调用功能.flv 033-ce,xdbg分析背包对象数组.flv 034-ce,xdbg分析背包对象,背包对象数量偏移.flv 035-ce,xdbg分析背包名字偏移,对象分类编号.flv 036-C,C++写代码遍历背包显示名字.flv 037-ce,xdbg宏指令CALL.flv 038-C,C++写代码测试宏指令功能.flv 039-ce,xdbg分析对象的大分类编号A.flv 040-ce,xdbg分析对象的大分类编号B.flv 041-C,C++遍历对象分类信息+优化遍历代码.flv 042-C,C++ MFC编辑框使用技巧示例.flv 043-C,C++ MFC多个窗口间的切换,控件TabControl的使用A.flv 044-C,C++ MFC多个窗口间的切换,控件TabControl的使用B.flv 045-C,C++项目改名与代码移植整理(花月录制).mp4 046-C,C++ 优化宏指令调用.flv 047-C,C++ 分析释放灵魂与天使复活.flv 048-C,C++ 写代码测试释放灵魂与复活代码.flv 049-C,C++ 第二次修复完善遍历代码+.flv 050-ce,xdbg分析装备耐久度分析(当前值,上限值).flv 051-ce,xdbg调试分析修理单个装备功能和修理所有装备.flv 052-C,C++写代码遍历装备耐久度.flv 053-ce,xdbg分析装备数组.flv 054-写代码遍历装备数组.flv 055-ce,xdbg调试分析接任务交任务完成任务.flv 056-C,C++写代码测试接任务交任务完成任务.flv 057-C,C++写代码测试交任务完成任务.flv 058-C,C++写代码HOOK分析封包数据格式A.flv 059-C,C++写代码HOOK分析封包数据格式B-detours劫持.flv 060-C,C++写代码HOOK分析封包数据格式C-过滤和格式化.flv 061-C,C++写代码HOOK分析封包数据格式D-写入配置文件.flv 062-C,C++写代码HOOK分析封包数据格式D-读取配置文件.flv 063-C,C++写代码HOOK分析封包数据格式E-配置信息容错处理.flv 064-C,C++写代码HOOK分析封包数据格式F-获取返回地址.flv 065-C,C++不使用汇编的情况下进行HOOK处理.flv 066-C,C++利用自写代码分析转向组包.flv 067-C,C++利用自写代码分析转向功能并测试.flv 068-C,C++利用自写代码分析进入副本的功能.flv ","date":"2021-11-20","objectID":"/2021/11/%E6%B8%B8%E6%88%8F%E5%A4%96%E6%8C%82%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%BA%A7%E7%8F%AD%E8%A7%86%E9%A2%91-%E7%9A%84%E7%9B%AE%E5%BD%95/:0:0","series":null,"tags":["郁金香精品帖"],"title":"游戏外挂技术(中级班)\\视频 的目录","uri":"/2021/11/%E6%B8%B8%E6%88%8F%E5%A4%96%E6%8C%82%E6%8A%80%E6%9C%AF%E4%B8%AD%E7%BA%A7%E7%8F%AD%E8%A7%86%E9%A2%91-%E7%9A%84%E7%9B%AE%E5%BD%95/"},{"categories":null,"content":"什么是内存 内存是计算机中重要的部件之一。计算机中所有程序的运行都要在内存中进行。其作用是用于暂时存放cpu中的运算数据。 我们调试软件时所说的内存，往往是指虚拟内存 。 计算机中软件执行后 ，会用到很多数据 ，这些数据都是被装载在该程序的进程空间的虚拟内存中。 虚拟内存是在硬盘上的 ，操作系统为该软件的进程分配4GB的虚拟内存空间用来存放数据。 注意没注意一个细节，我说到了分配4GB的虚拟内存空间 ","date":"2021-11-18","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】10 - 内存","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/"},{"categories":null,"content":"为什么是4GB这个大小 ？这里指定的32位系统 所谓的32位指的是32位2进制 那么32位2进制，最小值是32位0 ，最大值是32位1。 用16进制表示，也就是 0- 0xffffffff , 最多可以表示这么多个地址 和一堆房子的楼号一样（操作系统寻址方式导致的 也有办法扩展他的寻址范围 例如大内存补丁） 一个地址到下一个地址的数据宽度为一个字节(如果这个宽度不是一字节，内存就可以扩大了) 一共0x100000000个地址,也就是这些字节 0x100000000/1024/1024/1024 = 4GB 正好等于4gb ,所以32系统为我们分配4gb虚拟内存 而计算机的发展 程序变大 32内存慢慢满足不了需求 所以出现了64系统 以后还会出现128系统 那么这么大的空间 我们怎么找到我们想要的数据呢？就是通过的内存指针，也称内存地址 例如 我们有100个箱子 箱子中存放的东西就是我们要找的数据 而箱子的编号就是内存地址 我们可以通过编号 很容易的找到我们想要找的东西 00000000-FFFFFFFF 实际上就是 0x100000000个箱子 每个地址的编号就是内存地址，里面可以存放任意的数据 ","date":"2021-11-18","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】10 - 内存","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/"},{"categories":null,"content":"变量是存放在内存中的 \u0026表示取地址 void main() { int a = 0x12345678; printf(“address： %08X\\n”,\u0026a); getchar(); } 0x0103F938就是变量a的地址 我们来调试一下 ，看看内存地址里的变化。 需要掌握的几个简单的操作如下： 下断点 ： F9 单步调试:F10 进入调试： F5 停止调试:shift+F5 调试状态下并且断点断下的时候可以如下操作： 调试—-窗口—-选出需要的窗口 例如内存窗口 这里是反着放的，我们后面会说原因 我们可以看到内存中数值的变化 ","date":"2021-11-18","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】10 - 内存","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/"},{"categories":null,"content":"常量是取不了地址的 已经直接被编入了指令中，但是编入代码指令中，代码指令也是在内存中的，本质也是有地址的 不止数据，变量，包括代码，资源所有的东西都是加载到虚拟内存中的 只是C++语法限制我们不能读取，我们可以通过其他方法读取 ","date":"2021-11-18","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】10 - 内存","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B10-%E5%86%85%E5%AD%98/"},{"categories":null,"content":"在上一节课中咱们的代码中涉及到了printf()函数以及一些参数的设置 这里肯定有很多同学不知道怎么使用这个函数 那么，今天咱们的主题就是 输入和输出 函数 帮助大家进一步了解，好了,开始我们的讲解. 一、输出 输入函数printf(); 这个函数大家之前也见过. 现在我们看看他的参数： 首先 第一个参数:是一个字符串 也就是 \"\" 双引号里面的 最终会被格式化输出在控制台上 显示出来的 那么这里肯定有同学会问 格式化？ 到底是什么意思? 简单的来说就是 把某个数据 按照一定的 格式 转为别的 格式 printf(\"a：%d \\n\",66); 如下： 咱们这个66是个数字也就是一个整数类型,最终我们需要以字符串类型的形式输出到控制台上. 2种类型不匹配,这时候需要把66这个转为字符串就需要这么写. 在我们的第一个参数中用%d代表,这里用66这个值来替换了. 我们编译看一下 结果： 如果需要多个数据被格式化 就在第一个参数中加N个%d，同时从二个参数开始用逗号隔开每个数据 ,这里不一定是%d 这个主要取决于 被转换的类型是什么类型 就比如上节课 我们讲到了 %d 对应 整数类型 布尔类型 %c 对应字符类型 %f %lf对应浮点数类型 %s 对应字符串类型 后面还有%x 等等 这里先了解上面的几种 以后还会讲解到更多 1.1.printf扩展-位数对齐 3位对齐 printf(\"a：%3d \\n\",3); printf(\"a：%3d \\n\",33); printf(\"a：%3d \\n\",333); 前面补0 printf(\"a：%03d \\n\",3); 打印2位%.2f 二、输入 scanf（2013 以上的时候 使用 scanf_s） 在讲这个scanf函数之前,我们需要先了解一个符号\"\u0026“取地址符号,顾名思义就是取一个变量的地址. 这里先了解一下,初步认识一下,后面我们会细致的讲解. 好,我们继续. int a=0; printf(\"请输入a=\"); scanf_s(\"%d\",\u0026a); printf(\"您输入的a=%d\\n\",a); 我们会看到和printf的参数设置有些类似,但是在变量后面多了一个”\u0026“取地址符号,这是因为我们需要输入值(从我们自己输入值到控制台上,然后保存到对应变量上),这就需要一个变量的内存地址来存,所以需要一个”\u0026“取地址符号. ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B08-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】08 - 输入输出流","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B08-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81/"},{"categories":null,"content":"相信大家在上一节课的代码中看到过很多 变量的定义和声明 int a=1; bool b=TRUE; char c='h'; float f=1.0f; double d=2.0f; 等等 这些代码 不明白这是干什么的 其实这就是在申请一个变量 那么今天我们就讲解一下变量和常量 好了 开始我们今天的讲解 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"一、变量 首先讲解变量,这个变量从字面意思 在于一个\"变\" 字,怎么变呢？,说的通俗点,有一个盒子 里面能放各种物品 变量就类似这样,可能说的有点不太懂 那么我们先从变量开始,这里先举例说明. 例如: int a=88888; float b=99.0f'； 对，没错这a b就是变量的,写法就是 类型名 变量名 (= 初始值)； 在这里，类型名 必须是一个有效的 C 数据类型，可以是 char、w_char、int、float、double 或任何用户自定义的类型，同时变量名可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔,下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 在这里还需要继续扩展下变量的定义与声明 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"1.1.变量定义 1.程序中，变量有且仅有一个定义。比如:int a=88888; 同时这种是在告诉编译器 ，帮我们分配一个4字节大小的内存 类型为int类型 里面的值存为88888：就好像一个盒子 从生产出来 就要确保尺寸大小 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:1:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"1.2.变量声明 1.用于向程序表明变量的类型和名字。 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:1:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"1.3.声明和定义的区别 1.定义也是声明，extern声明不是定义。 2.定义分配存储空间，而声明不会。 3.通过使用extern关键字声明变量名而不定义它。 事实上它只是说明变量定义在程序的其他地方。程序中变量可以声明多次，但只能定义一次。 4.只有当声明也是定义时，声明才可以有初始化式，因为只有定义才分配存储空间。 例如： extern int a其中变量a是在别的文件中定义的。 前者是\"定义性声明（defining declaration）“或者称为\"定义（definition）\",而后者是\"引用性声明（referncing declaration）\"。 备注：extern 还没学到这里大家有个印象就行不要急. ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:1:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"1.4.扩展资料 1.变量是一种使用方便的占位符（比如上面的 a b c这种字符 方便我们对内存的操作），用于引用计算机内存地址，该地址可以存储代码运行时可更改的程序信息。 2.变量名必须以字母或下划线打头，名字中间只能由字母、数字和下划线“_”组成； 3,.变量名不能是VC中的保留字（关键字） 下面看一点实例： extern int d = 3, f = 5; // d 和 f 的声明与初始化 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = 'x'; // 变量 x 的值为 'x' ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:1:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"二、常量 1.我们知道了变量,那么常量就更好理解了就好比 把上面我们讲到的常量的那个盒子 进行加工 让这个盒子只能存唯一的物品 2.其实就是地址里面的值,是不能修改的 3.常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 4.常量可以是任何的基本数据类型，比如整数常量、浮点常量、字符常量，或字符串字面值，等等 5.常量就像是常规的变量，只不过常量的值在定义后不能进行修改 2.2.例如1 const int a=88888; a=99999;// 错误的 因为加了const关键字 表示 int类型的 a变量是个常量 常量，字面上的值 2.3.例如2 int a=10 ; //10就是常量 10 = 11？？ //常量不可以变 这样也是不行的 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"三、常量的简单列举 ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"1.整数常量： 520 0x521 const int a=88888; ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:3:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"2.浮点常量： 3.1415926 const float f=88888; ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:3:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"3.字符常量： 一个普通的字符（例如 ‘x’） 一个转义序列（例如 ‘\\n’） 一个通用的字符（例如 ‘+’） ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:3:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"4.字符串字面值**：** “hello, heart” ","date":"2021-11-17","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/:3:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】09 - 常量和变量","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B09-%E5%B8%B8%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F/"},{"categories":null,"content":"【飞郁2022新课程】03 - 计算机底层的二进制 飞郁网络 听说你们学编程不想学基础? 说实话,我还不想教呢! 基础理论乏味的很,哼!凸显不出我高深的技术! 不过啊! 基础有多好,**“一定”**决定了你以后高度有多高 **“一定”要听老师的劝,前面枯燥的几天基础“一定”**要好好学 俗话说的好,听人劝吃饱饭! 我前几天去医院看一个老大爷,他就劝我 小伙子,赚钱没有用,你**“一定”**带不走… ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"从进制开始学习的原因 由于我们要学习编程的原理,而不只是单单的学习编程,所以就要去学习计算机底层实现的原理。 但是计算机只认识2进制,那么我们想要了解其本质,就必须了解进制。 刨根问底,方能成就大业，否则这些知识一定带不走…（Call back） 实际上我们无论写出什么样的代码,最后都是变成2进制被计算机执行的,也就是说我们要学习进制,其实主要就是要学习2进制。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"从10进制的角度看待进制 10进制非常简单，我们现实生活中最常用的就是十进制。 10进制是由 0，1，2，3，4，5，6，7，8，9 共10个符号组成的逢10进1的一种进制。 这里面要注意的是，10进制中是没有10这个符号的， 哪个符号来代表10呢？其实是没有的。 10是由1和 0 ，2个符号组成的，而不是单独的一个符号。 知道了10进制的定义,我们引申出n进制定义。 n进制定义：由n个符号组成 逢n进位 。 n进制中是没有n这个符号的 。 **例：**2进制有2个符号组成，里面有2吗？ 没有，逢2进位了，只有 0和1这2个符号。 生活中还有很多其他进制。 时间有60进制和24进制，分别是逢60进1和逢24进1。 一打啤酒12瓶，就是12进制，逢12进1。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"进制的转换 进制我们谁都会,只是我们没有把他抽象成文字 例如 70秒你立刻就知道是1分钟零10秒，想想怎么算的呢？ 25瓶你立刻就知道是两打零1个，又是怎么计算的呢？ 自己莫名其妙的就会吧? 只是自己没有总结方法吧? 所以啊,我不是教你知识, 只是知识挖掘工，帮助你挖掘潜能。 看一下为什么70秒等于1分钟零10秒 70秒/进制 = 70秒/60 = 1分钟 余10秒 怎么样？得到什么启发了吗？ ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"十进制转二进制 那么十进制3转成二进制等于多少？ 3/2 = 1 余 1 十进制3 = 二进制 11 是不是很简单呢？ 需要除多次的十进制转二进制大家可以不掌握,因为我们只要知道原理就可以了 例： 十进制 12 转 二进制 直接12除以2 看看有多少个进位 12/2 = 60 （此时6在第二位，但是二进制是没有6的，所以要继续除）= 300(同理继续)= 1100（完全符合2进制的要求了） ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"二进制转十进制 一小箱白酒可以装2瓶 ,一个礼盒可以装2小箱,一大箱又可以装二个礼盒 请问 1大箱是多少瓶? 是不是感觉自己还是会的? 答案很简单:8瓶 其实就是对应的二进制转十进制 1000 = 8，列出来可能又看不懂了 那么我们来看看原理： 一个十进制数123,1为什么在百位？2为什么在十位？3为什么在个位？ 实际上123 = 11010 + 210 +3 = 1进制进制 + 2进制 +3, 2在十位的原因是因为他有2个10,是进位而来的,1在百位是因为有10个10进位而来的。 那么上面的2进制1000 实际等于 1222+022+02+0 = 8 怎么样懂了吗？ 例： 二进制111转换成10进制 111 = 122 +1*2+1 = 7 这样2进制就转换成10进制了 例： 二进制 10000000000 = 十进制 1024 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"进制的运算 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:6:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"二进制加法 (101)2+(111)2=? 101 + 111 1100 1+1=10，逢二进一 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:6:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"二进制减法 (1111)2-(1001)2 =? ​ 11110 －　10011 ​ 1011 10-1=1，被减数不够减向高位借１ ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:6:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"2.学员问答 问：老师计算机底层存的是二进制还是十进制？ 答：首先同学搞乱了概念， 一个仓库里存了很多很多的酒，是按照什么进制存的？ 你按照几进制，他也是那些酒，进制只是一个统计方式而已，计算机底层是用二进制来进行描述，你要转换成10进制的方式表达也是没问题的。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:7:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"3.习题+考核 １．二进制加减法 101+110 111+101 1111+111 100110+101101 10110-1011 11010-10101 2．特殊的二进制加法 11+11 101+101 110+110 1101+1101 是否能发现其中规律? 3．二进制转十进制 (1111)2 (1000)2 (111)2 (101)2 (111000)2 (1001)2 4．十进制转二进制 10 15 31 64 100 255 5．应用题 大鸟有5个萝卜和5个坑，一个萝卜一个坑，他想用这些萝卜和坑来表示一个数值，那么最多能表示多少个数值？ 答：最多可以表示1+(11111)2个数值，也就是10进制的32。 解析：萝卜放到坑里代表1，不放坑里代表0，最小值为0，最大值为(11111)2。 PS：本题重在理解，谢绝抬杠！否则你“一定”学不会(call back)！ ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/:8:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】03 - 计算机底层的二进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B03-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"同学同学,你怎么..不开心? 进制太烦了,我算的乱七八糟 来来来,听完我这节课,你还是不说不懂的话,我不保证不打死你???… ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"拓展内容:十进制转其他进制 十进制数12 如何转成二进制？其实上节课我们已经讲过了，我们来复习一下 我们把数值都放到个位，看看他怎么进位即可 我们12全放在个位是不行的，二进制只有1和0，那么我们需要进位， 所以 12/2 = 6 余0 代表我们有6个2进位到十位，余0代表个位为0，我们暂且可以写成60，当然2进制不能有6，所以我们继续进位 6/2 = 3 余 0 代表我们有3个2进位到百位 ，余0代表十位为0，我们暂且写成300，但是2进制不能有3，所以我们继续进位 3/2 = 1 余 1 代表我们有1个2进位到千位 ，余1代表百位为1，我们可以写成1100，里面已经没有除了1和0之前其他的数值，那么我们得到了最终结果1100 那么，我们来一点有难度的： 十进制123 转成 9进制等于多少？ 用同样的方法计算一下 146，怎么样会算吗？ ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"十六进制 计算机底层是2进制，我们常用是10进制，其实我们掌握这两种就够用了， 但是我们这节课来学习一下16进制。 为什么会牵扯出16进制呢？16进制实际上是2进制的简写方式。 为什么要简写呢？ 大家试想一下，如果屏幕上面全都是0和1一串数值，让你去看或则记忆，会是一种上面样的情况 例如 11010100100101000101111101001010101 疯掉了吧？ 所以我们必须要有一种简写的方式来帮助我们观看 聪明的人类是这样设计的 4位2进制最小是0000，最大是1111，也就是 0 - 15，那么我们就可以用一位的16进制来表示4位的2进制了,16进制的16的符号分别是0，1，2，3，4，5，6，7，8，9，A，B，C，D，E，F 例如 1101 我直接可以用 0xD 表示了 11011111 就是0xDF 是不是看起来舒服多了，看起来不那么累了 以后我们看到的二进制，无论是VS的反汇编窗口还是IDA,OD,CE等工具里，全部都是以16进制的形式体现出来的 也就是二进制的简写方式 写16进制的时候前面加个0x 例如 0x10 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"字节与位 我们说4位2进制可以用一位16进制表示 那么8位2进制就是两位16进制表示 8位也是我们编程应用的最小单位，叫做1字节 1字节8位的最大值： 1 1字节8位的最小值： 2 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"十六进制转换 例: 16进制转10进制 0x4a = ？ 答案：74 例: 10进制转16进制 99=? 1277=? 答案：99=0x63 1277=7916+d= d+F16+41616=0x4FD 3 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"进制符号化_拓展 我们来看下十进制的定义 0123456789 10个符号 逢10进1 注意是说的10个符号，这10个符号可以不是0123456789 如果是）！@#￥%……\u0026*（ 这10个符号 你还会计算吗 % + …… = ！！ 能看出来吗？ 打乱这种就可以达到加密的效果 例： 9进制 9个符号分别为543672189 （分别对应012345678 ） 现在5已经代表0了… 那么176+829=？ 答案： 176 和 829 分别对应 643和 758 643+758= 1512 然后转换回现在的定义 4 2 4 3 4 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"2.学员问答 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:6:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"3.习题+考核 课上练习题 •说出5种生活中进制使用的实例 •将十进制的256//1024//4095//65,536//1000转换为16进制 •将16进制的0x64//0x3E8//0x2710//0x666转换为10进制 •如果12345678分别代表8进制的01234567,那么243+367=? •16进制的0xAB+0xCD等于多少?将结果转换为10进制等于多少 •将16进制的0x579B转换为2进制 •将2进制的10110111011110分别转换为16进制和10进制 •将二进制的1011111010010100转化为16进制以及十进制,要求写出过程或原理 •计算0xD0DF1C+0x56789A的值 •将十进制的6666转化为9进制(防止你们用计算器) •如果! @ # $ % ^ 分别对应6进制的012345计算%$%+@^@ •分别用16进制表示32位游戏和64位游戏的最大内存是多少,他们相差的多么?是二倍关系么? •想一想生活中特殊进制的实例,以及他们的进位关系 •根据任鸟飞老师的讲解和你们的理解,想一想我们为什么要学习进制,为什么要做进制转换练习 •继续计算!将10进制的123,转化成2进制.想一想有几种算法,他们的特点是什么? 选做题 •10进制下有一个两位数AB,在7进制下恰好为BA。请问满足条件的两位数有几个？ •一个16进制的算式如下LN+LM=NMN,如果LMN各不相同,请问他们分别是那几个数字? 课上练习题答案 •说出5种生活中进制使用的实例 •将十进制的256//1024//4095//65,536//666转换为16进制 •0x100//0x400//0xFFF//0x10000//0x29A •将16进制的0x64//0x3E8//0x2710//0x666转换为10进制 •100//1000//10000//1638 •如果12345678分别代表8进制的01234567,那么243+367=? •521 •16进制的0xAB*0xCD等于多少?将结果转换为10进制等于多少 •0x178//376 •将16进制的0x579B转换为2进制 •0101 0111 1001 1011 •讲2进制的10110111011110分别转换为16进制和10进制 •0x2DDE//11742 •将二进制的1011111010010100转化为16进制以及十进制,要求写出过程或原理 1011111010010100按照4位一组进行排列 1011 1110 1001 0100 每4位对应一个16进制的数字,转换之后为 B E 9 4 0xBE94=11161616+141616+916+4=48,788 错误做法,直接将2进制按照常规算法转成10进制,然后再转16进制 这样会麻烦很多,工作量很大 •计算0xD0DF1C+0x56789A的值 16进制计算,逢16进1,直接相加即可 0xD0DF1C+0x56789A = 12757B6 逐位相加 D+5=12(00000) 0+6=6(0000) D+7=14(000) F+8=17(00) 1+9=A(0) C+A=16 16+A0+1700+14000+60000+1200000= 12757B6 不合理做法,先转成10进制,相加之后再转化回来 •将十进制的6666转化为9进制(防止你们用计算器) 做法除以9取余数倒叙排列 6666/9=740……6 740/9=82……2 82/9=9……1 9/9=1……0 1/9=0……1 最终结果为10126 •如果! @ # $ % ^ 分别对应6进制的012345计算%$%+@^@ 首先将%$%+@^@转化为012345 然后再进行计算,算完记得转化回来 %$%+@^@=434+151=1025=@!#^ •分别用16进制表示32位游戏和64位游戏的最大内存是多少,他们相差的多么?是二倍关系么? 32位是0-FFFFFFFF 64位是0-FFFFFFFF FFFFFFFF 相差的很多,应该是1 0000 0000倍而不是2倍 •想一想生活中特殊进制的实例,以及他们的进位关系 比如时间进制,秒和分是60进制,小时是24进制,天是30或者31进制,月是12进制 •根据任鸟飞老师的讲解和你们的理解,想一想我们为什么要学习进制,为什么要做进制转换练习 因为16进制是逆向的核心进制,在数据分析的过程中我们需要对16进制和10进制的关系非常敏感.而其他的进制也可能作为加密的数据出现在分析过程中,了解进制转换的过程,并不是说我们每次都要去手动计算,而是为了了解原理,看透本质 •继续计算!将10进制的123,转化成2进制.想一想有几种算法,他们的特点是什么? 两种算法,第一种直接用除以2的方式得出2进制为111 1011 第二种先将10进制转化为16进制0x7B,再将0x7B中的两个数字分别转化为0111和1011,最终结果为1111011 选做题1答案 •步骤1：先思考第一个问题， 7进制下BA在10进制下是多少？ 这个问题是最基本的进制换算， 7进制下BA就是7×B+A， 这就是10进制下的值。 •步骤2：再思考第二个问题， A和B需要满足什么条件？ 首先判断A和B的范围， A和B一定小于7。 由相等关系有7×B+A=10×A+B， 化简即3×A=2×B。 •步骤3：综合上述几个问题， 考虑原题目的答案。 根据步骤2的结果， B一定是3的整数倍， 结合小于7的条件，B只能取3或6， 此时对应的A是2或4， 所以满足条件的两位数是23或46 选做题2答案 一个16进制的算式如下LN+LM=NMN,如果LMN各不相同,请问他们分别是那几个数字? 答案为L=8 M=0 N=1 也就是0x81+0x80=0x101 原理,N和M相加等于N,说明M为0,并且个位没有进位 L+L=NM,说明进位了,并且十位为0,进位只能是进1,所以N一定为1 L+L=0x10,L必然等于0x8 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/:7:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】04 - 十六进制","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B04-%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"},{"categories":null,"content":"学不同语言的同学，总要争个高低，其实完全没有必要，萝卜白菜各有所爱。 但是计算机语言还真是具有高级语言和低级语言之分的。不过此高非彼高。 正式学习C++之前，我们先来了解下高级语言和低级语言。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"高级语言和低级语言 低级语言：机器语言和汇编语言。 高级语言：主要是相对于汇编语言和机器语言而言的，它是较接近自然语言和数学公式的编程，基本脱离了机器的硬件系统，用人们更易理解的方式编写程序。 像我们使用的C/c++ ，易语言 ，java 这些都是属于高级语言。 说白了，越容易看懂月容易理解的语言越高级。和其他没有关系，不是高级就厉害。 1 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"机器语言 机器语言是用二进制代码表示的，计算机能直接识别和执行的一种机器指令的集合。 所有的指令都是由0和1组成的一串串数字 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"汇编语言 汇编语言是把这些二进制码用符号来代替，就成了汇编语言。 汇编语言也被称为符号语言。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"高级语言 高级语言是在汇编语言的基础上封装而成。高级语言可以再封装，成为更高级的语言。 我们来举个例子 机器语言的10010000 简写以后是0x90 变成汇编语言就是 NoP 变成高级语言就是 空行 所以我们在这里能够明白 机器语言 汇编 C++ 从低到高排列的 写代码和玩积木是一样的，最小的积木是0和1。 例如我们去搭建一个房子， 机器语言就是用最小的零件0和1去搭建房子。 但是我们觉得太麻烦了，把这些0和1粘成各种形状的砖块，再去搭建房子，这就是汇编语言。 然后我们觉得还是麻烦，我们继续把砖块粘起来，做成门，窗，床，沙发等等更大一点的积木，能让我们搭一个房子的时候更为简单一些，这就出现了C++。 然后有人说，那我直接做一个房子，你不用搭建，想要房子的时候直接拿过去用就行了，但是房子具体是怎么搭建的你也不知道了，这可能就是易语言之类的更高级语言。 从这个例子可以看出来，越低级的语言越强大，可以更灵活，而越高级的语言都已经固定化 所以我们想去逆向程序,想去了 解程序的执行本质 想要精通逆向分析,就要去学习汇编语言。 为什么不是机器语言？我们能看懂吗？。。。 但是我们不需要用汇编代码去写程序,那是一件很繁琐的事,我们也没有这个必要 我们要了解汇编代码的含义和执行流程,这样就可以了。 甚至有一些生僻的汇编指令没有遇 见过,完全可以百度一下看看他的含义或者运行一下看看这条指令操作了什么。而完全没有 必要去死记硬背汇编指令。当然你能被动的记住更多的汇编指令 也是有好处的。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"C++和易语言之类的更高级语言的区别 1.推荐大家学习c/c++ 但是学员中也包含了完全没有编程概念和编程基础的学员,基础十分薄弱,英文又一窍不通的话，也可以选择先学习易语言,会让你的入门变得更为轻松。 不过为了以后更好的发展，建议有一定基础以后,还是要学习 c/c++。 2.这两种语言有什么样的区别呢？ 易语言就是c/c++封装出来的,因为是再次封装出来的,所以特征更明显,灵活性更差,对底层的了解更少 执行效率会受到一定的影响等等，这是他的缺点 但是他也有一定的优势那就是新手更容易入门,因为他是完全中文编程,易学易懂。 但是用易语言，千万不要用什么模块 这是我们客观评价这两种语言,直接抹灭其中一种都是不对的做法,看问题都是片面的。 本套课程选择C++ 进行学习，后续也会更新易语言版本。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"3.习题+考核 高低级语言对应关系学习比较,同时可以提前了解一下简单的命令,不要求完全掌握 例如 mov对应的a =1简单赋值 lea对应的 a = \u0026b 传递地址 高级语言到低级语言的转换(可以用OD或者xdbg申请内存来进行转换) NOP----0x90----1001 0000 INT3----CC----1100 1100 下面是c++代码编译出来的汇编代码,请将汇编代码转换成机器码 int a = 1---- mov dword ptr [ebp-0x8],1 int b = 2---- mov dword ptr [ebp-0x14],02 a = b + 10---- mov eax,dword ptr [ebp-0x14] ​ add eax,0xA ​ mov dword ptr [ebp-0x8],eax a = b - 10---- mov eax,dword ptr [ebp-0x14] ​ mov eax,dword ptr [ebp-0x14] ​ sub eax,0xA ​ mov dword ptr [ebp-0x8],eax a = b * 10---- imul eax,dword ptr [ebp-0x14],0xA ​ mov dword ptr [ebp-0x8],eax a = b / 10---- mov eax,dword ptr [ebp-0x14] ​ cdq ​ mov ecx,0xA ​ idiv eax,ecx ​ mov dword ptr [ebp-0x8],eax a = a \u003c\u003c 10---- mov eax,dword ptr [ebp-8] ​ shl eax,0xA ​ mov dword ptr [ebp-0x8],eax a = a \u003e\u003e 10---- mov eax,dword ptr [ebp-0x8] ​ sar eax,0xA ​ mov dword ptr [ebp-0x8],eax ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/:6:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】05 - 高级语言和低级语言","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B05-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%92%8C%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80/"},{"categories":null,"content":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍 飞郁网络 之前有个朋友,老牛逼了,他和我说学了10种编程语言, 顿时崇拜万分，羡慕的看着他说:能教教我吗？ 他说:没问题小伙子, 他立马拿出一本武功秘籍,翻开第一页,我一看！ 妈呀！我那个惊讶的呀！居然学了各种语言的hello world呀。 printf(\"Hello, World\"); std::cout \u003c\u003c \"Hello World\"; Console.WriteLine(\"Hello, World\"); echo \"Hello, World\" PRINT \"Hello, World\" System.out.println(\"Hello, World!\"); Writeln('Hello, World'); ? \"Hello, World\" console.log 'Hello, World' println(\"Hello, World\") disp('Hello, World') document.write('Hello, World'); NSLog(@\"Hello, World\"); 果然！一代语言一代神,代代离不开hello world,说到这,咱们就从hello world开始学习吧。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"创建第一个程序 1.创建项目：点击文件菜单-选择新建-选择项目 2.此时会弹出一个对话框： 选择Windows桌面-选择控制台应用-设置项目存放路径-点击确认-即可完成C语言项目创建 3.这样我们就创建了一个只有一个CPP的项目 4.我们点击网络安全学员.cpp可在编译器中查看到相关代码 5.注意： 如果没有解决方案资源管理器窗口或则不小心关掉了,可以通过以下方法打开视图-解决方案资源管理器 选择试图菜单-选择解决方案资源管理器-即可打开 解决方案资源管理器:主要是管理我们的项目文件的 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"入口函数main函数 1.我们可以编译一下空项目,把这4行代码注释的掉,看看是否可以编译成功。 注意：// 2个斜杠符号作为C语言的注释含义,表示本行代码不参与编译。 2.选择调试菜单-点击开始调试-观察是否有错误提示 3.发现以下错误 4.总结： main函数作为一个C程序的入口函数,是不可缺少的一部分，寓意在于告诉计算机从哪里开始执行代码,main函数称为主函数,当主函数结束那么表示整个程序也就结束了。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"头文件 项目中所使用的这些函数,被封装在了不同的文件中,如果想使用就必须要包含这个文件 头文件在C语言中一般是以.h为文件后缀的,h字母是header的英文缩写 #include \u003cstdio.h\u003e int main() { printf(\"Hello World!\\n\");//把字符串\"Hello World!\"打印输出到控制台 getchar();//触发暂停 return 0; //返回 } ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"项目的生成的简单介绍 1.编译生成项目：F7 2.调试程序：F5 3.运行项目：CTRL+F5 4.项目的类型是DEBUG版本还是RELEASE版本,具体还需要根据是32位还是64位程序 DEBUG版本：调试版本 RELEASE版本：发布版本 X86：32位程序 X64：64位程序 5.生成编译好后的程序会在输出窗口打印出来存放的路径,可以找到我们最终生成的EXE可执行文件(程序) 6.当关掉编译器后可能有的读者不知道如何打开编辑之前的项目了。 这里可以找到之前编辑过的项目存放的路径找到.sln后缀的文件(项目解决方案文件) 双击就可以打开之前编辑过得项目了。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"编辑代码的一些注意事项 \\1. 区分大小写以及 ,所使用的符号必须是英文输入法下的符号。 \\2. 每句代码必须\";“分号结尾。 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:5:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"C语言中的输出函数的简单调用 print 打印 f 格式的缩写 printf 按格式打印，向控制台输出 printf(“网络安全学院 \\n”); 把“”中的内容向控制台输出 后面跟着的\\n 是换行符 \\t制表符 \\ 反斜杠 按CTRL+F5快捷键运行项目,即可弹出控制台,并把字符串”网络安全学院“打印到控制台上 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:6:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】06 - 创建第一个hello world项目及其简单介绍","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B06-%E5%88%9B%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AAhello-world%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"一、数据宽度 首先在了解数据类型之前 我们要了解数据宽度 任何的数据类型都是有宽度的，宽度就是表示这种数据类型的数据占多大的空间。 数据宽度的两个基本单位是字节和位。 这里的位说的是二进制，一位就是一位二进制(只能用0或者1 来表示) 位是计算机最小的储存单位 。 一字节等于8位，等于两位16进制，字节是我们应用的最小单位。 这里有同学可能会问道？ 为什么等于2位十六进制 那是因为比如： 8个二进制1 组成1字节 1111 1111 每4个二进制位最大表示的数为 也就是说4个二进制位表示的范围可以在0到15 这刚好符合16进制的特性 因为16进制的范围大小也是0到15 这样看来 1字节8位二进制等于2位16进制 是顺理成章的事了！ 这里要特别说明下： 以后的学习中最小的宽度单位就是字节也就是两位16进制 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"二、数据类型 在C语言中 有很多基本类型 void类型 整数类型 布尔型类型 浮点数类型 字符类型 从字面意思上 可以简单的理解下 然后咋门用这些类型 定义不同类型的变量 下面我们一一讲解 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"2.1.void 无类型 1.不可以定义变量 2.很多时候我们把void用在函数的返回值 和 函数参数的传递上 3.例如： void main() { //函数体 } 这个main函数这样 就表示无返回值 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:2:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"2.2.整数类型 1.以下都是整数型只是数据宽度不一样而已也就是表示的数字范围大小不同 byte 1字节 short word 2字节 int dword long 4字节 long long qword 8字节 等等 同时有的类型是根据系统的不同而定所占字节大小 就比如32位系统 和64位 就有所不同 这里给大家演示下： 在讲解之前 需要了解下sizeof 这个关键字主要用于计算类型的所占字节大小 注意头文件：使用 word dword qword 类型 需要头文件 #include “windows.h” #include\u003cwindows.h\u003e void main() { byte a=1; short b=2; WORD c=3; int d=3; DWORD e=4; long f=5; longlong g=6; QWORD h=7; printf(\"byte 大小=%d\\n\", sizeof(byte)); printf(\"short 大小=%d\\n\", sizeof(short)); printf(\"WORD 大小=%d\\n\", sizeof(WORD)); printf(\"int 大小=%d\\n\", sizeof(int)); printf(\"DWORD 大小=%d\\n\", sizeof(DWORD)); printf(\"long 大小=%d\\n\", sizeof(long)); printf(\"longlong 大小=%d\\n\", sizeof(long long)); printf(\"QWORD 大小=%d\\n\", sizeof(QWORD)); system(\"pause\");//暂停的意思 以免控制台消失 } 看了上面的代码 有的同学对printf 可能不太明白怎么使用 以后章节我们会细细道来不要担心 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:2:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"2.3.bool 布尔类型 0为false 可以用0来表示为“假” 非0为true 可以用1表示或者任意一个非0的值来表示为“真” 对于布尔类型来判断真假的话：0为false ,1为true 对于其他类型来判断真假的话：0为false ,非0为true 看看下面一小段代码 void main() { bool a = 123; printf(\"a = %d\\n\",a); printf(\"bool 大小=%d\\n\",sizeof(bool)); system(\"pause\");//暂停的意思 以免控制台消失 } 编译后可以看到打印信息为:a不是等于123,因为是布尔类型,所以等于一个非0的布尔类型的1,也就是为真 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:2:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"三、浮点数类型 主要有2种类型 float 4字节 double 8字节 他们和整数不同 切记！ 同时小数点的后面的精度上 也不同 明显double 要比float高 这里我们也看一小段代码 void main() { float f1 = 123.0f;//这里注意浮点数要用到f结尾来赋值数据 printf(\"f1 = %f\\n\",f1); printf(\"float 大小=%d\\n\",sizeof(float)); double d1 = 123.0f;//这里注意浮点数要用到f结尾来赋值数据 printf(\"d1 = %f\\n\",d1); printf(\"double 大小=%d\\n\",sizeof(double)); system(\"pause\");//暂停的意思 以免控制台消失 } 可以看到大小不一样,这也是精度不同的原因 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"四、字符和字符串 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"4.1.字符 那么这里我们还需要讲解 字符的表示 什么是字符了 其实也就是符号 包含了 字母 符号 等等 比如a b c d 字符 1.首先字符的定义是在单引号’a’中 然后赋值给字符变量 void main() { char c1='a'; printf(\"c1 = %c\\n\",c1);//%c表示 输出的值的类型是 字符类型 printf(\"char 大小=%d\\n\",sizeof(char)); system(\"pause\");//暂停的意思 以免控制台消失 } 可以看到 char类型占1字节 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:4:1","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"4.2.字符数组 接下来是字符串 比字符 从字面上讲 多了一个字 “串” 顾名思义就是 把多个字符串在一起就成了字符串 在这里 我们需要提前了解下数组的概念 其实也很好理解 数组也就是把多个数紧紧的挨在一起 数组 这里就简单的了解下 比如 int aa[5]={1,2,3,4,5};//这样就是 把1 2 3 4 5 5个数放在一个数组中 紧紧的挨在一起 字符数组 接下来 我们把int类型 换成 char 类型看看 char cc[5]={'H','e','a','r','t'};//注意要用单引号来表示字符类型哦 我们这里打印下看看 void main() { char cc[5]={'H','e','a','r','t'};//注意要用单引号来表示字符类型哦 printf(\"%c\",cc[0]);//打印数组第一个元素从0索引开始 这里可能有的同学会不太明白 不要着急 后面会讲解 这里只是提及一下 printf(\"%c\",cc[1]); printf(\"%c\",cc[2]); printf(\"%c\",cc[3]); printf(\"%c\",cc[4]); printf(\" char cc[5] 大小=%d\\n\",sizeof(cc)); system(\"pause\");//暂停的意思 以免控制台消失 } ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:4:2","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"4.3.字符串 看到打印信息 所以？ 这里可能有的同学懂了 似乎明白了什么？ 其实字符串和字符数组差不多一个意思 只是说字符串要注意的是 是以’\\0’为结尾(也就是数值为0) 也就是说 把上面的代码需要替换一下 void main() { char cc[6]={'H','e','a','r','t','\\0'};//注意表示字符串的话 要'\\0'结尾哦 printf(\"cc = %s\\n \",cc);//%s表示 输出的值的类型是 字符串类型 printf(\" char cc[6] 大小=%d\\n\",sizeof(cc));//其实也就是6个字符表示的一个字符串 system(\"pause\");//暂停的意思 以免控制台消失 } ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:4:3","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"4.4.字符串和字符数组区别： 通过上面比较我们看到了字符数组不是字符串虽然在控制台上显示出来没有看出任何区别,其实字符串最后还会多一个\\0字符的存在, 只是说这个\\0是不会打印显示出来的,所以我们看到的都是heart 好了C语言的基本数据类型 我们就讲到这里 其他复杂的类型 后面会讲解到 ","date":"2021-11-12","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/:4:4","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】07 - 数据类型 和数据宽度","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B07-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AE%BD%E5%BA%A6/"},{"categories":null,"content":"工欲善其事，必先利其器。 学习编程，学习网络空间安全,我们首先要认识的一款叫做Visual Studio的工具。 连写字都需要一张纸，代码也一样，Visual Studio就是这张纸，就是这个开发环境。 Visual Studio是一个基本完整的开发工具集，它包括了整个软件生命周期中所需要的大部分工具，如UML工具、代码管控工具、集成开发环境(IDE)等等,简称VS 。 上面这段话看不懂？ 不理解？ 其实暂时不用懂，在这里只要知道我们写代码需要在这个环境下即可，后面会了解他的更多功能。 接下来我们进行安装： 首先我们需要获取这个工具 ，这里提供给大家 下载链接: https://pan.baidu.com/s/1D36ITkCPEtRU0oF_1bMFwQ 提取码: 2v1i 由于方便讲课和课后练习具有一致性，咱们统一使用vs2017编译器，当然大家可以根据喜好下载其他版本。 ","date":"2021-11-09","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:1:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】02 - Visual Studio的安装和简单的项目创建","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"编译器的安装 打开预先下载好的安装包 图1 2.我们会看到有2个版本的安装程序，vs_Community是社区版(免费版本) vs_Professional是专业版(收费版本)，看到了下面的激活秘钥文本文件,那么我们肯定要用专业版咯!好了我们现在就双击打开vs_Professional安装程序 3.勾选使用C++的桌面开发-勾选把MFC组件勾上-勾选一个最低版本SDK和一个最高版本SDK,如图所示： 图2 4.选择安装路径点击安装等待安装完成后 5.第一次启动选择环境选C++ 图3 6.打开后可能会提示30天试用期,我们当然是不想试用的,要用就直接永久期限！ 7.选择帮助菜单-选择注册产品-输入激活码-即可完成激活 图4 ","date":"2021-11-09","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:2:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】02 - Visual Studio的安装和简单的项目创建","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"编译器简单介绍 安装完成后，我们打开软件看看visual studio 的菜单栏，这里简单的介绍几个菜单页面 图5 1.文件菜单栏：主要针对项目创建的一系列操作 图6 2.编辑菜单栏：主要针对项目文件的一些列操作 图7 3.调试菜单栏：主要针对对项目代码的调试操作 图8 为了不让读者感觉到繁琐 我们就先介绍这几个简单的功能,后续我们会继续介绍到更多的功能 ","date":"2021-11-09","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:3:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】02 - Visual Studio的安装和简单的项目创建","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"C语言项目的创建 上面讲过项目的创建在文件菜单栏：点击文件-选择新建-选择项目 图9 2.此时会弹出一个选择创建什么类型的项目的对话框： 选择Windows桌面-选择控制台应用-设置项目保存路径-点击确认-即可完成对项目的创建 图10 3.此时如果我们看到左边有一个解决方案的项目,那么恭喜您!项目创建成功了！ 图11 直播交流QQ群：727731398 助教报名QQ：3534373359 ","date":"2021-11-09","objectID":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/:4:0","series":null,"tags":["飞郁精品帖"],"title":"【飞郁2022新课程】02 - Visual Studio的安装和简单的项目创建","uri":"/2021/11/%E9%A3%9E%E9%83%812022%E6%96%B0%E8%AF%BE%E7%A8%8B02-visual-studio%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA/"},{"categories":null,"content":"过去式 = 过去分词 = 原形 原形 过去式 过去分词 汉语意思 bet bet bet 打赌 cost cost cost 耗费**(钱)** cut cut cut 切，割 hit hit hit 撞，击打 hurt hurt hurt 使…伤痛 let let let 让 put put put 放 read read read 读 set set set 安排，安置 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:1","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改字母, 过去分词 = 原形 原形 过去式 过去分词 汉语意思 become became become 成为 come came come 来 run ran run 跑 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:2","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改字母, 过去分词 = 原形+en 原形 过去式 过去分词 汉语意思 eat ate eaten 吃 fall fell fallen 落下 forbid forbade forbidden 禁止 forgive forgave forgiven 原谅，宽恕 give gave given 给 ride rode ridden 骑 see saw seen 看见 write wrote written 写 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:3","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改字母, 过去分词 = 过去式 + en 原形 过去式 过去分词 汉语意思 break broke broken 打破，折断 choose chose chosen 选择 forget forgot forgotten 忘记 freeze froze frozen 冻 speak spoke spoken 说 wear wore worn 穿 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:4","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"原形ow, 过去式ew, 过去分词n 原形 过去式 过去分词 汉语意思 blow blew blown 吹 draw drew drawn 画 fly flew flown 飞 grow grew grown 生长 know knew known 知道 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:5","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"原形i, 过去式a, 过去分词u 原形 过去式 过去分词 汉语意思 begin began begun 开始 drink drank drunk 喝 ring rang rung 门铃响，电话铃响 sing sang sung 唱 swim swam swum 游泳 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:6","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"原形, 过去式ought, 过去分词ought 原形 过去式 过去分词 汉语意思 bring brought brought 带来 buy bought bought 买 fight fought fought 打架 seek sought sought 寻求 think thought thought 思考 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:7","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"原形, 过去式aught, 过去分词aught 原形 过去式 过去分词 汉语意思 catch caught caught 捉,抓 teach taught taught 教 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:8","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改元音字母, 过去分词 =过去式 原形 过去式 过去分词 汉语意思 dig dug dug 挖 feed fed fed 喂 find found found 发现 get got got 得到 hold held held 拥有 lead led led 引导 meet met met 遇见 sit sat sat 坐 babysit babysat babysat 临时照看 win won won 赢 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:9","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改辅音字母, 过去分词 =过去式 原形 过去式 过去分词 汉语意思 build built built 建造 rebuild rebuilt rebuilt 重建 deal dealt dealt 处理 hear heard heard 听见 lend lent lent 借贷 make made made 制造 mean meant meant 意思 send sent sent 寄,送 spend spent spent 花费 bend bent bent 使弯曲 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:10","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"过去式改字母 + t, 过去分词 =过去式 原形 过去式 过去分词 汉语意思 feel felt felt 感到 keep kept kept 保持 leave left left 离开 sleep slept slept 睡 smell smelt smelt 闻 sweep swept swept 扫 ","date":"2021-10-29","objectID":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/:0:11","series":null,"tags":["英语兔"],"title":"英语“不规则”动词“规律”","uri":"/2021/10/%E8%8B%B1%E8%AF%AD%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D%E8%A7%84%E5%BE%8B/"},{"categories":null,"content":"32位游戏逆向安全之角色及怪物分析 角色对象作为一个特殊的个体，一般都是单独存放在一个基地址下的，而有些游戏则需要通过角色名字 或者ID到怪物遍历中去获取。通过CE搜索角色血量，得到2个地址，分别是当前血量和最大血量（如图） 当前血量下访问断点，改变血量后游戏断下，这里会断到几个不同的位置，所以正确的选择断下的代码 才能快速的找到结果（如图） 断到的函数里可以得到+F8和+C偏移，执行到返回后，在4C997D处的call 006EF250中可以得到+A8偏 移（如图）（如图） 继续向上分析，发现来源于004C993E处的call [edx+38]（如图） 到函数内部可以得到+10偏移和二叉树遍历（如图）（如图） 在函数里可以得到+30偏移，而在外层可以得到基地址[10BC4E4]（如图） 这样我们就得到了角色血量的来源，但不是来源于一个单独的基地址，而是来源于一个二叉树遍历，经 过分析可以得出这个遍历恰好是怪物和NPC的遍历，也就是说我们想取角色信息，首先要通过角色名字去 这个遍历中去获取。 帖子没看够？ 添加QQ群：805981646 每晚都有免费的公开课等你来看 ","date":"2021-10-25","objectID":"/2021/10/32%E4%BD%8D%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AE%89%E5%85%A8%E4%B9%8B%E8%A7%92%E8%89%B2%E5%8F%8A%E6%80%AA%E7%89%A9%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"32位游戏逆向安全之角色及怪物分析","uri":"/2021/10/32%E4%BD%8D%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91%E5%AE%89%E5%85%A8%E4%B9%8B%E8%A7%92%E8%89%B2%E5%8F%8A%E6%80%AA%E7%89%A9%E5%88%86%E6%9E%90/"},{"categories":null,"content":"64位数据扫描及工具介绍 x64位程序的分析，主要用到两款工具，而这两款工具同x32位程序的分析工具类似，一款是CE，另一款则是xdbg64。 CE与x32的用法大致相同，主要用来对数据的突破口及地址进行扫描（如图） 有人可能会说64位程序应该用8字节来扫描，其实大部分作为突破口的数据都是从4字节开始扫描的，因为64位地址的需求还不是那么大，有些游戏数据中甚至只有基地址等少量地址是8字节的，其他的都是只有4字节的有效数据。虽然我们扫描的是4字节的数据，但是在64位的CE中是可以扫描出8字节的地址的（如图） 当然也有一些游戏中会出现很多的8字节的数据（如图） 这是一款游戏中的某种对象的ID，虽然这个ID是8字节的，但是我们看到他的地址缺只是4字节的。所以说目前为止，对于64位程序的数据，大部分还是以4字节为主的，灵活的去运用ce的扫描功能才是关键。 ce的其他功能和32位都大体相同，毕竟是同一款软件的不同版本，这里就不过多的讲解了。 下面我们来看一下xdbg64，xdbg也分为32和64版本，他的界面和功能都和OD很像。随着游戏公司对OD的检测力度越来越大，xdbg也逐渐成为逆向调试器的主流。不过xdbg明显还是不如OD好用，有很多插件都没有被完美的移植（如图） 图中是一款xdbg64的界面，从左到右，从上到下，依次为反汇编窗口，寄存器窗口，参数窗口，数据窗口，以及堆栈窗口。这些都是xdbg64的常用显示窗口，除了参数窗口是为了让我们更加清晰和容易的分析x64程序的函数参数，其他的和OD都没有什么差别。 下面有几个与32为OD操作不同的地方，我们着重看一下。 首先是查找用户的注释，在OD中我们可以在反汇编窗口中点右键来找到，但是在xdbg中是没有的，我们需要再左上方的视图中，或者在快捷按钮中找到（如图） 在数据定位时，反汇编窗口需要拉倒顶端去查找，否则的话会漏掉很多（如图）（如图） 这是我们在不同位置使用相同的机器码进行的定位，这说明xdbg的定位只能定位到模块内以下的代码，而无法将上面的特征定位到。 然后是数据窗口中跟随数据，在OD32中我们可以通过DD DB等指令去跳转并查看地址中的信息，但是在有些xdbg64中，这类插件并没有被完善，所以我们只能通过ctrl+g的方式去跳转到我们需要查看的地址（如图） 还有一些细节方面的不同，比如模块列表无法通过ALT+E查看，只能在上方导航栏点击符号进行查看（如图） 以上就是在使用xdbg64中需要注意的一些地方，其他的内容我们会在后面的文章和视频中进行详细的讲解。 看的不过瘾? 加入任鸟飞公众号直播群 QQ群号:805981646 大波知识点等你来学! 赶快加入吧!!! ","date":"2021-10-25","objectID":"/2021/10/64%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%89%AB%E6%8F%8F%E5%8F%8A%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/:0:0","series":null,"tags":["飞郁精品帖"],"title":"64位数据扫描及工具介绍","uri":"/2021/10/64%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%89%AB%E6%8F%8F%E5%8F%8A%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/"},{"categories":null,"content":"MXD系列之技能分析技能点数结构 随着游戏代码的发展，新游戏的技能越来越华丽，分类也越来越多，数据结构用的五花八门。而老游戏也不甘寂寞，技能数据也处理的有模有样，分析起来也颇有难度。以下面这款游戏为例，我们从逆向安全的角度来学习一下它的技能体系数据结构。 这款游戏的技能体系我们大致分为三个部分去分析，分别为技能等级结构，技能库结构，剩余级技能点数结构。下面先分析最简单的技能等级结构。 技能的分析可以从技能ID，技能等级，技能名字三个角度入手分析，而如果技能等级可以使用的话自然是最方便的一种，起码扫描起来很简单。而这款游戏恰好就可以通过技能加点来入手。 首先我们呢用CE来任意扫描一个高级魔法的等级，最终可以得到一个结果 在xdbg32中对这个地址下硬件访问断点，游戏直接断下，并得到一个+C偏移 向上分析可以看到一个跳转跳过ret，执行到+C偏移处，而上面可以得到一个循环+4的链表结构 图中可以看出这个链表最初的来源是上面的一个数组，当数组指向地址+8的位置与传入的esi相等时会跳出链表，或者当链表节点eax等于0时结束链表循环。 我们先到上面分析出数组的起始地址和范围，然后再获取下标的信息。 在上面不远处可以看到起始地址为[ecx+4]，而外面传入的第一个参数在循环右移5之后与[ecx+8]进行模运算，可以获取到下标edx 经观察可以得出这个这个[ecx+8]恰好是数组中总的元素数量。 由于数组中元素较少，而链表中的节点也不多，可以判断这个数组下标其实可以不去管他，只要我们得到技能库与之关联就可以得到所有的技能信息。 接下来我们继续去分析数组起始地址ecx的来源，在执行到返回后可以得到一个+0DCE偏移 向上分析得到来来源于[ebp+8]，执行到返回继续分析第一个参数，可以得到来源[eax+4] 然而这个+4并不是偏移，因为eax是一个堆栈地址，[eax+4]是一个局部变脸，并且在上面的CALL 0x2D50780中被赋值。我们到这个CALL中可以很快找到来源，并得到一个+22EC的偏移 退出这个CALL并再次下断执行到返回，可以很快得到基地址 这个数据结构总体来说是很简单的，只是中间的局部变量作为参数到CALL的赋值的操作对逆向新手有一些难度，如果对堆栈比较熟悉的话可以轻松搞定，从安全角度来讲，这里可以做的更加复杂一些。 公式就不整理了，我们接下来将要分析较为复杂的技能库结构。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 不过瘾? 那就加入QQ群:805981646 每晚直播免费的公开课 大波知识点向你袭来 赶快加入吧!!! ","date":"2021-10-25","objectID":"/2021/10/mxd%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["飞郁精品帖"],"title":"MXD系列之技能分析技能点数结构","uri":"/2021/10/mxd%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"XMD系列之技能真实名称遍历 上一篇文章里，我们对技能名字进行分析，得到了一个数组，但是经过观察，我们发现这个数组是一个临时存放的数组，只有当技能栏打开时才会显示当前一栏的技能，这样我们在获取所有技能信息时是很不方便的，所以下面我们要换一个方向找到真正的技能库遍历。 在之前找到的数组上下F2断点，并获取同一个技能的对象，我们会发现及时从新打开技能栏，获取到的技能对象都是一样的，只是存放的地址发生了变化。所以我们可以通过CE对这个地址进行扫描，并通过重新打开技能栏来过滤掉临时存放的地址。 分别在数据窗口中观察这两个地址，我们发现第二个地址的结构和临时存放的结构是一样的，也就是说这里就是拷贝到临时地址中的数组。 在这个地址上下硬件访问断点，切换技能栏，游戏断到一个新的数组位置 这里同样是一个+8偏移和一个*8+4的数组，在ebx+8处下断，观察断下的值，发现里面的内容是固定不变的，重新打开技能栏，ebx也不会重新生成。 我们继续分析ebx的来源，在上面可以得到来源于一个CALL的返回eax 在CALL上下断，分析参数，发现这个CALL只有一个参数，而参数的值很可能就是技能类型的ID 到CALL里面分析eax的来源，得到来源于局部变量[ebp-10]，而这个局部变量在上面的以结构体参数传到CALL中并被赋值。 到CALL 9CB360中分析来源，首先得到一个+10偏移 继续向上分析，可以得到一个数组套链表的结构 对代码的走向进行分析，可以得出数组套链表的节点+8中存放的数值会反复的与外面传入的技能类型ID进行比较，所以说这个位置存放的就是技能类型ID 执行到返回后，继续分析ecx的来源，可以得到+20偏移 再次执行到返回可以得到基地址 既然得到了基地址，是不是说我们的分析结束了呢？ 不！还没有结束！ 我们对数组套链表的结构进行观察后发现，这里的元素和节点实在是太多了，我们需要继续分析传入到CALL中的技能类型ID的来源 我们执行到返回后得到了一个数组 直接用CE扫描这个ebx可以得到一个基地址 接下来分析数组里面元素，可以得出以下公式 [[0x047CECD0]+138]+n*4+4技能类型 n=1为1转类型ID n=2为2转类型ID n=3为3转类型ID n=4为4转类型ID 而0转的技能类型所有职业都为0 可以说，追到这里我们就已经可以通过关联来获取到完整遍历了，但是如果为了提高一点代码效率，我们可以用技能类型ID经过加密计算获取到数组套链表的数组下标，这部分代码就在数组套链表的上面 最终我们可以整理出公式如下 技能类型ID 循环右移5 得到结果为G [[[0x03CF46D8]+20+4]+(G%[[0x03CF46D8]+20+8])*4]+4链表 [[[0x03CF46D8]+20+4]+(G%[[0x03CF46D8]+20+8])*4]+8ID [[[0x03CF46D8]+20+4]+(G%[[0x03CF46D8]+20+8])*4]+10对象 链表+4链表 链表+8ID 链表+10对象 当ID==技能类型ID时，取出对象 ========================== [对象+8]-4技能数组元素数量 [[对象+8]+n*8+4]+4技能ID [[[对象+8]+n*8+4]+8]+0技能名字ASCII 完整的技能遍历已经获取到了，虽然有些复杂，不过成就感是慢慢的，当然如果有小伙伴觉得这个办法太麻烦，也可以用传参调CALL的方式获取，被检测到了不要哭哦。 从安全角度来讲，这个部分正向代码的设计其实要比逆向麻烦很多，如果能在关键的CALL中加入弱VM并加入本地检测，会得到意想不到的效果。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 没看够? 可以加入我们QQ直播群:805981646 每晚都有免费的公开课 欢迎大家加入 ","date":"2021-10-25","objectID":"/2021/10/xmd%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8A%80%E8%83%BD%E7%9C%9F%E5%AE%9E%E5%90%8D%E7%A7%B0%E9%81%8D%E5%8E%86/:0:0","series":null,"tags":["飞郁精品帖"],"title":"XMD系列之技能真实名称遍历","uri":"/2021/10/xmd%E7%B3%BB%E5%88%97%E4%B9%8B%E6%8A%80%E8%83%BD%E7%9C%9F%E5%AE%9E%E5%90%8D%E7%A7%B0%E9%81%8D%E5%8E%86/"},{"categories":null,"content":"调试游戏.了解64位汇编指令（1） 之前我们对64位的通用寄存器和一些常用的调试器功能有了初步的认识，下面我们来通过调试游戏，对64位的汇编指令进行了解。 首先我们先对一款游戏的内息值进行扫描， 最终可以得到一个结果（如图） 在xdbg64中跟随地址，并在数据窗口中观察周围的地址（如图） 我们发现这地址其实是以4字节存放的，而在他的周围还有角色的一些其他的属性，也均是以4字节存放。于是我们在OD中下4字节的硬件访问断点，游戏在消耗内息，或者打开角色栏时游戏会断下（如图） 先将断点删点，在上方的标签中找到断点，右键删除其中的硬件断点，并将游戏运行起来（如图） 正常来讲我们是要追rdi的来源的，因为rdi+48是我们下访问的地址，但是在这个地址的附近并没有太多角色的属性，包括名字等等。而且当我们对其改动时会发现他会很快进行修正，而不会对我们的本地效果产生影响。所以我们要分析其比较的来源r13d。 r13d和eax一样，是32位寄存器，相当于r13的低32位。向上分析r13d，我们一条cmovl指令，这条指令在之前的游戏代码中是很少见的，他的意思是小于传递，其中的l是小于的意思。通过判断其上一条的cmp edx，ebx的结果，来决定本条的赋值是否执行。 我们通过下在cmp edx，ebx处下F2断点，并F8单步执行来观察寄存器的变化（如图）（如图） 在第一幅图中，edx小于rbx，所以在第二幅图中r13d被edx进行赋值。类似的指令还有上面会出现的cmovg，cmove，cmovge，cmovle等等，这些指令往往都与前一条cmp或者test指令的结果相关，和跳转指令是类似的。当然，如果想对其有深入的了解，还需要对rflags，也就是标志寄存器的变化进行学习，不过一般来说我们并不需要对这个进行死记硬背（如图） 继续向上分析edx，如果代码代码段太长，观察起来不方便，可以点H，在点击edx寄存器，来对其进行高亮设置（如图） 得出其来源于eax，而eax来源于xor eax, 0xa59cf5b6，这是一条位异或的指令，相当于一个简单的加密代码，而继续向上分析eax，则来源于mov eax, dword ptr [r12 + 0x178] 这里要注意逗号后面的赋值范围是dword，如果是qword则需要赋值8字节，不过既然是赋值给eax的那么自然不可能赋值8字节。这样就得到了数据的第一层偏移0x178。 继续向上分析r12的来源，可以得到来源于call 0x1a9cec0的返回值rax（如图） 在call里可以得到一个遍历代码，我们放到下一篇文章来接着写。 每晚7-8点都有免费的公开课 欢迎大家来看 公众号直播QQ群：805981646 直播地址会发在直播群里 ","date":"2021-10-25","objectID":"/2021/10/%E8%B0%83%E8%AF%95%E6%B8%B8%E6%88%8F.%E4%BA%86%E8%A7%A364%E4%BD%8D%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A41/:0:0","series":null,"tags":["飞郁精品帖"],"title":"调试游戏.了解64位汇编指令（1）","uri":"/2021/10/%E8%B0%83%E8%AF%95%E6%B8%B8%E6%88%8F.%E4%BA%86%E8%A7%A364%E4%BD%8D%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A41/"},{"categories":null,"content":"天刀x64明文收包及狩猎抢怪功能分析 任鸟飞 任鸟飞逆向 8月7日 天涯明月刀》从首测开始已经经历了6年的时间，因为画风唯美，玩法多样，如今依然热度不减当年，这也导致了外挂工作室的层出不穷。虽然游戏进行了反复的修改，已经基本杜绝了BUG的出现，而且各类检测也限制了大部分工作室外挂的功能，但是依然有一些暴利功能可以通过内存的角度来实现。 狩猎是游戏中的一个非常重要的日常玩法，结合了RPG和FPS游戏的多种元素。由于狩猎过程中可以掉落装备强化中必不可少的材料，导致大量的外挂工作室盯上了这里。多方竞争导致最初封包自瞄秒怪已经无法满足其牟利需要，于是很多外挂开始从收包入手，来提高代码效率，达到抢怪的效果。 由于从收到服务器的协议封包到本地的数据结构遍历这个过程中，会经历很多的代码，其中还包括很多反调试所必须的VMP，代码混淆，以及线程循环。所以在怪物刷新时，直接收包读取怪物信息，和遍历本地结构里的信息要经过短暂的时间间隔，大概几十毫秒甚至上百毫秒。这个时间从玩家的角度来看，是无法分辨出来的，但是从软件的代码角度来讲是可以做很多事情的。这就导致现在不用收包是无法抢到被狩猎动物的。下面，我们就对这款游戏的64位收包函数进行分析，并找到怪物刷新的封包。 首先我们用64位的xllydbg对游戏进行加载，并跳转到recv函数头部(如图) 下F2断点观察recv的参数情况（如图） 游戏断下之后，我们发现RCX，RDX都是比较正常的情况，分别是socket和buf，但是R8的值只有5，也就是说收包的len非常小，这显然是不正常的，说明这有可能是一个干扰包，或者是一个心跳包。于是我们从新下断，并点击F9，发现R8在执行几次后变成了0x101052，这比较像正常收包的情况。（如图） 在这种情况下执行到返回，我们发现返回的位置和之前返回的位置是不同的（如图） 接下来就需要我们找到分解的收包，在函数上下F2断点，并点击F8单步执行（如图） 此时经过了收包函数，说明已经收到包，我们在游戏断下的情况下在包内下硬件访问断点（为了避免断在包头的位置，我们尽量在稍微靠下一些的位置下断），游戏断下（如图） 执行到返回后我们来到一个memmove函数处（如图） 在这里下断，并喊话，我们发现这里已经是明文收包的位置（如图） 我们喊话的内容是11111111，在包里会得到很多“31”的ascii编码字节集，我们还可以确定包长为0x63，单步执行后RDX向RCX里面拷贝了收包内容（如图） 在确定了明文收包的位置以后，我们就可以分析刷怪包了，由于怪物的刷新时间是我们无法准确掌握的，所以最好的方式是通过HOOK收包来进行分析。另外一种办法就是通过观察，得出怪物大概的刷新时间，然后提前下好断点，并不断的点击F9来获取刷怪包。 首先我们在不杀死怪物的情况下下F2断点，并不断点击F9来观察收包长度的变化，发现这里的包长大部分为0x36和0x19，并没有特别大的包出现（如图） 然后我们杀死一些怪物，并在怪物快要刷新的时候下F2断点，在点击F9执行的时候发现出现了一些包长为0x239的封包（如图） 接下来我们对这些封包进行观察，发现在+40的后面会出现一些UTF-8编码的字符串，经过转码后可以得到刷新怪物的名字（如图） 这样就可以确定封包为刷怪包了，接下来只要通过HOOK收包，对包头和内部的属性进行关联，就可以得到怪物的ID，坐标，等其他信息了。 通过这种方式获取到的怪物信息，要比在内部获取到的信息快了很多，这个差异淘汰了很多狩猎工作室，但同样也对游戏的平衡性产生了更大的影响，玩家在看不到怪物的情况下，怪物就已经被打死了。可以从CRC检测HOOK，以及加入时间戳，对怪物的刷新时间和死亡时间进行判断，来检测是否是玩家进行的操作。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-25","objectID":"/2021/10/%E5%A4%A9%E5%88%80x64%E6%98%8E%E6%96%87%E6%94%B6%E5%8C%85%E5%8F%8A%E7%8B%A9%E7%8C%8E%E6%8A%A2%E6%80%AA%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"天刀x64明文收包及狩猎抢怪功能分析","uri":"/2021/10/%E5%A4%A9%E5%88%80x64%E6%98%8E%E6%96%87%E6%94%B6%E5%8C%85%E5%8F%8A%E7%8B%A9%E7%8C%8E%E6%8A%A2%E6%80%AA%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":["辅助"],"content":"整体流程 graph subgraph 整体流程 找出发包函数--\u003e 判断是否线程发包 --\u003e |否|找出加密封包 判断是否线程发包--\u003e |是|跳出线程发包--\u003e 找出加密封包--\u003e |ctrl+F9向外层找|明文包--\u003e 在明文包与加密封包之间找出加密call--\u003e 分析加密call--\u003e |过滤心跳包|控件包 end ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:1:0","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"检测 CRC检测 数据检测（内存地址） CALL检测 堆栈检测 标志位检测 graph subgraph CRC检测 a1([CRC检测\u003cbr\u003e即代码修改检测])--\u003e 在猜测的位置下访问断 --\u003e 能跳到检测的位置 --\u003e nop \u0026 hook \u0026 中策:jmp \u0026 上策:改变检测标志位 end graph subgraph CALL检测 d0([CALL检测])--\u003e堆栈检测 \u0026 标志位检测 堆栈检测--\u003e d3[\"第一种\u003cbr\u003e本地堆栈检测\"]--\u003e d1[\"mov ecx,[ebp+4]\"] 堆栈检测--\u003e d4[\"第二种\u003cbr\u003e网络堆栈检测\"]--\u003e d2[\"发包的包内容中\u003cbr\u003e包含大量堆栈数据\"] end graph subgraph 数据检测 z1([\"数据检测\u003cbr\u003e即内存地址数据检测\"])--\u003e CE对数据查访问--\u003e z3[\"找到疑似检测代码\"] z1--\u003e CE对数据的替身查访问--\u003e z3--\u003e z2[\"OD内找来源\u003cbr\u003e可向上层找\"]--\u003e 找到疑似检测call--\u003e 观察平栈情况--\u003e z4[\"观察寄存器\u003cbr\u003e在call执行前后\u003cbr\u003e的变化情况\"]--\u003e z5[\"观察变化后的寄存器\u003cbr\u003e对后面的代码有没有作用\u003cbr\u003e没有作用的可忽略\"]--\u003e z6[\"把检测call nop掉或者hook\u003cbr\u003e给有用的寄存器赋值\u003cbr\u003e并平栈\"] end ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:2:0","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"主线程调用 call 写内存 hook ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:3:0","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"Hook流程 graph z1([Hook流程])--\u003e 选一个大于5字节的位置--\u003e 保存原来的代码--\u003e 修改代码--\u003e 改写c++代码 ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:4:0","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"安装与卸载主线程勾子 ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:4:1","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"窗口回调函数 HHOOK g_hhookGame; ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:4:2","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"注册消息 const DWORD MyMSGId=RegisterWindowMessageA(\"MyMSG\"); //注册消息 ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:4:3","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":["辅助"],"content":"发送消息（向主线程发送） 键盘按下的消息 #define MSG_KeyDown 100 ","date":"2021-10-21","objectID":"/2021/10/%E6%95%B4%E7%90%86/:4:4","series":null,"tags":["辅助"],"title":"整理","uri":"/2021/10/%E6%95%B4%E7%90%86/"},{"categories":null,"content":"输出调试信息 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:1:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"读内存 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:2:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"写内存 ![image-20211121215009391](/Users/xinqi/Library/Application Support/typora-user-images/image-20211121215009391.png) ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:3:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"调试输出（人物信息） ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:4:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"结构体初始化（人物属性） ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:5:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"宏定义基址及偏移 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:6:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"玩家信息 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:7:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"怪物列表初始化 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:8:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"HOOK明文包 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:9:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"还原HOOK明文包 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:10:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"HOOK明文包子程序 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:11:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"获取窗口句柄 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:12:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"内联汇编 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:13:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"遍历周围信息 点击控件 ","date":"2021-10-16","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/:14:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞C++","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9Ec-/"},{"categories":null,"content":"上一篇帖子中我们对技能等级进行了分析，接下来我们对技能名字库进行分析，进而获得完整的技能遍历。既然分析名字库，自然要从名字入手了，我们任意选择一个技能，用对其名字进行扫描，可以得到若干ASCII型的结果 这里注意的是如果名字后面带有后缀的结果比较多的话，可以转化成字节集，并加上结束标志00再扫描。分别对这些名字进行修改，同时切换技能栏，找到一个可以改变技能名字本地显示的地址。在xdbg32中对这个地址下硬件访问断点。 向上分析esi的来源，经过多层参数的传递，得到来源于一个[ebp-68]的局部变量 继续分析局部变量的来源，发现在上面出现了2个[ebp-68]，第一个是传入0，第二个是作为ecx指针传入到了CALL中 而第二个位置F2不会断，说明这个位置代码没有经过，那么来源就只能在传入0下面的CALL中了。在024B4BD处call 0x5A0CB0上下F2断点，单独到内部分析来源。这里得到了一个+C偏移，继续分析在上面又得到了一个-C偏移，而这个两个位置都是lea指令，所以只得到了+0偏移。 执行到返回后继续分析第一个参数eax，得到+8偏移，以及来源局部变量[ ebp-14]。代码再次向上滚动很久，可以得出局部变量[ebp-14]来源于eax eax来源一个数组，数组起始地址eax来源于[esi+8]。我们切换不同种类的技能栏并对esi+8处下F2断点，发现esi是随着技能种类变化的，也就是说这个数组只是某个种类技能的数组，在上面还有一个技能种类的结构。 我们先将这里得到的数据进行分析和整理，如下 [技能种类+8]-4 技能数组元素数量 [[技能种类+8]+n8+4]+4 技能ID [[[技能种类+8]+n*8+4]+8]+0 技能名字ASCII 上面这个分析的过程除了有一点绕，并没有很难的知识点，不过这里能不能观察到esi的变化规律是一个关键，因为技能名字库还有需要对技能进行分类的游戏的确很少。在下一篇文章里我们将去分析技能种类的加密算法，并获取到完整的技能库。玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-13","objectID":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E6%8A%80%E8%83%BD%E5%BA%93/:0:0","series":null,"tags":["飞郁精品帖"],"title":"《冒险岛》技能分析之技能库","uri":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E6%8A%80%E8%83%BD%E5%BA%93/"},{"categories":null,"content":"一、步骤1. exe → pyc方法1：pyinstxtractor.py 执行python pyinstxtractor.py \u003c待解包文件名\u003e ，如果成功，即可获得\u003c待解包文件名\u003e_extracted 文件夹。 注：执行时会提示python版本问题，想要正常解包必须使用正确的python版本。 方法2：archive_viewer.py 执行python archive_viewer.py \u003c待解包文件名\u003e ，会打印EXE文件中包含的所有文件信息 使用x \u003c文件名\u003e命令将想要提取出的文件提取出来，q 命令退出。 两者的区别 方法1可以一次性提取出所有文件，方法2只能逐个提取文件。但是在个人使用时，方法2的成功率相对较高。可以先尝试用方法1，失败后用方法2。 2. pyc → py 步骤1获得的文件是pyc文件，还需要进一步反编译获得py文件。 注：我遇到过直接获得py文件的情况，所以在反编译之前可以先查看一下是不是已经成功了。 2.1 pyc文件恢复 注：最新版pyinstxtractor.py支持自动恢复pyc，但是经实验不能保证准确性。或者说需要使用准确的python版本才行。 在将python文件打包成exe文件的过程中，会抹去pyc文件前面的部分信息，所以在反编译之前需要检查并添加上这部分信息。 抹去的信息内容可以从struct文件中获取： struct文件： pyc文件： Q1：需要添加多少字节？ 多个参考文章中提到的添加字节数都不一致，这应该与使用的python版本有关。但是在已知的几个例子中，可以看出pyc文件开头的几个字节与struct文件中的字节是一样的。比如说上图中pyc文件是以E3 00 00 00开头，而这部分字节就和struct文件的第二行起始字节相同。 因此在此例中，需要复制添加的字节就是struct文件中第一行的16个字节 Q2：添加的方法是什么？ 在010editor中，选择Edit→Insert/Overwrite→InsertBytes，Start Address填0，Size填16。 然后将字节复制进去即可。 2.2 反编译 反编译工具 Easy Python Decompiler 这是一个GUI界面的可执行文件，下载下来直接用就可以，但是并不是每次都能成功，有些magic value不能识别。 uncompyle6 该工具需要使用pip安装，使用脚本执行。成功率较高。 反编译提示magic value有问题怎么办？ 在上面我们添加的16个字节中，前四个字节表示的就是magic value，其中前两个字节表示的是python的版本号，一般来说magic value的问题就是版本号有问题，编译工具没有识别出来该版本号表示的python版本。 如果使用的是Easy Python Decompiler，那么就可以直接转用uncompyle6了。 如果用的已经是uncompyle6，那么需要先看一下它可以识别的版本号都有哪些，这个信息可以在xdis包的magics.py文件中找到，具体方法如下： 命令行输入pip install xdis，查看其安装位置到该目录下，打开xdis文件夹下的magics.py文件 确定需要识别的版本号，就是之前添加的16个字节的前两个字节，此例中为0D42，需要转换为十进制，就是3394。查看magics.py中是否有该版本号。我这里一开始没有发现这个版本号 我的解决方法 我在谷歌上搜索了int2magic(3394)，找到了这个Github项目。 下载下来，按照介绍进行安装。 在执行pip install -e .的时候，提示我xdis和uncompyle6的版本不匹配，于是卸载了uncompyle6，又重新安装了一次。 目前的版本：xdis 5.0.5 uncompyle6 3.7.4 查看该版本xdis的magics.py文件： 可以看到已经有3394了。 反编译： 成功！ 注：pyc文件一定要有后缀名pyc，不然会报错 二、PYZ文件的加密问题 有些时候在步骤1 exe→pyc的过程中，会出现PYZ中的文件无法正常提取（archive_viewer.py），或者提取出来后显示encrypted（pyinstxtractor.py）的问题。 这个问题可以使用参考文章2和3中的方法解决： PYZ文件加密的密钥保存在pyimod00_crypto_key文件中，该文件也是一个pyc文件，可以使用上面介绍的方法进行反编译，然后就可以获得密钥： 之后的解密脚本有三个可供选择，均在参考文章3中，根据pyinstaller的版本不同选择不同的脚本，使用时需要替换其中的key、header以及待解密文件名和目标文件名，执行后即可获得解密后的pyc文件，再使用uncompyle6反编译即可。 注：这三个脚本中，第一个脚本适用于PyInstaller\u003c4.0，使用python2执行；第二个和第三个脚本适用于PyInstaller≥4.0，使用python3执行。 ","date":"2021-10-13","objectID":"/2021/10/%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97python-exe%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【安全系列】python exe文件解包方法总结","uri":"/2021/10/%E5%AE%89%E5%85%A8%E7%B3%BB%E5%88%97python-exe%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8C%85%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"共享内存指 (shared memory)在多处理器的计算机系统中，可以被不同中央处理器(CPU)访问的大容量内存。由于多个CPU需要快速访问存储器，这样就要对存储器进行缓存(Cache)。任何一个缓存的数据被更新后，由于其他处理器也可能要存取，共享内存就需要立即更新，否则不同的处理器可能用到不同的数据。共享内存是 Unix下的多进程之间的通信方法 ,这种方法通常用于一个程序的多进程间通信，实际上多个程序间也可以通过共享内存来传递信息。 ​ 百科的回答比较官方，那么实际运用中，共享内存可以用来做什么？ 详细举个例子： 某游戏助手（如TGP/wagame），读取英雄名称或者类型，推荐最佳出装/技能方案，在单开游戏的情况下，自然用不到共享内存，而往往单开满足不了玩家需求。如大多数DNF玩家都是通过wagame或者其他助手进行双开同步刷图，这个时候想要给两个客户端同时下达相同的指令，即可用共享内存实现。 流程如下（设想）： wagame 申请共享内存 客户端1消息循环读取共享内存中的指令 客户端2消息循环读取共享内存中的指令 同步按键指令。 这个时候，如果关闭申请共享内存的程序（wagame平台），那么客户端1和2都将无法访问这一块内存区域。 以易语言为例子： 先以申请并写入内存为例： 1、CreateFileMapping申请一个文件映射内核对象，返回值为映射对象的句柄。 2、MapViewOfFile 将文件映射对象映射到当前应用程序的地址空间，返回值为内存区域指针。 3、将要写入的数据转化为字节集的形式，并且取得字节集长度。 4、在内存区域指针+4的位置开始写入指定的数据。 5、UnmapViewOfFile停止当前程序的内存映射。 CreateFileMapping函数原型 MapViewOfFile函数原型 UnmapViewOfFile函数 易代码如下图： 完成了写入内存数据代码后，还要实现读取写入数据的代码，那么应该如何实现读取共享内存中的数据？ 1、OpenFileMapping 通过内存名称打开共享内存。 2、同上，MapViewOfFile 将文件映射对象映射到当前应用程序的地址空间，返回值为内存区域指针。 3、将MapViewOfFile所返回的内存区域指针转换为字节集，用到易语言函数——指针到字节集。 4、取得该内存区域的字节集长度，并在区域指针+4的位置开始读取。 5、UnmapViewOfFile停止当前程序的内存映射。 OpenFileMapping函数原型 代码如下图: 以字节集的形式读出了共享内存中的内存数据，就可以给他转换为各种数据类型，文件，或者图片应用程序等等。 转换数据类型如下图： 实际运用效果图如下： 程序1写入内存数据 程序2、3、4、5读取。 ","date":"2021-10-13","objectID":"/2021/10/%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%86%99%E6%B3%95/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【代码系列】共享内存的应用与写法","uri":"/2021/10/%E4%BB%A3%E7%A0%81%E7%B3%BB%E5%88%97%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%8E%E5%86%99%E6%B3%95/"},{"categories":null,"content":"首先对角色名字进行搜索，得到3个结果，分别改变3个结果后，切换角色栏，发现角色名字变为了第三个地址的名字**（如图）** 通过OD对这个地址下访问断点，游戏断下**（如图）** 通过堆栈得处0x0A15D6E处函数的第二个参数是我们要的地址，跳到返回处向上分析，得到两个+4偏移**（如图）** 继续向上分析，得到1CC偏移和一个数组**（如图）** 在这里下断，发现ebx不变，不过切换不同的角色栏，edx会发生变化，也就是说edx决定数组是一般角色栏还是商城角色栏。 而对上面的算法进行分析，可以得到结构体数组的结构大小为0x80，继续向上分析ebx的来源，得到+0、+4和+10偏移**（如图）** 不过在这里下断，发现ecx的值和我们之前得到ecx是不同的，也就是说在函数call eax中可能还有其他偏移被我们漏掉了。在eax处下断，进入内部分析，得到+8偏移**（如图）** 继续分析0xD3DB04处的esi，发现esi来源本层函数中的二叉树，而二叉树 中只有一个节点**（如图）** 继续分析，我们又可以得到很多个二叉树的嵌套，并最终跳到了控件相关的遍历循环中。也就是说我们要分析的角色列表是挂在控件下的，所以只要得到了控件遍历就可以通过上面得到的公式对角色列表进行遍历了。 ","date":"2021-10-13","objectID":"/2021/10/%E5%B9%BB%E6%83%B3%E7%A5%9E%E5%9F%9F%E4%BA%BA%E7%89%A9%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【幻想神域】人物属性分析","uri":"/2021/10/%E5%B9%BB%E6%83%B3%E7%A5%9E%E5%9F%9F%E4%BA%BA%E7%89%A9%E5%B1%9E%E6%80%A7%E5%88%86%E6%9E%90/"},{"categories":null,"content":"随着游戏代码的发展，新游戏的技能越来越华丽，分类也越来越多，数据结构用的五花八门。而老游戏也不甘寂寞，技能数据也处理的有模有样，分析起来也颇有难度。以下面这款游戏为例，我们从逆向安全的角度来学习一下它的技能体系数据结构。 这款游戏的技能体系我们大致分为三个部分去分析，分别为技能等级结构，技能库结构，剩余级技能点数结构。下面先分析最简单的技能等级结构。 技能的分析可以从技能ID，技能等级，技能名字三个角度入手分析，而如果技能等级可以使用的话自然是最方便的一种，起码扫描起来很简单。而这款游戏恰好就可以通过技能加点来入手。 首先我们呢用CE来任意扫描一个高级魔法的等级，最终可以得到一个结果 在xdbg32中对这个地址下硬件访问断点，游戏直接断下，并得到一个+C偏移 向上分析可以看到一个跳转跳过ret，执行到+C偏移处，而上面可以得到一个循环+4的链表结构 图中可以看出这个链表最初的来源是上面的一个数组，当数组指向地址+8的位置与传入的esi相等时会跳出链表，或者当链表节点eax等于0时结束链表循环。 我们先到上面分析出数组的起始地址和范围，然后再获取下标的信息。 在上面不远处可以看到起始地址为[ecx+4]，而外面传入的第一个参数在循环右移5之后与[ecx+8]进行模运算，可以获取到下标edx 经观察可以得出这个这个[ecx+8]恰好是数组中总的元素数量。 由于数组中元素较少，而链表中的节点也不多，可以判断这个数组下标其实可以不去管他，只要我们得到技能库与之关联就可以得到所有的技能信息。 接下来我们继续去分析数组起始地址ecx的来源，在执行到返回后可以得到一个+0DCE偏移 向上分析得到来来源于[ebp+8]，执行到返回继续分析第一个参数，可以得到来源[eax+4] 然而这个+4并不是偏移，因为eax是一个堆栈地址，[eax+4]是一个局部变脸，并且在上面的CALL 0x2D50780中被赋值。我们到这个CALL中可以很快找到来源，并得到一个+22EC的偏移 退出这个CALL并再次下断执行到返回，可以很快得到基地址 这个数据结构总体来说是很简单的，只是中间的局部变量作为参数到CALL的赋值的操作对逆向新手有一些难度，如果对堆栈比较熟悉的话可以轻松搞定，从安全角度来讲，这里可以做的更加复杂一些。 公式就不整理了，我们接下来将要分析较为复杂的技能库结构。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-13","objectID":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E7%AD%89%E7%BA%A7%E9%81%8D%E5%8E%86%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【冒险岛】技能等级遍历分析","uri":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E7%AD%89%E7%BA%A7%E9%81%8D%E5%8E%86%E5%88%86%E6%9E%90/"},{"categories":null,"content":"PE结构图: 在游戏外挂和反外挂的对抗中 驱动有其重要的作用 但是随着Windows 系统的升级 很多东西出现了局限性，不过我们还是需要了解学习一下 其最基础的知识 创建驱动设备对象的符号链接 //环境设置: //属性页-\u003eC / C++-\u003e警告等级 : 等级3 / W3 //属性页-\u003eC / C++-\u003e将警告视为错误 : 否 / WX - //属性页-\u003eInf2Cat-\u003eRun Inf2Cat : 否 //属性页-\u003eDriver Settings-\u003eTarget Os Version : 设置版本 Windows 7 Windows 10任选 //属性页-\u003eDriver Settings-\u003eTarget PlatForm : Desktop //属性页-\u003eStampInf-\u003eEndable ArchiteCture : 否 //KdPrint类似于 控制台的printf //DriverEntry类似于 C / C++里的main #include \u003cntifs.h\u003e #pragma code_seg(\"PAGE\") //创建驱动设备对象 NTSTATUS CreateDevice(PDRIVER_OBJECT driver) { NTSTATUS status; UNICODE_STRING uzDriverName; PDEVICE_OBJECT device; RtlInitUnicodeString(\u0026uzDriverName, L\"\\\\DEVICE\\\\uzDriverName001\"); //创建驱动设备 status = IoCreateDevice(driver, sizeof(driver-\u003eDriverExtension), \u0026uzDriverName, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, \u0026device); if (status == STATUS_SUCCESS) { KdPrint((\"yjx:驱动设备对象 %wZ 创建成功，OK -----------\\n\", \u0026uzDriverName)); //为设备对象绑定一个符号链接 UNICODE_STRING uzSymbolName; //符号链接名字 RtlInitUnicodeString(\u0026uzSymbolName, L\"\\\\??\\\\uzDriverName001\"); //CreateFile status = IoCreateSymbolicLink(\u0026uzSymbolName, \u0026uzDriverName); if (status==STATUS_SUCCESS) { KdPrint((\"yjx:创建符号链接 %wZ 成功 \", \u0026uzSymbolName)); } else { KdPrint((\"yjx:创建符号链接 %wZ 失败 \", \u0026uzSymbolName)); } } else { KdPrint((\"yjx:驱动设备对象 %wZ 创建失败，准备删除Device -----------\\n\", \u0026uzDriverName)); IoDeleteDevice(device); } return status; } //驱动卸载例程 void UnLoad(PDRIVER_OBJECT driver) { NTSTATUS status = 0; IoDeleteDevice(driver-\u003eDeviceObject); //删除设备对象,如果此处不删除 卸载不干净 再次用IoCreateDevice创建同名驱动 会蓝屏 //删除符号链接 UNICODE_STRING uzSymbolName; //符号链接名字 RtlInitUnicodeString(\u0026uzSymbolName, L\"\\\\??\\\\uzDriverName001\"); status=IoDeleteSymbolicLink(\u0026uzSymbolName); if (!status) //if(status == STATUS_SUCCESS) { KdPrint((\"yjx:删除符号链接 %wZ 成功 \",\u0026uzSymbolName)); } else { KdPrint((\"yjx:删除符号链接 %wZ 失败 \", \u0026uzSymbolName)); } KdPrint((\"yjx:驱动卸载成功\\n\")); } NTSTATUS DriverEntry(PDRIVER_OBJECT driver,PVOID szReg) //main { KdPrint((\"yjx:进入了我们的驱动 \\n\")); //printf driver-\u003eDriverUnload = UnLoad; NTSTATUS status=CreateDevice(driver);//创建了设备对象 return STATUS_SUCCESS; } IRP 派遣函数 driver-\u003eMajorFunction[IRP_MJ_DEVICE_CONTROL] = DeviceIrpCtl;//DeviceIoControl driver-\u003eMajorFunction[IRP_MJ_CREATE] = DeviceIrpCtl; //CreateFile driver-\u003eMajorFunction[IRP_MJ_CLOSE] = DeviceIrpCtl;//卸载驱动 CloseHandle NTSTATUS DeviceIrpCtl(PDEVICE_OBJECT device,PIRP pirp) { KdPrint((\"yjx:进入派遣函数\")); PIO_STACK_LOCATION irpStackL; ULONG CtlCode; ULONG InputBuffLength; irpStackL=IoGetCurrentIrpStackLocation(pirp); //获取应用层传来的参数 switch(irpStackL-\u003eMajorFunction) { IRP_MJ_DEVICE_CONTROL; IRP_MJ_CREATE; IRP_MJ_CLOSE; } pirp-\u003eIoStatus.Status = STATUS_SUCCESS; pirp-\u003eIoStatus.Information = 4;//返回给DeviceIoControl中的 倒数第二个参数lpBytesReturned IoCompleteRequest(pirp, IO_NO_INCREMENT);//调用方已完成所有I/O请求处理操作 并且不增加优先级 KdPrint((\"yjx:离开派遣函数\")); return STATUS_SUCCESS; } //打开驱动设备 void CIoControlIrpDlg::OnBnClickedCreate() { // TODO: 在此添加控件通知处理程序代码 DeviceHandle = CreateFileW( L\"\\\\??\\\\uzDriverName001\", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); } void CIoControlIrpDlg::OnBnClickedButtonClose() { // TODO: 在此添加控件通知处理程序代码 if (DeviceHandle) { CloseHandle(DeviceHandle); DeviceHandle = NULL; } } R3应用层与R0驱动层简单通信 #define IO_IS_OK_TEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x803, METHOD_BUFFERED,FILE_ANY_ACCESS) //测试 //WriteFile ReadFile BOOL DeviceIoControl( HANDLE hDevice, // 设备驱动的句柄 由CreateFile获取 DWORD dwIoControlCode, // 操作控制码 LPVOID lpInBuffer, // 输入缓冲区指针 要传入驱动的 参数 DWORD nInBufferSize, // 输入缓冲区大小 LPVOID lpOutBuffer, // 输出缓冲区指针 DWORD nOutBufferSize, // 输出缓冲区大小 LPDWORD lpBytesReturned, // 存放返回的字节数的指针 LPOVERLAPPED lpOverlapped // 异步结构指针,同步或者异步 ); BOOL WINAPI IoControlIsOK() { DWORD nTypeCode = IO_IS_OK_TEST; ULONG64 BufferInData = 0;; DWORD NumberOfBytesRead = 0; BOOL IsOK = DeviceIoControl( GetDeviceHandle(), //CreateFile函数打开的设备句柄 nTypeCode,//自定义的控制码 \u0026BufferInData,//输入缓冲区 sizeof(BufferInData),//输入缓冲区大小 \u0026BufferInData,////输出缓冲区 sizeof(BufferInData),//输出缓冲区的大小 \u0026NumberOfByte","date":"2021-10-13","objectID":"/2021/10/%E9%A9%B1%E5%8A%A8%E7%B3%BB%E5%88%97%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84x64%E9%A9%B1%E5%8A%A8/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【驱动系列】最简单的X64驱动","uri":"/2021/10/%E9%A9%B1%E5%8A%A8%E7%B3%BB%E5%88%97%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84x64%E9%A9%B1%E5%8A%A8/"},{"categories":null,"content":"大部分内购破解都是通过反编译软件对smali中的代码进行修改，首先通过android killer对apk进行分析，并通过模拟器对游戏进行安装。 打开游戏后对随便对一个项目进行内购，这时游戏中会显示“水晶石不足” 于是我们在工程搜索中搜索这个字符串的unicode编码，得到一个结果**（如图）** file:///C:\\Users\\AKM\\AppData\\Local\\Temp\\ksohtml4100\\wps1.jpg 跳转到smali内部，对函数代码进行分析，我们发现这个字符串上面有支付失败相关的代码**（如图）** file:///C:\\Users\\AKM\\AppData\\Local\\Temp\\ksohtml4100\\wps2.jpg 而在周围分析，可以发现这个函数有两个分支，通过一个if-ltz跳转分为两个部分，如果跳转实现，则跳到失败代码，否则直接执行成功代码**（如图）** file:///C:\\Users\\AKM\\AppData\\Local\\Temp\\ksohtml4100\\wps3.jpg 在跳转上添加一条const/4 v0, 0x1，即可让跳转不实现**（如图）** file:///C:\\Users\\AKM\\AppData\\Local\\Temp\\ksohtml4100\\wps4.jpg 保存并重编译，后安装游戏，再次内购，发现直接支付成功**（如图）** file:///C:\\Users\\AKM\\AppData\\Local\\Temp\\ksohtml4100\\wps5.jpg 不过这个内购只是可以免费支付水晶，而不是购买水晶，这也说明内购的方法也不是固定不变的，灵活的去运用内购中反馈的信息，可以让破解变的更加简单。 ","date":"2021-10-13","objectID":"/2021/10/%E6%89%8B%E6%B8%B8%E7%B3%BB%E5%88%97%E6%9A%B4%E8%B5%B0%E9%9B%B7%E9%BE%99%E6%88%98%E6%9C%BA%E5%86%85%E8%B4%AD%E7%A0%B4%E8%A7%A3%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"【手游系列】《暴走雷龙战机》内购破解分析","uri":"/2021/10/%E6%89%8B%E6%B8%B8%E7%B3%BB%E5%88%97%E6%9A%B4%E8%B5%B0%E9%9B%B7%E9%BE%99%E6%88%98%E6%9C%BA%E5%86%85%E8%B4%AD%E7%A0%B4%E8%A7%A3%E5%88%86%E6%9E%90/"},{"categories":null,"content":"随着游戏行业的发展，x32位的程序已经很难满足一些新兴游戏的需求了，因为32位内存的最大值为0xFFFFFFFF，这个值看似足够，但是当游戏对资源需求非常大，那么真正可以分配的内存就显得捉襟见肘了，于是很多公司尝试并成功的开发了64位的游戏。并且很多32位的游戏也在向64位转型。 很多初学者在刚刚接触64位程序时会觉得很陌生，想象着这是一个新的领域，会比32位的分析难度高很多。其实当你对32位的逆向有一定的基础和理解的时候，再来看64位就不那么难了。 64位与32位最直观的区别就是他可分配的内存最大值是0xFFFFFFFFFFFFFFFF。有人可能会说这也就比32位的多了一倍，其实不然，他的大小是32位的0x100000000倍。这个大小就足够我们去使用了，甚至当你在分析64位的游戏时会发现，很多地址也仅仅是1XXXXXXXX，因为目前来说这些也就足够了。 64位与32位逆向的第二个区别就是他的寄存器，他的寄存器为16个而不是8个（如图） 在这16个寄存器中，前面8个的名字与32位的很像，只是前面的E改为了R。后面的8个则以R8-R15命名。当然我们所说的这16个是通用寄存器，而后面还有16个浮点数使用的XMM寄存器（如图） 在初学者的学习中，我们主要来学习通用寄存器的使用。 RAX与EAX的作用是类似的，他主要用来存放函数的返回值，他的数值也是经常会变化的（如图） 图中是一个随意截取的一断64位函数代码，函数后面的RAX传递给RDI，其实就是将返回值进行传递，这里了解一下即可，后面还会详细讲解。 RCX，RDX，R8，R9则常常会做为第1-4个参数（如图） 图中是一个游戏调用send函数的代码，RCX-R9分别为函数的s，buf，len，flags，当然如果还有其他的参数的话则会存放在RSP+20中，这些在后面讲函数的时候会详细讲解。 RSP和32位中的ESP是类似的，同样作为堆栈指针（如图） RBP虽然偶尔会用来作为帧指针，也就是所谓的栈底，但是显然没有32位用的频繁，下图则是RBP在函数头部被赋值的情况（如图） 当然RBP也常常会被用作普通的寄存器去进行传址。 R10和R11在syscall/sysret 指令中会被使用，暂时只需要了解一下即可。 而这些寄存器中，除了RAX，RCX,RDX,R8,R9,RSP之外的寄存器，如果在函数过程中被调用，则必须在调用前对其数值进行保留（如图）（如图） 以上就是64为内存和通用寄存器的一些基础知识，深入的内容会在后面的文章和视频中进行讲解。 ","date":"2021-10-13","objectID":"/2021/10/64%E4%BD%8D%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/:0:0","series":null,"tags":["飞郁精品帖"],"title":"64位内存与通用寄存器","uri":"/2021/10/64%E4%BD%8D%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"},{"categories":null,"content":"pc hunter graph z1([PCHunter]) z2[\"System进程中\u003cbr\u003e有红色等待的都\u003cbr\u003e结束线程\"] z3[\"找到游戏进程\u003cbr\u003e右键查看进程线程\u003cbr\u003e找到ntdll.dll\u003cbr\u003e其中入口以233B结尾的结束线程\u003cbr\u003e其它的都暂停线程运行\"] z4([\"OD可以正常附加了\"]) z5([\"如果OD里找不到游戏进程\u003cbr\u003e可能是隐藏了\"]) z6[PCHunter] z7[内核勾子] z8[右键恢复所有] z1--\u003ez2--\u003ez3--\u003ez4 z5--\u003ez6--\u003ez7--\u003ez8--\u003ez4 ","date":"2021-10-13","objectID":"/2021/10/win7%E8%BF%87tp/:1:0","series":null,"tags":["任鸟飞","过TP","过检测"],"title":"win7过TP","uri":"/2021/10/win7%E8%BF%87tp/"},{"categories":null,"content":"InHook.h #pragma once #ifdef _WIN64 typedef unsigned __int64 SELF_PTR; #else typedef unsigned int SELF_PTR; #endif #if _WIN64 constexpr int byte_length = 9; #else constexpr int byte_length = 5; #endif // 0 class InHook { public: void Initalize(SELF_PTR oldAddr, SELF_PTR myAddr); static InHook* GetInitalize(); // 修改地址 void motifyAddress(); // 恢复地址 void restoreAddress(); using uchar = unsigned char; uchar m_oldByte[byte_length]; uchar m_myByte[byte_length]; SELF_PTR m_oldFuncAddr; SELF_PTR m_myFuncAddr; private: static InHook* m_pInstance; }; InHook.cpp #include \"pch.h\" #include \"InHook.h\" InHook* InHook::m_pInstance = NULL; InHook* InHook::GetInitalize() { if (m_pInstance == NULL) { m_pInstance = new InHook; } return m_pInstance; } //修改地址页面属性，返回原地址属性 DWORD motifyMemoryAttributes(SELF_PTR myAddr, SELF_PTR attributes = PAGE_EXECUTE_READWRITE) { DWORD oldAttributes; VirtualProtect((void*)myAddr, byte_length, attributes, \u0026oldAttributes); return oldAttributes; } void InHook::Initalize(SELF_PTR oldAddr, SELF_PTR myAddr) { memcpy(\u0026oldAddr, \u0026m_oldFuncAddr, sizeof(oldAddr)); memcpy(\u0026myAddr, \u0026m_myFuncAddr, sizeof(myAddr)); m_myByte[0] = { 0xe9 }; int offset = m_myFuncAddr - m_oldFuncAddr - byte_length; memcpy(\u0026m_myByte[1], \u0026offset, byte_length - 1); DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy(m_oldByte, (void*)m_oldFuncAddr, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } // 修改地址 void InHook::motifyAddress() { DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy((void*)m_oldFuncAddr, m_myByte, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } // 恢复地址 void InHook::restoreAddress() { DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy((void*)m_oldFuncAddr, m_oldByte, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } 调用示例： main.cpp #include \u003cWindows.h\u003e #include \"InHook.h\" InHook::GetInitalize()-\u003eInitalize(d3d9Device_table[42],(SELF_PTR)hkEndScene); InHook::GetInitalize()-\u003emotifyAddress(); InHook::GetInitalize()-\u003erestoreAddress(); ","date":"2021-10-13","objectID":"/2021/10/x86-%E5%92%8C-x64-%E5%85%B1%E7%94%A8hook%E7%B1%BB/:0:0","series":null,"tags":["飞郁精品帖"],"title":"x86 和 x64 共用HOOK类","uri":"/2021/10/x86-%E5%92%8C-x64-%E5%85%B1%E7%94%A8hook%E7%B1%BB/"},{"categories":null,"content":"随着游戏代码的发展，新游戏的技能越来越华丽，分类也越来越多，数据结构用的五花八门。而老游戏也不甘寂寞，技能数据也处理的有模有样，分析起来也颇有难度。以下面这款游戏为例，我们从逆向安全的角度来学习一下它的技能体系数据结构。 这款游戏的技能体系我们大致分为三个部分去分析，分别为技能等级结构，技能库结构，剩余级技能点数结构。下面先分析最简单的技能等级结构。 技能的分析可以从技能ID，技能等级，技能名字三个角度入手分析，而如果技能等级可以使用的话自然是最方便的一种，起码扫描起来很简单。而这款游戏恰好就可以通过技能加点来入手。 首先我们呢用CE来任意扫描一个高级魔法的等级，最终可以得到一个结果 在xdbg32中对这个地址下硬件访问断点，游戏直接断下，并得到一个+C偏移 向上分析可以看到一个跳转跳过ret，执行到+C偏移处，而上面可以得到一个循环+4的链表结构 图中可以看出这个链表最初的来源是上面的一个数组，当数组指向地址+8的位置与传入的esi相等时会跳出链表，或者当链表节点eax等于0时结束链表循环。 我们先到上面分析出数组的起始地址和范围，然后再获取下标的信息。 在上面不远处可以看到起始地址为[ecx+4]，而外面传入的第一个参数在循环右移5之后与[ecx+8]进行模运算，可以获取到下标edx 经观察可以得出这个这个[ecx+8]恰好是数组中总的元素数量。 由于数组中元素较少，而链表中的节点也不多，可以判断这个数组下标其实可以不去管他，只要我们得到技能库与之关联就可以得到所有的技能信息。 接下来我们继续去分析数组起始地址ecx的来源，在执行到返回后可以得到一个+0DCE偏移 向上分析得到来来源于[ebp+8]，执行到返回继续分析第一个参数，可以得到来源[eax+4] 然而这个+4并不是偏移，因为eax是一个堆栈地址，[eax+4]是一个局部变脸，并且在上面的CALL 0x2D50780中被赋值。我们到这个CALL中可以很快找到来源，并得到一个+22EC的偏移 退出这个CALL并再次下断执行到返回，可以很快得到基地址 这个数据结构总体来说是很简单的，只是中间的局部变量作为参数到CALL的赋值的操作对逆向新手有一些难度，如果对堆栈比较熟悉的话可以轻松搞定，从安全角度来讲，这里可以做的更加复杂一些。 公式就不整理了，我们接下来将要分析较为复杂的技能库结构。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-13","objectID":"/2021/10/%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"技能点数结构（冒险岛技能分析）","uri":"/2021/10/%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"DbgPlugin 调试保护 x64dbg官网 x64dbg官方插件 解压密码 123 666 www.feiyuol.com ","date":"2021-10-13","objectID":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E5%B7%A5%E5%85%B7/:0:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞工具","uri":"/2021/10/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"今天我们来分析一下\u003c传奇永恒\u003e的释放技能CALL, 调用技能CALL可以实现全自动循环打怪功能. 首先, 定位到明文包头部 在明文包头部下断, 再按快捷键, 释放技能打怪 按Ctrl+F9, 再按F8, 返回到第1层, 这个CALL看上去有点乱, 参数不明显, 再返回一层看看. 返回到第2层, 这个CALL看起来就明朗的多了, 参数明显, 就是它了! 在CALL上下断, 分析一下参数. 经过分析, 参数1, Rcx, 来源于上面的CALL, 直接是一个\u003c基地址\u003e. 参数2, Edx, 可能是\u003c怪物ID\u003e 参数3, r8d, 值并不是很大, 很有可能是\u003c技能ID\u003e 参数4, r9d, 是一个更小的值, 也许是\u003c技能等级\u003e 参数5, eax, 是一个结构体, DD之后发现是一个\u003c坐标结构体\u003e, 并且不是人物坐标, 那就一定是怪物的坐标了. 参数6, 经过多次下断尝试, 是个\u003c固定值, 1\u003e 参数7, 直接就是一个基地址, 并且每次释放技能, 都会+1, 所以这是一个\u003c计数器\u003e 现在释放技能CALL已经分析完毕, 参数明确, 下面是循环调用释放技能CALL的效果图. ","date":"2021-10-12","objectID":"/2021/10/x64%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E4%B9%8B%E9%87%8A%E6%94%BE%E6%8A%80%E8%83%BDcall/:0:0","series":null,"tags":["飞郁精品帖"],"title":"x64\u003c传奇永恒\u003e之释放技能CALL","uri":"/2021/10/x64%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E4%B9%8B%E9%87%8A%E6%94%BE%E6%8A%80%E8%83%BDcall/"},{"categories":null,"content":"明文发包CALL是分析一款游戏功能的主要突破口，但是很多游戏都是线程发包，需要跳出线程才能得到明文CALL的位置。以往的条线程方式都是在包内容或者内容来源上下写入断点，一次或者多次写入就可以跳出线程，但是韩服的剑灵2又有了一些不一样的地方，很多人也会在这里止步不前。下面我们就利用几种不同的方式跳出这个游戏的发包线程。 前面的方法都是固定不变的，首先我们用xdbg64找到其发包函数WSASend 由于这里每次断的包内容地址是变化的，所以我们要取追一下来源，执行到返回后来到函数调用处 这里的包内容来源于rax+[rdi+18]，而下断之后我们可以发现rax始终都0，所以我们继续向上追rdi，可以得到来源于CALL的返回值。在CALL上下断，并单步到内部，可以得到一个数组，这发包方式和传奇永恒的特别像 这里的RCX是不变的，所以我们可以直接配出包内容的公式为[rcx+18]+([rcx]\u0026FFFFFFFF)*8填入rcx的值,在数据窗口中跟随,并在下面不远处选择一个地址,提前下好写入断点,不断的走路发包,等待游戏断下 我们发现写入的这个位置还是在原来那个函数内部,也就是说我们还是没有跳出线程 那么我们要继续向上追rbp的来源，在执行到返回后得到了[r14+rax] 在这里下断后发现r14始终是0，而rax是不变的，于是我们在rax上下写入断点，走路后游戏断下 现在这个位置就是很多人都会遇到的难点，继续向上追可以得到一个数组，而这数组的下标是随机获取的，想从这个里入手很麻烦 既然这里不好下写入断，那我们只要整体函数的执行流程做一个分析。在上面我们发现了一个位置断的特备频繁，发包的执行流程中会掺杂大量的假包，并跳到函数尾部，不执行发包代码。而这个位置的上面会有一个判断，用来分辨当前执行的代码是否是真的发包代码。 所以我们分别取追一下r14d和eax的来源，并最终得到了两处赋值的位置 我们在下面的数组上下断，获取到真正发包时的rbp的值，并对+40和+88进行下断观察，可以发现+88是决定代码流程的关键，因为有的时候+40不变，而+88会改变，此时恰好会让二者不相等，实现真的发包。 于是我们在这个+88偏移上下写入断点，尝试跳出线程。在游戏内下断断的狠频繁，我们很难做出写入的动作。所以我们要来带创建角色界面下断，在这里可以很轻松的断下，并来到跳出线程的代码里 这是我们的第一种跳出方式，而第二种方式比较简单，我们可以用CE对这个地址下写入断点，然后挨个尝试，其中会有一个写入会在线程外 第三种方式有一些玄学，就是在模块内扫描比较函数中的基地址，虽然扫描到的基地址有很多，不过在前面的几个里面就会有一个在线程外，跳过去下断可以返回到功能CALL。当然这种方式虽然有一定的道理，但也是在我们走投无路的情况下才去尝试的。 以上就是跳出剑灵2线程的几种方法，如果大家有更多的方法，也可以联系我，大家一起学习交流下。玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-12","objectID":"/2021/10/%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9F%A9%E6%9C%8D%E5%89%91%E7%81%B52/:0:0","series":null,"tags":["飞郁精品帖"],"title":"跳出线程发包的几种方式（韩服剑灵2）","uri":"/2021/10/%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9F%A9%E6%9C%8D%E5%89%91%E7%81%B52/"},{"categories":["辅助"],"content":"ASCII控制字符 二进制 十进制 十六进制 缩写 名称/意义 0000 0000 0 00 NUL 空字符（Null） 0000 0001 1 01 SOH 标题开始 0000 0010 2 02 STX 本文开始 0000 0011 3 03 ETX 本文结束 0000 0100 4 04 EOT 传输结束 0000 0101 5 05 ENQ 请求 0000 0110 6 06 ACK 确认回应 0000 0111 7 07 BEL 响铃 0000 1000 8 08 BS 退格 0000 1001 9 09 HT 水平定位符号 0000 1010 10 0A LF 换行键 0000 1011 11 0B VT 垂直定位符号 0000 1100 12 0C FF 换页键 0000 1101 13 0D CR 归位键 0000 1110 14 0E SO 取消变换（Shift out） 0000 1111 15 0F SI 启用变换（Shift in） 0001 0000 16 10 DLE 跳出数据通讯 0001 0001 17 11 DC1 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 设备控制二 0001 0011 19 13 DC3 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 设备控制四 0001 0101 21 15 NAK 确认失败回应 0001 0110 22 16 SYN 同步用暂停 0001 0111 23 17 ETB 区块传输结束 0001 1000 24 18 CAN 取消 0001 1001 25 19 EM 连接介质中断 0001 1010 26 1A SUB 替换 0001 1011 27 1B ESC 跳出 0001 1100 28 1C FS 文件分割符 0001 1101 29 1D GS 组群分隔符 0001 1110 30 1E RS 记录分隔符 0001 1111 31 1F US 单元分隔符 0111 1111 127 7F DEL 删除 ","date":"2021-10-07","objectID":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/:0:1","series":null,"tags":["辅助"],"title":"ASCII码对照表","uri":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"},{"categories":["辅助"],"content":"ASCII可显示字符 二进制 十进制 十六进制 字符/缩写 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C | 01111101 125 7D } 01111110 126 7E ~ ","date":"2021-10-07","objectID":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/:0:2","series":null,"tags":["辅助"],"title":"ASCII码对照表","uri":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"},{"categories":["辅助"],"content":"菜单栏 E 模块 T 线程（挂起与激活）resume恢复线程 B 执行断点 HBP 硬件断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD指令 dd 查看dword db 查看字节集 hw 硬件写入断点 hr 硬件访问断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"快捷键 CTRL + A 分析代码 CTRL + S 查找命令序列 F2 下断和取消 Shift+F2 条件断点 F4 代码执行一次 F7 单步步入（进call） F8 单步步过（不进call） ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:3:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"条件断点 == 等于 != 不等于 \u0026\u0026 和 || 或 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:4:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"汇编指令 mov 赋值 lea 传址 push 入栈 pop 出栈 add 加 sub 减 mul 乘法 div 除法 call 函数 retn 返回 rep 主要用来重复执行指令 详见 REP指令前缀簇 ​ 指令：REP MOVS mem8/16/32, m8/16/32 ​ 描述：从DS:[(E)SI]中复制(E)CX个字节/字/双字到ES:[(E)DI] DS:[(E)SI]由于(E)SI寄存器中保存的是源操作数的地址，所以DS:[(E)SI]指的就是该地址保存的值 mov ecx,12 rep movs dword ptr es:[edi],dword ptr [esi] # 从[esi]中复制 ecx个四字节 到ES:[edi] # 每复制一次 esi 和 edi 的地址要加4，而ecx减1 # 源自 飞郁网络培训 2018-2019 52第二部分第八节结构体数组 55结构体数组实例1 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:5:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"断点 内存访问 断在执行之前 内存写入 断在执行之前 硬件访问（CE） 断在执行之后 硬件写入（CE） 断在执行之后 硬件执行 可添加条件断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD断点缺点 一次只能断在一个位置 CE则可以把所有相关断点列在一起 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD断点优点 高亮插件，易于追踪 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"堆栈 esp 栈顶指针 堆栈顶端的刻度 ebp 栈底指针 本层函数的栈底 ebp 不稳定，有时不是栈底，而是普通寄存器 判断方法，看ebp与esp的差距是否很大 如果差距大，则是普通寄存器 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:7:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"堆栈平衡 特性 esp 不能变化 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:8:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"寄存器 EAX call的返回值 ECX call的参数 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:9:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找call总结 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找call时，需要注意的地方： 找call在send上下断，尽量避免被心跳call干扰 在我们找call的时候，会有一些其它伴生函数干扰 例如： 打怪、打开npc对话框或者寻路call，可能会先触发走路call 打坐、释放技能可能会伴随快捷键函数 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找到call后，我们还需要对函数的参数、寄存器进行分析。 外平栈，看清楚参数的数量，是否和平栈的数值对应。在调用call的时候一定要平栈，否则会崩溃。 内平栈，通过retn的数值，来判断参数的数量，并且分析ecx的来源。个别情况下，还需要分析edx和esi等参数的来源。 有些函数调用的是虚函数，比如 call eax或者call [edx+8],我们需要去分析call里寄存器的来源。 如果我们的参数中需要用到eax，但是eax无法很快的得到结果，这时可以通过调用eax来源的call来获得，前提是分析清楚来源函数的参数和寄存器。调用连call。 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"带有结构体的函数 申请一片内存（可以通过OD插件） 在内存中填写结构体里的内容 将我们申请的内存地址，push到call中 进行调用 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:3","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"无法通过发包函数获得的call 例如：寻路，控件，按键 graph LR 寻路--\u003e走路--\u003ez[\"通过目的地坐标，\u003cbr\u003e下写入断点\"] graph LR 控件--\u003ez[\"可以通过背包的打开状态，\u003cbr\u003e来对状态下写入断点\"] graph LR 按键 --\u003ez \u0026 z1 \u0026 z2 z[\"可以通过背包的打开状态，\u003cbr\u003e来对状态下写入断点\"] z1[\"鼠标点击\"] z2[\"键盘\"] ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:4","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"发包函数 bp send send sendto WSASend 重新实现的发包函数 WSPSend 线程发包 graph subgraph 普通发包 喊话call --\u003e 喊话_内层call --\u003e 组包的过程1 --\u003e 最内层喊话call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 --\u003e 加密 --\u003e 发包发送 走路call --\u003e 走路_内层call --\u003e 组包的过程2 --\u003e 最内层走路call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 其它call --\u003e 其它_内层call --\u003e 组包的过程3 --\u003e 最内层其它call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 end ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:11:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件输入 寻找突破口: graph z1[\"方法一\"] z2[\"方法二\"] z3[\"字符串的长度\"] z4[\"直接搜索字符串\"] z5[\"下写入断点\"] z1--\u003ez3--\u003ez5 z2--\u003ez4--\u003ez5 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件点击 graph z[\"下写入断点\"] z1[\"方法一\"] z2[\"控件界面打开，搜1或0\"] z3[\"控件界面关闭，搜0或1\"] z4[\"方法二\"] z5[\"单选框选中，搜1或0\"] z6[\"单选框未选中，搜0或1\"] z1--\u003ez2--\u003ez3--\u003ez z4--\u003ez5--\u003ez6--\u003ez ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"按键call graph z[\"按一下对应按键来触发\"] z1[\"方法一\"] z2[\"通过按键触发发包函数\"] z3[\"在发包函数处下断\"] z4[\"方法二\"] z5[\"比如通过背包打开\u003cbr\u003e或者关闭的标志位\u003cbr\u003e来进行查找\"] z6[\"下写入断点\"] z7[\"之后返回，\u003cbr\u003e就有可能断在按键call\"] z8[\"有可能断在按键call\"] z9[\"proc断点\"] z10[\"方法三\"] z1--\u003ez2--\u003ez3--\u003ez7 z4--\u003ez5--\u003ez6--\u003ez--\u003ez8 z10--\u003ez9 proc断点 (源自 飞郁网络培训 2018-2019 2018.12.22 proc断点分析按键CALL) ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:13:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"插件 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:14:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"IDA 用于查看伪函数代码 对于复杂的结构体、数组、二叉树、链表，更直观。 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:15:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"跳出VM graph z1([遇到VM]) z2[追附近地址\u003cbr\u003e最好是对象] z3[需要自己算偏移] z1--\u003ez2--\u003ez3 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:16:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"步骤: 新建MFC项目(用于注入DLL) 新建win32项目 dll 导出符号 安全开发生命周期 ","date":"2021-10-03","objectID":"/2021/10/%E7%94%A8mfc%E5%86%99%E6%B3%A8%E5%85%A5%E5%99%A8/:1:0","series":null,"tags":["辅助"],"title":"用MFC写注入器","uri":"/2021/10/%E7%94%A8mfc%E5%86%99%E6%B3%A8%E5%85%A5%E5%99%A8/"},{"categories":["辅助"],"content":"0x00 Target 【基地址】+【偏移】+【偏移】+…=【偏移地址】 【Target】是【Winform】窗体； 【Winform】标题是【Form1】； 【button】功能是刷新【label】； 【label】标签用来显示【int类型】测试变量，测试变量的【初始值】为9528。 以下源代码： public partial class Form1 : Form { // int Num = 9528; // public Form1() { InitializeComponent(); } // private void button1_Click(object sender, EventArgs e) { label1.Text = Num.ToString(); } // private void Form1_Load(object sender, EventArgs e) { label1.Text = Num.ToString(); } } ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:1:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x01 偏移地址 查找变量【当前值】： 筛选出能改变 【Target】的【偏移地址】： 此次得到【偏移地址】为【02BB5960】。 ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:2:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x02 指针扫描 对【02BB5960】进行【指针扫描】： 默认扫描【最大偏移值】4095，默认【最大偏移层次】7层： 选择【*.PTR】文件保存位置： 总共扫描【336422】个指针，下列的是【符合条件的指针列表】： ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:3:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x03 多次筛选 为了避免偶然性，我们重启【Target】以改变【偏移地址】，然后在【符合条件的指针列表】中再一次进行【指针扫描】。新的【偏移地址】是【030B5960】： 打开从【符合条件的指针列表】再次扫描界面： 填入新的偏移地址【030B5960】： 选择【*.PTR】文件保存位置，覆盖上次文件即可： 总共扫描【6648】个指针，下列是【此次符合条件的指针列表】： 【再次扫描】这个步骤，一般重复三到五次，多多益善。 ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:4:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x04 测试 多次扫描后，在新打开的【CE】中按住【Ctrl】，依次点击【M】【P】【O】键，然后导入【*.PTR】文件： 观察【Points to】列，值为空的表示这不是一个真正的【基地址】： 【双击】选择一个【Points to】列的值为测试值的【基地址】，将自动添加到【CE】： 通过该【基地址】，将指向的值更改为【6666】： 刷新【Target】，检验是否是正确的【基地址】： 刷新前 刷新后 经检验，是正确的【基地址】。 ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:5:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x05 CT 将【基地址】以【*.CT】形式保存到本地： 导入【*.CT】，使用【基地址】： 通过【基地址】成功读取到【测试值】： ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:6:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":["辅助"],"content":"0x06 实战 练手经典游戏【植物大战僵尸】的【阳光基地址】： 为了准确，首先制作两个【阳光偏移地址】的【Generate Pointermap】： 然后关闭游戏再来一次 两个【阳光偏移地址】的【Generate Pointermap】制作完成： 然后查看是哪个地址改写了第二个【阳光偏移地址】: 捡一个阳光，然后获得一条改写记录，双击此记录： 因为【上个地址】+【偏移】指向第二个【阳光偏移地址】，所以我们得到第二个【阳光偏移地址】的最上层偏移是【5578】： 接下来，对第二个【阳光偏移地址】进行【指针扫描】，设置如下： 将扫描结果保存为【PVZ.PTR】，扫描得到【32417】个有真有假的【阳光基地址】： 现在将当前阳光【25】变动为【75】，然后再次对【PVZ.PTR】进行扫描： 现在剩余【18011】个有真有假的【阳光基地址】： 再次将当前阳光【75】变动为【100】，然后对【PVZ.PTR】进行扫描，发现梯度已经不再下降，我们开始对【阳光基层偏移】进行【排序】，以便我们找到最短最有效的【阳光基地址】。 按照下图序号依次点击排序，最后我们找到了最少偏移个数的阳光基地址【“THREADSTACK0”-00000568】，实际上阳光基地址有更简单的，这种方法没有搜到，将当前阳光【100】变动为【75】测试一下： 【“THREADSTACK0”-00000568】+【0】+【8】+【5578】\u003e【阳光偏移地址】： 现在重启电脑后，再重启游戏进行测试： 开始游戏前 开始游戏后 【“THREADSTACK0”】是【线程地址】，我们可以通过【threadstack.exe】工具转换【线程地址】成一个【内存地址】，这样便于写工具，当然使用【进程基地址】就没有这个麻烦： 也就是说： 【\"THREADSTACK0\"-00000568】+【0】+【8】+【5578】\u003e【阳光偏移地址】 等价于 【0x0019ff7c-00000568】+【0】+【8】+【5578】\u003e【阳光偏移地址】 CheatEngine是我随便下的。 ","date":"2021-10-03","objectID":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/:7:0","series":null,"tags":["辅助"],"title":"指针扫描","uri":"/2021/10/%E6%8C%87%E9%92%88%E6%89%AB%E6%8F%8F/"},{"categories":null,"content":" 购普通课程或者核心课程，为保您购买与售后无忧，先咨询飞郁客服QQ:290330101，并享受不定额度优惠！ 逆向基本工具包 链接：https://pan.baidu.com/s/1CLTHQ3BXi4aA8iFbELZAJA 提取码：h45h 基础篇课件+课堂源码+课堂用到的一些工具等 链接：https://pan.baidu.com/s/1B8ozmsy4qsDiFJk_Dnn_bA 提取码：9scm ","date":"2021-09-30","objectID":"/2021/09/%E9%A3%9E%E9%83%81%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"飞郁逆向课程详解","uri":"/2021/09/%E9%A3%9E%E9%83%81%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"内存中的浮点数 3开头 1.xxxx 0.xxxx 4开头 100.xxxx b开头 -0.xxxx c开头 -15.xxxx ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:1:0","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"CE扫四种编码 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:0","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"ASCI UNIDCOE（不勾选） ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:1","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"UNIDCOE UNIDCOE graph 勾选UNIDCOE--\u003e 扫描类型_字符串--\u003e 输入待扫描内容--\u003e a[\"搜索\"]--成功---\u003e 完毕 a--失败--\u003e 扫描类型_字节集---\u003e a 字符串转字节集的方法--\u003e 随便添加一个空白地址--\u003e 类型选择字符串或文本型--\u003e 输入待扫描的内容--\u003e 更改类型为字节集--\u003e b[\"完毕\"] ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:2","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"utf_8 graph 不勾选UNIDCOE--\u003e 扫描类型_字符串--\u003e 输入待扫描内容--\u003e 更改类型为字节集--\u003e 完毕 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:3","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"big5 用工具转换 GBK转BIG5 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:4","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":["C++"],"content":"C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; int main() { // 创建一个向量存储 int vector\u003cint\u003e vec; int i; // 显示 vec 的原始大小 cout \u003c\u003c \"vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 推入 5 个值到向量中 for(i = 0; i \u003c 5; i++){ vec.push_back(i); } // 显示 vec 扩展后的大小 cout \u003c\u003c \"extended vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 访问向量中的 5 个值 for(i = 0; i \u003c 5; i++){ cout \u003c\u003c \"value of vec [\" \u003c\u003c i \u003c\u003c \"] = \" \u003c\u003c vec[i] \u003c\u003c endl; } // 使用迭代器 iterator 访问值 vector\u003cint\u003e::iterator v = vec.begin(); while( v != vec.end()) { cout \u003c\u003c \"value of v = \" \u003c\u003c *v \u003c\u003c endl; v++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： vector size = 0 extended vector size = 5 value of vec [0] = 0 value of vec [1] = 1 value of vec [2] = 2 value of vec [3] = 3 value of vec [4] = 4 value of v = 0 value of v = 1 value of v = 2 value of v = 3 value of v = 4 关于上面实例中所使用的各种函数，有几点要注意： push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。 size( ) 函数显示向量的大小。 begin( ) 函数返回一个指向向量开头的迭代器。 end( ) 函数返回一个指向向量末尾的迭代器。 菜鸟官方笔记 C++ STL 之 vector 的 capacity 和 size 属性区别 size 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。 capacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。 当然，这两个属性分别对应两个方法：resize() 和 reserve()。 使用 resize() 容器内的对象内存空间是真正存在的。 使用 reserve() 仅仅只是修改了 capacity 的值，容器内的对象并没有真实的内存空间(空间是\"野\"的)。 此时切记使用[ ]操作符访问容器内的对象，很可能出现数组越界的问题。 下面用例子进行说明： #include \u003ciostream\u003e #include \u003cvector\u003e using std::vector; int main(void) { vector\u003cint\u003e v; std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; v.reserve(10); std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; v.resize(10); v.push_back(0); std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; return 0; } 运行结果为：(win 10 + VS2010) 注： 对于 reserve(10) 后接着直接使用 [] 访问越界报错(内存是野的)，大家可以加一行代码试一下，我这里没有贴出来。 这里直接用[]访问，vector 退化为数组，不会进行越界的判断。此时推荐使用 at()，会先进行越界检查。 相关引申： 针对 capacity 这个属性，STL 中的其他容器，如 list map set deque，由于这些容器的内存是散列分布的，因此不会发生类似 realloc() 的调用情况，因此我们可以认为 capacity 属性针对这些容器是没有意义的，因此设计时这些容器没有该属性。 在 STL 中，拥有 capacity 属性的容器只有 vector 和 string。 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B040stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记40STL 教程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B040stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 标准库 C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"标准函数库 标准函数库分为以下几类： 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"面向对象类库 标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":null,"content":"报名QQ: 3534373359 ================================ 本期在线班, 实战游戏列表: 口袋西游 传奇永恒 幻想神域单机版 猎天 QQ自由幻想 天涯明月刀 魔兽单机版 神途 QQ三国 新寻仙 魔兽怀旧服 自由足球 成吉思汗2 QQ仙侠传 轩辕传奇 NBA2KOL 最终幻想14 创世战车 第九大陆 武林外传 神魔大陆 完美世界 极光世界 新风云 神鬼世界 诛仙3 鹿鼎记 斗战神 彩虹岛Online 待添加… 21年11月在线班, 游戏实战新加: 传奇4 天堂W 新世界 FPS(X鸡, APEX) ================================ ♦ 课程目录： ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:0:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第一章：创建第一个程序编写进制转换器 进制 13:10 进制进阶 12:08 高级语言和低级语言 15:36 创建第一个程序 18:52 printf和scanf编写进制转换器 19:30 变量和常量 10:09 内存 23:56 数据类型 22:22 数据在内存中的储存方式_字符，整数类 10:54 数据在内存中的储存方式_浮点类 26:03 有符号和无符号区别，强制转换类型 25:10 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:1:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第二章: CE基础和实现游戏瞬移 CE入门整数扫描 20:05 CE浮点数扫描实现瞬移 14:17 CE扫描进入游戏标志位 16:30 基地址，动态地址和偏移 16:52 CE的一些技巧 13:32 CE扫描字符串_Ascii Unicode 18:45 CE扫描字符串_UTF_8 Big5 13:22 CE找偏移表达式 23:41 代码编写MFC DLL显示窗口 16:47 内存读写，输出人物血量和实现瞬移 24:46 Writeprocessmemory和指针读写 04:53 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:2:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第三章: OD基础，逆向游戏基地址和偏移表达式 OD基础 22:04 动态加载模块，静态加载模块和游戏领空 18:57 GetModuleHandle 10:18 数据段和代码段18:01 寄存器20:57 堆栈18:33 汇编基础指令 mov lea push pop pushad popad24:14 基础汇编指令 add sub mul div jmp call retn25:12 浮点数指令fld fild fldl fldpi19:10 浮点数指令fstp fistp fst fist19:31 逆向思维看汽车质量问题14:43 浮点数指令fadd fmul fsub fdiv08:55 OD和CE的对应关系22:34 OD追整数类型偏移表达式其一22:36 OD追整数类型偏移表达式其二26:30 OD追浮点数类型偏移表达式15:52 OD中的七种断点18:08 OD中追哪个寄存器的技巧 10:29 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:3:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第四章 call，变态功能和编写自动吃药脚本 什么是函数[视频未上传] 编写第一个函数17:53 逆向函数，call和子程序的对应关系13:41 函数的调用关系22:29 通过send调用关系找功能call例子18:16 发包函数及晒除心跳包18:11 外层call和内层call的关系以及变态功能11:03 执行到返回，K和堆栈中跳转的关系12:51 分析call，代码注入器调call实现功能19:19 堆栈平衡和函数约定，防止崩溃代码注入器22:58 _asm内联汇编12:10 内联汇编需要注意的事项12:52 吃药call，真正的项目使用什么样的call15:44 结构体参数call，malloc和free22:14 call详解12:48 内存的访问找万能按键call12:07 编写万能按键call和学习sleep20:10 补充万能按键call为什么不能走路26:22 参数找寻路call12:42 锻炼堆栈构建结构体及寻路call10:13 寻路状态找寻路call12:21 控件输入call12:21 控件点击call12:05 EFLAGS寄存器，篡改变态功能的原理18:51 JCC09:51 流程控制语句14:09 if else和逆向16:29 switch和逆向11:26 for和逆向16:19 break和continue12:47 while和逆向10:32 什么是线程13:42 编写自动吃药15:05 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:4:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第五章: 检测多开入门 call的检测，变量检测05:53 处理call检测17:36 最简单的处理API解除游戏限制多开14:23 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:5:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第六章 堆栈及 检测进阶 全局变量和局部变量13:36 逆向全局变量和局部变量08:09 堆栈知识09:22 堆栈详解EBP26:57 堆栈详解ESP12:45 堆栈详解ESP追局部变量20:32 堆栈补充10:18 堆栈锻炼名称字符串18:40 进call逆向数据来源09:08 本层call内部追局部变量16:29 内联汇编需要注意的事项其二10:47 堆栈隐藏调用痕迹10:42 堆栈检测的两种方式11:11 堆栈检测07:21 处理一层堆栈检测防封15:27 处理多层堆栈检测防封11:23 处理多层堆栈检测防封补充[视频未上传] CRC检测09:23 过CRC检测防封23:13 直接nop引起网络波动的问题09:10 数据检测05:58 过数据检测防封11:35 过数据间接检测防封20:27 行为检测 09:31 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:6:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第七章: 明文收发包，脱机和漏洞bug 三大发包函数send,sendto,WSASend[视频未上传] 系统发包函数WSPSend 重新实现的发包函数15:12 线程发包的形态和特点11:35 WSASend条件断点晒出心跳包10:35 跳出线程发包的思路18:15 线程发包跳出线程找到功能函数18:15 确定加密封包位置14:56 明文发包函数12:04 加密call19:29 分析加密call调用方法18:08 自己调用加密call加密12:00 发送喊话函数封包26:55 偷功能119:18 偷功能207:39 不走游戏代码测试吃药封包07:17 收包函数recv，WSARecv和沾包18:57 找明文收包函数的方法12:24 解密call和找明文收包函数的更巧妙办法07:19 脱机和漏洞bug09:10 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:7:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第八章: HOOK HOOK的原理15:03 手动修改实现HOOK14:21 代码HOOK明文发包16:21 VirtualProtect修改页面属性13:45 dbgview输出信息13:00 拦截所有封包内容24:02 实例测试排除bug10:50 HOOK明文收包31:14 bug对半排除法16:09 发送封包实现任意功能 14:20 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:8:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第九章: 数据结构和自动打怪 数据结构[视频未上传] 数组[视频未上传] 二维数组 [视频未上传] 逆向数组[视频未上传] 逆向数组套数组及call内修改参数值[视频未上传] 逆向数组实战调call取对象[视频未上传] 逆向数组实战内层call追局部变量[视频未上传] 逆向数组实战加密数组下标[视频未上传] 分析人物所有属性[视频未上传] 字符串和字符数组[视频未上传] 结构体[视频未上传] 结构体的大小[视频未上传] 结构体数组[视频未上传] 代码整理[视频未上传] 结构体成员函数和输出人物信息[视频未上传] __try()[视频未上传] 代码编写输出数组信息[视频未上传] 链表[视频未上传] 有头链表，无头链表和链表的插入方式[视频未上传] 链表在内存中的形态[视频未上传] 实战周围对象链表[视频未上传] JMP隐藏返回和堆栈[视频未上传] 代码编写输出链表信息[视频未上传] 名称字符串找法和字符串内存存放规则[视频未上传] big5转码输出怪物名字[视频未上传] 冒泡算法取最近怪物[视频未上传] 二叉树[视频未上传] 背包数据嵌套结构[视频未上传] 背包二叉树[视频未上传] 二叉树分析[视频未上传] 嵌套结构分析[视频未上传] 遍历背包二叉树信息[视频未上传] 物品名称分析[视频未上传] 物品库[视频未上传] 数据结构关联[视频未上传] 分析调用吃药封包[视频未上传] 编写保护线程[视频未上传] 技能冷却二叉树牵扯出游戏全部冷却数据[视频未上传] 编程输出冷却技能数据[视频未上传] 获取技能名称[视频未上传] 获取技能名称编程[视频未上传] 技能遍历1[视频未上传] 技能遍历2[视频未上传] 已学技能遍历和BUG调试[视频未上传] 分析编写技能封包[视频未上传] 简陋版自动打怪[视频未上传] ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:9:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十章: Al智能 主线脚本 寻路call[视频未上传] 改进自动打怪[视频未上传] 程序调call或运行久了产生崩溃[视频未上传] 修改主线程调用[视频未上传] 完善自动打怪[视频未上传] 完善自动打怪-技能循环[视频未上传] 判断障碍点[视频未上传] 分析判断障碍点1[视频未上传] 分析判断障碍点2[视频未上传] 绕过卡点怪物继续攻击错误版[视频未上传] 绕过卡点怪物继续攻击正确版[视频未上传] 异常bug修复[视频未上传] 任务分析[视频未上传] 任务遍历[视频未上传] 任务要求分析[视频未上传] 任务遍历编写[视频未上传] 交接任务封包[视频未上传] 编写交接任务封包[视频未上传] 任务逻辑编写[视频未上传] 自动任务[视频未上传] 自动主线任务1[视频未上传] 自动主线任务2[视频未上传] 自动主线任务3[视频未上传] 自动主线任务4[视频未上传] ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:10:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十一章 x64游戏逆向 198.x64寄存器 199.x64堆栈与函数 200.x64写汇编 201.x64写汇编调call 202.x64工具 203.×64逆向分析加密 204.x64数组套链表 嵌套结构 205.x64逆向浮点数运算及XMM寄存器 206.x64逆向浮点数运算及XMM寄存器2 207.x64注入 208.x64找游残call 209.x64汇编用调用call 210.x64遍万代码写法 211.x64实战W某某游残1 212.x64实战W某某游戏2 213.x64实战W某某游戏3 214.x64实战W某某游戏4 215.×64实战W某某游戏5 216.x64实战W某某游戏6 217.x64实战W某某游戏7 218.x64实战W某某游戏8 219.x64实战W某某游戏9 220.x64实战W某某游戏10 221.x64实战W某某游戏11 222.x64实战W某某游戏12 223.×64实战W某某游戏13 224.x64实战W某某游戏14 225.x64实战W某某游戏15 226.x64实战W某某游戏16 227.x64实战W某某游戏17 228.x64实战W某某游戏18 229.x64实战W某某游戏19 230.x64实战W某某游戏20 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:11:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十二章 FPS游戏实战 231.FPS游戏自瞄效果实战 232.FPS游戏实战之模块动态加载 233.FPS游戏之玩转堆栈 234.FPS游戏获取敌我所有目标 235.FPS游戏攻击敌人目标属性总结 236.FPS游戏自瞄爆头准星数据查找 237.FPS游残炮头准星变化规律 238.FPS游戏自瞄准星算法 239.FPS游戏自瞄透视之C++代码实现自瞄1 240.FPS游戏自瞄透视之C++代码实现自瞄2 241.FPS游戏自瞄透视之C++代码实现自瞄3 242.FPS游戏封装必要函数 243.FPS游戏用类遍历输出人物属性 244.FPS游戏热键瞄准和计算最近距离 245.FPS游残实现自瞄 246.某F加密准星分析 247.某F人物坐标分析 248.某F遍历周边玩家 249.某F分析坐标规律实现自瞄 250.某F分析绘制和所需数据及视角查找 251.某F取窗口矩形位置和大小 252.某F建立透明口 跟随游戏 253.某F分析水平可视敌人 254.某F分析垂直可视敌人 255.某F转换2D坐标画出基础方框 256.某F透 视之如何调整方框比例1 257.某F透 视之如何调整方框比例2 258.某F计算并瞄准准案最近的敌人 259.某Fcf变态功能之飞天蹲地 260.某Fcf变态功能之无限子弹 26l.某F实战内存人物透视CRC 262.某F实战内存人物透视CRC 263.某F理解检测和对抗原理 264.某F封包处理检测 265.某F实战明文发包及木马加载 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:12:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十三章 RPG大型3D游残实战 266.RPG大型3D游残过TP驱动保护 267.RPG大型3D游残换属性绕过VM 268.RPG大 型3D游戏call内跳转隐藏偏移 269.RPG大型3D游戏人物属性整理 270.RPG大型3D游残编程输出人物信息 271.RPG大型3D游戏人物对象特性分析玩家链表 272.RPG大型3D游戏模仿结构搞定NPC怪物链表 273.RPG大型3D游戏其他找NPC怪物思路 274.RPG大型3D游戏属性对比分析以及编程输出链表 275.RPG大型3D游戏WSPSend以及重新实现的发包函数 276.RPG大型3D游戏线程发包 277.RPG大型3D游戏明文发 包call 278.RPG大型3D游戏Hook原理 279.RPG大型3D游戏Hook明文包分析封包协议 280.RPG大型3D游戏HOOK代码实现 281.RPG大型3D游戏巧妙方法找重新实现的收包函数 282.RPG大型3D游残特殊巧妙方法找明文包 283.RPG大型3D游残内联汇编 284.RPG大型3D游戏过QTE封包协议 285.RPG大型3D游戏无敌倍功功能 286.RPG大型3D游戏动画宝藏BUG 287.RPG大型3D游残动画宝藏效果 288.RPG大型3D游戏封包之外需要找的call整理 289.RPG大型3D游戏通用快捷键Call 290.RPG大型3D游戏快捷键CALL编写 291.RPG大型3D游戏控件点击call 292.RPG大型3D游残控件选择cal 293.RPG大型3D游戏控件callI编写以及动态模块编写 294.RPG大型3D游残变异二叉树 295.RPG大型3D游戏变异二叉树编写 296.RPG大型3D游戏寻路call 297.RPG大型3D游戏寻路call的编写 298.RPG大型3D游戏寻路隐藏检测点 299.RPG大型3D游戏带价值计算跨图寻路 300.RPG大型3D游戏小退call 301.RPG大型3D游戏攻击角度分析 302.RPG大型3D游戏攻击封包构建 302.RPG大型3D游攻击封包构建 303.RPG大型3D游戏朝向算法 304.RPG大型3D游戏冒泡算法计算最近怪物 305.RPG大 型3D游戏多 种技能封包结构 306.RPG大型3D游戏快速射击 307.RPG大型3D游戏技能库遍历 308.RPG大型3D游戏技能库二叉树编写 309.RPG大型3D游残已学技能遍历 310.RPG大型3D游戏技能冷却的巧妙思路 311.RPG大型3D游戏自动打怪代码遭辑实现 312.RPG大型3D游戏自动打怪效果视频及要求 313.RPG大型3D游戏接任务封包以及防封跟包 314.RPG大型3D游戏交任务封包 315.RPG大型3D游戏交中间小任务封包 316.RPG大型3D游戏任务库遍历 317.RPG大型3D游戏已接任务二叉树及数据关联 318.RPG大型3D游戏小任务数据跟踪原因及思路 319.RPG大型3D游戏自动任务脚本逻辑 320.RPG大型3D游戏多 线程控制辅助 321.RPG大型3D游戏自动主线自动副本效果 322.RPG大型3D游戏背包物品遍历 323.RPG大型3D游戏属性暴力对比分析及智能换装 324.RPG大型3D游戏地面物品遍历 325.RPG大型3D游戏躲避子弹 326.RPG大型3D游戏物品库及数据关联 327.RPG大型3D游残吸物 328.RPG大型3D游戏宝藏遍厅 329.RPG大型3D游戏变态获取自己想要的宝藏 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:13:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十四章 回合制游戏实战 330.回合制游戏人物对象 331.回合制游残加密坐标 332.回合制游戏升级经验数组 333.回合制游残等级加密解密 334.回合制游戏战斗标志位 335.回合制游戏战斗顺序标志位 336.回合制游戏怪物数 组遍历 337.回合制游戏序号提取表 338.回合制游戏编写DLL显示窗口 339.回合制游戏调试输出人物信息 340.回合制游残寻路call 341.回合制游戏内敛汇编编写寻路call 342.回合制游戏数据定位 343.回合制游戏封装周围数 组 344.回合制游戏封装升级标志战斗标志 345.回合制游戏HOOK原理 346.回合制游戏HOOK明文 包 347.回合制游戏封包和HOOK明文包的优点发包变态功能理解 348.回合制游戏send发送封包 349.回合制游戏分析攻击封包 350.回合制游戏封装人 物攻击宝宝攻击 351.回合制游戏通过参数找选角色call验征主线程调用效果 352.回合制游戏封装主线程调用 353.回合制游戏自动打怪逻辑 354.回合制游戏自 动打怪循环寻路线程 355.回合制游戏自动打怪杀怪线程 356.回合制游戏任务遍历 357.回合制游戏二叉树递归算法 358.回合制游戏任务属性分析 359.回合制游残检测概 论 360.回合制游戏第一个任务的3连封包分析 361.回合制游戏分析加密封包 362.回合制游戏远线程注入DLL 363.回合制游戏劫持注入DLL 364.回合制游戏收 包概论 365.回合制游戏recv实例分析 366.回合制游残收 包实例 367.回合制游戏收 包一些技巧 368.回合制游戏窗口 句柄and账号 369.回合制游戏背包遍历 370.回合制游戏寻宝 坐标加密 371.回合制游戏物品丢弃封包 372.回合制游戏自动清包 373.回合制游戏控件输入call 374.回合制游残控件遍 历数 组递归 375.回合制游戏控件遍厅编写 376.回合制游戏角色遍厅 377.回合制游戏创建角色封包 378.回合制游戏画江山总结 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:14:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十五章 MOBA游戏实战 379.L某某创建 380.L某某人物血量 381.L某某编辑读取人物血量 382.L某某人物全部信息以及简单绕VM 383.L某某编程管理更新数据输出人物信息 384.L某某线程发 包 385.L某某发包函数 386.L某某明文包 387.L某某回城call 388.L某某技能call 389.L某某技能数组 390.L某某秒切黄牌 39l.L某某无限视距 392L某某过无限视距检测及补充 393.L某某主线程防 止游戏崩溃 394.L某某自动补兵题辑和分析 395.L某某攻击call 396.L某某周围遍历数组 397.L某某玩家热键功能 398.L某某编写周围遍历 399.L某某寻路 400.L某某call总结 401.L某某背包遍历 402.L某某使用物品及封包调用逻辑 403.L某某BUFF判断 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:15:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十六章 WOWx64怀J服LUA脚本编写 404.创建x64项目及×64汇编写法 405.x64项目 汇编编写 406-407.x64项目汇编编写及调试bug 408.WOW怀旧服明文封包分析 409-410.x64项目 Hook原理及实现 410.WOW怀旧服代码段保护前提下获取明文封包 411.明文结构解析处理获得完整明文包 412.新思路绕道hook明文封包 413.x64瞬间定位数据自动更新 414.×64项目通用call写法 415.WOW怀旧服分析最内层明文发包call 416.分析调用喊话封包 417.处理喊话封包长度崩溃的bug 418.函数指针方式调用×64Call 419.走路call，汇编传专递值 420.主线程调用防止崩溃和万能按键消息 421.x64项目配置lua中文版 422.lua堆栈 423.取lua脚本变量 424.lua基础知识 425.LUA脚本调用C++函数 426.使用中文lua指令 427.修改Lua支持×64 QWORD（正向程序员和逆向程序员的方法） 428.lua MLD脚本 429.lua MLD脚本2 430.x64 堆栈对齐 431.取角色对象方法1 432.取角色对象方法2 433.对象遍历结构及加密代码 434.角色ID和角色基地址 435.分析角色名字以及判断对象类型 436.角色对象下的坐标分析 437.角色对象下的主背包遍历 438.附加背包遍万 439.主背包及其他格子ID分析 440.物品名字分析 441.装备基础属性偏移分析 442.装备前名字 443.装备前缀属性分析 444.连续调CALL取绿字名字 445.物品对象下属性及金币数量 446.技能名字遍历分析 447.已学技能数组分析 448.技能等级和类型遍历 449.技能学习标志遍历 450.天赋遍万分析1 451.天赋遍历分析2 452.天赋遍厅分析3 453.专业技能分析1 454.专业技能分析2 455.飞行点遍厅 456.拍卖行遍历 457.邮箱主题遍历 458.邮件内部分析 459.BUFF遍历 460.找到明文包 461.怪物尸体是否可拾取 462.怪物尸体内部遍历 463.控件点击CALL 464.控件遍历 465.账号密码输入 466.目的坐 标找鼠标走路 467.物品发包拾取 468.自动拾取分析 469.鼠标走路方法2 470.NPC交互相关封包 471.飞厅相关封包 472.使用物品和装备 473.扔物品脱装备 474.存取物品和更换背包 475.天赋加点解BUFF及学习技能包 476.扫拍包分析 477.购买与上架 478.打开和提取邮件 479.发邮件包 480.喊话包 481.技能包及加密1 482.技能包及加密2 483.技能包及加密3 4 484.正在释放技能标志 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:16:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":["C++"],"content":"C++ 预处理器 C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： #include \u003ciostream\u003e using namespace std; #define PI 3.14159 int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c PI \u003c\u003c endl; return 0; } 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下： $ gcc -E test.cpp \u003e test.p ... int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c 3.14159 \u003c\u003c endl; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"参数宏 您可以使用 #define 来定义一个带有参数的宏，如下所示： #include \u003ciostream\u003e using namespace std; #define MIN(a,b) (a\u003cb ? a : b) int main () { int i, j; i = 100; j = 30; cout \u003c\u003c\"较小的值为：\" \u003c\u003c MIN(i, j) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 较小的值为：30 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码： #ifdef NULL #define NULL 0 #endif 您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： #ifdef DEBUG cerr \u003c\u003c\"Variable x = \" \u003c\u003c x \u003c\u003c endl; #endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示： #if 0 不进行编译的代码 #endif 让我们尝试下面的实例： 实例 #include \u003ciostream\u003e using namespace std; #define DEBUG #define MIN(a,b) (((a)\u003c(b)) ? a : b) int main () { int i, j; i = 100; j = 30; #ifdef DEBUG cerr \u003c\u003c\"Trace: Inside main function\" \u003c\u003c endl; #endif #if 0 /* 这是注释部分 */ cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; #endif cout \u003c\u003c\"The minimum is \" \u003c\u003c MIN(i, j) \u003c\u003c endl; #ifdef DEBUG cerr \u003c\u003c\"Trace: Coming out of main function\" \u003c\u003c endl; #endif return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Trace: Inside main function The minimum is 30 Trace: Coming out of main function ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 请看下面的宏定义： 实例 #include \u003ciostream\u003e using namespace std; #define MKSTR( x ) #x int main () { cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： HELLO C++ 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; 转换成了： cout \u003c\u003c \"HELLO C++\" \u003c\u003c endl; ## 运算符用于连接两个令牌。下面是一个实例： #define CONCAT( x, y ) x ## y 当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++\"，如下面实例所示。 实例 #include \u003ciostream\u003e using namespace std; #define concat(a, b) a ## b int main() { int xy = 100; cout \u003c\u003c concat(x, y); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 100 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c concat(x, y); 转换成了： cout \u003c\u003c xy; ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 中的预定义宏 C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 让我们看看上述这些宏的实例： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Value of __LINE__ : \" \u003c\u003c __LINE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __FILE__ : \" \u003c\u003c __FILE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __DATE__ : \" \u003c\u003c __DATE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __TIME__ : \" \u003c\u003c __TIME__ \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of __LINE__ : 6 Value of __FILE__ : test.cpp Value of __DATE__ : Feb 28 2011 Value of __TIME__ : 18:52:48 菜鸟官方笔记 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 字符串化的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。 当用作字符串化操作时，# 的主要作用是将宏参数不经扩展地转换成字符串常量。 宏定义参数的左右两边的空格会被忽略，参数的各个 Token 之间的多个空格会被转换成一个空格。 宏定义参数中含有需要特殊含义字符如\"或\\时，它们前面会自动被加上转义字符 \\。 ## 连接符号，把参数连在一起。 将多个 Token 连接成一个 Token。要点： 它不能是宏定义中的第一个或最后一个 Token。 前后的空格可有可无。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"预处理更多例子。 #if SOMETHING\u003e=100 //... #else //... #endif #ifndef SOMETHING_H #define SOMETHING_H //... #endif #if (defined DEBUG)\u0026\u0026(defined SOMETHING) //... #endif #ifdef SOMETHING int func1(){/*...*/} #else int func1(){/*...*/} #endif #ifdef SOMETHING namespace space1{ #endif //... #ifdef SOMETHING }//space1 #endif ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 程序终止(interrupt)信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"signal() 函数 C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： void (*signal (int sig, void (*func)(int)))(int); 这个看起来有点费劲，以下语法格式更容易理解： signal(registered signal, signal handler) 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。 让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例： 实例 #include \u003ciostream\u003e #include \u003ccsignal\u003e #include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(1){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Going to sleep.... Going to sleep.... Going to sleep.... 现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"raise() 函数 您可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下： int raise (signal sig); 在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例： 实例 #include \u003ciostream\u003e #include \u003ccsignal\u003e #include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; if( i == 3 ){ raise( SIGINT); } sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果，并会自动退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"创建线程 下面的程序，我们可以用它来创建一个 POSIX 线程： #include \u003cpthread.h\u003e pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"终止线程 使用下面的程序，我们可以用它来终止一个 POSIX 线程： #include \u003cpthread.h\u003e pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"实例 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\": 实例 #include \u003ciostream\u003e // 必须的头文件 #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 // 线程的运行函数 void* say_hello(void* args) { cout \u003c\u003c \"Hello Runoob！\" \u003c\u003c endl; return 0; } int main() { // 定义线程的 id 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for(int i = 0; i \u003c NUM_THREADS; ++i) { //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(\u0026tids[i], NULL, say_hello, NULL); if (ret != 0) { cout \u003c\u003c \"pthread_create error: error_code=\" \u003c\u003c ret \u003c\u003c endl; } } //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来； pthread_exit(NULL); } 使用 -lpthread 库编译下面的程序： $ g++ test.cpp -lpthread -o test.o 现在，执行程序，将产生下列结果： $ ./test.o Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。 实例 //文件名：test.cpp #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 void *PrintHello(void *threadid) { // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout \u003c\u003c \"Hello Runoob! 线程 ID, \" \u003c\u003c tid \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; int indexes[NUM_THREADS];// 用数组来保存i的值 int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : 创建线程, \" \u003c\u003c i \u003c\u003c endl; indexes[i] = i; //先保存i的值 // 传入的时候必须强制转换为void* 类型，即无类型指针 rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026(indexes[i])); if (rc){ cout \u003c\u003c \"Error:无法创建线程,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 现在编译并执行程序，将产生下列结果： $ g++ test.cpp -lpthread -o test.o $ ./test.o main() : 创建线程, 0 main() : 创建线程, 1 Hello Runoob! 线程 ID, 0 main() : 创建线程, Hello Runoob! 线程 ID, 21 main() : 创建线程, 3 Hello Runoob! 线程 ID, 2 main() : 创建线程, 4 Hello Runoob! 线程 ID, 3 Hello Runoob! 线程 ID, 4 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"向线程传递参数 这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示： 实例 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg) { struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout \u003c\u003c \"Thread ID : \" \u003c\u003c my_data-\u003ethread_id ; cout \u003c\u003c \" Message : \" \u003c\u003c my_data-\u003emessage \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c\"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; td[i].thread_id = i; td[i].message = (char*)\"This is message\"; rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026td[i]); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： $ g++ -Wno-write-strings test.cpp -lpthread -o test.o $ ./test.o main() : creating thread, 0 main() : creating thread, 1 Thread ID : 0 Message : This is message main() : creating thread, Thread ID : 21 Message : This is message main() : creating thread, 3 Thread ID : 2 Message : This is message main() : creating thread, 4 Thread ID : 3 Message : This is message Thread ID : 4 Message : This is message ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"连接和分离线程 我们可以使用以下两个函数来连接或分离线程： pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。 实例 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e using namespace std; #define NUM_THREADS 5 void *wait(void *t) { int i; long tid; tid = (long)t; sleep(1); cout \u003c\u003c \"Sleeping in thread \" \u003c\u003c endl; cout \u003c\u003c \"Thread with id : \" \u003c\u003c tid \u003c\u003c \" ...exiting \" \u003c\u003c endl; pthread_exit(NULL); } int main () { int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_JOINABLE); for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; rc = pthread_create(\u0026threads[i], NULL, wait, (void *)\u0026i ); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } // 删除属性，并等待其他线程 pthread_attr_destroy(\u0026attr); for( i=0; i \u003c NUM_THREADS; i++ ){ rc = pthread_join(threads[i], \u0026status); if (rc){ cout \u003c\u003c \"Error:unable to join,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } cout \u003c\u003c \"Main: completed thread id :\" \u003c\u003c i ; cout \u003c\u003c \" exiting with status :\" \u003c\u003c status \u003c\u003c endl; } cout \u003c\u003c \"Main: program exiting.\" \u003c\u003c endl; pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Sleeping in thread Thread with id : 4 ...exiting Sleeping in thread Thread with id : 3 ...exiting Sleeping in thread Thread with id : 2 ...exiting Sleeping in thread Thread with id : 1 ...exiting Sleeping in thread Thread with id : 0 ...exiting Main: completed thread id :0 exiting with status :0 Main: completed thread id :1 exiting with status :0 Main: completed thread id :2 exiting with status :0 Main: completed thread id :3 exiting with status :0 Main: completed thread id :4 exiting with status :0 Main: program exiting. 更多实例参考：http://www.runoob.com/w3cnote/cpp-multithread-demo.html 菜鸟官方笔记 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"c++ 11 之后有了标准的线程库： #include \u003ciostream\u003e #include \u003cthread\u003e std:🧵:id main_thread_id = std::this_thread::get_id(); void hello() { std::cout \u003c\u003c \"Hello Concurrent World\\n\"; if (main_thread_id == std::this_thread::get_id()) std::cout \u003c\u003c \"This is the main thread.\\n\"; else std::cout \u003c\u003c \"This is not the main thread.\\n\"; } void pause_thread(int n) { std::this_thread::sleep_for(std::chrono::seconds(n)); std::cout \u003c\u003c \"pause of \" \u003c\u003c n \u003c\u003c \" seconds ended\\n\"; } int main() { std::thread t(hello); std::cout \u003c\u003c t.hardware_concurrency() \u003c\u003c std::endl;//可以并发执行多少个(不准确) std::cout \u003c\u003c \"native_handle \" \u003c\u003c t.native_handle() \u003c\u003c std::endl;//可以并发执行多少个(不准确) t.join(); std::thread a(hello); a.detach(); std::thread threads[5]; // 默认构造线程 std::cout \u003c\u003c \"Spawning 5 threads...\\n\"; for (int i = 0; i \u003c 5; ++i) threads[i] = std::thread(pause_thread, i + 1); // move-assign threads std::cout \u003c\u003c \"Done spawning threads. Now waiting for them to join:\\n\"; for (auto \u0026thread : threads) thread.join(); std::cout \u003c\u003c \"All threads joined!\\n\"; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"要注意内存泄露问题 如果设置为 PTHREAD_CREATE_JOINABLE，就继续用 pthread_join() 来等待和释放资源，否则会内存泄露。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"C++ Web 编程 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。 公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 架构图 下图演示了 CGI 的架构： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi。 默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分： \u003cDirectory \"/var/www/cgi-bin\"\u003e AllowOverride None Options ExecCGI Order allow,deny Allow from all \u003c/Directory\u003e \u003cDirectory \"/var/www/cgi-bin\"\u003e Options All \u003c/Directory\u003e 在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"第一个 CGI 程序 请看下面的 C++ 程序： 实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eHello World - 第一个 CGI 程序\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ch2\u003eHello World! 这是我的第一个 CGI 程序\u003c/h2\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 chmod 755 cplusplus.cgi UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Hello World! 这是我的第一个 CGI 程序 上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 Content-type:text/html\\r\\n\\r\\n。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"HTTP 头信息 行 Content-type:text/html\\r\\n\\r\\n 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下： HTTP 字段名称: 字段内容 例如 Content-type: text/html\\r\\n\\r\\n 还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。 头信息 描述 Content-type: MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 Expires: Date 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 Location: URL 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 Last-modified: Date 资源的最后修改日期。 Content-length: N 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 Set-Cookie: String 通过 string 设置 cookie。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 环境变量 所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。 变量名 描述 CONTENT_TYPE 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 CONTENT_LENGTH 查询的信息长度。只对 POST 请求可用。 HTTP_COOKIE 以键 \u0026 值对的形式返回设置的 cookies。 HTTP_USER_AGENT 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 PATH_INFO CGI 脚本的路径。 QUERY_STRING 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 REMOTE_ADDR 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 REMOTE_HOST 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 REQUEST_METHOD 用于发出请求的方法。最常见的方法是 GET 和 POST。 SCRIPT_FILENAME CGI 脚本的完整路径。 SCRIPT_NAME CGI 脚本的名称。 SERVER_NAME 服务器的主机名或 IP 地址。 SERVER_SOFTWARE 服务器上运行的软件的名称和版本。 下面的 CGI 程序列出了所有的 CGI 变量。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cstdlib.h\u003e #include \u003cstring\u003e using namespace std; const string ENV[ 24 ] = { \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\", \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\", \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\", \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\", \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\", \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\", \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\", \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\", \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" }; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 环境变量\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\" cellspacing = \\\"2\\\"\u003e\"; for ( int i = 0; i \u003c 24; i++ ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c ENV[ i ] \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; // 尝试检索环境变量的值 char *value = getenv( ENV[ i ].c_str() ); if ( value != 0 ){ cout \u003c\u003c value; }else{ cout \u003c\u003c \"环境变量不存在。\"; } cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:9:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ CGI 库 在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 ftp://ftp.gnu.org/gnu/cgicc/ 上下载这个 CGI 库，并按照下面的步骤安装库： $ tar xzf cgicc-X.X.X.tar.gz $ cd cgicc-X.X.X/ $ ./configure --prefix=/usr $ make $ make install **注意：**libcgicc.so 和 libcgicc.a 库会被安装到/usr/lib目录下，需执行拷贝命令： $ sudo cp /usr/lib/libcgicc.* /usr/lib64/ 才能使 CGI 程序自动找到 libcgicc.so 动态链接库。 您可以点击 C++ CGI Lib Documentation，查看相关的库文档。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:10:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"GET 和 POST 方法 您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:11:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 GET 方法传递信息 GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示： http://www.test.com/cgi-bin/cpp.cgi?key1=value1\u0026key2=value2 GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。 当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。 您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML 标签的 GET 方法来传信息。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:12:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的 URL 实例：Get 方法 下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。 /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 下面的实例生成 cpp_get.cgi CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e使用 GET 和 POST 方法\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"first_name\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"名：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for first name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; fi = formData.getElement(\"last_name\"); if( !fi-\u003eisEmpty() \u0026\u0026fi != (*formData).end()) { cout \u003c\u003c \"姓：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for last name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，如下所示： $g++ -o cpp_get.cgi cpp_get.cpp -lcgicc 生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问： /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 这会产生以下结果： 名：ZARA 姓：ALI ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:13:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的表单实例：GET 方法 下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。 \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"get\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e \u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:14:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 POST 方法传递信息 一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。 我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示： \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"post\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e\u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:15:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递复选框数据 当需要选择多个选项时，我们使用复选框。 下面的 HTML 代码实例是一个带有两个复选框的表单： \u003cform action=\"/cgi-bin/cpp_checkbox.cgi\" method=\"POST\" target=\"_blank\"\u003e \u003cinput type=\"checkbox\" name=\"maths\" value=\"on\" /\u003e 数学 \u003cinput type=\"checkbox\" name=\"physics\" value=\"on\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; bool maths_flag, physics_flag; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递复选框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; maths_flag = formData.queryCheckbox(\"maths\"); if( maths_flag ) { cout \u003c\u003c \"Maths Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Maths Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; physics_flag = formData.queryCheckbox(\"physics\"); if( physics_flag ) { cout \u003c\u003c \"Physics Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Physics Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:16:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递单选按钮数据 当只需要选择一个选项时，我们使用单选按钮。 下面的 HTML 代码实例是一个带有两个单选按钮的表单： \u003cform action=\"/cgi-bin/cpp_radiobutton.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cinput type=\"radio\" name=\"subject\" value=\"maths\" checked=\"checked\"/\u003e 数学 \u003cinput type=\"radio\" name=\"subject\" value=\"physics\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递单选按钮数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"subject\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Radio box selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:17:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递文本区域数据 当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。 下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单： \u003cform action=\"/cgi-bin/cpp_textarea.cgi\" method=\"post\" target=\"_blank\"\u003e \u003ctextarea name=\"textcontent\" cols=\"40\" rows=\"4\"\u003e 请在这里输入文本... \u003c/textarea\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递文本区域数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"textcontent\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Text Content: \" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:18:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递下拉框数据 当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。 下面的 HTML 代码实例是一个带有下拉框的表单： \u003cform action=\"/cgi-bin/cpp_dropdown.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cselect name=\"dropdown\"\u003e \u003coption value=\"Maths\" selected\u003e数学\u003c/option\u003e \u003coption value=\"Physics\"\u003e物理\u003c/option\u003e \u003c/select\u003e \u003cinput type=\"submit\" value=\"提交\"/\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递下拉框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"dropdown\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Value Selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:19:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"在 CGI 中使用 Cookies HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。 在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"它是如何工作的 服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。 cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段： Expires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。 Domain : 网站的域名。 Path : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。 Secure : 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。 Name=Value : cookie 以键值对的形式被设置和获取。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"设置 Cookies 向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示： 实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Set-Cookie:UserID=XYZ;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Password=XYZ123;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Path=/perl;\\n\"; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"设置 cookies\" \u003c\u003c endl; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 从这个实例中，我们了解了如何设置 cookies。我们使用 Set-Cookie HTTP 头来设置 cookies。 在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 “Content-type:text/html\\r\\n\\r\\n 之前被设置的。 编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies： /cgi-bin/setcookies.cgi ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"获取 Cookies 检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下： key1=value1;key2=value2;key3=value3.... 下面的实例演示了如何获取 cookies。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; const_cookie_iterator cci; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\" cellspacing = \\\"2\\\"\u003e\"; // 获取环境变量 const CgiEnvironment\u0026 env = cgi.getEnvironment(); for( cci = env.getCookieList().begin(); cci != env.getCookieList().end(); ++cci ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c cci-\u003egetName() \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; cout \u003c\u003c cci-\u003egetValue(); cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies： /cgi-bin/getcookies.cgi 这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies： UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"文件上传实例 为了上传一个文件，HTML 表单必须把 enctype 属性设置为 multipart/form-data。带有文件类型的 input 标签会创建一个 “Browse” 按钮。 \u003chtml\u003e \u003cbody\u003e \u003cform enctype=\"multipart/form-data\" action=\"/cgi-bin/cpp_uploadfile.cgi\" method=\"post\"\u003e \u003cp\u003e文件：\u003cinput type=\"file\" name=\"userfile\" /\u003e\u003c/p\u003e \u003cp\u003e\u003cinput type=\"submit\" value=\"上传\" /\u003e\u003c/p\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 这段代码的结果是下面的表单： **注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。 下面是用于处理文件上传的脚本 cpp_uploadfile.cpp： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的文件上传\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; // 获取要被上传的文件列表 const_file_iterator file = cgi.getFile(\"userfile\"); if(file != cgi.getFiles().end()) { // 在 cout 中发送数据类型 cout \u003c\u003c HTTPContentHeader(file-\u003egetDataType()); // 在 cout 中写入内容 file-\u003ewriteToStream(cout); } cout \u003c\u003c \"\u003c文件上传成功\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 上面的实例是在 cout 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:21:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 动态内存 C++ 程序中的内存分为两个部分： **栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"malloc 和 free 成对出现 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： new data-type; double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; if( !(pvalue = new double )) { cout \u003c\u003c \"Error: out of memory.\" \u003c\u003cendl; exit(1); } malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 delete pvalue; // 释放 pvalue 所指向的内存 实例 #include \u003ciostream\u003e using namespace std; int main () { double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout \u003c\u003c \"Value of pvalue : \" \u003c\u003c *pvalue \u003c\u003c endl; delete pvalue; // 释放内存 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of pvalue : 29495 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"数组的动态内存分配 假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示： char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 要删除我们刚才创建的数组，语句如下： delete [] pvalue; // 删除 pvalue 所指向的数组 下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示： 一维数组 // 动态分配,数组长度为 m int *array=new int [m]; //释放内存 delete [] array; 二维数组 int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int [n] ; } //释放 for( int i=0; i\u003cm; i++ ) { delete [] array[i]; } delete [] array; 二维数组实例测试： 实例 #include \u003ciostream\u003e using namespace std; int main() { int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i\u003c4;i++){ p[i]=new int [8]; } for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++){ p[i][j] = j*i; } } //打印数据 for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++) { if(j==0) cout\u003c\u003cendl; cout\u003c\u003cp[i][j]\u003c\u003c\"\\t\"; } } //开始释放申请的堆 for(i=0; i\u003c4; i++){ delete [] p[i]; } delete [] p; return 0; } 三维数组 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int *[n]; for( int j=0; j\u003cn; j++ ) { array[i][j] = new int [h]; } } //释放 for( int i=0; i\u003cm; i++ ) { for( int j=0; j\u003cn; j++ ) { delete[] array[i][j]; } delete[] array[i]; } delete[] array; 三维数组测试实例： 实例 #include \u003ciostream\u003e using namespace std; int main() { int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i\u003c2; i++) { p[i]=new int *[3]; for(j=0; j\u003c3; j++) p[i][j]=new int[4]; } //输出 p[i][j][k] 三维数据 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { for(k=0;k\u003c4;k++) { p[i][j][k]=i+j+k; cout\u003c\u003cp[i][j][k]\u003c\u003c\" \"; } cout\u003c\u003cendl; } cout\u003c\u003cendl; } // 释放内存 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { delete [] p[i][j]; } } for(i=0; i\u003c2; i++) { delete [] p[i]; } delete [] p; return 0; } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"对象的动态内存分配 对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念： 实例 #include \u003ciostream\u003e using namespace std; class Box { public: Box() { cout \u003c\u003c \"调用构造函数！\" \u003c\u003cendl; } ~Box() { cout \u003c\u003c \"调用析构函数！\" \u003c\u003cendl; } }; int main( ) { Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 菜鸟官方笔记 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"delete 与 delete[] 区别： 针对简单类型 使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可 如： int *a = new int[10]; delete a; delete [] a; 针对类Class 两种方式体现出具体差异 当你通过下列方式分配一个类对象数组： class A { private: char *m_cBuffer; int m_nLen; public: A(){ m_cBuffer = new char[m_nLen]; } ~A() { delete [] m_cBuffer; } }; A *a = new A[10]; // 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏 delete a; // 调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间 delete [] a; 所以总结下就是，如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么： delete ptr – 代表用来释放内存，且只用来释放ptr指向的内存。 delete[] rg – 用来释放rg指向的内存，！！还逐一调用数组中每个对象的 destructor！！ 对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是C++ 对象数组就不同了！ ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++ 命名空间 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： namespace namespace_name { // 代码声明 } 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围： 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int main () { // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space Inside second_space ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"using 指令 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } using namespace first_space; int main () { // 调用第一个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： using std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示： 实例 #include \u003ciostream\u003e using std::cout; int main () { cout \u003c\u003c \"std::endl is used with std!\" \u003c\u003c std::endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： std::endl is used with std! using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： namespace namespace_name { // 代码声明 } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示： namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } 您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员： // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示： 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } } using namespace first_space::second_space; int main () { // 调用第二个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside second_space 菜鸟官方笔记 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"关于命名空间内变量和函数及全局变量的使用和作用域: #include \u003ciostream\u003e using namespace std; namespace A { int a = 100; namespace B //嵌套一个命名空间B { int a =20; } } int a = 200;//定义一个全局变量 int main(int argc, char *argv[]) { cout \u003c\u003c\"A::a =\"\u003c\u003c A::a \u003c\u003c endl; cout \u003c\u003c\"A::B::a =\"\u003c\u003cA::B::a \u003c\u003c endl; cout \u003c\u003c\"a =\"\u003c\u003ca \u003c\u003c endl; cout \u003c\u003c\"::a =\"\u003c\u003c::a \u003c\u003c endl; int a = 30; cout \u003c\u003c\"a =\"\u003c\u003ca \u003c\u003c endl; cout \u003c\u003c\"::a =\"\u003c\u003c::a \u003c\u003c endl; return 0; } 结果： A::a =100 A::B::a =20 a =200 //全局变量a ::a =200 a =30 //局部变量a ::a =200 即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 补充关于 using 的错误事例： #include \u003ciostream\u003e using namespace std; namespace A { int a = 100; int fun() { cout\u003c\u003c\"a = \"\u003c\u003ca\u003c\u003cendl; } namespace B //嵌套一个命名空间B { int a =20; int fun() { cout\u003c\u003c\"a = \"\u003c\u003ca\u003c\u003cendl; } } } int main(int argc, char *argv[]) { cout\u003c\u003ca\u003c\u003cendl; fun(); return 0; } 这样会出错：会显示 a 变量和 fun 函数 “was not declared in this scope”，即找不到这个 a 和 fun 函数。 解决办法： 用 using 来告诉编译器用到的是哪个命名空间内的内容。在 main() 上面加 using namespace A; 或者 using namespace A::B; 。这样就可以使用其中的 a 和 fun()。但是不能同时使用，因为这样也会导致编译出错，编译器器不知道要去使用哪个 a 和 fun()。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"补充一个命名空间冲突的情况： #include \u003ciostream\u003e using namespace std; namespace A { int a = 100; namespace B //嵌套一个命名空间B { int a = 20; } } int a = 200;//定义一个全局变量 int main(int argc, char *argv[]) { cout \u003c\u003c \"A::a =\" \u003c\u003c A::a \u003c\u003c endl; //A::a =100 cout \u003c\u003c \"A::B::a =\" \u003c\u003c A::B::a \u003c\u003c endl; //A::B::a =20 cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; //a =200 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 using namespace A; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; // Reference to 'a' is ambiguous // 命名空间冲突，编译期错误 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 int a = 30; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; //a =30 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 //即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 using namespace A; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; // a =30 // 当有本地同名变量后，优先使用本地，冲突解除 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 return 0; } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。 您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"函数模板 模板函数定义的一般形式如下所示： template \u003ctypename type\u003e ret-type func-name(parameter list) { // 函数的主体 } 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 下面是函数模板的实例，返回两个数中的最大值： 实例 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max (T const\u0026 a, T const\u0026 b) { return a \u003c b ? b:a; } int main () { int i = 39; int j = 20; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： template \u003cclass type\u003e class class-name { . . . } 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack\u003c\u003e，并实现了泛型方法来对元素进行入栈出栈操作： ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003ccstdlib\u003e #include \u003cstring\u003e #include \u003cstdexcept\u003e using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; // 元素 public: void push(T const\u0026); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push (T const\u0026 elem) { // 追加传入元素的副本 elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop () { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top () const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; // int 类型的栈 Stack\u003cstring\u003e stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout \u003c\u003c intStack.top() \u003c\u003cendl; // 操作 string 类型的栈 stringStack.push(\"hello\"); cout \u003c\u003c stringStack.top() \u003c\u003c std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003cendl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果： 7 hello Exception: Stack\u003c\u003e::pop(): empty stack ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"三大发包函数 send WSASend sendto 模块前缀为ws2_32 WSPSend （在同一个电脑上位置是固定的） DXF单机版 私服 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:1:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"找到WSPSend 附加上口袋西游(或者任何的send发包的软件都可以)，跳到send位置 send 第三个call下断（win7是第三个，win10是第四个），断下后F7进入，这就是WSPSend的位置。 附加到目标进程，跳转到这个地址，下断。 有时WSASend胡乱断，不是真正的发包 ，根据它的特征码，去搜索。查找–\u003e所有命令 ,输入特征码，然后右键–\u003e在每个命令上下设置断点。然后在所有被断下的位置做标记（注释），并取消断点。然后去执行喊话等发包操作，看在哪断下。如果不断，说明在刚才被标记的里面。之后逐一下断测试。 graph z([找出三大发包函数])--\u003e 可直接找出 z--\u003e 不可直接找出 --\u003e 找出WSPSend--\u003e 附加其它游戏--\u003e 跳到send处--\u003e z1[\"在第三/四个call下断\u003cbr\u003e（win7 第三个，win10 第四个）\"]--\u003e 断下后F7进入--\u003e 此处就是WSPSend的位置--\u003e z2[\"记录下来，附加到目标进程，\u003cbr\u003e跳转到这个地址，下断\"]--\u003e 正常断--\u003e 找到发包函数 z2--\u003e胡乱断--\u003e 记录它的特征码--\u003e 查找所有命令--\u003e 输入特征码--\u003e 右键在每个命令上下设置断点--\u003e 在所有被断下的位置做注释--\u003e 取消断点--\u003e 执行喊话等发包操作--\u003e 看在哪断下--\u003e 如果不断--\u003e 说明在刚才注释的里面--\u003e 逐一下断测试 找出WSPSend --\u003e 在三大发包函数下--\u003e 找到ws2_32.WEP--\u003e 再下一句就是WSPSend的外部--\u003e 下断后反复操作游戏--\u003e 断下后F7进入 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:1:1","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"线程发包 线程发包的特点： 断得非常频繁 任何功能堆栈返回都是一样的 graph y0([\"判断是不是线程发包\"])--\u003e 观察断得是否频繁--\u003e y1[\"在发包函数头部下断，\u003cbr\u003e喊话断一次，\u003cbr\u003e按K打开堆栈，\u003cbr\u003e复制整个表\"]--\u003e y2[\"走路断一次，再复制整个表\"]--\u003e y3{\"对比两次的表内容是否相同\"}--\u003e|相同|线程发包 y3--\u003e|不同|普通发包 正常流程 找到发包函数 判断是不是线程发包 判断包内容(非包长)的地址是否变化 跳出线程发包的步骤： graph z([跳出线程发包])--\u003ez2{\"判断包内容\u003cbr\u003e(非包长)的地址\u003cbr\u003e是否变化\"} z2 --是--\u003e z4[唯一突破口,找到包的内容来源]--\u003e z5[\"向上追,直到追到不变的地址\"]---\u003e z7[\"在不变的地址上，\u003cbr\u003e下硬件写入断点，\u003cbr\u003e返回，看是否跳出线程外\"] z2 --否--\u003e z6[在包内容处下硬件写入dword断点] --\u003e 就能跳出线程发包 --\u003e z8 z7 -.-\u003e|否| z5 z7 --是--\u003e z8([yeah]) z7-.-\u003ez9[\"从线程发包处，向外层层标注\"] z8-.-\u003ez10([\"此时可以来验证功能函数\"])-.-\u003e z11[\"下断并喊话，反复ctrl+f9多次，并标记\"]--\u003e z12([\"逐一测试标记call并验证\"]) ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:2:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"条件断 实例 [[esp+8]]!=11\u0026\u0026[[esp+8]]!=4 # esp 是堆顶 # == 等于 # != 不等于 # \u0026\u0026 和 word ptr[[[ebp+8]+4]] != 11 #word ptr 代表一个字节 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:3:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"找出加密封包 找出加密封包的步骤： graph z[\"跳出线程发包后\"] z1[\"配好表达式\"] z2[\"验证是不是加密封包\"] z3[\"在此处(跳出线程封包的位置)下断\"] z3a[\"喊话或者其它动作，令其断下\"] z4[\"dd 表达式\"] z5[\"在send处下断\"] z5a[\"喊话或者其它动作，令其断下\"] z6[\"找到封包内容\"] z7[\"此处应该就是封包内容\"] z8{\"对比\"} z9[\"确定是加密封包\"] z10[\"失败，寻找错误或者换其他方法\"] z--\u003ez1--\u003ez2 z2--\u003ez5--\u003ez5a--\u003ez6--\u003ez8 z2--\u003ez3--\u003ez3a--\u003ez4--\u003ez7--\u003ez8 z8--相同--\u003ez9 z8--不相同--\u003ez10 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:4:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"明文包 graph LR 功能call --\u003e 明文封包 --\u003e 加密CALL --\u003e 加密封包 到加密封包的外层找明文包。 找出明文封包的步骤： graph LR 加密封包 --\u003e Ctrl+F9到外层找明文包 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:5:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"找出加密CALL 找出加密CALL的步骤： graph z1[\"找出已加密的最外层\"]--\u003e z2[\"找出明文封包\"]--\u003e z3[\"进入明文包\"]--\u003e z4[\"先走一圈，并标注跳转\"] z5[\"回到明文封包外部\"]--\u003e z6[\"下断\"]--\u003e z7[\"喊话\"]--\u003e z8[\"dd 明文封包内容\"]--\u003e z9[\"F7进入明文封包\"]--\u003e z10[\"F8逐步走，并观察内存窗口中明文封包何时变化\"]--\u003e z11[\"如果经过某个call之后，内存窗口内容变化\"]--\u003e z12[\"找到加密CALL\"]--\u003e z13([\"覆盖式加密\"]) z10--\u003e没有变化--\u003e x1([\"复制式加密\"])--\u003e|没遇到过|需要从明文包开始逐步分析--\u003e 看到底哪里利用过包地址或者包内容 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:6:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"分析加密CALL 需要分析的元素： CALL的参数 包长 包地址 加密地址 加密长度 密钥（找到就行） CALL内的寄存器 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:7:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"调用加密CALL加密 实例 push 12345678 push 12345678 push 11 mov ecx,[00f84ba4] mov ecx,[ecx] mov ecx.[ecx+4] mov ecx,[ecx+14] mov ecx, [ecx] lea ecx,[ecx+54] push ecx call 00B94700 add esp, 10 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:8:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"发送喊话函数封包 void HXSYDialog::OnBnClickedEutton15() { byte a[100] = {0x11,0x00,0x7E,0x00,0x00,0x00,0x00,0x02,0x00,0x31,0x31, OFF, OxFF,OxFF,OxFF,0x00,0x00,0x00,0x00,0x60,0xA8,0x6C}: DWORD 包长 = 0x13; DWORD 包地址=(DWORD)a; DWORD 加密地址 = 包地址+2; DWORD 加密长度 = 包长-2; __asm { push 加密地址 push 加密地址 push 加密长度 mov ecx, 0x00f84ba4 mov ecx, [ecx] mov ecx, [ecx] mov ecx, [ecx+0x4] mov ecx, [ecx+0x14] mov ecx, [ecx] lea ecx, [ecx+0x54] push ecx mov eax, 0x00B94700 call eax add esp, 0x10 } HWND 窗口句柄=FindWindowA(\"Lapis Network C1ass\",0); DWORD A=GetWindowLongW(窗口句柄，-21); DWORD S=*(DWORD*)(A+0x38); send(S,(const char*)包地址,包长,0); //TODO：在此添加控件通知处理程序代码 } ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:9:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"C++写 加密CALL __declspec(naked) void 加密Ca11(DWORD秘钥,DWORD 加密长度,DWOED 加密地址,DWORD 加密地址2) { __asm { ... } } //__declspec(naked) 裸体函数 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:10:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"结合加密call，写加密封包，完全不走游戏代码 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:11:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"不走游戏代码，写吃药封包 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:11:1","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"收包recv recv也存在重写问题 graph LR subgraph 收包正常流程 z1[\"recv\"] z2[\"明文收包\"] z3[\"加密\"] z4[\"解密\"] z5[\"反复MemoryCopy\"] z6[\"写入内存\"] end z1--\u003ez3--\u003ez4--\u003ez2--\u003ez5--\u003ez6 graph LR z1[\"recv下断\"] z3[\"正常操作\"] z4[\"寻找明文收包\"] z5[\"recv被重写\"] z6[\"双开喊话\"] z1--\u003e|可断|z3 z1--\u003e|不可断|z5--\u003ez4--\u003ez6--\u003eA喊--\u003eB搜索--\u003e反复验证并最终确定--\u003e向上层返回--\u003e直到找到明文收包 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:12:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":null,"content":"控件包 graph 在明文包处--\u003e |下条件断 过滤心跳包|通过会触发向服务器发包的功能按键--\u003e z1[\"触发执行断点\"]--\u003e 堆栈 \u0026 K键堆栈 \u0026 z2[\"外层(推荐)\"] z2--\u003e 逐层验证并确定 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/:13:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包、收包","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85/"},{"categories":["C++"],"content":"C++ 异常处理 C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。 double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"捕获异常 catch 块跟在 try 块后面，用于捕获异常。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示： try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 实例 #include \u003ciostream\u003e using namespace std; double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout \u003c\u003c z \u003c\u003c endl; }catch (const char* msg) { cerr \u003c\u003c msg \u003c\u003c endl; } return 0; } 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： Division by zero condition! ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 标准的异常 C++ 提供了一系列标准的异常，定义在 \u003cexception\u003e 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset\u003c\u003e::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"定义新的异常 您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 实例 #include \u003ciostream\u003e #include \u003cexception\u003e using namespace std; struct MyException : public exception { const char * what () const throw () { return \"C++ Exception\"; } }; int main() { try { throw MyException(); } catch(MyException\u0026 e) { std::cout \u003c\u003c \"MyException caught\" \u003c\u003c std::endl; std::cout \u003c\u003c e.what() \u003c\u003c std::endl; } catch(std::exception\u0026 e) { //其他的错误 } } 这将产生以下结果： MyException caught C++ Exception 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。 菜鸟官方笔记 在 C++11 中，声明一个函数不可以抛出任何异常使用关键字 noexcept。 void mightThrow(); // could throw any exceptions. void doesNotThrow() noexcept; // does not throw any exceptions. 下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常。 void old_stytle() throw(); void new_style() noexcept; 对于: const char * what () const throw () { //函数体 } 做几点说明，从左到右看： const char * 表示返回值类型 what 是函数名称 () 是参数列表 const 表示该成员函数不能修改成员变量 throw() 是异常规格说明符。括号内写该函数可抛出的异常类型 上述 5 点均为函数的声明部分。 ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： ofstream outfile; outfile.open(\"file.dat\", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： ifstream afile; afile.open(\"file.dat\", ios::out | ios::in ); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"关闭文件 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"写入文件 在 C++ 编程中，我们使用流插入运算符（ « ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取文件 在 C++ 编程中，我们使用流提取运算符（ » ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取 \u0026 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"实例 #include \u003cfstream\u003e #include \u003ciostream\u003e using namespace std; int main () { char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cout \u003c\u003c \"Writing to the file\" \u003c\u003c endl; cout \u003c\u003c \"Enter your name: \"; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; cout \u003c\u003c \"Enter your age: \"; cin \u003e\u003e data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); cout \u003c\u003c \"Reading from the file\" \u003c\u003c endl; infile \u003e\u003e data; // 在屏幕上写入数据 cout \u003c\u003c data \u003c\u003c endl; // 再次从文件读取数据，并显示它 infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 infile.close(); return 0; } 当上面的代码被编译和执行时，它会产生下列输入和输出： $./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"文件位置指针 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（“seek get”）和关于 ostream 的 seekp（“seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"C++ 异常处理 异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示： try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。 以下是尝试除以零时抛出异常的实例： double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"捕获异常 catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示： try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 实例 #include \u003ciostream\u003e using namespace std; double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout \u003c\u003c z \u003c\u003c endl; }catch (const char* msg) { cerr \u003c\u003c msg \u003c\u003c endl; } return 0; } 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： Division by zero condition! ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 标准的异常 C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset\u003c\u003e::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"定义新的异常 您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 实例 #include \u003ciostream\u003e #include \u003cexception\u003e using namespace std; struct MyException : public exception { const char * what () const throw () { return \"C++ Exception\"; } }; int main() { try { throw MyException(); } catch(MyException\u0026 e) { std::cout \u003c\u003c \"MyException caught\" \u003c\u003c std::endl; std::cout \u003c\u003c e.what() \u003c\u003c std::endl; } catch(std::exception\u0026 e) { //其他的错误 } } 这将产生以下结果： MyException caught C++ Exception 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 动态内存 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分： **栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点： double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; if( !(pvalue = new double )) { cout \u003c\u003c \"Error: out of memory.\" \u003c\u003cendl; exit(1); } malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示： delete pvalue; // 释放 pvalue 所指向的内存 下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符： 实例 #include \u003ciostream\u003e using namespace std; int main () { double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout \u003c\u003c \"Value of pvalue : \" \u003c\u003c *pvalue \u003c\u003c endl; delete pvalue; // 释放内存 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of pvalue : 29495 ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"数组的动态内存分配 假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示： char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 要删除我们刚才创建的数组，语句如下： delete [] pvalue; // 删除 pvalue 所指向的数组 下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示： 一维数组 // 动态分配,数组长度为 m int *array=new int [m]; //释放内存 delete [] array; 二维数组 int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int [n] ; } //释放 for( int i=0; i\u003cm; i++ ) { delete [] array[i]; } delete [] array; 二维数组实例测试： 实例 #include \u003ciostream\u003e using namespace std; int main() { int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i\u003c4;i++){ p[i]=new int [8]; } for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++){ p[i][j] = j*i; } } //打印数据 for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++) { if(j==0) cout\u003c\u003cendl; cout\u003c\u003cp[i][j]\u003c\u003c\"\\t\"; } } //开始释放申请的堆 for(i=0; i\u003c4; i++){ delete [] p[i]; } delete [] p; return 0; } 三维数组 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int *[n]; for( int j=0; j\u003cn; j++ ) { array[i][j] = new int [h]; } } //释放 for( int i=0; i\u003cm; i++ ) { for( int j=0; j\u003cn; j++ ) { delete[] array[i][j]; } delete[] array[i]; } delete[] array; 三维数组测试实例： 实例 #include \u003ciostream\u003e using namespace std; int main() { int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i\u003c2; i++) { p[i]=new int *[3]; for(j=0; j\u003c3; j++) p[i][j]=new int[4]; } //输出 p[i][j][k] 三维数据 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { for(k=0;k\u003c4;k++) { p[i][j][k]=i+j+k; cout\u003c\u003cp[i][j][k]\u003c\u003c\" \"; } cout\u003c\u003cendl; } cout\u003c\u003cendl; } // 释放内存 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { delete [] p[i][j]; } } for(i=0; i\u003c2; i++) { delete [] p[i]; } delete [] p; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"对象的动态内存分配 对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念： 实例 #include \u003ciostream\u003e using namespace std; class Box { public: Box() { cout \u003c\u003c \"调用构造函数！\" \u003c\u003cendl; } ~Box() { cout \u003c\u003c \"调用析构函数！\" \u003c\u003cendl; } }; int main( ) { Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++ 命名空间 假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。 同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。 因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。 ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： namespace namespace_name { // 代码声明 } 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围： 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int main () { // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space Inside second_space ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"using 指令 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } using namespace first_space; int main () { // 调用第一个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： using std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示： 实例 #include \u003ciostream\u003e using std::cout; int main () { cout \u003c\u003c \"std::endl is used with std!\" \u003c\u003c std::endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： std::endl is used with std! using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： namespace namespace_name { // 代码声明 } ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示： namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } 您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员： // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示： 实例 #include \u003ciostream\u003e using namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } } using namespace first_space::second_space; int main () { // 调用第二个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside second_space ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。 您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。 ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"函数模板 模板函数定义的一般形式如下所示： template \u003ctypename type\u003e ret-type func-name(parameter list) { // 函数的主体 } 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 下面是函数模板的实例，返回两个数中的最大值： 实例 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max (T const\u0026 a, T const\u0026 b) { return a \u003c b ? b:a; } int main () { int i = 39; int j = 20; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： template \u003cclass type\u003e class class-name { . . . } 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack\u003c\u003e，并实现了泛型方法来对元素进行入栈出栈操作： ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003ccstdlib\u003e #include \u003cstring\u003e #include \u003cstdexcept\u003e using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; // 元素 public: void push(T const\u0026); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push (T const\u0026 elem) { // 追加传入元素的副本 elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop () { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top () const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; // int 类型的栈 Stack\u003cstring\u003e stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout \u003c\u003c intStack.top() \u003c\u003cendl; // 操作 string 类型的栈 stringStack.push(\"hello\"); cout \u003c\u003c stringStack.top() \u003c\u003c std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003cendl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果： 7 hello Exception: Stack\u003c\u003e::pop(): empty stack ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"C++ 预处理器 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。 我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。 C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： #include \u003ciostream\u003e using namespace std; #define PI 3.14159 int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c PI \u003c\u003c endl; return 0; } 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下： $ gcc -E test.cpp \u003e test.p ... int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c 3.14159 \u003c\u003c endl; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"参数宏 您可以使用 #define 来定义一个带有参数的宏，如下所示： #include \u003ciostream\u003e using namespace std; #define MIN(a,b) (a\u003cb ? a : b) int main () { int i, j; i = 100; j = 30; cout \u003c\u003c\"较小的值为：\" \u003c\u003c MIN(i, j) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 较小的值为：30 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码： #ifdef NULL #define NULL 0 #endif 您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： #ifdef DEBUG cerr \u003c\u003c\"Variable x = \" \u003c\u003c x \u003c\u003c endl; #endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示： #if 0 不进行编译的代码 #endif 让我们尝试下面的实例： 实例 #include \u003ciostream\u003e using namespace std; #define DEBUG #define MIN(a,b) (((a)\u003c(b)) ? a : b) int main () { int i, j; i = 100; j = 30; #ifdef DEBUG cerr \u003c\u003c\"Trace: Inside main function\" \u003c\u003c endl; #endif #if 0 /* 这是注释部分 */ cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; #endif cout \u003c\u003c\"The minimum is \" \u003c\u003c MIN(i, j) \u003c\u003c endl; #ifdef DEBUG cerr \u003c\u003c\"Trace: Coming out of main function\" \u003c\u003c endl; #endif return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Trace: Inside main function The minimum is 30 Trace: Coming out of main function ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 请看下面的宏定义： 实例 #include \u003ciostream\u003e using namespace std; #define MKSTR( x ) #x int main () { cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： HELLO C++ 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; 转换成了： cout \u003c\u003c \"HELLO C++\" \u003c\u003c endl; ## 运算符用于连接两个令牌。下面是一个实例： #define CONCAT( x, y ) x ## y 当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++\"，如下面实例所示。 实例 #include \u003ciostream\u003e using namespace std; #define concat(a, b) a ## b int main() { int xy = 100; cout \u003c\u003c concat(x, y); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 100 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c concat(x, y); 转换成了： cout \u003c\u003c xy; ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 中的预定义宏 C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 让我们看看上述这些宏的实例： ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Value of __LINE__ : \" \u003c\u003c __LINE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __FILE__ : \" \u003c\u003c __FILE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __DATE__ : \" \u003c\u003c __DATE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __TIME__ : \" \u003c\u003c __TIME__ \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of __LINE__ : 6 Value of __FILE__ : test.cpp Value of __DATE__ : Feb 28 2011 Value of __TIME__ : 18:52:48 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 程序终止(interrupt)信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"signal() 函数 C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： void (*signal (int sig, void (*func)(int)))(int); 这个看起来有点费劲，以下语法格式更容易理解： signal(registered signal, signal handler) 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。 让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例： 实例 #include \u003ciostream\u003e #include \u003ccsignal\u003e #include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(1){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Going to sleep.... Going to sleep.... Going to sleep.... 现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"raise() 函数 您可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下： int raise (signal sig); 在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例： 实例 #include \u003ciostream\u003e #include \u003ccsignal\u003e #include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; if( i == 3 ){ raise( SIGINT); } sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果，并会自动退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"创建线程 下面的程序，我们可以用它来创建一个 POSIX 线程： #include \u003cpthread.h\u003e pthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"终止线程 使用下面的程序，我们可以用它来终止一个 POSIX 线程： #include \u003cpthread.h\u003e pthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"实例 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\": 实例 #include \u003ciostream\u003e // 必须的头文件 #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 // 线程的运行函数 void* say_hello(void* args) { cout \u003c\u003c \"Hello Runoob！\" \u003c\u003c endl; return 0; } int main() { // 定义线程的 id 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for(int i = 0; i \u003c NUM_THREADS; ++i) { //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(\u0026tids[i], NULL, say_hello, NULL); if (ret != 0) { cout \u003c\u003c \"pthread_create error: error_code=\" \u003c\u003c ret \u003c\u003c endl; } } //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来； pthread_exit(NULL); } 使用 -lpthread 库编译下面的程序： $ g++ test.cpp -lpthread -o test.o 现在，执行程序，将产生下列结果： $ ./test.o Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。 实例 //文件名：test.cpp #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 void *PrintHello(void *threadid) { // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout \u003c\u003c \"Hello Runoob! 线程 ID, \" \u003c\u003c tid \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; int indexes[NUM_THREADS];// 用数组来保存i的值 int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : 创建线程, \" \u003c\u003c i \u003c\u003c endl; indexes[i] = i; //先保存i的值 // 传入的时候必须强制转换为void* 类型，即无类型指针 rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026(indexes[i])); if (rc){ cout \u003c\u003c \"Error:无法创建线程,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 现在编译并执行程序，将产生下列结果： $ g++ test.cpp -lpthread -o test.o $ ./test.o main() : 创建线程, 0 main() : 创建线程, 1 Hello Runoob! 线程 ID, 0 main() : 创建线程, Hello Runoob! 线程 ID, 21 main() : 创建线程, 3 Hello Runoob! 线程 ID, 2 main() : 创建线程, 4 Hello Runoob! 线程 ID, 3 Hello Runoob! 线程 ID, 4 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"向线程传递参数 这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示： 实例 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg) { struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout \u003c\u003c \"Thread ID : \" \u003c\u003c my_data-\u003ethread_id ; cout \u003c\u003c \" Message : \" \u003c\u003c my_data-\u003emessage \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c\"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; td[i].thread_id = i; td[i].message = (char*)\"This is message\"; rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026td[i]); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： $ g++ -Wno-write-strings test.cpp -lpthread -o test.o $ ./test.o main() : creating thread, 0 main() : creating thread, 1 Thread ID : 0 Message : This is message main() : creating thread, Thread ID : 21 Message : This is message main() : creating thread, 3 Thread ID : 2 Message : This is message main() : creating thread, 4 Thread ID : 3 Message : This is message Thread ID : 4 Message : This is message ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"连接和分离线程 我们可以使用以下两个函数来连接或分离线程： pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。 实例 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cpthread.h\u003e #include \u003cunistd.h\u003e using namespace std; #define NUM_THREADS 5 void *wait(void *t) { int i; long tid; tid = (long)t; sleep(1); cout \u003c\u003c \"Sleeping in thread \" \u003c\u003c endl; cout \u003c\u003c \"Thread with id : \" \u003c\u003c tid \u003c\u003c \" ...exiting \" \u003c\u003c endl; pthread_exit(NULL); } int main () { int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_JOINABLE); for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; rc = pthread_create(\u0026threads[i], NULL, wait, (void *)\u0026i ); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } // 删除属性，并等待其他线程 pthread_attr_destroy(\u0026attr); for( i=0; i \u003c NUM_THREADS; i++ ){ rc = pthread_join(threads[i], \u0026status); if (rc){ cout \u003c\u003c \"Error:unable to join,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } cout \u003c\u003c \"Main: completed thread id :\" \u003c\u003c i ; cout \u003c\u003c \" exiting with status :\" \u003c\u003c status \u003c\u003c endl; } cout \u003c\u003c \"Main: program exiting.\" \u003c\u003c endl; pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Sleeping in thread Thread with id : 4 ...exiting Sleeping in thread Thread with id : 3 ...exiting Sleeping in thread Thread with id : 2 ...exiting Sleeping in thread Thread with id : 1 ...exiting Sleeping in thread Thread with id : 0 ...exiting Main: completed thread id :0 exiting with status :0 Main: completed thread id :1 exiting with status :0 Main: completed thread id :2 exiting with status :0 Main: completed thread id :3 exiting with status :0 Main: completed thread id :4 exiting with status :0 Main: program exiting. 更多实例参考：http://www.runoob.com/w3cnote/cpp-multithread-demo.html ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"C++ Web 编程 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。 公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 架构图 下图演示了 CGI 的架构： ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi。 默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分： \u003cDirectory \"/var/www/cgi-bin\"\u003e AllowOverride None Options ExecCGI Order allow,deny Allow from all \u003c/Directory\u003e \u003cDirectory \"/var/www/cgi-bin\"\u003e Options All \u003c/Directory\u003e 在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"第一个 CGI 程序 请看下面的 C++ 程序： 实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eHello World - 第一个 CGI 程序\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ch2\u003eHello World! 这是我的第一个 CGI 程序\u003c/h2\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 chmod 755 cplusplus.cgi UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出： ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Hello World! 这是我的第一个 CGI 程序 上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 Content-type:text/html\\r\\n\\r\\n。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"HTTP 头信息 行 Content-type:text/html\\r\\n\\r\\n 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下： HTTP 字段名称: 字段内容 例如 Content-type: text/html\\r\\n\\r\\n 还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。 头信息 描述 Content-type: MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 Expires: Date 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 Location: URL 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 Last-modified: Date 资源的最后修改日期。 Content-length: N 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 Set-Cookie: String 通过 string 设置 cookie。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 环境变量 所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。 变量名 描述 CONTENT_TYPE 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 CONTENT_LENGTH 查询的信息长度。只对 POST 请求可用。 HTTP_COOKIE 以键 \u0026 值对的形式返回设置的 cookies。 HTTP_USER_AGENT 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 PATH_INFO CGI 脚本的路径。 QUERY_STRING 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 REMOTE_ADDR 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 REMOTE_HOST 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 REQUEST_METHOD 用于发出请求的方法。最常见的方法是 GET 和 POST。 SCRIPT_FILENAME CGI 脚本的完整路径。 SCRIPT_NAME CGI 脚本的名称。 SERVER_NAME 服务器的主机名或 IP 地址。 SERVER_SOFTWARE 服务器上运行的软件的名称和版本。 下面的 CGI 程序列出了所有的 CGI 变量。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cstdlib.h\u003e #include \u003cstring\u003e using namespace std; const string ENV[ 24 ] = { \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\", \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\", \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\", \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\", \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\", \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\", \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\", \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\", \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" }; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 环境变量\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\" cellspacing = \\\"2\\\"\u003e\"; for ( int i = 0; i \u003c 24; i++ ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c ENV[ i ] \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; // 尝试检索环境变量的值 char *value = getenv( ENV[ i ].c_str() ); if ( value != 0 ){ cout \u003c\u003c value; }else{ cout \u003c\u003c \"环境变量不存在。\"; } cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:9:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ CGI 库 在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 ftp://ftp.gnu.org/gnu/cgicc/ 上下载这个 CGI 库，并按照下面的步骤安装库： $ tar xzf cgicc-X.X.X.tar.gz $ cd cgicc-X.X.X/ $ ./configure --prefix=/usr $ make $ make install **注意：**libcgicc.so 和 libcgicc.a 库会被安装到/usr/lib目录下，需执行拷贝命令： $ sudo cp /usr/lib/libcgicc.* /usr/lib64/ 才能使 CGI 程序自动找到 libcgicc.so 动态链接库。 您可以点击 C++ CGI Lib Documentation，查看相关的库文档。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:10:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"GET 和 POST 方法 您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:11:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 GET 方法传递信息 GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示： http://www.test.com/cgi-bin/cpp.cgi?key1=value1\u0026key2=value2 GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。 当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。 您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML 标签的 GET 方法来传信息。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:12:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的 URL 实例：Get 方法 下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。 /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 下面的实例生成 cpp_get.cgi CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e使用 GET 和 POST 方法\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"first_name\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"名：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for first name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; fi = formData.getElement(\"last_name\"); if( !fi-\u003eisEmpty() \u0026\u0026fi != (*formData).end()) { cout \u003c\u003c \"姓：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for last name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，如下所示： $g++ -o cpp_get.cgi cpp_get.cpp -lcgicc 生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问： /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 这会产生以下结果： 名：ZARA 姓：ALI ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:13:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的表单实例：GET 方法 下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。 \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"get\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e \u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:14:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 POST 方法传递信息 一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。 我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示： \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"post\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e\u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:15:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递复选框数据 当需要选择多个选项时，我们使用复选框。 下面的 HTML 代码实例是一个带有两个复选框的表单： \u003cform action=\"/cgi-bin/cpp_checkbox.cgi\" method=\"POST\" target=\"_blank\"\u003e \u003cinput type=\"checkbox\" name=\"maths\" value=\"on\" /\u003e 数学 \u003cinput type=\"checkbox\" name=\"physics\" value=\"on\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; bool maths_flag, physics_flag; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递复选框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; maths_flag = formData.queryCheckbox(\"maths\"); if( maths_flag ) { cout \u003c\u003c \"Maths Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Maths Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; physics_flag = formData.queryCheckbox(\"physics\"); if( physics_flag ) { cout \u003c\u003c \"Physics Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Physics Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:16:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递单选按钮数据 当只需要选择一个选项时，我们使用单选按钮。 下面的 HTML 代码实例是一个带有两个单选按钮的表单： \u003cform action=\"/cgi-bin/cpp_radiobutton.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cinput type=\"radio\" name=\"subject\" value=\"maths\" checked=\"checked\"/\u003e 数学 \u003cinput type=\"radio\" name=\"subject\" value=\"physics\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递单选按钮数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"subject\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Radio box selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:17:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递文本区域数据 当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。 下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单： \u003cform action=\"/cgi-bin/cpp_textarea.cgi\" method=\"post\" target=\"_blank\"\u003e \u003ctextarea name=\"textcontent\" cols=\"40\" rows=\"4\"\u003e 请在这里输入文本... \u003c/textarea\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递文本区域数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"textcontent\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Text Content: \" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:18:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递下拉框数据 当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。 下面的 HTML 代码实例是一个带有下拉框的表单： \u003cform action=\"/cgi-bin/cpp_dropdown.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cselect name=\"dropdown\"\u003e \u003coption value=\"Maths\" selected\u003e数学\u003c/option\u003e \u003coption value=\"Physics\"\u003e物理\u003c/option\u003e \u003c/select\u003e \u003cinput type=\"submit\" value=\"提交\"/\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递下拉框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"dropdown\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Value Selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:19:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"在 CGI 中使用 Cookies HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。 在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"它是如何工作的 服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。 cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段： Expires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。 Domain : 网站的域名。 Path : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。 Secure : 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。 Name=Value : cookie 以键值对的形式被设置和获取。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"设置 Cookies 向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示： 实例 #include \u003ciostream\u003e using namespace std; int main () { cout \u003c\u003c \"Set-Cookie:UserID=XYZ;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Password=XYZ123;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Path=/perl;\\n\"; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"设置 cookies\" \u003c\u003c endl; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 从这个实例中，我们了解了如何设置 cookies。我们使用 Set-Cookie HTTP 头来设置 cookies。 在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 “Content-type:text/html\\r\\n\\r\\n 之前被设置的。 编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies： /cgi-bin/setcookies.cgi ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"获取 Cookies 检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下： key1=value1;key2=value2;key3=value3.... 下面的实例演示了如何获取 cookies。 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; const_cookie_iterator cci; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\" cellspacing = \\\"2\\\"\u003e\"; // 获取环境变量 const CgiEnvironment\u0026 env = cgi.getEnvironment(); for( cci = env.getCookieList().begin(); cci != env.getCookieList().end(); ++cci ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c cci-\u003egetName() \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; cout \u003c\u003c cci-\u003egetValue(); cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies： /cgi-bin/getcookies.cgi 这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies： UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:3","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"文件上传实例 为了上传一个文件，HTML 表单必须把 enctype 属性设置为 multipart/form-data。带有文件类型的 input 标签会创建一个 “Browse” 按钮。 \u003chtml\u003e \u003cbody\u003e \u003cform enctype=\"multipart/form-data\" action=\"/cgi-bin/cpp_uploadfile.cgi\" method=\"post\"\u003e \u003cp\u003e文件：\u003cinput type=\"file\" name=\"userfile\" /\u003e\u003c/p\u003e \u003cp\u003e\u003cinput type=\"submit\" value=\"上传\" /\u003e\u003c/p\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 这段代码的结果是下面的表单： **注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。 下面是用于处理文件上传的脚本 cpp_uploadfile.cpp： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的文件上传\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; // 获取要被上传的文件列表 const_file_iterator file = cgi.getFile(\"userfile\"); if(file != cgi.getFiles().end()) { // 在 cout 中发送数据类型 cout \u003c\u003c HTTPContentHeader(file-\u003egetDataType()); // 在 cout 中写入内容 file-\u003ewriteToStream(cout); } cout \u003c\u003c \"\u003c文件上传成功\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 上面的实例是在 cout 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:21:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求： 实例 #include \u003ciostream\u003e #include \u003cvector\u003e using namespace std; int main() { // 创建一个向量存储 int vector\u003cint\u003e vec; int i; // 显示 vec 的原始大小 cout \u003c\u003c \"vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 推入 5 个值到向量中 for(i = 0; i \u003c 5; i++){ vec.push_back(i); } // 显示 vec 扩展后的大小 cout \u003c\u003c \"extended vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 访问向量中的 5 个值 for(i = 0; i \u003c 5; i++){ cout \u003c\u003c \"value of vec [\" \u003c\u003c i \u003c\u003c \"] = \" \u003c\u003c vec[i] \u003c\u003c endl; } // 使用迭代器 iterator 访问值 vector\u003cint\u003e::iterator v = vec.begin(); while( v != vec.end()) { cout \u003c\u003c \"value of v = \" \u003c\u003c *v \u003c\u003c endl; v++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： vector size = 0 extended vector size = 5 value of vec [0] = 0 value of vec [1] = 1 value of vec [2] = 2 value of vec [3] = 3 value of vec [4] = 4 value of v = 0 value of v = 1 value of v = 2 value of v = 3 value of v = 4 关于上面实例中所使用的各种函数，有几点要注意： push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。 size( ) 函数显示向量的大小。 begin( ) 函数返回一个指向向量开头的迭代器。 end( ) 函数返回一个指向向量末尾的迭代器。 ","date":"2021-09-13","objectID":"/2021/09/c-40stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 40STL 教程","uri":"/2021/09/c-40stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 标准库 C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"标准函数库 标准函数库分为以下几类： 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"面向对象类库 标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"C++ 有用的资源 以下资源包含了 C++ 有关的网站、书籍和文章。请使用它们来进一步学习 C++ 的知识。 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 有用的网站 C++ Standard Library headers − C++ 标准库。 C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。 C++ FAQ − C++ 常见问题 Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。 C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 有用的书籍 《Essential C++ 中文版》 《C++ Primer Plus 第6版中文版》 《C++ Primer中文版（第5版）》 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 实例 C++ 实例 - 输出 “Hello, World!” C++ 实例 - 标准输入输出 C++ 实例 - 输出换行 C++ 实例 - 实现两个数相加 C++ 实例 - 创建不同类型的变量 C++ 实例 - 求商及余数 C++ 实例 - 查看 int, float, double 和 char 变量大小 C++ 实例 - 交换两个数 C++ 实例 - 判断一个数是奇数还是偶数 C++ 实例 - 判断元音/辅音 C++ 实例 - 判断三个数中的最大数 C++ 实例 - 求一元二次方程的根 C++ 实例 - 计算自然数之和 C++ 实例 - 判断闰年 C++ 实例 - 求一个数的阶乘 C++ 实例 - 创建各类三角形图案 C++ 实例 - 求两数的最大公约数 C++ 实例 - 求两数最小公倍数 C++ 实例 - 实现一个简单的计算器 猴子吃桃问题 ","date":"2021-09-13","objectID":"/2021/09/c-43%E5%AE%9E%E4%BE%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 43实例","uri":"/2021/09/c-43%E5%AE%9E%E4%BE%8B/"},{"categories":["C++"],"content":"C++ 文件和流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 \u003ciostream\u003e 和 \u003cfstream\u003e。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"打开文件 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： ofstream outfile; outfile.open(\"file.dat\", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： ifstream afile; afile.open(\"file.dat\", ios::out | ios::in ); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"关闭文件 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"写入文件 在 C++ 编程中，我们使用流插入运算符（ « ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取文件 在 C++ 编程中，我们使用流提取运算符（ » ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取 \u0026 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"实例 #include \u003cfstream\u003e #include \u003ciostream\u003e using namespace std; int main () { char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cout \u003c\u003c \"Writing to the file\" \u003c\u003c endl; cout \u003c\u003c \"Enter your name: \"; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; cout \u003c\u003c \"Enter your age: \"; cin \u003e\u003e data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); cout \u003c\u003c \"Reading from the file\" \u003c\u003c endl; infile \u003e\u003e data; // 在屏幕上写入数据 cout \u003c\u003c data \u003c\u003c endl; // 再次从文件读取数据，并显示它 infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 infile.close(); return 0; } 当上面的代码被编译和执行时，它会产生下列输入和输出： $./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"文件位置指针 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（“seek get”）和关于 ostream 的 seekp（“seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。 就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签： 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"数据抽象的好处 数据抽象有两个重要的优势： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"数据抽象的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是用户不需要了解的，但又是类能正常工作所必需的。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。 在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据封装 所有的 C++ 程序都有以下两个基本要素： **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制。 数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"数据封装的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"C++ 接口（抽象类） C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示： class Box { public: // 纯虚函数 virtual double getVolume() = 0; private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。 可用于实例化对象的类被称为具体类。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()： 实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Rectangle area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Triangle area: \" \u003c\u003c Tri.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total Rectangle area: 35 Total Triangle area: 17 从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。 外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。 这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 下面的实例中，基类 Shape 被派生为两个类，如下所示： 实例 #include \u003ciostream\u003e using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Rectangle class area :\" \u003c\u003cendl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Triangle class area :\" \u003c\u003cendl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = \u0026rec; // 调用矩形的求面积函数 area shape-\u003earea(); // 存储三角形的地址 shape = \u0026tri; // 调用三角形的求面积函数 area shape-\u003earea(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Parent class area Parent class area 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; 修改后，当编译和执行前面的实例代码时，它会产生以下结果： Rectangle class area Triangle class area 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"虚函数 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"纯虚函数 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 我们可以把基类中的虚函数 area() 改写如下： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; }; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 继承 // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"基类 \u0026 派生类 类派生列表以一个或多个基类命名，形式如下： class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 假设有一个基类 Shape，Rectangle 是它的派生类，如下所示： #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"访问控制和继承 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： class \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,… { \u003c派生类类体\u003e }; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; // 输出总花费 cout \u003c\u003c \"Total paint cost: $\" \u003c\u003c Rect.getCost(area) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 Total paint cost: $2450 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"C++ 重载运算符和重载函数 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的函数重载 同名函数 print() 被用于输出不同的数据类型： #include \u003ciostream\u003e using namespace std; class printData { public: void print(int i) { cout \u003c\u003c \"整数为: \" \u003c\u003c i \u003c\u003c endl; } void print(double f) { cout \u003c\u003c \"浮点数为: \" \u003c\u003c f \u003c\u003c endl; } void print(char c[]) { cout \u003c\u003c \"字符串为: \" \u003c\u003c c \u003c\u003c endl; } }; int main(void) { printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = \"Hello C++\"; pd.print(c); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 整数为: 5 浮点数为: 500.263 字符串为: Hello C++ ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的运算符重载 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box\u0026); 在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： #include \u003ciostream\u003e using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"可重载运算符/不可重载运算符 下面是可重载的运算符列表： 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，\u003c (小于)，\u003e (大于)，\u003c=(小于等于)，\u003e=(大于等于) 逻辑运算符 ||(逻辑或)，\u0026\u0026(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，\u0026(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，\u0026 (按位与)，~(按位取反)，^(按位异或),，« (左移)，»(右移) 赋值运算符 =, +=, -=, *=, /= , % = , \u0026=, |=, ^=, «=, »= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-\u003e(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -\u003e*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"运算符重载实例 下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。 序号 运算符和实例 1 一元运算符重载 2 二元运算符重载 3 关系运算符重载 4 输入/输出运算符重载 5 ++ 和 – 运算符重载 6 赋值运算符重载 7 函数调用运算符 () 重载 8 [下标运算符 ] 重载 9 类成员访问运算符 -\u003e 重载 C++ 一元运算符重载 递增运算符（ ++ ）和递减运算符（ – ） 一元减运算符，即负号（ - ） 逻辑非运算符（ ! ） #include \u003ciostream\u003e using namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // 显示距离的方法 void displayDistance() { cout \u003c\u003c \"F: \" \u003c\u003c feet \u003c\u003c \" I:\" \u003c\u003c inches \u003c\u003cendl; } // 重载负运算符（ - ） Distance operator- () { feet = -feet; inches = -inches; return Distance(feet, inches); } }; int main() { Distance D1(11, 10), D2(-5, 11); -D1; // 取相反数 D1.displayDistance(); // 距离 D1 -D2; // 取相反数 D2.displayDistance(); // 距离 D2 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： F: -11 I:-10 F: 5 I:-11 C++ 二元运算符重载 加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。 #include \u003ciostream\u003e using namespace std; class Box { double length; // 长度 double breadth; // 宽度 double height; // 高度 public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 C++ 关系运算符重载 C++ 语言支持各种关系运算符（ \u003c 、 \u003e 、 \u003c= 、 \u003e= 、 == 等等） #include \u003ciostream\u003e using namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // 显示距离的方法 void displayDistance() { cout \u003c\u003c \"F: \" \u003c\u003c feet \u003c\u003c \" I:\" \u003c\u003c inches \u003c\u003cendl; } // 重载负运算符（ - ） Distance operator- () { feet = -feet; inches = -inches; return Distance(feet, inches); } // 重载小于运算符（ \u003c ） bool operator \u003c(const Distance\u0026 d) { if(feet \u003c d.feet) { return true; } if(feet == d.feet \u0026\u0026 inches \u003c d.inches) { return true; } return false; } }; int main() { Distance D1(11, 10), D2(5, 11); if( D1 \u003c D2 ) { cout \u003c\u003c \"D1 is less than D2 \" \u003c\u003c endl; } else { cout \u003c\u003c \"D2 is less than D1 \" \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： D2 is less than D1 C++ 输入/输出运算符重载 C++ 能够使用流提取运算符 \u003e\u003e 和流插入运算符 « 来输入和输出内置的数据类型。 有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。 #include \u003ciostream\u003e using namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } friend ostream \u0026operator\u003c\u003c( ostream \u0026output, const Distance \u0026D ) { output \u003c\u003c \"F : \" \u003c\u003c D.feet \u003c\u003c \" I : \" \u003c\u003c D.inches; return output; } friend istream \u0026operator\u003e\u003e( istream \u0026input, Distance \u0026D ) { input \u003e\u003e D.feet \u003e\u003e D.inches; return input; } }; int main() { Distance D1(11, 10), D2(5, 11), D3; cout \u003c\u003c \"Enter the value of object : \" \u003c\u003c endl; cin \u003e\u003e D3; cout \u003c\u003c \"First Distance : \" \u003c\u003c D1 \u003c\u003c endl; cout \u003c\u003c \"Second Distance :\" \u003c\u003c D2 \u003c\u003c endl; cout \u003c\u003c \"Third Distance :\" \u003c\u003c D3 \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： $./a.out Enter the value of object : 70 10 First Distance : F : 11 I : 10 Second Distance :F : 5 I : 11 Third Distance :F : 70 I : 10 C++ ++ 和 – 运算符重载 #include \u003ciostream\u003e using namespace std; class Time { private: int hours; // 0 到","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["任鸟飞","C++"],"content":"C++ 逆向 C++编程原理 软件安全 破解与防破解 外挂与反外挂 病毒分析 灵魂起源 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:0:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"创建DLL并且注入窗口中 实例 //唯一的一个 C我们的DLLApp 对象 C我们的DLLApp theApp; CMyDialog *PMainDialog; //窗口类 DWORD WINAPI ShowDialog(LPARAM lpData) { PMainDialog = new CMyDialog; //给指针分配空间 PMainDialog-\u003eDoModal(); //阻塞的方式 模态窗口 delete PMainDialog; //释放空间 FreeLibraryAndExitThread(theApp.m_hInstance,1); //释放DLL退出线程 return TRUE; } // C我们的DLLApp 初始化 BOOL C我们的DLLApp::InitInstance() { CWinApp::InitInstance(); ::CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)ShowDialog,NULL,NULL,NULL); //创建线程 return TRUE; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"读写内存修改血量 实例 void CMyDialog::OnBnClickedButton1() { // [[[0x00D0DF1C]+1C]+28]+288 //读取内存数据 DWORD a = *(DWORD*)0x00D0DF1C; a = *(DWORD*)(a+0x1C); a = *(DWORD*)(a+0x28); a = *(DWORD*)(a+0x288); CString Stemp; Stemp.Format(_T(\"%d\"),a); MessageBox(Stemp); //写入内存数据 a = *(DWORD*)0x00D0DF1C; a = *(DWORD*)(a+0x1C); a = *(DWORD*)(a+0x28); *(DWORD*)(a+0x288) = 999； } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"函数和call的对应关系 画江山 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"人物属性结构 typedef struct TROLE_PROPERTY //人物属性结构 { char* szpName; DWORD ndHp; ... ... TROLE_PROPERTY* GetData(); //获得人物数据 void FindWay(int x,int y); DWORD GetMaxJy(); //获得人物当前升级最大经验 DWORD GetisCombat(); //获得战斗标志位 DWORD GetComebatNo(); //获得战斗顺序标志位 }_TROLE_PROPERTY; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物数据 TROLE_PROPERTY*TROLE_PROPERTY::GetData() //获得人物数据 { try { DWORD Base = GetBase(Offset_RoleProperty1); DWORD Offset2 = Offset_RoleProperty2; Base = Base+Offset_RoleProperty2; DWORD Temp = *(DWORD*)Base; ndLv = *(DWORD*)(Temp+0x12*8); } catch(...) { OutputDebugStringA(\"读取人物信息异常\\r\\n\"); return NULL; } return this; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物基地址+大偏移 DWORD GetBase(DWORD offset) //获得人物基地址+大偏移 { DWORD backeax; DWORD of = offset; __asm { mov ecx,Base_Role mov edx,[ecx] mov eax,of mov eax,[edx+eax] call eax mov backeax,eax } return backeax; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:6:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"寻路 void TROLE_PROPERTY::FindWay(int x,int y) //寻路 { try { DWORD ID = this-\u003eGetData()-\u003endMapId; DWORD X=x; DWORD Y=y; __asm { mov ecx,Base_Role mov eax,[ecx] mov edx,[eax+Offset_FindWay] call edx mov ecx,eax push 0 push Y push X push ID mov edx,[ecx] mov eax,[edx+4] call eax } } catch(...) { OutputDebugStringA(\"寻路异常\\r\\n\"); } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:7:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"NPC结构 typedef struct TNpc_PROPERTY //NPC结构 { char* szpName; DWORD ndID; DWORD ndX; DWORD ndY; DWORD ndOpenNpcID; DWORD ndAttackSign; }_TNpc_PROPERTY; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:8:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"NPC列表结构 typedef struct TNpc_List //NPC列表结构 { DWORD ndNum; TNpc_PROPERTY NpcList[1000]; DWORD ndNo; void GetData(); }_TNpc_List; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:9:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得npc列表数据 void TNpc_List::GetData //获得npc列表数据 { try { DWORD Base = Base_NPC; DWORD Offset = Offset_RoleProperty2; ndNum = *(DWORD*)(Base+0xC); //ID数组成员数 DWORD Base1 = *(DWORD*)(Base+0x4); //ID数组根 DWORD Id= 0; int j = 0; DbgPrint_Mint(\"NPCID数组大小:%x\\r\\n\",ndNum); for(int i=0;i\u003cndNum;i++) { Id = *(DWORD*)(Base1+i*0x4); if(Id\u003e0x100000) { Id = Id\u00260x0FFFFF; DWORD Temp=*(DWORD*)Base; Temp=*(DWORD*)(Temp+Id*0x8); Temp=*(DWORD*)(Temp+Offset); NpcList[j].ndId=*(DWORD*)(Temp+0x0*0x8); NpcList[j].ndX=*(DWORD*)(Temp+0x5*0x8); NpcList[j].ndY=*(DWORD*)(Temp+0x6*0x8); NpcList[j].ndOpenNpcID=*(DWORD*)(Temp+0x96*0x8); NpcList[j].ndAttackSign=*(DWORD*)(Temp+0x3*0x8); DWORD NameAddr=*(DWORD*)(Temp+Ox1*0x8); NpcList[j].szpName=(char*)(NameAddr+0x4); j=j+1; } } ndNo=j; } catch(...) { OutputDebugStringA(\"获得npc列表数据异常\\r\\n\"); } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:10:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得战斗标志位 DWORD TROLE_PROPERTY::GetisCombat() //获得战斗标志位 { DWORD Back=GetBase(Offset_isCombat1); Back=Back+Offset_isCombat2; DWORD n=*(DWORD*)Back; return n; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:11:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得战斗顺序标志位 DWORD TROLE_PROPERTY::GetComebatNo() //获得战斗顺序标志位 { DWORD Back = GetBase(Offset_CombatNo1) __asm { mov ecx ,Back mov eax ,[ecx] mov edx ,[eax+Offset_CombatNo2] call edx mov Back,eax } Back =*(DWORD*)(Back+4): return Back; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:12:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物当前升级最大经验 DWORD TROLE_PROPERTY::GetMaxJy() //获得人物当前升级最大经验 { DWORD Back1=GetBase (Offset_MaxJingYan); DWORD* pLv = new DWORD; DWORD* pBack = new DWORD; *pLv = this-\u003eGetData()-\u003endLv; __asm { push pLv push pBack mov ecx, Back1 add ecx, 4 mov eax, Call_LvtoJy call eax } DWORD Temp=*pBack; Temp=*(DWORD*)(Temp+Ox10); return Temp; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:13:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"Hook明文包 void HookGameClearE() //Hook明文包 { DWORD dwHookAddr = HookClearEAddr; //HOOK地址 DWORD dwTargetAddr = (DWORD)HookGameClearECall; //跳转到的子程序 DbgPrint_Mine(\"Hook明文包地址%x HookCall地址%x\\r\\n\",dwHookAddr ,dwTargetAddr); EnableDebugPrivilege(TRUE); //提升权限 DWORD pid =NULL; DWORD WriteSize =NULL; GetWindowThreadProcessId(GetGameWndHandle(), \u0026pid); //获得进程ID hProcess =OpenProcess(PROCESS_ALL_ACCESS,FALSE ,pid ); //打开进程 DbgPrint_Mine(\"pid:%x\\r\\n\",pid ); DbgPrint_Mine(\"hProcess:%x\\r\\n\",hProcess ); byte Temp =OxE9; //jmp WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x00),\u0026Temp,1 ,\u0026WriteSize); DWORD Temp1= dwTargetAddr - dwHookAddr - 5; //跳转的差值 WriteProcessMemory(hProcess,(LDDWORD)(dwHookAddr + 0x01),\u0026Temp1,4 ,\u0026WriteSize); byte Temp2=0x90; //用nop填充 WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x05),\u0026Temp2,1 ,\u0026WriteSize); } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:14:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"提升权限 BOOL EnableDebugPrivilege (BOOL bEnable) //提升权限OpenProcess { BOO fOK =FALSE; HANDLE hToken; if(OpenProcessToken(GetCurrentProcess()), TOKEN_ADTUSI_PRIVILEGES, \u0026hToken)) //打开进程访问令牌 { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegelalue(NULL, SE_DEBUG_NAME, \u0026tp.Privileges[0].Luid); tp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED:0; AdjustTokenPrivileges(hToken, FALSE, \u0026tp, sizeof (tp), NULL, NULL); fOK = (GetlastError() == ERROR_SUCCESS); CloseHandle(hToken); } return fOK; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:15:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"HOOK明文包子程序 __declspec(naked) void HookGameCIearECa11()//裸体函数 HOOK明文包子程序 { __asm { //eax包长 ecx包内容 edx socket flags 0 pushad mov BaoChang, eax mov ecx, [esi+4] mov BaoNeiRongAddr, ecx } p =new byte[BaoChang]; ReadProcessMemory(hProcess, (LPCVOID)BaoNeiRongAddr, p, BaoChang, O); DbgPrint_Mine(\"包长:%x\",BaoChang); for (int i=0;i\u003c(int)BaoChang; i++) { sprintf(s, \"%02X\",p[i]); strcat_s(a, s); } DbgPrint_Mine(\"%s\", a); sprintf(a, \"%s\",\"包内容：\"); delete p; __asm { popd mov ecx,dword ptr [esi+4] mov edx,dword ptr [edi+0xC] jmp HookGameClearBackAdrr } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:16:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"还原明文包 void UnHookGameClearE() //还原明文包 { //8B 4E 04 8B 57 0C 还原代码 DWORD dwHookAddr = HookClearEAddr; DWORD WriteSize = NULL; byte Temp[] = {0x8B,0x4E,0x04,0x8b,0x57,0x0C}; WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x00),\u0026Temp,6 ,\u0026WriteSize); } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:17:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"发送封包 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"发送封包 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"HexChar转Byte ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"人物攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪相关 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"byte数组转string ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"宝宝攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:20:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"封装主线程调用 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"设置主线程和卸载主线程 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得窗口句柄 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"回调函数 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"主线程选角色消息 主线程HOOK明文包消息 主线程发包消息 寻路消息 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪参数结构体 typedef struct TAutomaticKill //自动打怪参数结构体 { int ndx1; int ndy1; int ndx2; int ndy2; }_TAutomaticKill; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"结束自动打怪 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"StructGame.h声明 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪寻路线程 FindwayThread ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"循环寻路 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:5","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪杀怪线程 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:23:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务遍历 void CMainDialogWnd::OnBnClickedButton14() ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务属性 Ttask_PROPERTY ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务列表结构 typedef struct Ttask_List ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得任务列表数据 void Ttask_List::GetData() ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务二叉树遍历 void Ttask_List::taskthree(int threeBase) ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"检测概论 exe dll 特征码 改写内存或者改写汇编代码 CRC检测 代码段 下访问断 数据检测 数据段 下访问断 CALL检测 堆栈检测 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:25:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"远程注入dll int _tmain(int argc,_TCHAR* argue[]) InJectDll ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:26:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"劫持注入 劫持工具 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:27:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"收包 发包可以达到功能 收包只能作为判断 收包效率高 recv WS2_32.recv ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:28:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"收包实例 hook明文包 另一处 还原明文包 另一处 裸体函数 另一处 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:29:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"窗口句柄和帐号 游戏账号 查找到游戏帐号的文本以后 下访问断 退出游戏得到访问代码 发现是一个常量（类似基地址）1670D31C 这个代码在主线程中 主线程入口地址是16670000 那个公式应该是 主线程入口+9C31C 我们用ce搜索主线程入中发现有基地址存放 得到公式 [27AC124]+9D31C ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:30:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"控件遍历 获得控件列表数据 GetData 控件遍历递归 GetData2 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:31:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类 \u0026 对象 #include \u003ciostream\u003e using namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double get(void); void set( double len, double bre, double hei ); }; // 成员函数定义 double Box::get(void) { return length * breadth * height; } void Box::set( double len, double bre, double hei) { length = len; breadth = bre; height = hei; } int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 详述 Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // box 1 的体积 volume = Box1.height * Box1.length * Box1.breadth; cout \u003c\u003c \"Box1 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 2 的体积 volume = Box2.height * Box2.length * Box2.breadth; cout \u003c\u003c \"Box2 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 3 详述 Box3.set(16.0, 8.0, 12.0); volume = Box3.get(); cout \u003c\u003c \"Box3 的体积：\" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Box1 的体积：210 Box2 的体积：1560 Box3 的体积：1536 私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"类 \u0026 对象详解 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类成员函数 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类访问修饰符 class Base { public: // 公有成员 protected: // 受保护成员 private: // 私有成员 }; 公有（public）成员 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 私有（private）成员 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 默认情况下，类的所有成员都是私有的。 protected（受保护）成员 protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。 继承中的特点 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； protected 成员可以被派生类访问。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"类构造函数 \u0026 析构函数 类的构造函数 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created Length of line : 6 带参数的构造函数 默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示： #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(double len); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line( double len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; length = len; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line(10.0); // 获取默认设置的长度 cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; // 再次设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created, length = 10 Length of line : 10 Length of line : 6 使用初始化列表来初始化字段 Line::Line( double len): length(len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 上面的语法等同于如下语法： Line::Line( double len) { length = len; cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示： C::C( double a, double b, double c): X(a), Y(b), Z(c) { .... } 类的析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 下面的实例有助于更好地理解析构函数的概念： #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数声明 ~Line(); // 这是析构函数声明 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } Line::~Line(void) { cout \u003c\u003c \"Object is being deleted\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created Length of line : 6 Object is being deleted ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 classname (const classname \u0026obj) { // 构造函数的主体 //obj 是一个对象引用，该对象是用于初始化另一个对象的。 } 实例 #include \u003ciostream\u003e using namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line \u0026obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout \u003c\u003c \"调用构造函数\" \u003c\u003c endl; // 为指针分配内存 ptr = new int; *ptr = len; } Line::Line(const Line \u0026obj) { cout \u003c\u003c \"调用拷贝构造函数并为指针 ptr 分配内存\" \u003c\u003c endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } Line::~Line(void) { cout \u003c\u003c \"释放内存\" \u003c\u003c endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout \u003c\u003c \"line 大小 : \" \u003c\u003c obj.getLength() \u003c\u003cendl; } // 程序的主函数 int main( ) { Line line(10); display(line); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 下面的实例对上面的实例稍作修改，通过使用已有的同类型的对象来初始化新创建的对象： #include \u003ciostream\u003e using namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line \u0026obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout \u003c\u003c \"调用构造函数\" \u003c\u003c endl; // 为指针分配内存 ptr = new int; *ptr = len; } Line::Line(const Line \u0026obj) { cout \u003c\u003c \"调用拷贝构造函数并为指针 ptr 分配内存\" \u003c\u003c endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } Line::~Line(void) { cout \u003c\u003c \"释放内存\" \u003c\u003c endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout \u003c\u003c \"line 大小 : \" \u003c\u003c obj.getLength() \u003c\u003cendl; } // 程序的主函数 int main( ) { Line line1(10); Line line2 = line1; // 这里也调用了拷贝构造函数 display(line1); display(line2); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 释放内存 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:4","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 友元函数 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示： class Box { double width; public: double length; friend void printWidth( Box box ); void setWidth( double wid ); }; 声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明： friend class ClassTwo; #include \u003ciostream\u003e using namespace std; class Box { double width; public: friend void printWidth( Box box ); void setWidth( double wid ); }; // 成员函数定义 void Box::setWidth( double wid ) { width = wid; } // 请注意：printWidth() 不是任何类的成员函数 void printWidth( Box box ) { /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout \u003c\u003c \"Width of box : \" \u003c\u003c box.width \u003c\u003cendl; } // 程序的主函数 int main( ) { Box box; // 使用成员函数设置宽度 box.setWidth(10.0); // 使用友元函数输出宽度 printWidth( box ); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Width of box : 10 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:5","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 内联函数 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 下面是一个实例，使用内联函数来返回两个数中的最大值： #include \u003ciostream\u003e using namespace std; inline int Max(int x, int y) { return (x \u003e y)? x : y; } // 程序的主函数 int main( ) { cout \u003c\u003c \"Max (20,10): \" \u003c\u003c Max(20,10) \u003c\u003c endl; cout \u003c\u003c \"Max (0,200): \" \u003c\u003c Max(0,200) \u003c\u003c endl; cout \u003c\u003c \"Max (100,1010): \" \u003c\u003c Max(100,1010) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max (20,10): 20 Max (0,200): 200 Max (100,1010): 1010 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:6","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ this 指针 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 #include \u003ciostream\u003e using namespace std; class Box { public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; } double Volume() { return length * breadth * height; } int compare(Box box) { return this-\u003eVolume() \u003e box.Volume(); } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; int main(void) { Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 if(Box1.compare(Box2)) { cout \u003c\u003c \"Box2 is smaller than Box1\" \u003c\u003cendl; } else { cout \u003c\u003c \"Box2 is equal to or larger than Box1\" \u003c\u003cendl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Box2 is equal to or larger than Box1 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:7","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向类的指针 一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -\u003e，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。 #include \u003ciostream\u003e using namespace std; class Box { public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; } double Volume() { return length * breadth * height; } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; int main(void) { Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 Box *ptrBox; // Declare pointer to a class. // 保存第一个对象的地址 ptrBox = \u0026Box1; // 现在尝试使用成员访问运算符来访问成员 cout \u003c\u003c \"Volume of Box1: \" \u003c\u003c ptrBox-\u003eVolume() \u003c\u003c endl; // 保存第二个对象的地址 ptrBox = \u0026Box2; // 现在尝试使用成员访问运算符来访问成员 cout \u003c\u003c \"Volume of Box2: \" \u003c\u003c ptrBox-\u003eVolume() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Volume of Box1: 5.94 Volume of Box2: 102 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:8","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类的静态成员 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 #include \u003ciostream\u003e using namespace std; class Box { public: static int objectCount; // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; // 每次创建对象时增加 1 objectCount++; } double Volume() { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 初始化类 Box 的静态成员 int Box::objectCount = 0; int main(void) { Box Box1(3.3, 1.2, 1.5); // 声明 box1 Box Box2(8.5, 6.0, 2.0); // 声明 box2 // 输出对象的总数 cout \u003c\u003c \"Total objects: \" \u003c\u003c Box::objectCount \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Total objects: 2 静态成员函数 静态函数只要使用类名加范围解析运算符 :: 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数与普通成员函数的区别： 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。 #include \u003ciostream\u003e using namespace std; class Box { public: static int objectCount; // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; // 每次创建对象时增加 1 objectCount++; } double Volume() { return length * breadth * height; } static int getCount() { return objectCount; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 初始化类 Box 的静态成员 int Box::objectCount = 0; int main(void) { // 在创建对象之前输出对象的总数 cout \u003c\u003c \"Inital Stage Count: \" \u003c\u003c Box::getCount() \u003c\u003c endl; Box Box1(3.3, 1.2, 1.5); // 声明 box1 Box Box2(8.5, 6.0, 2.0); // 声明 box2 // 在创建对象之后输出对象的总数 cout \u003c\u003c \"Final Stage Count: \" \u003c\u003c Box::getCount() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inital Stage Count: 0 Constructor called. Constructor called. Final Stage Count: 2 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:9","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 类 \u0026 对象 C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示： class Box { public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度 }; 关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"定义 C++ 对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象： Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box 对象 Box1 和 Box2 都有它们各自的数据成员。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"访问数据成员 类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。 为了更好地理解这些概念，让我们尝试一下下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double get(void); void set( double len, double bre, double hei ); }; // 成员函数定义 double Box::get(void) { return length * breadth * height; } void Box::set( double len, double bre, double hei) { length = len; breadth = bre; height = hei; } int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 详述 Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // box 1 的体积 volume = Box1.height * Box1.length * Box1.breadth; cout \u003c\u003c \"Box1 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 2 的体积 volume = Box2.height * Box2.length * Box2.breadth; cout \u003c\u003c \"Box2 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 3 详述 Box3.set(16.0, 8.0, 12.0); volume = Box3.get(); cout \u003c\u003c \"Box3 的体积：\" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Box1 的体积：210 Box2 的体积：1560 Box3 的体积：1536 需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。 类 \u0026 对象详解 到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 代码如下： // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"基类 \u0026 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下： class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 假设有一个基类 Shape，Rectangle 是它的派生类，如下所示： ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"访问控制和继承 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： class \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,… { \u003c派生类类体\u003e }; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; // 输出总花费 cout \u003c\u003c \"Total paint cost: $\" \u003c\u003c Rect.getCost(area) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 Total paint cost: $2450 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"C++ 重载运算符和重载函数 C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 中的函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。 下面的实例中，同名函数 print() 被用于输出不同的数据类型： 实例 #include \u003ciostream\u003e using namespace std; class printData { public: void print(int i) { cout \u003c\u003c \"整数为: \" \u003c\u003c i \u003c\u003c endl; } void print(double f) { cout \u003c\u003c \"浮点数为: \" \u003c\u003c f \u003c\u003c endl; } void print(char c[]) { cout \u003c\u003c \"字符串为: \" \u003c\u003c c \u003c\u003c endl; } }; int main(void) { printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = \"Hello C++\"; pd.print(c); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 整数为: 5 浮点数为: 500.263 字符串为: Hello C++ ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 中的运算符重载 您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box\u0026); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示： Box operator+(const Box\u0026, const Box\u0026); 下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"可重载运算符/不可重载运算符 下面是可重载的运算符列表： 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，\u003c (小于)，\u003e (大于)，\u003c=(小于等于)，\u003e=(大于等于) 逻辑运算符 ||(逻辑或)，\u0026\u0026(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，\u0026(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，\u0026 (按位与)，~(按位取反)，^(按位异或),，« (左移)，»(右移) 赋值运算符 =, +=, -=, *=, /= , % = , \u0026=, |=, ^=, «=, »= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-\u003e(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -\u003e*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"运算符重载实例 下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。 序号 运算符和实例 1 一元运算符重载 2 二元运算符重载 3 关系运算符重载 4 输入/输出运算符重载 5 ++ 和 – 运算符重载 6 赋值运算符重载 7 函数调用运算符 () 重载 8 [下标运算符 ] 重载 9 类成员访问运算符 -\u003e 重载 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 下面的实例中，基类 Shape 被派生为两个类，如下所示： 实例 #include \u003ciostream\u003e using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Rectangle class area :\" \u003c\u003cendl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Triangle class area :\" \u003c\u003cendl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = \u0026rec; // 调用矩形的求面积函数 area shape-\u003earea(); // 存储三角形的地址 shape = \u0026tri; // 调用三角形的求面积函数 area shape-\u003earea(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Parent class area Parent class area 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; 修改后，当编译和执行前面的实例代码时，它会产生以下结果： Rectangle class area Triangle class area 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"虚函数 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"纯虚函数 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 我们可以把基类中的虚函数 area() 改写如下： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; }; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。 数据抽象是一种依赖于接口和实现分离的编程（设计）技术。 让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。 因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。 现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。 例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。 在 C++ 中，我们使用类来定义我们自己的抽象数据类型（ADT）。您可以使用类 iostream 的 cout 对象来输出数据到标准输出，如下所示： 实例 #include \u003ciostream\u003e using namespace std; int main( ) { cout \u003c\u003c \"Hello C++\" \u003c\u003cendl; return 0; } 在这里，您不需要理解 cout 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签： 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"数据抽象的好处 数据抽象有两个重要的优势： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"数据抽象的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是用户不需要了解的，但又是类能正常工作所必需的。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"设计策略 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。 在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 数据封装 所有的 C++ 程序都有以下两个基本要素： **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如： class Box { public: double getVolume(void) { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。 为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"数据封装的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"C++ 接口（抽象类） 接口描述了类的行为和功能，而不需要完成类的特定实现。 C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示： class Box { public: // 纯虚函数 virtual double getVolume() = 0; private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。 可用于实例化对象的类被称为具体类。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["C++"],"content":"抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()： 实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Rectangle area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Triangle area: \" \u003c\u003c Tri.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total Rectangle area: 35 Total Triangle area: 17 从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["C++"],"content":"设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。 外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。 这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针的算术运算 下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 \u0026var[MAX - 1]，则把变量指针进行递增： #include \u003ciostream\u003e using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr; // 指针中第一个元素的地址 ptr = var; int i = 0; while ( ptr \u003c= \u0026var[MAX - 1] ) { cout \u003c\u003c \"Address of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c *ptr \u003c\u003c endl; // 指向上一个位置 ptr++; i++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Address of var[0] = 0xbfce42d0 Value of var[0] = 10 Address of var[1] = 0xbfce42d4 Value of var[1] = 100 Address of var[2] = 0xbfce42d8 Value of var[2] = 200 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针数组 #include \u003ciostream\u003e using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr[MAX]; for (int i = 0; i \u003c MAX; i++) { ptr[i] = \u0026var[i]; // 赋值为整数的地址 } for (int i = 0; i \u003c MAX; i++) { cout \u003c\u003c \"Value of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c *ptr[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var[0] = 10 Value of var[1] = 100 Value of var[2] = 200 您也可以用一个指向字符的指针数组来存储一个字符串列表，如下： #include \u003ciostream\u003e using namespace std; const int MAX = 4; int main () { const char *names[MAX] = { \"Zara Ali\", \"Hina Ali\", \"Nuha Ali\", \"Sara Ali\", }; for (int i = 0; i \u003c MAX; i++) { cout \u003c\u003c \"Value of names[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c names[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of names[0] = Zara Ali Value of names[1] = Hina Ali Value of names[2] = Nuha Ali Value of names[3] = Sara Ali ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向指针的指针（多级间接寻址） 一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针： int **var; #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int **pptr; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 使用运算符 \u0026 获取 ptr 的地址 pptr = \u0026ptr; // 使用 pptr 获取值 cout \u003c\u003c \"var 值为 :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"*ptr 值为:\" \u003c\u003c *ptr \u003c\u003c endl; cout \u003c\u003c \"**pptr 值为:\" \u003c\u003c **pptr \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var 值为 :3000 *ptr 值为:3000 **pptr 值为:3000 C++ 引用 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 #include \u003ciostream\u003e using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026 r = i; double\u0026 s = d; i = 5; cout \u003c\u003c \"Value of i : \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"Value of i reference : \" \u003c\u003c r \u003c\u003c endl; d = 11.7; cout \u003c\u003c \"Value of d : \" \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c \"Value of d reference : \" \u003c\u003c s \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中创建引用 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 把引用作为参数 #include \u003ciostream\u003e using namespace std; // 函数声明 void swap(int\u0026 x, int\u0026 y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 */ swap(a, b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } // 函数定义 void swap(int\u0026 x, int\u0026 y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 把引用作为返回值 #include \u003ciostream\u003e using namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double\u0026 setValues(int i) { double\u0026 ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]，最后再返回 shit。 } // 要调用上面定义函数的主函数 int main () { cout \u003c\u003c \"改变前的值\" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"vals[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c vals[i] \u003c\u003c endl; } setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 cout \u003c\u003c \"改变后的值\" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"vals[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c vals[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 改变前的值 vals[0] = 10.1 vals[1] = 12.6 vals[2] = 33.1 vals[3] = 24.1 vals[4] = 50 改变后的值 vals[0] = 10.1 vals[1] = 20.23 vals[2] = 33.1 vals[3] = 70.8 vals[4] = 50 当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。 int\u0026 func() { int q; //! return q; // 在编译时发生错误 static int x; return x; // 安全，x 在函数作用域外依然是有效的 } ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 日期 \u0026 时间 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; 序号 函数 \u0026 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"当前日期和时间 #include \u003ciostream\u003e #include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026now); cout \u003c\u003c \"本地日期和时间：\" \u003c\u003c dt \u003c\u003c endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(\u0026now); dt = asctime(gmtm); cout \u003c\u003c \"UTC 日期和时间：\"\u003c\u003c dt \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 本地日期和时间：Sat Jan 8 20:07:41 2011 UTC 日期和时间：Sun Jan 9 03:07:41 2011 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"使用结构 tm 格式化时间 使用箭头 -\u003e 运算符来访问结构成员 #include \u003ciostream\u003e #include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); cout \u003c\u003c \"1970 到目前经过秒数:\" \u003c\u003c now \u003c\u003c endl; tm *ltm = localtime(\u0026now); // 输出 tm 结构的各个组成部分 cout \u003c\u003c \"年: \"\u003c\u003c 1900 + ltm-\u003etm_year \u003c\u003c endl; cout \u003c\u003c \"月: \"\u003c\u003c 1 + ltm-\u003etm_mon\u003c\u003c endl; cout \u003c\u003c \"日: \"\u003c\u003c ltm-\u003etm_mday \u003c\u003c endl; cout \u003c\u003c \"时间: \"\u003c\u003c ltm-\u003etm_hour \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_min \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_sec \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 1970 到目前时间:1503564157 年: 2017 月: 8 日: 24 时间: 16:42:37 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"C++ 基本的输入输出 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 \u003ciostream\u003e 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 \u003ciomanip\u003e 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 \u003cfstream\u003e 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准输入流（cin） cin \u003e\u003e name \u003e\u003e age; 这相当于下面两个语句： cin \u003e\u003e name; cin \u003e\u003e age; ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准错误流（cerr） 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据结构 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"定义结构 struct type_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3; . . } object_names; ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"访问结构成员 使用成员访问运算符（.） ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"结构作为函数参数 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0; } void printBook( struct Books book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book.title \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book.author \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book.subject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book.book_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"指向结构的指针 为了使用指向该结构的指针访问结构的成员，您必须使用 -\u003e 运算符 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void printBook( struct Books *book ); struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( \u0026Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( \u0026Book2 ); return 0; } // 该函数以结构指针作为参数 void printBook( struct Books *book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book-\u003etitle \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book-\u003eauthor \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book-\u003esubject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book-\u003ebook_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"typedef 关键字 下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如： typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }Books; 现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 您可以使用 typedef 关键字来定义非结构类型，如下所示： typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"在c++使用and替代\u0026\u0026 背景 ​ 在之前的一个项目中发现使用了 and 替代 \u0026\u0026，当时感觉很奇怪，c++有这样的用法吗？ 编译没有问题，发现是c++的替代标记。 用法来源 维基百科搜索C替代标记。解释的很清楚。如果不能科学上网，我这里给出一些解释。 C替代标记指一批C语言常见运算符的可选拼写。它们实现为C标准库中iso646.h头文件内的一组宏定义。此标记作为C90标准的修正案于1995年增补。 替代标记允许程序员使用C语言按位和逻辑运算符，原先的标记在一些国际和非QWERTY键盘上很难输入。根据ISO/IEC 646标准实现的头文件有一些区域性的变化，其中一些用重音字符替换了C运算符使用的标点符号。 在iso646.h中定义了11个宏： 在c++中上述标识符是运算符，因此不需要包含头文件。iso646.h的主要内容为 #ifndef __ISO646_H #define __ISO646_H #ifndef __cplusplus #define and \u0026\u0026 #define and_eq \u0026= #define bitand \u0026 #define bitor | #define compl ~ #define not ! #define not_eq != #define or || #define or_eq |= #define xor ^ #define xor_eq ^= #endif #endif /* __ISO646_H */ 参考链接 【1】https://en.cppreference.com/w/cpp/language/operator_alternative 【2】https://zh.wikipedia.org/wiki/C%E6%9B%BF%E4%BB%A3%E6%A0%87%E8%AE%B0 ","date":"2021-08-24","objectID":"/2021/08/%E5%9C%A8c-%E4%BD%BF%E7%94%A8and%E6%9B%BF%E4%BB%A3/:0:0","series":null,"tags":null,"title":"在c++使用and替代\u0026\u0026","uri":"/2021/08/%E5%9C%A8c-%E4%BD%BF%E7%94%A8and%E6%9B%BF%E4%BB%A3/"},{"categories":["C++"],"content":"C++ 指针 学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（\u0026）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { int var1; char var2[10]; cout \u003c\u003c \"var1 变量的地址： \"; cout \u003c\u003c \u0026var1 \u003c\u003c endl; cout \u003c\u003c \"var2 变量的地址： \"; cout \u003c\u003c \u0026var2 \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var1 变量的地址： 0xbfebd5c0 var2 变量的地址： 0xbfebd5b6 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"什么是指针？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 中使用指针 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = \u0026var; // 在指针变量中存储 var 的地址 cout \u003c\u003c \"Value of var variable: \"; cout \u003c\u003c var \u003c\u003c endl; // 输出在指针变量中存储的地址 cout \u003c\u003c \"Address stored in ip variable: \"; cout \u003c\u003c ip \u003c\u003c endl; // 访问指针中地址的值 cout \u003c\u003c \"Value of *ip variable: \"; cout \u003c\u003c *ip \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var variable: 20 Address stored in ip variable: 0xbfc601ac Value of *ip variable: 20 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 指针详解 在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念： 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 中创建引用 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如： int i = 17; 我们可以为 i 声明引用变量，如下所示： int\u0026 r = i; double\u0026 s = d; 在这些声明中，\u0026 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用： ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026 r = i; double\u0026 s = d; i = 5; cout \u003c\u003c \"Value of i : \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"Value of i reference : \" \u003c\u003c r \u003c\u003c endl; d = 11.7; cout \u003c\u003c \"Value of d : \" \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c \"Value of d reference : \" \u003c\u003c s \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 日期 \u0026 时间 C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。 序号 函数 \u0026 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"当前日期和时间 下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026now); cout \u003c\u003c \"本地日期和时间：\" \u003c\u003c dt \u003c\u003c endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(\u0026now); dt = asctime(gmtm); cout \u003c\u003c \"UTC 日期和时间：\"\u003c\u003c dt \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 本地日期和时间：Sat Jan 8 20:07:41 2011 UTC 日期和时间：Sun Jan 9 03:07:41 2011 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"使用结构 tm 格式化时间 tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -\u003e 运算符来访问结构成员。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); cout \u003c\u003c \"1970 到目前经过秒数:\" \u003c\u003c now \u003c\u003c endl; tm *ltm = localtime(\u0026now); // 输出 tm 结构的各个组成部分 cout \u003c\u003c \"年: \"\u003c\u003c 1900 + ltm-\u003etm_year \u003c\u003c endl; cout \u003c\u003c \"月: \"\u003c\u003c 1 + ltm-\u003etm_mon\u003c\u003c endl; cout \u003c\u003c \"日: \"\u003c\u003c ltm-\u003etm_mday \u003c\u003c endl; cout \u003c\u003c \"时间: \"\u003c\u003c ltm-\u003etm_hour \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_min \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_sec \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 1970 到目前时间:1503564157 年: 2017 月: 8 日: 24 时间: 16:42:37 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"C++ 基本的输入输出 C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 \u003ciostream\u003e 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 \u003ciomanip\u003e 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 \u003cfstream\u003e 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准输出流（cout） 预定义的对象 cout 是 iostream 类的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。cout 是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Hello C++\"; cout \u003c\u003c \"Value of str is : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Value of str is : Hello C++ C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。« 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。 流插入运算符 « 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准输入流（cin） 预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 » 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char name[50]; cout \u003c\u003c \"请输入您的名称： \"; cin \u003e\u003e name; cout \u003c\u003c \"您的名称是： \" \u003c\u003c name \u003c\u003c endl; } 当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果： 请输入您的名称： cplusplus 您的名称是： cplusplus C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 » 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： cin \u003e\u003e name \u003e\u003e age; 这相当于下面两个语句： cin \u003e\u003e name; cin \u003e\u003e age; ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准错误流（cerr） 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:9:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"C++ 数据结构 C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性： Title ：标题 Author ：作者 Subject ：类目 Book ID ：书的 ID ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： struct type_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3; . . } object_names; type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 Books，变量为 book： struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book; ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 下面的实例演示了结构的用法： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 cout \u003c\u003c \"第一本书标题 : \" \u003c\u003c Book1.title \u003c\u003cendl; cout \u003c\u003c \"第一本书作者 : \" \u003c\u003c Book1.author \u003c\u003cendl; cout \u003c\u003c \"第一本书类目 : \" \u003c\u003c Book1.subject \u003c\u003cendl; cout \u003c\u003c \"第一本书 ID : \" \u003c\u003c Book1.book_id \u003c\u003cendl; // 输出 Book2 信息 cout \u003c\u003c \"第二本书标题 : \" \u003c\u003c Book2.title \u003c\u003cendl; cout \u003c\u003c \"第二本书作者 : \" \u003c\u003c Book2.author \u003c\u003cendl; cout \u003c\u003c \"第二本书类目 : \" \u003c\u003c Book2.subject \u003c\u003cendl; cout \u003c\u003c \"第二本书 ID : \" \u003c\u003c Book2.book_id \u003c\u003cendl; return 0; } 实例中定义了结构体类型 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果： 第一本书标题 : C++ 教程 第一本书作者 : Runoob 第一本书类目 : 编程语言 第一本书 ID : 12345 第二本书标题 : CSS 教程 第二本书作者 : Runoob 第二本书类目 : 前端技术 第二本书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"结构作为函数参数 您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0; } void printBook( struct Books book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book.title \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book.author \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book.subject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book.book_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"指向结构的指针 您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 \u0026 运算符放在结构名称的前面，如下所示： struct_pointer = \u0026Book1; 为了使用指向该结构的指针访问结构的成员，您必须使用 -\u003e 运算符，如下所示： struct_pointer-\u003etitle; 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; void printBook( struct Books *book ); struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( \u0026Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( \u0026Book2 ); return 0; } // 该函数以结构指针作为参数 void printBook( struct Books *book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book-\u003etitle \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book-\u003eauthor \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book-\u003esubject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book-\u003ebook_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"typedef 关键字 下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如： typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }Books; 现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 您可以使用 typedef 关键字来定义非结构类型，如下所示： typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"任鸟飞逆向分析基础教程 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞天涯明月刀辅助实战教程 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:1","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"2020飞郁任鸟飞C++之灵魂起源 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:2","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"代号1124-任鸟飞2019之易语言FPS游戏自瞄爆头飞天透视画框 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:3","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2016百尺竿头 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:4","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞天涯明月刀 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:1:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"2020飞郁任鸟飞C++之灵魂起源系列教程 课程目录： 001.灵魂起源_进制 002.灵魂起源_进制_进阶 003.灵魂起源_高级语言和低级语言 004.灵魂起源_创建第一个程序 005.灵魂起源_printf和scanf编写进制转换器 006.灵魂起源_变量与常量 007.灵魂起源_内存 008.灵魂起源_数据类型 009.灵魂起源_数据类型在内存中的储存方式1 010.灵魂起源_数据类型在内存中的储存方式2 011.灵魂起源_有符号和无符号区别，强制转换类型 012.灵魂起源_CE入门整数扫描 013.灵魂起源_CE浮点数扫描实现瞬移 014.灵魂起源_CE扫描进入游戏标志位 015.灵魂起源_基地址，动态地址和偏移 016.灵魂起源_CE的一些技巧 017.灵魂起源_CE扫描字符串1 018.灵魂起源_CE扫描字符串2 019.灵魂起源_CE找偏移表达式 020.灵魂起源_代码编写MFCDLL显示窗口 021.内存读写，输出人物血量和实现瞬移 089.堆栈检测 090.处理一层堆栈检测防封 095.数据检测 096.过数据检测防封 106.明文发包函数 114.收包函数recv，WSARecv和沾包 115.找明文收包函数的方法 165.技能冷却二叉树牵扯出游戏全部冷却数据 169.技能遍历1 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:2:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2019之易语言FPS游戏自瞄爆头飞天透视画框 教程目录: 0.FPS游戏自瞄展示 1.FPS游戏自瞄透视之模块动态加载; 2.FPS游戏自瞄透视之玩转堆栈 3.FPS游戏自瞄透视之遍历周围所有目标 4.FPS游戏自瞄透视之目标需要的属性总结 5.FPS游戏自瞄透视之准星数据查找\" 6.FPS游戏自瞄透视之准星变化规律 7.FPS游戏自瞄透视之准星算法 8.FPS游戏自瞄透视之C++代码实现自瞄1 9.FPS游戏自瞄透视之C++代码实现自瞄2 10.FPS游戏自瞄透视之C++代码实现自瞄3 11.C++源码FPSyouxi——————-不是视频 12.创世最新数据——————不是视频 13.FPS游戏易语言之封装必要函数 14.FPS游戏易语言之用类遍历人物属性4 15.FPS游戏易语言之热键瞄准和计算最近距离 16.FPS游戏易语言之实现自瞄 17.易语言创世战车源码! 18.cf加密准星分析 19.cf人物坐标分析 20.cf遍历周边玩家 21.cf分析坐标规律实现自瞄, 22.分析绘制和所需数据（视角查找） 23.取窗口矩形位置和大小 24.建立透明窗口跟随游戏! 25..分析水平可视敌人 26..分析垂直可视敌人 27.转换2D坐标画出基础方框 28.如何调整方框比例（1） 29.如何调整方框比例（2） 30.计算并瞄准准星最近的敌人 31.cf变态功能之飞天蹲地 32.cf变态功能之无限子弹 33.实战内存人物透视CRC(1) 34.实战内存人物透视CRC(2) 35.理解检测和对抗原理1 36.封包处理检测（理论） 37.实战明文发包（木马加载 ） 38.分享实战笔记(不是视频 ) ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:3:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2016百尺竿头 任鸟飞2016百尺竿头课程00介绍00.rar 任鸟飞2016百尺竿头课程第1课人物对象.rar 任鸟飞2016百尺竿头课程第2课加密坐标.rar 任鸟飞2016百尺竿头课程第3课升级经验数组.rar 任鸟飞2016百尺竿头课程第4课等级加密解密.rar 任鸟飞2016百尺竿头课程第5课战斗标志位.rar 任鸟飞2016百尺竿头课程第6课战斗顺序标志位.rar 任鸟飞2016百尺竿头课程第7课怪物数组遍历.rar 任鸟飞2016百尺竿头课程第8课序号提取表.rar 任鸟飞2016百尺竿头课程第9课(C++)编写DLL显示窗口.rar 任鸟飞2016百尺竿头课程第10课(C++)调试输出人物信息.rar 任鸟飞2016百尺竿头课程第11课寻路CALL.rar 任鸟飞2016百尺竿头课程第12课(C++)内联汇编编写寻路CALL.rar 任鸟飞2016百尺竿头课程第13课数据定位.rar 任鸟飞2016百尺竿头课程第14课(C++)封装周围数组.rar 任鸟飞2016百尺竿头课程第15课(C++)封装升级标志战斗标志.rar 任鸟飞2016百尺竿头课程第16课HOOK原理.rar 任鸟飞2016百尺竿头课程第17课(C++)HOOK明文包.rar 任鸟飞2016百尺竿头课程第18课封包和HOOK明文包的优点发包变态功能理解.rar 任鸟飞2016百尺竿头课程第19课(C++)send发送封包.rar 任鸟飞2016百尺竿头课程第20课分析攻击封包.rar 任鸟飞2016百尺竿头课程第21课(C++)封装人物攻击宝宝攻击.rar 任鸟飞2016百尺竿头课程第22课通过参数找选角色Call并且验证主线程调用的作用.rar 任鸟飞2016百尺竿头课程第23课(C++)封装主线程调用.rar 任鸟飞2016百尺竿头课程第24课自动打怪逻辑.rar 任鸟飞2016百尺竿头课程第25课(C++)自动打怪循环寻路线程.rar 任鸟飞2016百尺竿头课程第26课(C++)自动打怪杀怪线程.rar 任鸟飞2016百尺竿头课程第27课任务遍历.rar 任鸟飞2016百尺竿头课程第28课(C++)二叉树递归算法.rar 任鸟飞2016百尺竿头课程第29课任务属性分析.rar 任鸟飞2016百尺竿头课程第30课检测概论.rar 任鸟飞2016百尺竿头课程第31课第一个任务的3连封包分析.rar 任鸟飞2016百尺竿头课程第32课分析加密封包.rar 任鸟飞2016百尺竿头课程第33课远线程注入DLL.rar 任鸟飞2016百尺竿头课程第34课劫持注入.rar 任鸟飞2016百尺竿头课程第35课收包概论.rar 任鸟飞2016百尺竿头课程第36课recv实例分析.rar 任鸟飞2016百尺竿头课程第37-38课收包实例及一些技巧.rar 任鸟飞2016百尺竿头课程第39课窗口句柄and账号.rar 任鸟飞2016百尺竿头课程第40课背包遍历.rar 任鸟飞2016百尺竿头课程第41课寻宝坐标加密.rar 任鸟飞2016百尺竿头课程第42课物品丢弃封包.rar 任鸟飞2016百尺竿头课程第43课自动清包.rar 任鸟飞2016百尺竿头课程第44课控件输入CALL.rar 任鸟飞2016百尺竿头课程第45课控件遍历数组递归.rar 任鸟飞2016百尺竿头课程第46课控件遍历编写.rar 任鸟飞2016百尺竿头课程第47课角色遍历.rar 任鸟飞2016百尺竿头课程第48课创建角色封包.rar 任鸟飞2016百尺竿头课程第49课画江山总结.rar graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:4:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":["C++"],"content":"C++ 自增自减运算符 C++ 运算符 自增运算符 ++ 会把操作数加 1，自减运算符 – 会把操作数减 1。因此： x = x+1; 等同于 x++; 同样的： x = x-1; 等同于 x--; 无论是自增运算符还是自减运算符，都可以放在操作数的前面（前缀）或后面（后缀）。例如： x = x+1; 可以写成： ++x; // 前缀形式 或者： x++; // 后缀形式 前缀形式与后缀形式之间有一点不同。如果使用前缀形式，则会在表达式计算之前完成自增或自减，如果使用后缀形式，则会在表达式计算之后完成自增或自减。 实例 请看下面的实例，理解二者之间的区别： #include \u003ciostream\u003e using namespace std; int main() { int a = 21; int c ; // a 的值在赋值之前不会自增 c = a++; cout \u003c\u003c \"Line 1 - Value of a++ is :\" \u003c\u003c c \u003c\u003c endl ; // 表达式计算之后，a 的值增加 1 cout \u003c\u003c \"Line 2 - Value of a is :\" \u003c\u003c a \u003c\u003c endl ; // a 的值在赋值之前自增 c = ++a; cout \u003c\u003c \"Line 3 - Value of ++a is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of a++ is :21 Line 2 - Value of a is :22 Line 3 - Value of ++a is :23 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12a自增自减运算符","uri":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 杂项运算符 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ sizeof 运算符 sizeof 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。 sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。 使用 sizeof 的语法如下： sizeof (data type) 其中，data type 是要计算大小的数据类型，包括类、结构、共用体和其他用户自定义数据类型。 请尝试下面的实例，理解 C++ 中 sizeof 的用法。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Size of char : \" \u003c\u003c sizeof(char) \u003c\u003c endl; cout \u003c\u003c \"Size of int : \" \u003c\u003c sizeof(int) \u003c\u003c endl; cout \u003c\u003c \"Size of short int : \" \u003c\u003c sizeof(short int) \u003c\u003c endl; cout \u003c\u003c \"Size of long int : \" \u003c\u003c sizeof(long int) \u003c\u003c endl; cout \u003c\u003c \"Size of float : \" \u003c\u003c sizeof(float) \u003c\u003c endl; cout \u003c\u003c \"Size of double : \" \u003c\u003c sizeof(double) \u003c\u003c endl; cout \u003c\u003c \"Size of wchar_t : \" \u003c\u003c sizeof(wchar_t) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果，结果会根据使用的机器而不同： Size of char : 1 Size of int : 4 Size of short int : 2 Size of long int : 4 Size of float : 4 Size of double : 8 Size of wchar_t : 4 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 条件运算符 ? : Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意冒号的使用和位置。? : 表达式的值取决于 Exp1 的计算结果。如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为整个 ? : 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为整个 ? : 表达式的值。 ? 被称为三元运算符，因为它需要三个操作数，可以用来代替如下所示的 if-else 语句： if(condition){ var = X; }else{ var = Y; } 例如，请看下面这段代码： if(y \u003c 10){ var = 30; }else{ var = 40; } 上面的代码可以写成以下语句： var = (y \u003c 10) ? 30 : 40; 在这里，如果 y 小于 10，则 var 被赋值为 30，如果 y 不小于 10，则 var 被赋值为 40。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; int main () { // 局部变量声明 int x, y = 10; x = (y \u003c 10) ? 30 : 40; cout \u003c\u003c \"value of x: \" \u003c\u003c x \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： value of x: 40 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 逗号运算符 使用逗号运算符是为了把几个表达式放在一起。 整个逗号表达式的值为系列中最后一个表达式的值。 从本质上讲，逗号的作用是将一系列运算按顺序执行。 表达式1, 表达式2 求解过程是：先求解表达式 1，再求解表达式 2。整个逗号表达式的值是表达式 2 的值。 最右边的那个表达式的值将作为整个逗号表达式的值，其他表达式的值会被丢弃。 例如： var = (count=19, incr=10, count+1); 在这里，首先把 count 赋值为 19，把 incr 赋值为 10，然后把 count 加 1，最后，把最右边表达式 count+1 的计算结果 20 赋给 var。上面表达式中的括号是必需的，因为逗号运算符的优先级低于赋值操作符。 尝试运行下面的实例，理解逗号运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main() { int i, j; j = 10; i = (j++, j+100, 999+j); cout \u003c\u003c i; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 1010 上面的程序中，j 最初的值为 10，然后自增到 11，这时 j 的值就为 11，然后再计算第二个表达式 j+100，最后 j（j 为 11） 再加上 999，最后 i 为 最后一个表达式的值 999+j，及 999+ 11=1010。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。箭头运算符与一个指向对象的指针一起使用。例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 强制转换运算符 强制转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。强制转换运算符是一元运算符，它的优先级与其他一元运算符相同。 大多数的 C++ 编译器都支持大部分通用的强制转换运算符： (type) expression 其中，type 是转换后的数据类型。下面列出了 C++ 支持的其他几种强制转换运算符： const_cast (expr): const_cast 运算符用于修改类型的 const / volatile 属性。除了 const 或 volatile 属性之外，目标类型必须与源类型相同。这种类型的转换主要是用来操作所传对象的 const 属性，可以加上 const 属性，也可以去掉 const 属性。 dynamic_cast (expr): dynamic_cast 在运行时执行转换，验证转换的有效性。如果转换未执行，则转换失败，表达式 expr 被判定为 null。dynamic_cast 执行动态转换时，type 必须是类的指针、类的引用或者 void*，如果 type 是类指针类型，那么 expr 也必须是一个指针，如果 type 是一个引用，那么 expr 也必须是一个引用。 reinterpret_cast (expr): reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。 static_cast (expr): static_cast 运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。 上述所有的强制转换运算符在使用类和对象时会用到。现在，请看下面的实例，理解 C++ 中如何使用一个简单的强制转换运算符。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003e using namespace std; int main() { double a = 21.09399; float b = 10.20; int c ; c = (int) a; cout \u003c\u003c \"Line 1 - Value of (int)a is :\" \u003c\u003c c \u003c\u003c endl ; c = (int) b; cout \u003c\u003c \"Line 2 - Value of (int)b is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of (int)a is :21 Line 2 - Value of (int)b is :10 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 指针运算符（\u0026 和 *） C++ 提供了两种指针运算符，一种是取地址运算符 \u0026，一种是间接寻址运算符 *。 指针是一个包含了另一个变量地址的变量，您可以把一个包含了另一个变量地址的变量说成是\"指向\"另一个变量。变量可以是任意的数据类型，包括对象、结构或者指针。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作**“取地址运算符”，这意味着，\u0026var** 读作\"var 的地址\"。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C 风格字符串 C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。 char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char site[] = \"RUNOOB\"; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。让我们尝试输出上面的字符串： 实例 #include \u003ciostream\u003e using namespace std; int main () { char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; cout \u003c\u003c \"菜鸟教程: \"; cout \u003c\u003c site \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 菜鸟教程: RUNOOB C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 \u0026 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = “runoob”;string str2 = “google”; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： 实例 #include \u003ciostream\u003e #include \u003ccstring\u003e using namespace std; int main () { char str1[13] = \"runoob\"; char str2[13] = \"google\"; char str3[13]; int len ; // 复制 str1 到 str3 strcpy( str3, str1); cout \u003c\u003c \"strcpy( str3, str1) : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 strcat( str1, str2); cout \u003c\u003c \"strcat( str1, str2): \" \u003c\u003c str1 \u003c\u003c endl; // 连接后，str1 的总长度 len = strlen(str1); cout \u003c\u003c \"strlen(str1) : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： strcpy( str3, str1) : runoob strcat( str1, str2): runoobgoogle strlen(str1) : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 中的 String 类 C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例： 现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。 实例 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main () { string str1 = \"runoob\"; string str2 = \"google\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： str3 : runoob str1 + str2 : runoobgoogle str3.size() : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 函数 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"定义函数 C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"函数参数 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"指针调用 // 函数定义 void swap(int *x, int *y) { int temp; temp = *x; /* 保存地址 x 的值 */ *x = *y; /* 把 y 赋值给 x */ *y = temp; /* 把 x 赋值给 y */ return; } #include \u003ciostream\u003e using namespace std; // 函数声明 void swap(int *x, int *y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 * \u0026a 表示指向 a 的指针，即变量 a 的地址 * \u0026b 表示指向 b 的指针，即变量 b 的地址 */ swap(\u0026a, \u0026b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"引用调用 // 函数定义 void swap(int \u0026x, int \u0026y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } #include \u003ciostream\u003e using namespace std; // 函数声明 void swap(int \u0026x, int \u0026y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 */ swap(a, b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: [capture](parameters)-\u003ereturn-type{body} 例如： [](int x, int y){ return x \u003c y ; } 如果没有返回值可以表示为： [capture](parameters){body} 例如： []{ ++global_x; } 在一个更为复杂的例子中，返回类型可以被明确的指定如下： [](int x, int y) -\u003e int { int z = x + y; return z + x; } 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： [this]() { this-\u003esomeFunc(); }(); C++ 数字 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数学运算 序号 函数 \u0026 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 随机数 rand()该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 time() 函数来获取系统时间的秒数 #include \u003ciostream\u003e #include \u003cctime\u003e #include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置随机种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 随机数： 1748144778 随机数： 630873888 随机数： 2134540646 随机数： 219404170 随机数： 902129458 随机数： 920445370 随机数： 1319072661 随机数： 257938873 随机数： 1256201101 随机数： 580322989 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数组 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"多维数组 多维数组声明的一般形式如下： type name[size1][size2]...[sizeN]; 初始化二维数组 int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向数组的指针 #include \u003ciostream\u003e using namespace std; int main () { // 带有 5 个元素的双精度浮点型数组 double runoobAarray[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; double *p; p = runoobAarray; // 输出数组中每个元素的值 cout \u003c\u003c \"使用指针的数组值 \" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"*(p + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(p + i) \u003c\u003c endl; } cout \u003c\u003c \"使用 runoobAarray 作为地址的数组值 \" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"*(runoobAarray + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(runoobAarray + i) \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 使用指针的数组值 *(p + 0) : 1000 *(p + 1) : 2 *(p + 2) : 3.4 *(p + 3) : 17 *(p + 4) : 50 使用 runoobAarray 作为地址的数组值 *(runoobAarray + 0) : 1000 *(runoobAarray + 1) : 2 *(runoobAarray + 2) : 3.4 *(runoobAarray + 3) : 17 *(runoobAarray + 4) : 50 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 传递数组给函数 方式 1 形式参数是一个指针： void myFunction(int *param) { . . . } 方式 2 形式参数是一个已定义大小的数组： void myFunction(int param[10]) { . . . } 方式 3 形式参数是一个未定义大小的数组： void myFunction(int param[]) { . . . } 实例 现在，让我们来看下面这个函数，它把数组作为参数，同时还传递了另一个参数，根据所传的参数，会返回数组中各元素的平均值： double getAverage(int arr[], int size) { int i, sum = 0; double avg; for (i = 0; i \u003c size; ++i) { sum += arr[i]; } avg = double(sum) / size; return avg; } 现在，让我们调用上面的函数，如下所示： #include \u003ciostream\u003e using namespace std; // 函数声明 double getAverage(int arr[], int size); int main () { // 带有 5 个元素的整型数组 int balance[5] = {1000, 2, 3, 17, 50}; double avg; // 传递一个指向数组的指针作为参数 avg = getAverage( balance, 5 ) ; // 输出返回值 cout \u003c\u003c \"平均值是：\" \u003c\u003c avg \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 平均值是： 214.4 您可以看到，就函数而言，数组的长度是无关紧要的，因为 C++ 不会对形式参数执行边界检查。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 从函数返回数组 C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。 如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下： int * myFunction() { . . . } C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 #include \u003ciostream\u003e #include \u003ccstdlib\u003e #include \u003cctime\u003e using namespace std; // 要生成和返回随机数的函数 int * getRandom( ) { static int r[10]; // 设置种子 srand( (unsigned)time( NULL ) ); for (int i = 0; i \u003c 10; ++i) { r[i] = rand(); cout \u003c\u003c r[i] \u003c\u003c endl; } return r; } // 要调用上面定义函数的主函数 int main () { // 一个指向整数的指针 int *p; p = getRandom(); for ( int i = 0; i \u003c 10; i++ ) { cout \u003c\u003c \"*(p + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(p + i) \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 624723190 1468735695 807113585 976495677 613357504 1377296355 1530315259 1778906708 1820354158 667126415 *(p + 0) : 624723190 *(p + 1) : 1468735695 *(p + 2) : 807113585 *(p + 3) : 976495677 *(p + 4) : 613357504 *(p + 5) : 1377296355 *(p + 6) : 1530315259 *(p + 7) : 1778906708 *(p + 8) : 1820354158 *(p + 9) : 667126415 C++ 字符串 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C 风格字符串 char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char site[] = \"RUNOOB\"; 以下是 C/C++ 中定义的字符串的内存表示： C/C++ 中的字符串表示 C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 \u0026 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = “runoob”;string str2 = “google”; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的 String 类 实例 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main () { string str1 = \"runoob\"; string str2 = \"google\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： str3 : runoob str1 + str2 : runoobgoogle str3.size() : 12 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解什么是局部变量和全局变量。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c; return 0; } ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout \u003c\u003c g; return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; // 全局变量声明 int g = 20; int main () { // 局部变量声明 int g = 10; cout \u003c\u003c g; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 10 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"auto 存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 实例 #include \u003ciostream\u003e // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main() { while(count--) { func(); } return 0; } // 函数定义 void func( void ) { static int i = 5; // 局部静态变量 i++; std::cout \u003c\u003c \"变量 i 为 \" \u003c\u003c i ; std::cout \u003c\u003c \" , 变量 count 为 \" \u003c\u003c count \u003c\u003c std::endl; } 当上面的代码被编译和执行时，它会产生下列结果： 变量 i 为 6 , 变量 count 为 9 变量 i 为 7 , 变量 count 为 8 变量 i 为 8 , 变量 count 为 7 变量 i 为 9 , 变量 count 为 6 变量 i 为 10 , 变量 count 为 5 变量 i 为 11 , 变量 count 为 4 变量 i 为 12 , 变量 count 为 3 变量 i 为 13 , 变量 count 为 2 变量 i 为 14 , 变量 count 为 1 变量 i 为 15 , 变量 count 为 0 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"extern 存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ’extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.cpp 实例 #include \u003ciostream\u003e int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件：support.cpp 实例 #include \u003ciostream\u003e extern int count; void write_extern(void) { std::cout \u003c\u003c \"Count is \" \u003c\u003c count \u003c\u003c std::endl; } 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示： $ g++ main.cpp support.cpp -o write 这会产生 write 可执行程序，尝试执行 write，它会产生下列结果： $ ./write Count is 5 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"thread_local 存储类 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"C++ 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"算术运算符 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 实例 请看下面的实例，了解 C++ 中可用的算术运算符。 复制并粘贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003e using namespace std; int main() { int a = 21; int b = 10; int c; c = a + b; cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a - b; cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a * b; cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a / b; cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a % b; cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; int d = 10; // 测试自增、自减 c = d++; cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; d = 10; // 重新赋值 c = d--; cout \u003c\u003c \"Line 7 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 10 Line 7 - c 的值是 10 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"关系运算符 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 #实例 请看下面的实例，了解 C++ 中可用的关系运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003e using namespace std; int main() { int a = 21; int b = 10; int c ; if( a == b ) { cout \u003c\u003c \"Line 1 - a 等于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 1 - a 不等于 b\" \u003c\u003c endl ; } if ( a \u003c b ) { cout \u003c\u003c \"Line 2 - a 小于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 2 - a 不小于 b\" \u003c\u003c endl ; } if ( a \u003e b ) { cout \u003c\u003c \"Line 3 - a 大于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 3 - a 不大于 b\" \u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 5; b = 20; if ( a \u003c= b ) { cout \u003c\u003c \"Line 4 - a 小于或等于 b\" \u003c\u003c endl ; } if ( b \u003e= a ) { cout \u003c\u003c \"Line 5 - b 大于或等于 a\" \u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - a 不等于 b Line 2 - a 不小于 b Line 3 - a 大于 b Line 4 - a 小于或等于 b Line 5 - b 大于或等于 a ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"逻辑运算符 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A || B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 #实例 请看下面的实例，了解 C++ 中可用的逻辑运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003e using namespace std; int main() { int a = 5; int b = 20; int c ; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 1 - 条件为真\"\u003c\u003c endl ; } if ( a || b ) { cout \u003c\u003c \"Line 2 - 条件为真\"\u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 0; b = 10; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 3 - 条件为真\"\u003c\u003c endl ; } else { cout \u003c\u003c \"Line 4 - 条件不为真\"\u003c\u003c endl ; } if ( !(a \u0026\u0026 b) ) { cout \u003c\u003c \"Line 5 - 条件为真\"\u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - 条件为真 Line 2 - 条件为真 Line 4 - 条件不为真 Line 5 - 条件为真 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示： p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 -—————- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则：0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：`0 0=0; 0 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 » 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 #实例 请看下面的实例，了解 C++ 中可用的位运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003e using namespace std; int main() { unsigned int a = 60; // 60 = 0011 1100 unsigned int b = 13; // 13 = 0000 1101 int c = 0; c = a \u0026 b; // 12 = 0000 1100 cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a | b; // 61 = 0011 1101 cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a ^ b; // 49 = 0011 0001 cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = ~a; // -61 = 1100 0011 cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003c\u003c 2; // 240 = 1111 0000 cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003e\u003e 2; // 15 = 0000 1111 cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"赋值运算符 下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 #实例 请看下面的实例，了解 C++ 中可用的赋值运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003e using namespace std; int main() { int a = 21; int c ; c = a; cout \u003c\u003c \"Line 1 - = 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c += a; cout \u003c\u003c \"Line 2 - += 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c -= a; cout \u003c\u003c \"Line 3 - -= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c *= a; cout \u003c\u003c \"Line 4 - *= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c /= a; cout \u003c\u003c \"Line 5 - /= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c = 200; c %= a; cout \u003c\u003c \"Line 6 - %= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003c\u003c= 2; cout \u003c\u003c \"Line 7 - \u003c\u003c= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003e\u003e= 2; cout \u003c\u003c \"Line 8 - \u003e\u003e= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u0026= 2; cout \u003c\u003c \"Line 9 - \u0026= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c ^= 2; cout \u003c\u003c \"Line 10 - ^= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c |= 2; cout \u003c\u003c \"Line 11 - |= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - = 运算符实例，c 的值 = 21 Line 2 - += 运算符实例，c 的值 = 42 Line 3 - -= 运算符实例，c 的值 = 21 Line 4 - *= 运算符实例，c 的值 = 441 Line 5 - /= 运算符实例，c 的值 = 21 Line 6 - %= 运算符实例，c 的值 = 11 Line 7 - \u003c\u003c= 运算符实例，c 的值 = 44 Line 8 - \u003e\u003e= 运算符实例，c 的值 = 11 Line 9 - \u0026= 运算符实例，c 的值 = 2 Line 10 - ^= 运算符实例，c 的值 = 0 Line 11 - |= 运算符实例，c 的值 = 2 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"杂项运算符 下表列出了 C++ 支持的其他一些重要的运算符。 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 中的运算符优先级 运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 #实例 请看下面的实例，了解 C++ 中运算符的优先级。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。 实例 #include \u003ciostream\u003e using namespace std; int main() { int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 cout \u003c\u003c \"(a + b) * c / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = ((a + b) * c) / d; // (30 * 15 ) / 5 cout \u003c\u003c \"((a + b) * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = (a + b) * (c / d); // (30) * (15/5) cout \u003c\u003c \"(a + b) * (c / d) 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = a + (b * c) / d; // 20 + (150/5) cout \u003c\u003c \"a + (b * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： (a + b) * c / d 的值是 90 ((a + b) * c) / d 的值是 90 (a + b) * (c / d) 的值是 90 a + (b * c) / d 的值是 50 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 循环 有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。 编程语言提供了允许更为复杂的执行路径的多种控制结构。 循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环类型 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环控制语句 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 实例 #include \u003ciostream\u003e using namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 **注意：**您可以按 Ctrl + C 键终止一个无限循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"C++ 判断 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。 下面是大多数编程语言中典型的判断结构的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"判断语句 C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"? : 运算符 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"C++ 函数 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"定义函数 C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 实例 以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"调用函数 创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 实例 #include \u003ciostream\u003e using namespace std; // 函数声明 int max(int num1, int num2); int main () { // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout \u003c\u003c \"Max value is : \" \u003c\u003c ret \u003c\u003c endl; return 0; } // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： Max value is : 200 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"参数的默认值 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; int sum(int a, int b=20) { int result; result = a + b; return (result); } int main () { // 局部变量声明 int a = 100; int b = 200; int result; // 调用函数来添加值 result = sum(a, b); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; // 再次调用函数 result = sum(a); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total value is :300 Total value is :120 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: [capture](parameters)-\u003ereturn-type{body} 例如： [](int x, int y){ return x \u003c y ; } 如果没有返回值可以表示为： [capture](parameters){body} 例如： []{ ++global_x; } 在一个更为复杂的例子中，返回类型可以被明确的指定如下： [](int x, int y) -\u003e int { int z = x + y; return z + x; } 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： [this]() { this-\u003esomeFunc(); }(); ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 数字 通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 定义数字 我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例： 实例 #include \u003ciostream\u003e using namespace std; int main () { // 数字定义 short s; int i; long l; float f; double d; // 数字赋值 s = 10; i = 1000; l = 1000000; f = 230.47; d = 30949.374; // 数字输出 cout \u003c\u003c \"short s :\" \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c \"int i :\" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"long l :\" \u003c\u003c l \u003c\u003c endl; cout \u003c\u003c \"float f :\" \u003c\u003c f \u003c\u003c endl; cout \u003c\u003c \"double d :\" \u003c\u003c d \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： short s :10 int i :1000 long l :1000000 float f :230.47 double d :30949.4 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数学运算 在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件 。 序号 函数 \u0026 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 下面是一个关于数学运算的简单实例： 实例 #include \u003ciostream\u003e #include \u003ccmath\u003e using namespace std; int main () { // 数字定义 short s = 10; int i = -1000; long l = 100000; float f = 230.47; double d = 200.374; // 数学运算 cout \u003c\u003c \"sin(d) :\" \u003c\u003c sin(d) \u003c\u003c endl; cout \u003c\u003c \"abs(i) :\" \u003c\u003c abs(i) \u003c\u003c endl; cout \u003c\u003c \"floor(d) :\" \u003c\u003c floor(d) \u003c\u003c endl; cout \u003c\u003c \"sqrt(f) :\" \u003c\u003c sqrt(f) \u003c\u003c endl; cout \u003c\u003c \"pow( d, 2) :\" \u003c\u003c pow(d, 2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： sin(d) :-0.634939 abs(i) :1000 floor(d) :200 sqrt(f) :15.1812 pow( d, 2 ) :40149.7 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 随机数 在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数： 实例 #include \u003ciostream\u003e #include \u003cctime\u003e #include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 随机数： 1748144778 随机数： 630873888 随机数： 2134540646 随机数： 219404170 随机数： 902129458 随机数： 920445370 随机数： 1319072661 随机数： 257938873 随机数： 1256201101 随机数： 580322989 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数组 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"声明数组 在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"初始化数组 在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： 实例 #include \u003ciostream\u003e using namespace std; #include \u003ciomanip\u003e using std::setw; int main () { int n[ 10 ]; // n 是一个包含 10 个整数的数组 // 初始化数组元素 for ( int i = 0; i \u003c 10; i++ ) { n[ i ] = i + 100; // 设置元素 i 为 i + 100 } cout \u003c\u003c \"Element\" \u003c\u003c setw( 13 ) \u003c\u003c \"Value\" \u003c\u003c endl; // 输出数组中每个元素的值 for ( int j = 0; j \u003c 10; j++ ) { cout \u003c\u003c setw( 7 )\u003c\u003c j \u003c\u003c setw( 13 ) \u003c\u003c n[ j ] \u003c\u003c endl; } return 0; } 上面的程序使用了 setw() 函数 来格式化输出。当上面的代码被编译和执行时，它会产生下列结果： Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 中数组详解 在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解： 类型 描述 bool 存储值 true 或 false。 char 通常是一个字符（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 下面我们将讲解如何定义、声明和使用各种类型的变量。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。 变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。 变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： type variable_name = value; 下面列举几个实例： extern int d = 3, f = 5; // d 和 f 的声明 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = 'x'; // 变量 x 的值为 'x' 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量声明 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的： #include \u003ciostream\u003e using namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 30 23.3333 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如： // 函数声明 int func(); int main() { // 函数调用 int i = func(); } // 函数定义 int func() { return 0; } ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的左值（Lvalues）和右值（Rvalues） C++ 中有两种类型的表达式： **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： int g = 20; 但是下面这个就不是一个有效的语句，会生成编译时错误： 10 = 20; ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++教程","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 数据类型 使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。 您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其实 wchar_t 是这样来的： typedef short int wchar_t; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 **注意：**不同系统会有所差异，一字节为 8 位。 **注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。 下面实例会输出您电脑上各种数据类型的大小。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } 实例使用了 endl，这将在每一行后插入一个换行符，« 运算符用于向屏幕传多个值，sizeof() 函数用来获取各种数据类型的大小。 当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同： type: ************size************** bool: 所占字节数：1 最大值：1 最小值：0 char: 所占字节数：1 最大值： 最小值：? signed char: 所占字节数：1 最大值： 最小值：? unsigned char: 所占字节数：1 最大值：? 最小值： wchar_t: 所占字节数：4 最大值：2147483647 最小值：-2147483648 short: 所占字节数：2 最大值：32767 最小值：-32768 int: 所占字节数：4 最大值：2147483647 最小值：-2147483648 unsigned: 所占字节数：4 最大值：4294967295 最小值：0 long: 所占字节数：8 最大值：9223372036854775807 最小值：-9223372036854775808 unsigned long: 所占字节数：8 最大值：18446744073709551615 最小值：0 double: 所占字节数：8 最大值：1.79769e+308 最小值：2.22507e-308 long double: 所占字节数：16 最大值：1.18973e+4932 最小值：3.3621e-4932 float: 所占字节数：4 最大值：3.40282e+38 最小值：1.17549e-38 size_t: 所占字节数：8 最大值：18446744073709551615 最小值：0 string: 所占字节数：24 type: ************size************** ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"typedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 212 // 合法的 215u // 合法的 0xFeeL // 合法的 078 // 非法的：8 不是八进制的数字 032UU // 非法的：不能重复后缀 以下是各种类型的整数常量的实例： 85 // 十进制 0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 3.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数 210f // 非法的：没有小数或指数 .e55 // 非法的：缺少整数或分数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"布尔常量 布尔常量共有两个，它们都是标准的 C++ 关键字： true 值代表真。 false 值代表假。 我们不应把 true 的值看成 1，把 false 的值看成 0。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符常量 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x’），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 ' ’ 字符 \" \" 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 下面的实例显示了一些转义序列字符： 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello\\tWorld\\n\\n\"; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Hello World ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符串常量 字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用 ** 做分隔符，把一个很长的字符串常量进行分行。 下面的实例显示了一些字符串常量： 实例 #include \u003ciostream\u003e #include \u003cstring\u003e using namespace std; int main() { string greeting = \"hello, runoob\"; cout \u003c\u003c greeting; cout \u003c\u003c \"\\n\"; // 换行符 string greeting2 = \"hello, \\ runoob\"; cout \u003c\u003c greeting; return 0; } hello, runoob hello, runoob ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"定义常量 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"#define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\\n' int main() { int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value; 具体请看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 请注意，把常量定义为大写字母形式，是一个很好的编程习惯。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"C++ 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 unsigned x; unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： 实例 #include \u003ciostream\u003e using namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000 上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 教程 C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。 本教程通过通俗易懂的语言来讲解 C++ 编程语言。 现在开始学习 C++ 编程！ C++ 在线工具 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"谁适合阅读本教程？ 本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"阅读本教程前，您需要了解的知识： 在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"编译/执行 C++ 程序 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 运行实例 » 你可以用 \"\\n\" 代替以上代码里的 endl。 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c \"\\n\"; return 0; } ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"GitHub","date":"2023-04-01","objectID":"/2023/04/%E5%88%A9%E7%94%A8github-action%E5%AE%9E%E7%8E%B0hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github-pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/","series":null,"tags":null,"title":"利用GitHub Action实现Hugo博客在GitHub Pages自动部署","uri":"/2023/04/%E5%88%A9%E7%94%A8github-action%E5%AE%9E%E7%8E%B0hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github-pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"引用 作为一名IT民工，善于利用各种工具提升工作效率才算合格，本文简单记录自己如何利用GitHub Actions实现个人Hugo博客在GitHub Pages中的自动化部署。 传统方式 自己的个人博客创建于2016年，在这期间自己一直基于如下方式创建并部署更新博客： 利用hugo命令创建对应的博客markdown文件 hugo new post/hugo/using-github-action-to-auto-build-deploy.md 利用下述命令开启hugo博客的动态监听展示，并进行编写 hugo server -w -D 博客内容编写完成后，利用下述命令将其切换到实际部署环境 hugo server --baseUrl=\"https://lucumt.info/\" --watch=false --appendPort=false --renderToDisk --environment production 执行下述命令提交到master分支 git add -A git commit -a -m \"xxxx\" git push origin master 利用下述命令将public目录中的内容从master 分支同步到gh-pages分支 git subtree push --prefix=public git@github.com:lucumt/ghblog.git gh-pages 上述过程中的1,2,4阶段是编写博客的必经阶段，而3,5阶段其实没太多必要，完全可以用工具自动化实现。作为IT从业者，我们需要尽可能的减少不必要的操作。 改进方式 结合网络上的相关资料，自己把实现方案定在了GitHub Actions和Travis CI二者之一，考虑到GitHub中已经内置了GitHub Actions ，最终解决采用其作为实现方案。 在Hugo的官方文档Build Hugo With GitHub Action中也推荐采用GitHub Actions作为持续集成部署方案，并提供了相应的流水线配置代码: Copy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 name: github pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == 'refs/heads/main' with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 该配置代码已经很完善，个人根据实际情况对其做了如下修改： 在Build阶段，将hugo命令改为适合个人环境的hugo -b \"https://lucumt.info/\" -e \"production\" 在个人GitHub中设置github_token 其中关于github_token的配置可按如下步骤配置： 在个人GitHub页面，依次点击Settings-\u003eDeveloper settings-\u003ePersonal access tokens进入如下页面： 点击Generate new token出现如下界面，在Note中输入名称，在Select scopes选择workflow 将生成的token复制出来为后续创建secret做准备，注意必须及时复制，一旦离开此页面后续就无法查看其值，只能重新创建新token： 进入对应的GitHub项目下，依次点击Settings-\u003eSecrets-\u003eActions进入添加Action secrets的界面，点击New repository secret按钮 在出现的界面中name部分输入我们设置的值，Secret部分输入步骤3中记录的token值，然后点击Add secret按钮 需要注意的是name的值不能以GITHUB_开头，否则创建会出错 在流水线中将github_token值设置为步骤5中secret的名称，类似${{ secrets.GH_PAGE_ACTION_TOKEN }}s，至此github_token设置过程完毕。 配置后完整的流水线代码如下： Copy 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 name: pages-auto-build-deploy on: # workflow_dispatch: push: branches: - master jobs: build-and-deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.100.2' extended: true - name: Build Hugo run: hugo -b \"https://lucumt.info/\" -e \"production\" - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GH_PAGE_ACTION_TOKEN }} publish_dir: ./public commit_message: ${{ github.event.head_commit.message }} 将该yaml文件放到对应GitHub项目下的.github/workflows目录下即完成全部配置。 当执行git push origin master后，GitHub Actions会开启自动构建部署，运行结果如下，至此整个设置过程完毕！ 其它 由于GitHub Action支持定时语法，将流水线触发条件修改如下 Copy 1 2 3 4 5 6 7 on: push: branches: - master schedule: # Runs everyday at 8:00 AM - cron: \"0 8 * * *\" 可实现每天上午8点自动触发构建，由于构建过程中会往gh-pages分支下提交代码，从而间接达成在GitHub中每天提交代码，在GitHub主页面展示时保持全绿的功能！1 ","date":"2023-04-01","objectID":"/2023/04/%E5%88%A9%E7%94%A8github-action%E5%AE%9E%E7%8E%B0hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github-pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/:0:0","series":null,"tags":null,"title":"利用GitHub Action实现Hugo博客在GitHub Pages自动部署","uri":"/2023/04/%E5%88%A9%E7%94%A8github-action%E5%AE%9E%E7%8E%B0hugo%E5%8D%9A%E5%AE%A2%E5%9C%A8github-pages%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"},{"categories":null,"content":"GitHub","date":"2022-01-13","objectID":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/","series":null,"tags":["Git"],"title":"Git忽略文件及文件夹操作","uri":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"删除 .DS_Store 如果你的项目中还没有自动生成的 .DS_Store 文件，那么直接将 .DS_Store 加入到 .gitignore 文件就可以了。如果你的项目中已经存在 .DS_Store 文件，那就需要先从项目中将其删除，再将它加入到 .gitignore。如下： 删除项目中的所有.DS_Store。这会跳过不在项目中的 .DS_Store 1.find . -name .DS_Store -print0 | xargs -0 git rm -f --ignore-unmatch 将 .DS_Store 加入到 .gitignore 2.echo .DS_Store \u003e\u003e ~/.gitignore 更新项目 3.git add --all 4.git commit -m '.DS_Store banished!' 如果你只需要删除磁盘上的 .DS_Store，可以使用下面的命令来删除当前目录及其子目录下的所有.DS_Store 文件: find . -name '*.DS_Store' -type f -delete ","date":"2022-01-13","objectID":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/:1:0","series":null,"tags":["Git"],"title":"Git忽略文件及文件夹操作","uri":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"GitHub Desktop清除本地缓存 git rm -r --cached . git add . git commit -m \"update .gitignore\" 1、已经安装了GitHub Desktop 2、打开CMD命令行模式窗口，切换到你的仓库目录，再执行上述命令 ","date":"2022-01-13","objectID":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/:2:0","series":null,"tags":["Git"],"title":"Git忽略文件及文件夹操作","uri":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"git忽略特定文件夹操作 当用户把项目上传至git时，通常会有一些文件夹是本地依赖，不需要上传到代码仓库的。此时，可以在根目录新建git的配置文件 .gitignore，文件内容例如： .DS_Store node_modules/ /dist/ npm-debug.log* yarn-debug.log* yarn-error.log* # Editor directories and files .idea .vscode *.suo *.ntvs* *.njsproj *.sln 注意：当特定文件夹已经被上传至代码仓库，需要在配置文件中添加忽略该文件夹时，你会发现特定文件夹并没有被忽略，如下图 这是因为.gitignore只能忽略以前没有被track的文件，当前dist文件夹已经被纳入了版本管理中，所以只在.gitignore中删除是无效的，还需要运行如下命令清除缓存。 git rm -r --cached filename(此例为dist文件夹) 删除完缓存以后，再使用git status查看一下，就会发现，dist目录中的文件被从版本管理中移除了 最后将代码提交，就大功告成了 git add -A git commit -m “忽略dist文件夹内容” ","date":"2022-01-13","objectID":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/:3:0","series":null,"tags":["Git"],"title":"Git忽略文件及文件夹操作","uri":"/2022/01/git%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9%E6%93%8D%E4%BD%9C/"},{"categories":null,"content":"Game","date":"2022-01-13","objectID":"/2022/01/%E6%96%87%E6%98%8E6mac/","series":null,"tags":null,"title":"文明6mac","uri":"/2022/01/%E6%96%87%E6%98%8E6mac/"},{"categories":null,"content":"闪退 方法1 1.在桌面点击最左上角的苹果图标 2.选择系统设置 3.选择安全与隐私 4.找到完全磁盘访问权限 5.找到文明6的图标，给他权限 6.进游戏检查是否可以打开 方法2 目前解决方案是将MODS从文档/Users/xinqi/Library/Application Support/Sid Meier's Civilization VI\\Mods\\文件夹里移至游戏目录/Applications/Civ6.app/Contents/Assets/Base/Assets/Scenarios文件夹下 ","date":"2022-01-13","objectID":"/2022/01/%E6%96%87%E6%98%8E6mac/:1:0","series":null,"tags":null,"title":"文明6mac","uri":"/2022/01/%E6%96%87%E6%98%8E6mac/"},{"categories":null,"content":"GitHub","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"持续创作，加速成长！这是我参与「掘金日新计划 · 6 月更文挑战」的第2天，点击查看活动详情 ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:0:0","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"0x1、问题描述 前些日子折腾了一个618自动做任务的jio本，随手写了两篇文章： 《节约\"阳寿\"——某电商618活动自动化》 《破大防！这个开源库，竟能让APP日常任务自动化变得如此简单》 因为代码写得乱而且有BUG，所以仓库虽然建了，代码却久久未上传，不过好像真的有人需要，恰逢今天没啥事，索性整理Push一波。 和往常提交代码一样，git add、git commit 然后添加远程仓库地址，准备push： git remote add origin git@github.com:coder-pig/CPAuto.git git push -u origin main 但却没有预期中的push成功： 这TM咋回事？ 前不久写的权限库上传没这个问题啊？换成https协议试试： git remote set-url origin https://github.com/coder-pig/CPAuto.git git push -u origin main 同样没有预期中的成功： ？？？ 可能需要 代理？终端键入下述命令启用一波： set http_proxy=http://127.0.0.1:7890 set https_proxy=http://127.0.0.1:7890 在此push，弹出登录弹窗： 键入账号密码，点击登录： 又得输一遍？反复确认账号密码没错后，我又输了一遍： 又报错了，简单翻译下原因： 对密码身份验证的支持已于2021年8月13日移除，请改用个人 访问令牌 后面还贴了一个官方的解释：Token authentication requirements for Git operations 大概意思：为了安全，取消账号密码身份验证，而使用令牌(Token)的身份验证，它有这些好处： 唯一： 令牌特定于 GitHub，可以按使用或按设备生成； 可撤销：可以随时单独撤销令牌，而无需更新未受影响的凭据； 有限 ： 令牌可以缩小范围以仅允许用例所需的访问； 随机：令牌不需要记住或定期输入的更简单密码可能会受到的字典类型或蛮力尝试的影响； 然后：SSH密钥的方式还是保留的，至于我采用这种方式push不成功及如何解决，等下会说。 好的，先来生成一波Github Token~ ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:1:0","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"0x2、生成Github Token 打开Github，点击自己的头像，依次点击 Settings → Developer Settings → Personal access tokens → Generate new token： 接着填Token描述、选有效期，勾选Token的作用域： 确认无误后，点击底下的 Generate token 生成Token： 然后是生成的Token： 注意保存好Token！！！页面刷新后你就再也看不到它了，当然实在忘记了，删掉再新建一个也是可以的~ 接着命令行修改下远程仓库的地址，加上这个token： git remote set-url origin https://\u003cyour_token\u003e@github.com/\u003cUSERNAME\u003e/\u003cREPO\u003e.git 如我的仓库： 此时再Push： 成功~ ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:2:0","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"0x3、SSH密钥 生成与配置SSH KEY具体步骤可见：《7.SSH Key避免每次push重复输入账号密码》，就不复述了。 本地和Github上都有这个密钥，但是就是不能Push，而且我发现旧项目也不能Push了，明明三周前还Push过一次的。网上一堆文章教你建个没卵用的config，也是醉了，只能自己排查一下了… ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:3:0","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"问题排查过程 使用ssh -v打印出详细日志： ssh -vT git@github.com 日志打印结果如下： 我擦？127.0.0.1，怎么指向本机地址了？ping一下： 看下 hosts 文件，并没有隐射这个地址，ipconfig/flushdns 刷新了DNS缓存，再ping也是这样。 百度了一波，很多人提到了 运营商DNS污染，用站长工具的DNS查询了一下： 卧槽？该不会那么恶心吧？本地 ipconfig/all 找到使用的DNS服务器地址： 接着使用 nslookup 域名 DNS服务器地址 看下能否解析： 呵呵，果真如此，估计是最近有什么日子，所以一刀切，知道了原因，解决方法就来了~ ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:3:1","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"解法一：修改DNS指向 控制面板 → 网络和Internet → 网络链接： 右键属性，找到 Internet 协议版本4(TCP/IPv4)属性，勾选使用下面的DNS服务器地址： 确定后，再次Push就可以了： 除了114.114.114.114、8.8.8.8 外，还有这些公用的DNS服务器可供选择： # 腾讯 DNS：（DNSPOD） IPv4地址： 119.29.29.29 182.254.116.116 IPv6地址： 2402:4e00:: # 阿里DNS： IPv4地址： 223.5.5.5 223.6.6.6 IPv6地址： 2400:3200::1 2400:3200:baba::1 # 百度DNS： ipv4：180.76.76.76 ipv6：2400:da00::6666 ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:3:2","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"解法二：修改Hosts windows系统，依次打开：C:\\Windows\\System32\\drivers\\etc，添加github.com解析，如： 键入git pull一下看看： 可以，如果DNS失效了，可以替换方法一种的DNS，也可以到站长之家DNS解析那里Copy，如果设置后没生效，可以在终端键入 ipconfig/flushdns 刷新下DNS缓存。附：群里的热心小伙分享的hosts，取需~ 140.82.114.26 alive.github.com 140.82.114.25 live.github.com 185.199.108.154 github.githubassets.com 140.82.112.21 central.github.com 185.199.108.133 desktop.githubusercontent.com 185.199.108.153 assets-cdn.github.com 185.199.108.133 camo.githubusercontent.com 185.199.108.133 github.map.fastly.net 199.232.69.194 github.global.ssl.fastly.net 140.82.113.3 gist.github.com 185.199.108.153 github.io 140.82.112.4 github.com 192.0.66.2 github.blog 140.82.112.6 api.github.com 185.199.108.133 raw.githubusercontent.com 185.199.108.133 user-images.githubusercontent.com 185.199.108.133 favicons.githubusercontent.com 185.199.108.133 avatars5.githubusercontent.com 185.199.108.133 avatars4.githubusercontent.com 185.199.108.133 avatars3.githubusercontent.com 185.199.108.133 avatars2.githubusercontent.com 185.199.108.133 avatars1.githubusercontent.com 185.199.108.133 avatars0.githubusercontent.com 185.199.108.133 avatars.githubusercontent.com 140.82.114.9 codeload.github.com 52.217.168.41 github-cloud.s3.amazonaws.com 52.217.194.89 github-com.s3.amazonaws.com 52.216.93.147 github-production-release-asset-2e65be.s3.amazonaws.com 52.216.93.147 github-production-user-asset-6210df.s3.amazonaws.com 52.217.202.113 github-production-repository-file-5c1aeb.s3.amazonaws.com 185.199.108.153 githubstatus.com 64.71.144.211 github.community 23.100.27.125 github.dev 140.82.113.21 collector.github.com 13.107.42.16 pipelines.actions.githubusercontent.com 185.199.108.133 media.githubusercontent.com 185.199.108.133 cloud.githubusercontent.com 185.199.108.133 objects.githubusercontent.com ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:3:3","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"解法三：代理设置 前两种方法适合没有代理的，作为一个面向Google编程的开发仔，基本人手必备一个代理~ 详细配置与相关问题，可以参见stackoverflow上的：《Connect with SSH through a proxy》 修改 ~/.ssh/config 文件，没有的话新建一个，按需添加代理配置，以读者Windows + Clash (socks5)为例： ProxyCommand connect -S 127.0.0.1:7890 -a none %h %p Host *github.com HostName github.com User git 此时再ssh -T，就可以了~ 附：Windows平台没有nc命令，MAC、Linux平台上设置命令如下： # socks5 ProxyCommand nc -v -x 127.0.0.1:1086 %h %p # HTTP代理，需要brew install socat ProxyCommand socat - PROXY:127.0.0.1:%h:%p,proxyport=1087 SSH代理配置非常简单，顺带也提下 Https代理配置 相关： ① 只对Github代理 (推荐) # http代理 git config --global http.https://github.com.proxy http://127.0.0.1:58591 # socks代理 git config --global http.https://github.com.proxy socks5://127.0.0.1:7890 ② 全局设置 (不推荐) #使用http代理 git config --global http.proxy http://127.0.0.1:58591 git config --global https.proxy https://127.0.0.1:58591 #使用socks5代理 git config --global http.proxy socks5://127.0.0.1:7890 git config --global https.proxy socks5://127.0.0.1:7890 ③ 取消代理 git config --global --unset http.proxy git config --global --unset https.proxy ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:3:4","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"0x4、小结 本节先描述了代码无法Push到Github上的问题，并进行了排查和解决，中途发现 Github为了安全，已于2021年8月13日取消账号密码身份验证，而使用令牌(Token)的身份验证，阐述了如何创建和使用这个Token。紧接着发现 运营商DNS污染(真TM坑) 导致ssh github指向本机地址(127.0.0.1)的问题，并提供了 改DNS、改Hosts、代理设置 的解决方案。 有同样情况的童鞋赶紧试试吧，本文应该能帮您解决这个问题，如果还不行可在评论区提出，一起探讨，感谢~ ","date":"2022-01-13","objectID":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/:4:0","series":null,"tags":null,"title":"无法Push代码到Github？？？","uri":"/2022/01/%E6%97%A0%E6%B3%95push%E4%BB%A3%E7%A0%81%E5%88%B0github/"},{"categories":null,"content":"发现最近网站的访问速度并不理想，因为当时只托管在了 GitHub 上，GitHub的服务器在国外，所以导致国内访问服务器的时间比较长。 解决方法就是把网站同时托管在国内的 Coding 上，正好他们也提供了 pages 服务。让国外解析到 GitHub 的服务器上，国内解析到 Coding 的服务器上，这样无论是在国内，还是再国外，网站的访问速度都会大幅提升。 所以就有了这次的踩坑经历，用 Git 同时管理并 push 到两个远程仓库。 废话不多说，下面直接上干货。 ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:0:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"创建远程仓库 先在 Coding 和 GitHub 上创建仓库，为了避免错误，不要初始化 README，license，或者 gitignore 文件 GitHub ： Coding ： ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:1:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"进入本地项目 打开终端，cd 你的本地项目地址，进入项目目录： ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:2:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"初始化本地仓库 git init ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:3:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"删除已关联的名为origin的远程库 使用多个远程库时，要注意 Git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库，首先要删除已关联的名为 origin 的远程库： git remote rm origin 如果输入后显示如下图所示：fatal: No such remote: origin ，说明你本地项目没有已关联的名为 origin 的远程库，那么你可以忽略此步。 ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:4:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"配置Git用户名和邮箱 git config user.name \"lien\" git config user.email \"artjay.code@gmail.com\" ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:5:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"关联GitHub远程库 这里我用的是 SSH 的方式，至于如何管理并配置 SSH，你可以参考这里 注意，远程库的名称叫 github，不叫 origin 了！ git remote add github git@github.com:isArtJay/test.git ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:6:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"关联Coding远程库 同样注意，远程库的名称叫 coding，不叫 origin 了！ git remote add coding git@e.coding.net:liencn/lien/test.git 现在，我们用 git remote -v 查看远程库信息，可以看到两个远程库： ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:7:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"添加文件到本地仓库 添加文件到本地仓库，其中 . 的意思是本地项目目录中的所有文件： git add . ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:8:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"提交文件 -m 后的参数是你的提交信息，可以随意填写： git commit -m \"First commit\" ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:9:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"push到远程仓库 如果要 push 到 GitHub，使用命令： git push github master 如果要 push 到 Coding，使用命令： git push coding master ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:10:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"查看远程仓库 可以看到我们已经将本地项目推送到了的 GitHub 仓库和 Coding 仓库： GitHub ： Coding ： ","date":"2022-01-13","objectID":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/:11:0","series":null,"tags":null,"title":"用Git同时上传代码到github和coding","uri":"/2022/01/%E7%94%A8git%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0github%E5%92%8Ccoding/"},{"categories":null,"content":"GitHub","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"Markdown数学公式语法 ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:0:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"行内与独行 行内公式：将公式插入到本行内，符号：$公式内容$，如：$xyz$ 独行公式：将公式插入到新的一行内，并且居中，符号：$$公式内容$$，如：$$xyz$$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:1:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"上标、下标与组合 上标符号，符号：^，如：$x^4$ 下标符号，符号：_，如：$x_1$ 组合符号，符号：{}，如：${16}{8}O{2+}{2}$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:2:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"汉字、字体与格式 汉字形式，符号：\\mbox{}，如：$V_{\\mbox{初始}}$ 字体控制，符号：\\displaystyle，如：$\\displaystyle \\frac{x+y}{y+z}$ 下划线符号，符号：\\underline，如：$\\underline{x+y}$ 标签，符号\\tag{数字}，如：$\\tag{11}$ 上大括号，符号：\\overbrace{算式}，如：$\\overbrace{a+b+c+d}^{2.0}$ 下大括号，符号：\\underbrace{算式}，如：$a+\\underbrace{b+c}_{1.0}+d$ 上位符号，符号：\\stacrel{上位符号}{基位符号}，如：$\\vec{x}\\stackrel{\\mathrm{def}}{=}{x_1,\\dots,x_n}$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:3:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"占位符 两个quad空格，符号：\\qquad，如：$x \\qquad y$ quad空格，符号：\\quad，如：$x \\quad y$ 大空格，符号\\，如：$x \\ y$ 中空格，符号\\:，如：$x : y$ 小空格，符号\\,，如：$x , y$ 没有空格，符号``，如：$xy$ 紧贴，符号\\!，如：$x ! y$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:4:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"定界符与组合 括号，符号：（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)，如：$（）\\big(\\big) \\Big(\\Big) \\bigg(\\bigg) \\Bigg(\\Bigg)$ 中括号，符号：[]，如：$[x+y]$ 大括号，符号：\\{ \\}，如：${x+y}$ 自适应括号，符号：\\left \\right，如：$\\left(x\\right)$，$\\left(x{yz}\\right)$ 组合公式，符号：{上位公式 \\choose 下位公式}，如：${n+1 \\choose k}={n \\choose k}+{n \\choose k-1}$ 组合公式，符号：{上位公式 \\atop 下位公式}，如：$\\sum_{k_0,k_1,\\ldots\u003e0 \\atop k_0+k_1+\\cdots=n}A_{k_0}A_{k_1}\\cdots$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:5:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"四则运算 加法运算，符号：+，如：$x+y=z$ 减法运算，符号：-，如：$x-y=z$ 加减运算，符号：\\pm，如：$x \\pm y=z$ 减甲运算，符号：\\mp，如：$x \\mp y=z$ 乘法运算，符号：\\times，如：$x \\times y=z$ 点乘运算，符号：\\cdot，如：$x \\cdot y=z$ 星乘运算，符号：\\ast，如：$x \\ast y=z$ 除法运算，符号：\\div，如：$x \\div y=z$ 斜法运算，符号：/，如：$x/y=z$ 分式表示，符号：\\frac{分子}{分母}，如：$\\frac{x+y}{y+z}$ 分式表示，符号：{分子} \\voer {分母}，如：${x+y} \\over {y+z}$ 绝对值表示，符号：||，如：$|x+y|$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:6:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"高级运算 平均数运算，符号：\\overline{算式}，如：$\\overline{xyz}$ 开二次方运算，符号：\\sqrt，如：$\\sqrt x$ 开方运算，符号：\\sqrt[开方数]{被开方数}，如：$\\sqrt[3]{x+y}$ 对数运算，符号：\\log，如：$\\log(x)$ 极限运算，符号：\\lim，如：$\\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 极限运算，符号：\\displaystyle \\lim，如：$\\displaystyle \\lim^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\sum，如：$\\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 求和运算，符号：\\displaystyle \\sum，如：$\\displaystyle \\sum^{x \\to \\infty}_{y \\to 0}{\\frac{x}{y}}$ 积分运算，符号：\\int，如：$\\int^{\\infty}_{0}{xdx}$ 积分运算，符号：\\displaystyle \\int，如：$\\displaystyle \\int^{\\infty}_{0}{xdx}$ 微分运算，符号：\\partial，如：$\\frac{\\partial x}{\\partial y}$ 矩阵表示，符号：\\begin{matrix} \\end{matrix}，如：$\\left[ \\begin{matrix} 1 \u00262 \u0026\\cdots \u00264\\5 \u00266 \u0026\\cdots \u00268\\vdots \u0026\\vdots \u0026\\ddots \u0026\\vdots\\13 \u002614 \u0026\\cdots \u002616\\end{matrix} \\right]$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:7:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"逻辑运算 等于运算，符号：=，如：$x+y=z$ 大于运算，符号：\u003e，如：$x+y\u003ez$ 小于运算，符号：\u003c，如：$x+y\u003cz$ 大于等于运算，符号：\\geq，如：$x+y \\geq z$ 小于等于运算，符号：\\leq，如：$x+y \\leq z$ 不等于运算，符号：\\neq，如：$x+y \\neq z$ 不大于等于运算，符号：\\ngeq，如：$x+y \\ngeq z$ 不大于等于运算，符号：\\not\\geq，如：$x+y \\not\\geq z$ 不小于等于运算，符号：\\nleq，如：$x+y \\nleq z$ 不小于等于运算，符号：\\not\\leq，如：$x+y \\not\\leq z$ 约等于运算，符号：\\approx，如：$x+y \\approx z$ 恒定等于运算，符号：\\equiv，如：$x+y \\equiv z$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:8:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"集合运算 属于运算，符号：\\in，如：$x \\in y$ 不属于运算，符号：\\notin，如：$x \\notin y$ 不属于运算，符号：\\not\\in，如：$x \\not\\in y$ 子集运算，符号：\\subset，如：$x \\subset y$ 子集运算，符号：\\supset，如：$x \\supset y$ 真子集运算，符号：\\subseteq，如：$x \\subseteq y$ 非真子集运算，符号：\\subsetneq，如：$x \\subsetneq y$ 真子集运算，符号：\\supseteq，如：$x \\supseteq y$ 非真子集运算，符号：\\supsetneq，如：$x \\supsetneq y$ 非子集运算，符号：\\not\\subset，如：$x \\not\\subset y$ 非子集运算，符号：\\not\\supset，如：$x \\not\\supset y$ 并集运算，符号：\\cup，如：$x \\cup y$ 交集运算，符号：\\cap，如：$x \\cap y$ 差集运算，符号：\\setminus，如：$x \\setminus y$ 同或运算，符号：\\bigodot，如：$x \\bigodot y$ 同与运算，符号：\\bigotimes，如：$x \\bigotimes y$ 实数集合，符号：\\mathbb{R}，如：\\mathbb{R} 自然数集合，符号：\\mathbb{Z}，如：\\mathbb{Z} 空集，符号：\\emptyset，如：$\\emptyset$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:9:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"数学符号 无穷，符号：\\infty，如：$\\infty$ 虚数，符号：\\imath，如：$\\imath$ 虚数，符号：\\jmath，如：$\\jmath$ 数学符号，符号\\hat{a}，如：$\\hat{a}$ 数学符号，符号\\check{a}，如：$\\check{a}$ 数学符号，符号\\breve{a}，如：$\\breve{a}$ 数学符号，符号\\tilde{a}，如：$\\tilde{a}$ 数学符号，符号\\bar{a}，如：$\\bar{a}$ 矢量符号，符号\\vec{a}，如：$\\vec{a}$ 数学符号，符号\\acute{a}，如：$\\acute{a}$ 数学符号，符号\\grave{a}，如：$\\grave{a}$ 数学符号，符号\\mathring{a}，如：$\\mathring{a}$ 一阶导数符号，符号\\dot{a}，如：$\\dot{a}$ 二阶导数符号，符号\\ddot{a}，如：$\\ddot{a}$ 上箭头，符号：\\uparrow，如：$\\uparrow$ 上箭头，符号：\\Uparrow，如：$\\Uparrow$ 下箭头，符号：\\downarrow，如：$\\downarrow$ 下箭头，符号：\\Downarrow，如：$\\Downarrow$ 左箭头，符号：\\leftarrow，如：$\\leftarrow$ 左箭头，符号：\\Leftarrow，如：$\\Leftarrow$ 右箭头，符号：\\rightarrow，如：$\\rightarrow$ 右箭头，符号：\\Rightarrow，如：$\\Rightarrow$ 底端对齐的省略号，符号：\\ldots，如：$1,2,\\ldots,n$ 中线对齐的省略号，符号：\\cdots，如：$x_1^2 + x_2^2 + \\cdots + x_n^2$ 竖直对齐的省略号，符号：\\vdots，如：$\\vdots$ 斜对齐的省略号，符号：\\ddots，如：$\\ddots$ ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:10:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":null,"content":"希腊字母 字母 实现 字母 实现 A A α \\alhpa B B β \\beta Γ \\Gamma γ \\gamma Δ \\Delta δ \\delta E E ϵ \\epsilon Z Z ζ \\zeta H H η \\eta Θ \\Theta θ \\theta I I ι \\iota K K κ \\kappa Λ \\Lambda λ \\lambda M M μ \\mu N N ν \\nu Ξ \\Xi ξ \\xi O O ο \\omicron Π \\Pi π \\pi P P ρ \\rho Σ \\Sigma σ \\sigma T T τ \\tau Υ \\Upsilon υ \\upsilon Φ \\Phi ϕ \\phi X X χ \\chi Ψ \\Psi ψ \\psi Ω \\v ω \\omega ","date":"2022-01-02","objectID":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/:11:0","series":null,"tags":null,"title":"数学公式","uri":"/2022/01/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"},{"categories":["Mermaid"],"content":"GitHub","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":["Mermaid"],"content":"Mermaid之流程图语法 ","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":["Mermaid"],"content":"可能的形状有: ([])体育场形 表示开始/结束 []矩形/()圆角矩形 表示流程(一些特定的操作) [[]]表示子流程 [()]圆柱体 表示数据库 (())圆形 表示页面内引用(指示流程在同一页面上其他位置包含相同字母的匹配符号上继续进行) \u003e]不规则形状 {}菱形 表示判断 {{}}六角形 表示预备流程/初始化 ///\\平行四边形 表示数据(输入数据(参数)/输出数据(结果)) ///梯形 表示人工操作(只能人为进行的操作) graph LR A([开始])--\u003eA1([结束]) B[流程]--- C(流程)--- D[[子流程]]--- E[(数据库)] F((页面引用))--- G\u003e不规则形状]--- H{条件判断}--- I{{初始化}} J[/输入/出/]--- K[\\输入/出\\]--- L[/人为操作\\]--- M[\\人为操作/] ","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"Quick setup — if you’ve done this kind of thing before Set up in Desktop or HTTPS https://github.com/xinqinew/NewCode.git SSH git@github.com:xinqinew/NewCode.git Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore. ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:1","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"在命令行上创建新的存储库 echo \"# NewCode\" \u003e\u003e README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin git@github.com:xinqinew/NewCode.git git push -u origin main ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:2","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"从命令行推出现有存储库 git remote add origin git@github.com:xinqinew/NewCode.git git branch -M main git push -u origin main ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:3","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"从另一个存储库中导入代码 You can initialize this repository with code from a Subversion, Mercurial, or TFS project. Import code ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:4","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"GitHub不再支持密码验证解决方案：SSH免密与Token登录配置 今天提交代码，push到GitHub上，突然出现这个问题。 remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access ‘https://github.com/zhoulujun/algorithm.git/': The requested URL returned error: 403 官方的解释：https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/ As previously announced, starting on August 13, 2021, at 09:00 PST, we will no longer accept account passwords when authenticating Git operations on GitHub.com. Instead, token-based authentication (for example, personal access, OAuth, SSH Key, or GitHub App installation token) will be required for all authenticated Git operations. Please refer to this blog post for instructions on what you need to do to continue using git operations securely. Removal August 13, 2021, at 09:00 PST 大致意思是，密码验证于2021年8月13日不再支持，也就是今天intellij不能再用密码方式去提交代码。请用使用 personal access token 替代。 这个去年年底就说了，https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ In July 2020, we announced our intent to require the use of token-based authentication (for example, a personal access, OAuth, or GitHub App installation token) for all authenticated Git operations. Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations on GitHub.com. 自己鼓捣了一遍 Token，烦人的很。还是觉得直接ssh 的方式操作git就好(之前是ssh的源，也没有这个问题)。 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:0:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"github配置SSH免密登录 这里讲的是Mac OS 操作。windows可以借鉴 查看ssh目录 ls -al ~/.ssh Mac OS目录~/.ssh，windows目录是： Users/uestc/.ssh/id_rsa -如果有配过，会列出： id_rsa (私钥)——这个不能泄露 id_rsa.pub（公钥） -如果没有配过，那么就进入第二步 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"新建一个新的SSH KEY ssh-keygen -t rsa -b 4096 -C \"uestchan@sina.com\" 接着会提示这个公钥私钥的保存路径-建议直接回车就好（默认目录里) 接着提示输入私钥密码passphrase - 如果不想使用私钥登录的话，私钥密码为空，直接回车 生成成功后，把 id_rsa.pub 拷贝到 github 新建的 SSH keys 中 配置好好，记住，你项目得使用 SSH clone 如果本地是https 源，那么就修改git 仓库地址 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:1","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"git修改远程仓库地址 方法有三种： 1.修改命令 git remote origin set-url [url] 先删后加 git remote rm origin git remote add origin [url] 直接修改config文件 git文件夹，找到config，编辑，把就的项目地址替换成新的。 顺手安利下 《git宝典—应付日常工作使用足够的指北手册》 关于github 建议让换 Token的形势，操作如下 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:2","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"GitHub token 打开自己的GitHub主页，点击自己的头像找到Settings并进入，在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请即可，过程简单。Scopes（范围）那里建议全选。 Token申请成功后，将Token复制到Token一栏中 操作路径： 生成新的token就好。权限我是全部勾选上的。 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:3","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"Intellij IDEA 上Github账号校验 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"配置Git路径 打开Settings（File–\u003eSettings） –\u003e 在搜索栏内输入git，回车跳转到Git配置页面 –\u003e 将git的运行路径填入Path to Git executable一栏（一般IDEA会自动定位） ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:1","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"配置GitHub账户密码 第一种方法可以选择使用帐号密码认证（Password） 之前的老板是这样的 在Login一栏填入你GitHub的用户名 –\u003e Password那栏填入你GitHub的登录密码 现在新版本的，点击密码登录，会自动跳转到登录验证页面，在验证页面点击确定（我的密码是chrome记住的）。就自动登录 选择log width token，填入token就好 参考文章： github配置SSH免密登录 https://blog.csdn.net/qq_38163309/article/details/105335097 GIT免密登录神器 SSH KEY配置详解 https://blog.csdn.net/w15321271041/article/details/80535135 Intellij IDEA 使用GitHub+Git https://www.cnblogs.com/yysbolg/p/8566389.html Intellij IDEA 协同 Git 与 GitHub 进行开发使用 https://www.jianshu.com/p/ea1703adf5cc Github 生成token的方法 — IDEA 拉代码或push失败需要从新校验Token https://blog.csdn.net/SR02020/article/details/106882205 Intellij IDEA 协同 Git 与 GitHub 进行开发使用 https://www.jianshu.com/p/ea1703adf5cc ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:2","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"俺如何为 hugo-theme-even 提供 mermaid 支持 如上是一个利用 mermaid 绘制的 SVG 图形 ，相比于直接在某些软件绘制好再截图，显然利用 mermaid 绘图具备诸多优点： 网站保存的是带 mermaid 的 markdown 文件，不涉及到图片存储。存储占用小。 渲染出图是 SVG 格式，上面的文字可以直接拷贝。 网站数据传输时是使用 mermaid 源码，而不是图片，可以有效减少网站加载过程产生的流量耗费。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:0:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"如何为你的 Hugo 博客引入 mermaid 支持？ 贴士 虽然由于 even theme 更新过慢，似乎久已无更多维护，因此本站已经开始使用 LoveIt 作为主题。 但是对于 even theme 而言，本方法应当依旧适用。 对于这一点，俺可以说前人之述备矣。反手就是一堆参考资料： Diagrams in hugo with mermaid 拓展 Hugo 的 MarkDown 流程图 这些解决方案引入 mermaid 的方法简单素雅，这一套流程可以总结为： 在博客中加载 mermaidJS。具体方法有： 直接在一定会加载的 HTML 文件中引入 \u003cscript\u003e 标签，加载 mermaid。 在部分支持自定义 JavaScript 的主题中，引入 JavaScript 文件。 自定义 ShortCodes，依靠 ShortCodes 实现标签替换。 但是习惯了通过 typora 之类的 MarkDown 拓展编辑器，他们无一例外都支持按照如下风格进行渲染： ```mermaid ... 图表内容 ... ``` 能不能实现它，从而实现更加一颗赛艇的编辑体验呢？ 能的。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:1:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"实现原理 通过阅读 mermaid 的 API 咱们可以得知 mermaidAPI 渲染 mermaid 图形的大致流程： 上述的特定标签是指\u003cdiv class=\"mermaid\"\u003e的 HTML 标签。通过检查页面元素，咱们会发现如今的大部分博客将代码块渲染成如下式样： \u003cpre\u003e\u003ccode class=\"language-语言种类\"\u003e \u003c!-- code --\u003e \u003c/code\u003e\u003c/pre\u003e 也就是说咱们只需要找到形如： \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e \u003c!-- mermaid code --\u003e \u003c/code\u003e\u003c/pre\u003e 的代码块，并将其替换成\u003cdiv class=\"mermaid\"\u003e即可。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:2:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"在 even theme 中的实现 注意 注意： 下文中的 “/” 目录代表 even theme 项目的根目录而不是 *nix 文件系统的 root. 本博客使用的是 even theme. 但是俺相信参照本文在其他博客中进行实现也会大差不差。 俺在自己实现了此种风格之后即向 hugo-theme-even 提出了 PR，even theme 的用户应该可以在不久以后在新版本中得到 mermaid 支持。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"导入 mermaid.min.js 实现应当遵循原理的指示精神，首先咱们需要拥有 mermaid 库。通过观察源码猜测 even 主题在 /static/layouts/partials/scripts.html 中进行 JS 的载入。于是咱们向其中插入能够引入 mermaid 模块的 script 标签。（实际上只要是会被加载的 HTML 文件都可以插） 这个标签在 HTML 文件里随便找个地方插就完事了，如果完全不懂，建议怼到 HTML 文件末尾。 通过 CDN 导入 为了保持文章的时效性，俺不会直接提供该 script 标签，但是你可以在 jsdelivr.com 中找到你中意版本的 mermaid.min.js 并按下右边的 Copy HTML + SRI 按钮即可获得对应的标签。 通过本地文件导入 由于房间里的大象太大挡住了境外CDN的信号，所以你也可以选择本地文件。在网上找到你中意版本的 mermaid.min.js, 下载下来并放在 /static/lib/mermaid/ 目录下（没有就新建一个），这时可以得到对应的 script 标签如下： \u003cscript src=\"{{ \"lib/mermaid/mermaid.min.js\" | relURL }}\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e 本人对境外 CDN 在内地的稳定性持悲观态度，建议中国大陆用户使用此方法。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:1","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"替换 HTML 标签 观察 even 主题的源码，咱们可以在 /assets/js/ 目录下发现 main.js 和 even.js。在 even.js 中插入如下代码段： // 插到文件末尾完事了 Even.mermaid = function () { if (!window.mermaid) return; const blocks = document.querySelectorAll(\"pre code.language-mermaid\"); // change all \u003cpre\u003e\u003ccode mamaid\u003e tags to \u003cdiv class=\"mermaid\"\u003e // mermaid will handle the rest! for (let i = 0; i \u003c blocks.length; i++) { if (!window.hljs \u0026\u0026 i % 2 === 0) continue; const block = blocks[i]; const rootElement = window.hljs ? block.parentElement : block.parentElement.parentElement.parentElement.parentElement .parentElement.parentElement.parentElement; var container = document.createElement(\"div\"); const id = `js-mermaid-diagrams-${i}`; container.id = id; container.className = \"align-center mermaid\"; container.textContent = block.childNodes[0].textContent; rootElement.parentElement.replaceChild(container, rootElement); } window.mermaid.mermaidAPI.initialize( window.mermaidOptions ? window.mermaidOptions : { securityLevel: \"loose\", theme: \"base\" } // 替换它可以修改 mermaid 的样式=======↑ ); }; 在 main.js 中插入： // 个人比较喜欢插在 Even.sequence(); 的后面 Even.mermaid(); 现在你应该可以在自己的博客中写 mermaid 了。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:2","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"工具推荐 Typora 写 MarkDown 咋能少得了 「Typora」？ Visual Studio Code 俺写这篇文章用的无所不能的编辑器，建议添加插件： Markdown All in One Markdown Preview Enhanced Mermaid Markdown Syntax Highlighting 之所以用 Visual Studio Code，很大程度上是因为它的 Vim 拓展。 “2021年了不会还有人不会用 Vim 吧？” vim ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:3","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"GitHub","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"好好配置了一下Hugo ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:0:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":" 换了个新的主题，原来的主题有Bug。 重新配置了MathJax和mermaid，原本随便弄的那个用不了了。 给旧文章换了标题 给文章打了tags 中文文章要设置isCJKLanguage=true不然字数是错的 重新写了部署脚本 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:1:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"换主题 之前用的主题叫hugo_theme_pickles，研究了下发现bug非常严重。它对主页的渲染就存在很大的问题，文章不会显示在主页上。遂尝试更新。更新之后问题更大了，除了Posts菜单下的文章都显示不出来了。而且看了一眼那个项目的提交历史也是非常混乱…… 去Hugo主题页找主题咯，最后发现自己还是喜欢Hermit这种简约的风格。 有些主题会让你把它加到你Git储存库的submodules，说是方便你升级。其实这个东西加上去很容易，要删就麻烦了 添加只要一个命令： git submodule add \u003curl\u003e \u003cpath\u003e Copy 删要手动删： # https://blog.csdn.net/guotianqing/article/details/82391665 rm -rf #子模块目录 删除子模块目录及源码 vi .gitmodules #删除项目目录下.gitmodules文件中子模块相关条目 vi .git/config #删除配置项中子模块相关条目 rm .git/module/* #删除模块下的子模块目录，注意只删除对应的子模块目录即可 Copy ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:2:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"重新配置MathJax和mermaid MathJax是用来渲染数学公式的，mermaid是用来渲染图表的。Hugo升级之后不给我直接在Markdown里嵌HTML了，然后就探索了一下到底应该怎么弄 配置这两个东西主要要把\u003cscript\u003e标签加到页面里，所以要在/layouts/partials目录下创建一个自定义的页面头模版。 {{ if .Params.usemermaid}} \u003cscript src=\"/mermaid.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e window.onload = function () { mermaid.initialize({ theme: \"dark\" }) mermaid.init(undefined, \".language-mermaid\"); }; \u003c/script\u003e {{ end }} {{ if .Params.usemathjax }} \u003cscript src='/MathJax.js' async\u003e\u003c/script\u003e {{ end }} 用模版的语法判断当前页面是否启用了MathJax或者mermaid支持，只有当在文章开头的Front Matter里面显式地注明usemathjax: true和usemermaid: true，才为当前页面引入相应的.js。 网上有种配置mermaid的方法要用到shortcodes，但是那种用起来麻烦。我这种的话直接在Markdown里定义一个语言类型为mermaid的代码块就能渲染出图表了 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用mermaid ```mermaid graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ``` graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ps: 在代码块里嵌入要用到零宽字符\\u200b` ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:1","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用MathJax 在文章里写\\\\( \\\\LaTeX \\\\) 会被Markdown转义为\\( \\LaTeX \\) 经过MathJax处理输出LATEXLATEX ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:2","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"给文章换标题 要有一个好标题才能吸引读者吧哈哈哈 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:4:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"打标签tags 直接在Front Matter里面写tags: [\"tag1\", \"tag2\"]就好了，Hugo会自动分类 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:5:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"重新写了部署脚本 我之前自己写的用的是笨办法，是先tar打包，然后scp传上服务器，再在服务端解压，所以每次都要传输全部的数据。 直到我今天看的Hugo介绍的部署方法，用rsync可以实现增量同步 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:6:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用Mermaid在hugo的Markdown中绘制UML ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:0:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"简介 ¶ Mermaid是一个提供绘图功能的JavaScript项目。 它目前（8.6.4）支持： 流程图——Flowchat 顺序图——Sequence Diagram 类图——Class Diagram 状态图——State Diagram 甘特图——Gantt 饼图——Pie 实体关系图——Entity Relationship Diagram 用户行程图——User Journey Diagram ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:1:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"使用 ¶ 在Markdown中，使用Mermaid十分简单。 ```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ``` 写出以上代码块，就可以在网页渲染时，自动变成以下的svg图。 graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; 本文不对如何用它表达思想，做过多描述，详见官网文档。 此外，还可在其在线编辑器直接试用：mermaid-live-editor 以下介绍如何配置使用。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:2:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"配置 ¶ 在GitLab等平台中，内置了Mermaid，只是版本不是最新。 想要使用，直接写就好。 在自己的hugo网站中，则需要在head.html这类的模板中，配置一番。 确保在最后的网页中，在恰当的位置包含以下要素。 \u003chead\u003e ... \u003cscript async src=\"https://cdn.staticfile.org/mermaid/8.6.4/mermaid.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e ... \u003cscript\u003e // Replace mermaid pre.code to div Array.from(document.getElementsByClassName('language-mermaid')).forEach(el =\u003e { el.parentElement.outerHTML = `\u003cdiv class=\"mermaid\"\u003e${el.innerText}\u003c/div\u003e` }) \u003c/script\u003e \u003cstyle\u003e /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u003c/style\u003e \u003c/body\u003e 其中，\u003chead\u003e部分是引入mermaid.js。 这里使用的是staticfile.org作为CDN，可按需替换。 在\u003cbody\u003e的最后，需要加上\u003cscript\u003e这段，用处是替换mermaid代码块为\u003cdiv\u003e，确保mermaid.js开始工作。 如果没有这段\u003cscript\u003e，把````mermaid写成`也是能用的，但不够优雅。 最后的\u003cstyle\u003e则是让svg居中显示。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:3:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"另一种配置 ¶ 以下是本站一次更新后的配置。 除了CDN使用jsdelivr、版本更新为8.8.2以外，主要改动是在Hugo模板中添加了if。 {{ if .Params.mermaid }} \u003cscript src=\"https://cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js\" integrity=\"sha256-KqisLh8jVMBRjpNkOhH5W9VWs+F6x6vQksLqxs7+x9A=\" crossorigin=\"anonymous\" \u003e\u003c/script\u003e \u003cscript\u003e // Replace mermaid pre.code to div Array.from(document.getElementsByClassName(\"language-mermaid\")).forEach( (el) =\u003e { el.parentElement.outerHTML = `\u003cdiv class=\"mermaid\"\u003e${el.innerText}\u003c/div\u003e`; } ); \u003c/script\u003e \u003cstyle\u003e /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u003c/style\u003e {{ end }} 额外加上了.Params.mermaid的检查，避免所有页面都需要加载它。 在需要使用的Hugo页面，可以在Front Matter中添加一个配置，显式指定使用Mermaid。 以下为TOML形式的示例： +++ ... mermaid = true +++ ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:4:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"结语 ¶ 用好Mermaid，可以让Markdown的表现力增色不少。 以后，本站也会更多地使用它来做更好的表达。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:5:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":["C++"],"content":"C++ 简介 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 **注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"面向对象程序设计 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准库 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"ANSI 标准 ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。 由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"学习 C++ 学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。 学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。 C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"C++ 的使用 基本上每个应用程序领域的程序员都有使用 C++。 C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。 C++ 广泛用于教学和研究。 任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准化 发布时间 通称 备注 2017 C++17 第五个C++标准 2017 coroutines TS 协程库扩展 2017 ranges TS 提供范围机制 2017 library fundamentals TS 标准库扩展 2016 concurrency TS 用于并发计算的扩展 2015 concepts TS 概念库，用于优化编译期信息 2015 TM TS 事务性内存操作 2015 parallelism TS 用于并行计算的扩展 2015 filesystem TS 文件系统 2014 C++14 第四个C++标准 2011 - 十进制浮点数扩展 2011 C++11 第三个C++标准 2010 - 数学函数扩展 2007 C++TR1 C++技术报告：库扩展 2006 - C++性能技术报告 2003 C++03 第二个C++标准 1998 C++98 第一个C++标准 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"这里收录了我的Python相关笔记. ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"常见命令 quit() 停止,退出 def() 声明函数 max() 获取最大值 min() 获取最小值 type() 获取类型 float() 转换为浮点数 int() 转换为整数 return() 返回 break 跳出循环 continue 继续下一次的循环 sorted() 排序 dir() 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表； 带参数时，返回参数的属性、方法列表。 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"try/except 捕获错误 word = 'Hello world!' try: word1=int(word) except: word1=-1 print('word',word1) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Files open(file, mode=‘r’) 方法用于打开一个文件，并返回文件对象。 方法 方法及描述 file.close() 关闭文件。关闭后文件不能再进行读写操作。 file.flush() 刷新文件内部缓冲，直接把内部缓冲区的数据立刻写入文件, 而不是被动的等待输出缓冲区写入。 file.fileno() 返回一个整型的文件描述符(file descriptor FD 整型), 可以用在如os模块的read方法等一些底层操作上。 file.isatty() 如果文件连接到一个终端设备返回 True，否则返回 False。 file.next() **Python 3 中的 File 对象不支持 next() 方法。**返回文件下一行。 file.read([size]) 从文件读取指定的字节数，如果未给定或为负则读取所有。 file.readline([size]) 读取整行，包括 “\\n” 字符。 file.readlines([sizeint]) 读取所有行并返回列表，若给定sizeint\u003e0，返回总和大约为sizeint字节的行, 实际读取值可能比 sizeint 较大, 因为需要填充缓冲区。 file.seek(offset[, whence]) 移动文件读取指针到指定位置 file.tell() 返回文件当前位置。 file.truncate([size]) 从文件的首行首字符开始截断，截断文件为 size 个字符，无 size 表示从当前位置截断；截断之后后面的所有字符被删除，其中 windows 系统下的换行代表2个字符大小。 file.write(str) 将字符串写入文件，返回的是写入的字符长度。 file.writelines(sequence) 向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符。 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"数组 [ ] 括起来 list() 创建数组 list.append(obj) 在列表末尾添加新的对象 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"字典 {} 括起来 dict() 创建字典 dict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 dict.keys() 返回一个视图对象 dict.values() 返回一个视图对象 dict.items() 以列表返回一个视图对象 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"多元组(不可改变) () 括起来 只有两个方法 tuple.count() tuple.index() ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"正则表达式 import re 引入正则库 '@([^ ]*)' ( )内的正则表达式表示需要返回的数据 @不返回 ^代表从头开始 [^...] 方括号内的^代表除此之外 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"网络编程 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"socket import socket 引用socket库 建立TCP socket: import socket mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) mysock.connect(('data.pr4e.org', 80)) 请求: import socket mysock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) mysock.connect(('data.pr4e.org', 80)) cmd ='GET http://data.pr4e.org/romeo.txt HTTP/1.0\\r\\n\\r\\n'.encode() mysock.send(cmd) while True: data = mysock.recv(512) if (len(data) \u003c 1) : break print(data.decode()) mysock.close() import urllib.request,urllib.parse,urllib.error 引用urllib库 import urllib.request import urllib.parse import urllib.error fhand = urllib.request.urlopen('http://www.dr-chuck.com/page1.htm') for line in fhand: print(line.decode().strip()) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"Beautiful Soup 安装方式: pip install beautifulsoup4或pip3 install beautifulsoup4来安装 也可以下载tar压缩包，将bs4/目录放入几乎任何Python应用程序（或您的库路径），并立即开始使用它 引用 from bs4 import BeautifulSoup 引用 ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"http import urllib.request, urllib.parse, urllib.error from bs4 import BeautifulSoup url = input('Enter - ') html = urllib.request.urlopen(url).read() soup = BeautifulSoup(html, 'html.parser') # Retrieve all of the anchor tags tags = soup('a') for tag in tags: print(tag.get('href', None)) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"https import urllib.request, urllib.parse, urllib.error from bs4 import BeautifulSoup import ssl # Ignore SSL certificate errors ctx = ssl.create_default_context() ctx.check_hostname = False ctx.verify_mode = ssl.CERT_NONE url = input('Enter - ') html = urllib.request.urlopen(url, context=ctx).read() soup = BeautifulSoup(html, 'html.parser') # Retrieve all of the anchor tags tags = soup('a') for tag in tags: print(tag.get('href', None)) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"xml import xml.etree.ElementTree as ET data = '''\u003cperson\u003e \u003cname\u003eChuck\u003c/name\u003e \u003cphone type=\"intl\"\u003e+1 734 303 4456\u003c/phone\u003e \u003cemail hide=\"yes\"/\u003e \u003c/person\u003e''' tree = ET.fromstring(data) print('Name:', tree.find('name').text) print('Attr: ', tree.find('email').get('hide')) import xml.etree.ElementTree as ET input = '''\u003cstuff\u003e \u003cusers\u003e \u003cuser x=\"2\"\u003e \u003cid\u003e001\u003c/id\u003e \u003cname\u003eChuck\u003c/name\u003e \u003c/user\u003e \u003cuser x=\"7\"\u003e \u003cid\u003e009\u003c/id\u003e \u003cname\u003eBrent\u003c/name\u003e \u003c/user\u003e \u003c/users\u003e \u003c/stuff\u003e''' stuff = ET.fromstring(input) lst = stuff.findall('users/user') print('User count:', len(lst)) for item in lst: print('Name:', item.find('name').text) print('Id:', item.find('id').text) print('Attribute:', item.get(\"x\")) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:5","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"json import json data = '''{ \"name\" : \"Chuck\", \"phone\" : { \"type\" : \"intl\", \"number\" : \"+1 734 303 4456\" }, \"email\" : { \"hide\" : \"yes\" } }''' info = json.loads(data) print('Name:',info[\"name\"]) print('Hide:',info[\"email\"][\"hide\"]) import json input = '''[ { \"id\" : \"001\", \"x\" : \"2\", \"name\" : \"Chuck\" } , { \"id\" : \"009\", \"x\" : \"7\", \"name\" : \"Chuck\" } ]''' info = json.loads(input) print('User count:', len(info)) for item in info: print('Name', item['name']) print('Id', item['id']) print('Attribute', item['x']) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:6","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"API import urllib.request, urllib.parse, urllib.error import twurl import json TWITTER_URL = 'https://api.twitter.com/1.1/friends/list.json' while True: print('') acct = input('Enter Twitter Account:') if (len(acct) \u003c 1): break url = twurl.augment(TWITTER_URL, {'screen_name': acct, 'count': '5'}) print('Retrieving', url) connection = urllib.request.urlopen(url) data = connection.read().decode() headers = dict(connection.getheaders()) print('Remaining', headers['x-rate-limit-remaining']) js = json.loads(data) print(json.dumps(js, indent=4)) for u in js['users']: print(u['screen_name']) s = u['status']['text'] print(' ', s[:50]) ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:7","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"数据库 多条代码之间要加\";“号 建立table CREATE TABLE Users( name VARCHAR(128), email VARCHAR(128) ) 删除table DROP TABLE IF EXISTS Artist INSERT 插入 INSERT INTO Users (name, email) VALUES ('Kristin', ' kf@umich.edu ') DELETE 删除数据 DELETE FROM Users WHERE email='ted@umich.edu' UPDATE 更新 UPDATE Users SET name='Charles' WHERE email='csev@umich.edu' SELECT 检索记录 SELECT * FROM Users SELECT * FROM Users WHERE email=' csev@umich.edu ' ORDER BY 排序 SELECT * FROM Users ORDER BY email SELECT * FROM Users ORDER BY name DESC 导入 import sqlite3 连接join select Album.title, Artist.name from Album join Artist on Album.artist_id = Artist.id ","date":"2023-04-15","objectID":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":["Python"],"title":"学习笔记","uri":"/2023/04/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"(失败记录)单机手游《最后战役X》修复飞天BUG：尝试改汇编指令 赶码人 本文不是教程，下面是一次失败的记录，可能更像是日记吧，如果担心被误导，建议离开本文…(温馨提示)。 打算尝试用修改指令的方式实现（包括判断是否勾选飞天），不确定是否可以成功，至少今天这俩小时没成功。我是个汇编小白，慢慢尝试吧。 前面文章用frida临时实现了飞天，本文仍然接着这个系列往后写。 最后战役X(单机手游)连跳飞天思路点击进入查看全文\u003e文章 赶码人 174 14 5 最后战役X，获取“飞天”选择框选中状态点击进入查看全文文章 赶码人 50 5 1 本系列第一篇文章末尾提到的frida持久化，可以参考这位大佬写的这篇文章，已经很详细， 对于修复这款游戏而言，安装完安装包之后再手动把js放到/data/local/tmp目录不太优雅，可以反编译dex，加几句代码把js资源释放到自己私有目录，比如/data/data/包名/。（理论可行，我没测试） 首先前面说过jumap里面的判断条件，无论咋nop，都飞不起来，具体给人物施加力的函数并不是在这个函数内部调用。这个地方*(_BYTE *)(v5 + 0x58) = 1，这里赋值为0，上面第18行又判断它是否为0，但是这个函数内部并没把这个值设置成0，所以大概是有某个函数（比如各种update函数）在“监视”这个值，发现是1则改成0，然后给角色施加一个向上的力。 说白了就是0x58不能动，那咱指令往哪扩充？我想的是把33和34行干掉，因为4f8ddc这个函数总是和if(!xx)成对频繁出现，感觉和异常处理有关，并且这个异常好像很难触发。 把0x58设置成1的指令： （修改速度就照着这两行改写，）紧接着的if和4f8ddc的指令： .text:0000000000720020 LDR X20, [X19,#0xA0] .text:0000000000720024 LDR X19, [X19,#0xB0] .text:0000000000720028 CBNZ X20, loc_720034 .text:000000000072002C MOV X0, XZR .text:0000000000720030 BL sub_4F8DDC 因为后面指令还用到X20和X19，前两个LDR要保留，并且需要调整顺序（避免X20被影响）， CBNZ给NOP掉，然后MOV和BL改成MOV和STR： .text:0000000000720020 MOV W8, #0x41200000 .text:0000000000720024 STR W8, [X20,#0x6C] .text:0000000000720028 NOP .text:000000000072002C LDR X20, [X19,#0xA0] .text:0000000000720030 LDR X19, [X19,#0xB0] 然后就失败了，没效果啊（速度达不到10），我也有些疑惑，难不成修改这个值的时机太晚了？明天再看看吧。 ","date":"2022-01-28","objectID":"/2022/01/%E5%A4%B1%E8%B4%A5%E8%AE%B0%E5%BD%95%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9bug%E5%B0%9D%E8%AF%95%E6%94%B9%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/:0:0","series":null,"tags":["赶码人"],"title":"(失败记录)单机手游《最后战役X》修复飞天BUG：尝试改汇编指令","uri":"/2022/01/%E5%A4%B1%E8%B4%A5%E8%AE%B0%E5%BD%95%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9bug%E5%B0%9D%E8%AF%95%E6%94%B9%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/"},{"categories":null,"content":"推荐大家安装 anaconda 项目的部署环境搭建 推荐大家去看我机器人 anaconda 安装 视频链接 首先需要去执行 安装 三方包 pip install -r requirements.txt 可能遇到的错误 pycocotools https://www.bilibili.com/video/BV1tf4y1t7ru?p=2 先去安装GPU 驱动 cuda 10.2下载 安装 pytorch for cuda tips conda 国内源 配置 windows为“C:\\用户\\你的用户名.condarc”，Linux为\"/home/你的用户名/.condarc\"。（若没有这个文件就新建一个，注意文件名为.condarc，不要有任何其他后缀） channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ - defaults show_channel_urls: true yolov5源码及模型文件地址 使用时请将 yolon.txt 结尾改为 pt 外链:https://musuyun.lanzouw.com/b0e9iz24d 密码:fz8n ","date":"2022-01-28","objectID":"/2022/01/1.-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","series":null,"tags":["yolov5"],"title":"1. 项目部署和环境搭建","uri":"/2022/01/1.-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%92%8C%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"做教学视频又耗时又累，白嫖率(收藏和点赞的比例)偏高（如下图所示），并且本人录制和剪辑效率低，蚌埠住了， 如果直接摆烂宣布放弃，会愧对于 点过赞、投过币、充过电的朋友，所以停更是不可能的，本系列教程剩下的部分做成图文版，这样也能提高你的浏览效率；大约每2000字~3000字发布一次。 前面的教程1~9在视频的开头都有一个目录，那个目录就是个大致方向，从这期开始不展示目录了，本系列教程写完之后会有一篇文章专门用于导航。 有问题直接在文章底部评论，我懂的问题会回复，同时也欢迎在本文评论区纠错。 本系列教程【新手向】（本人在此方面也算初学者），大佬勿喷。 这里以坦克英雄激光战争为例（因为它是纯粹的单机游戏，并且多年未更新；后文简称\"T游戏\"），纯路人不必担心本文破坏游戏体验（相反，逆向工程会维护游戏环境、提升你的游戏体验），本文与各种联网游戏完全无关，本文内容仅供学习IDA基本操作，提高编程开发以及逆向工程的学习兴趣，以及为将来的维护游戏安全、反外挂工作提供思路、“埋下种子”。 准备好IDA，本系列教程不需要懂汇编，跟着我无脑F5看伪代码，会看LR寄存器就够了。 首先要知道，通常游戏逆向领域所谓的找数组，数组是最常见的用于存储敌人信息的结构，这个数组当中的每个元素都对应着一个敌人的结构体，数组里的元素可能是这个结构体的地址（大部分游戏是这样的），也可能直接就是某个结构体（某个结构体类型的数组，T游戏是这种）。 这里随便举个例子吧（虽然意义不大）： #include \u003cstdio.h\u003e struct Role{ int hp; //血量 float x; float y; float z; //...实际上，属性会多的很，并且可能有指向另一个结构体（比如武器）的指针，这里省略... }; #define ROLE_MAX_COUNT 20 struct GameData1{ int roleCount; //敌人实际数量 struct Role* roles[ROLE_MAX_COUNT]; //敌人数组 //...省略 } gd1; struct GameData2{ int roleCount; //敌人实际数量 struct Role roles[ROLE_MAX_COUNT]; //敌人数组 //...省略 } gd2; int main(void){ gd1.roleCount = 3; struct Role r1, r2, r3; r1.hp = 100; r1.x = 1; r1.y = 2; r1.z = 3; r2.hp = 90; r2.x = 10; r2.y = 2; r2.z = 30; r3.hp = 95; r3.x = 30; r3.y = 2; r3.z = 20; gd1.roles[0] = \u0026r1; gd1.roles[1] = \u0026r2; gd1.roles[2] = \u0026r3; gd2.roleCount = 3; gd2.roles[0].hp = 100; gd2.roles[0].x = 1; gd2.roles[0].y = 2; gd2.roles[0].z = 3; gd2.roles[1].hp = 90; gd2.roles[1].x = 10; gd2.roles[1].y = 2; gd2.roles[1].z = 30; gd2.roles[2].hp = 95; gd2.roles[2].x = 30; gd2.roles[2].y = 2; gd2.roles[2].z = 20; getchar(); return 0; } 代码中gd1和gd2就是两种不同的敌人数组的形式， 用NDK编译，推到手机运行，ce+ceserver附加（我前面视频教程演示过，本文省略），添加地址两次，分别直接写gd1和gd2： 情况一 情况二 GG视角： 情况一（GG视角） 情况二（GG视角） 拿捏了敌人数组，就可以获取全部敌人的各种属性了，比如坐标和血量。 蚌埠住了，时间太晚了，天亮继续更新 ","date":"2022-01-28","objectID":"/2022/01/10-1%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["赶码人"],"title":"10-1：认识数组","uri":"/2022/01/10-1%E8%AE%A4%E8%AF%86%E6%95%B0%E7%BB%84/"},{"categories":null,"content":"如果没看上一篇，建议去看看：安卓单机游戏绘制教程10-1：认识数组 先补充上一篇文章的一个细节： 这里随便run-as了一个debuggable=true的app包名，是为了能在gg中看到我们的hello程序，如果直接运行hello可执行文件，gg的进程列表是看不到的。 解压T游戏的安装包找到so文件，直接拖进IDA，这一步可以参考我前面录制的IDA找单机老旧手游矩阵思路 要找数组的基址偏移，首先找到数组出现的位置，先猜猜数组可能出现到的函数，有以下思路（个人经验，仅供参考）： \\1. “AI”表示人机，搜索带有AI的函数 \\2. 找单个敌人的行为相关函数，例如fire，damage，move等 分辨哪里用到了数组，并不难，找while循环和for循环就行了，多留意观察循环中哪个变量有变化（以及变了多少），哪个变量无变化，以及循环的终止条件；我们最后写代码的时候，也是要通过while或者for循环去遍历所有敌人，循环的条件到时候也可以“照抄”。 找到数组出现的函数之后，接下来找调用栈（函数之间的调用关系），这样就可以通过观察参数变化，找到参数的来源，就可以分析出数组的基址、偏移。找调用栈思路：对着函数名按X，如果按X找不到，打断点看R14寄存器（具体请等下期教程）。 比如，GmSimInitAITANKs和GmSimAiUpdate这两个函数， GmSimInitAITANKs GmSimAiUpdate 如上图所示，我们可以猜测724就是敌人结构体的长度。 AIMoveAndFireAITANK 像AIMoveAndFireAITANK这种比较复杂的可以先大概看一眼，根据刚才的推测，724可能是结构体长度，这里和724相乘的a2不被循环影响，a2显然是敌人在数组中的下标，所以可以对着这个函数名按X，一定有地方有for或者while循环且在循环体当中调用了AIMoveAndFireAITANK函数。 对着函数名按一下X，果然，是GmSimAiUpdate调用了这个函数，数组在GmSimAiUpdate函数中被遍历，AIMoveAndFireAITANK的参数2是循环到的次数（可以直接理解成敌人的序号） 然后找单个敌人的行为相关函数再演示一次，比如move，可以发现GmSimMoveTANKs这个函数里面就已经有循环了， GmSimMoveTANKs 不具体演示了，总之就是，找行为动作相关函数，然后按X，找引用调用它的函数，调用它的函数内部很可能就有for或while循环 比如GmSimIsFriendlyFire， GmSimIsFriendlyFire 按X，就能找到GmSimCheckProjectileCollisionWithAllTANKs这个函数，并且可以看到一个很清晰的循环。 对于本游戏，也可以通过数量下手，搜索count、get num of···,这样可以找到GmSimGetNumOfDeadAiTANKs这个函数（搜索“AI”也能看到它）， GmSimGetNumOfDeadAiTANKs 根据函数名称可以猜测这个函数作用是统计已经死亡的人机坦克数量，返回v3，v3最初是0，v2最初是参数1，每一次循环，v2都会自增724，也就是说，while循环过程中，v2是每个人机坦克的结构体地址，而参数一就是整个数组的起始地址，每个敌人结构体可以通过偏移72这个byte类型数值来判断是否为死亡的人机。所以这里用来判断敌人是否死亡的偏移也得到了，后续可以用来过滤死掉的敌人。 后续文章会通过GmSimGetNumOfDeadAiTANKs这个函数进行“溯源”（因为它看起来最清晰，代码只是在很单纯的遍历，从这个函数的名字就能看出它只是负责统计坦克数量），得到数组的基址偏移。 本系列教程作者B站账号：赶码人 ","date":"2022-01-28","objectID":"/2022/01/10-2ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%80%9D%E8%B7%AF%E6%9C%89%E7%AC%A6%E5%8F%B7so/:0:0","series":null,"tags":["赶码人"],"title":"10-2：IDA找敌人数组相关函数思路（有符号so）","uri":"/2022/01/10-2ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%80%9D%E8%B7%AF%E6%9C%89%E7%AC%A6%E5%8F%B7so/"},{"categories":null,"content":"单机安卓游戏绘制教程10-3：IDA找敌人数组相关函数调用关系（有符号so） 赶码人 本文接上一篇：单机安卓游戏绘制教程10-2：IDA找敌人数组相关函数思路（有符号so） 目前已知GmSimGetNumOfDeadAiTANKs这个函数的参数就是敌人数组的起始地址，接下来找它的调用栈，通过调用栈上的函数，找到参数的来源。 能对着函数名按X，就按X，如果按X出现的列表没有“BL”指令，就给函数打断点，观察LR寄存器的值，接下来演示操作： 按X找到了两个函数，我们先进去第一个看看： 可以得知，GmSimGetNumOfDeadAiTANKs的参数一，是GmSceneCampaignCallbackSimEventTANKKilled的参数一a1+32得到的地址所指向的数值（注意这个*(_DWORD *)(a1 + 32)，把a1+32转为了指针，并读取出了这个指针指向的地址的值） 再对着这个函数按X，发现并没有出现BL指令，只有一个GmSceneCampaignResume函数当中用到了该函数的指针，后续游戏会通过函数指针的形式调用这个函数，这种情况IDA不能静态分析出来， 所以接下来要回到GmSceneCampaignCallbackSimEventTANKKilled，直接如图所示，给这个函数第一条语句打上断点（点击行号左边的蓝色圆圈）： 先回到GmSimGetNumOfDeadAiTANKs函数，这次进入xrefs窗口的第二个函数GmScenePreviewCallbackSimEventTANKKilled，可以看到，这两个函数参数关系是*(_DWORD *)(a1 + 4) 对着GmScenePreviewCallbackSimEventTANKKilled函数按X，发现仍然找不到BL指令调用，所以，这里也打个断点 现在按X已经遇到阻碍了，接下来要通过LR寄存器继续找调用关系，需要用到IDA目录的dbgsrv文件夹的android_server，这部分教程网络上已经有很多了，推荐一个帖子作参考：https://www.52pojie.cn/thread-1511844-1-2.html （专栏不能设置站外链接） android_server和ceserver使用方式一样（关于ceserver，可以参考我这个视频教程05-1：免root使用ceserver桥接真机的准备工作：设置debuggable=true，以及这个视频教程05-2：CE查看安卓手机内存中的数据（ceserver桥接教程）），有ROOT直接用；如果没有ROOT，就需要修改安装包debuggable属性，然后run-as启动android_server。 在手机端启动android_server之后，IDA操作如图所示： 选中游戏进程点OK，然后： 如果出现上图这个弹窗，是在问你当前打开的so和内存中的so是否一样（就是说 解压的apk和安装的apk是否是同一个版本），选择Same就行了， 然后游戏进程就被暂停掉了，等待上面这张图的窗口消失， 刚刚已经打过俩断点了，然后在游戏里面动一动，等待触发断点，然后你会发现，在子弹即将接触到某个角色时，游戏被暂停，此时触发断点， 所以是GmSceneCampaignCallbackSimEventTANKKilled这个函数的断点触发了，并且是GmSimDealDamageToTANK调用了它，参数一是v17[36]， 这里先简单记一下这个函数内部和v18的参数一有关的代码： int __fastcall GmSimDealDamageToTank(int result, int a2, int a3, int a4) { v4 = (_DWORD *)result; v17 = v4 + 0x2E00; result = v18(v17[36], a2, a3); 然后继续，找这个函数是谁调用： 先点击去第一个看看： 参数一不可能是float，不多解释了，直接改类型： 记一下： int __fastcall DealCollateralDamage(int result, float *a2, int a3, int a4) { v4 = (int *)result; result = GmSimDealDamageToTank((int)v4, i, a4, (int)(float)((float)((float)a3 * v10) + (float)((float)a3 * v10))); 继续找： 记下来： int __fastcall sub_C956AA28(int result, int a2) { result = DealCollateralDamage(result, (float *)(a2 + 4), *(_DWORD *)(a2 + 56), *(_DWORD *)(a2 + 40)); 找： 这个时候，前两个函数进去按X找不到调用者，打断点并没有遇到他们的触发条件，然后干脆将剩下四个也打断点，最终触发了GmSimProcessInstantProjectile，所以进这个函数： 该记就记，该找就找， int __fastcall GmSimProcessInstantProjectile(_DWORD *a1, int a2, float *a3) { return sub_C956AA28((int)a1, a2); int __fastcall GmSimUpdateProjectiles(int result) { v1 = (_DWORD *)result; result = GmSimProcessInstantProjectile(v1, (int)v1 + v3, (float *)v43); 剩下的都是以此类推，看图吧， 到目前为止，已经找到的调用栈：（个人习惯这样记录，仅供参考） int __fastcall GmSimDealDamageToTank(int result, int a2, int a3, int a4) { v4 = (_DWORD *)result; v17 = v4 + 0x2E00; result = v18(v17[36], a2, a3); int __fastcall DealCollateralDamage(int result, float *a2, int a3, int a4) { v4 = (int *)result; result = GmSimDealDamageToTank((int)v4, i, a4, (int)(float)((float)((float)a3 * v10) + (float)((float)a3 * v10))); int __fastcall sub_C956AA28(int result, int a2) { result = DealCollateralDamage(result, (float *)(a2 + 4), *(_DWORD *)(a2 + 56), *(_DWORD *)(a2 + 40)); int __fastcall GmSimProcessInstantProjectile(_DWORD *a1, int a2, float *a3) { return sub_C956AA28((int)a1, a2); int __fastcall GmSimUpdateProjectiles(int result) { v1 = (_DWORD *)result; result = GmSimProcessInstantProjectile(v1, (int)v1 + v3, (float *)v43); int *__fastcall GmSimUpdateSim(int *result, int a2) { v2 = (int)result; GmSimUpdateProjectiles(v2); int __fastcall GmSceneCampaignUpdate(int a1) { GmSimUpdateSim(*(int **)(a1 + 0x20), 30); 先到这里吧，写得好累，明天再继续。 ","date":"2022-01-28","objectID":"/2022/01/10-3ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E6%9C%89%E7%AC%A6%E5%8F%B7so/:0:0","series":null,"tags":["赶码人"],"title":"10-3：IDA找敌人数组相关函数调用关系（有符号so）","uri":"/2022/01/10-3ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E6%9C%89%E7%AC%A6%E5%8F%B7so/"},{"categories":null,"content":"本文接上一篇：单机安卓游戏绘制教程10-3：IDA找敌人数组相关函数调用关系（有符号so） 上一篇教程已经找到了GmSceneCampaignUpdate这个函数，继续，打断点，点LR寄存器旁边的箭头之后如图： 上图的蓝色框，是点击LR之后默认选中的地方，但实际上这行代码还没开始执行。可以给这两行以及GmSceneCampaignUpdate函数都打上断点，观察执行顺序。v3+32是GmSceneCampaignUpdate的参数。 v3 = gmc + 40 * *(_DWORD *)(gmc + 288); v7 = (*(int (__fastcall **)(_DWORD))(v3 + 4))(*(_DWORD *)(v3 + 0x20)); //GmSceneCampaignUpdate 现在已经不用再跟了，注意这里出现了个“gmc”，v3和gmc有关，双击它之后： 发现这是bss段的一个数值，在游戏开发过程中，gmc可能是一个全局变量，总之，bss段的地址不会变，这里的gmc相对于libnative.so这个模块的偏移是固定的。可以在未开启debug的状态下直接看到它的偏移（可以参考我前面IDA找矩阵的视频，这里不浪费时间截图了），也可以拿模块加载到内存中的地址算一下，如图： 接下来回顾我们找到的调用栈，写出基址偏移，这个基址直接用gmc表示，写代码的时候再转成libnative.so+0x689cc的形式。 现在要注意的就是先关掉IDA的动态调试，再去用CE附加游戏，否则ceserver会有“没ROOT”之类的提示（我印象中是这样的，感兴趣可以根据ceserver的输出自己解决这个问题）。 刚才的 gmc + 40 * *(_DWORD *)(gmc + 288)，写到CE就是：[gmc] + 0x28 * [ [gmc] + 0x120] GmSceneCampaignUpdate接收到的参数，实际是：[gmc]+0x28*[[gmc]+0x120]+0x20 地址框框为啥不能跟随窗口变宽呢… 于是就有了基址偏移， 调用栈如图，从下往上看，这些函数都是只看参数一就够了。v17看做一个表示地址值的int变量，v17[36]相当于v17 + 36*4（十进制），也就是v17+0x90，这里v18就是GmSceneCampaignCallbackSimEventTankKilled，参数一就是： [[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890 int __fastcall GmSceneCampaignCallbackSimEventTankKilled(int a1, int a2) { result = GmSimGetNumOfDeadAiTanks(*(_DWORD *)(a1 + 32)); 所以，GmSimGetNumOfDeadAiTanks的参数一是： [[[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890] + 0x20 于是： int __fastcall GmSimGetNumOfDeadAiTanks(int a1) { int v1; // r2 int v2; // r1 int v3; // r3 v1 = 0; v2 = a1; // [[[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890] + 0x20 v3 = 0; while ( v1 \u003c *(_DWORD *)(a1 + 20) ) //所以 循环终止条件这里是: [[[[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890]+0x20] { if ( !*(_BYTE *)(v2 + 72) ) // [[[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890]+0x724*n + 0x48 表示敌人n已死亡 ++v3; ++v1; v2 += 724; // [[[[gmc]+0x28*[[gmc]+0x120]+0x20]+0x20]+0xB890]+0x724*n 这个就是每个敌人的结构体地址 } *(_DWORD *)(a1 + 24) = v3; return v3; } 现在已经知道敌人最大数量和每个敌人的结构体起始地址的基址偏移是： [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x14 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * n （这里顺便提一句，有多个基址偏移是很正常的，如果从其他函数下手，基址偏移和我这个不同也是很正常。如果想用GG脚本扫出这个数组的基址偏移，偏移量至少要填写到47248…，况且，目前没证据表明[ [gmc] + 0x120] 是个固定值，说白了就是，指针扫描或许不能通杀所有游戏 接下来要找到敌人坐标的偏移，分析代码，或者直接观察内存都行；一些大型游戏，坐标数值并不在人物结构体当中，而是另一个结构体，而人物结构体保存着另一个结构体的指针（这就是所谓的XX游戏的坐标和XX属性“不在同一层”），这种可以去学学CE结构分析器用法，网上教程很多。 敌人最大数量这个值是大于屏幕所有敌人数量的，但是也没大多少，关注以下地址： [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 0 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 1 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 2 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 3 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 4 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 5 [[[[ [gmc] + 0x28 * [ [gmc] + 0x120] + 0x20] + 0x20 ]+ 0xB890] + 0x20] + 0x2d4 * 6 ... 用Ctrl+B直接观察就能看到坐标了，直接给出坐标偏移吧：0x19c 血量还没看，明天再说。 本系列教程作者：赶码人 ","date":"2022-01-28","objectID":"/2022/01/10-4ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E5%9F%BA%E5%9D%80%E5%81%8F%E7%A7%BB%E6%9C%89%E7%AC%A6%E5%8F%B7so/:0:0","series":null,"tags":["赶码人"],"title":"10-4：IDA找敌人数组基址偏移（有符号so）","uri":"/2022/01/10-4ida%E6%89%BE%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84%E5%9F%BA%E5%9D%80%E5%81%8F%E7%A7%BB%E6%9C%89%E7%AC%A6%E5%8F%B7so/"},{"categories":null,"content":"安卓单机游戏绘制教程10-1：认识数组 单机安卓游戏绘制教程10-2：IDA找敌人数组相关函数思路（有符号so） 单机安卓游戏绘制教程10-3：IDA找敌人数组相关函数调用关系（有符号so） 单机安卓游戏绘制教程10-4：IDA找敌人数组基址偏移（有符号so） 本文是教程10的最后一篇：遍历敌人数组， 然后今天录一个视频，展示遍历敌人数组的效果（因为我怀疑专栏文章推送几率很低，似乎很多观众不知道有这几篇专栏），如果本系列专栏对你有收获，不妨给这个效果视频点点赞，谢谢啦~ 教程系列视频、专栏点过赞的用户名我会记下来，将来会发些小福利（比如开发的软件优先对你们开放测试，诸如此类） 教程11是绘图部分，然后本系列教程就完结了，补前面视频字幕，然后打算讲讲正向开发的内容(比如Bash···如果有时间)，或者是做编程科普类视频··· 之前答应过，发单机CF（最后战役X）修复无法飞天BUG的思路，最后战役X的GG的Xa功能思路（高空掉落不掉血、一击必杀）、静默自瞄（时间待定）、骨骼绘制（待定），这些仍然会不定期更新。 回到主题，接下来把教程10剩下部分写了： 关于坐标，从代码分析有些复杂了，直接Ctrl+B观察内存就行了，如图所示： 淡入淡出时间可以改大一些 淡入淡出我设置的6000ms，根据自己习惯改一下， 关于血量，敌人尺寸，可以看如图所示这个函数： GmSimInitAITanks 注意GmSimAiInitTankFromLevelTankData的参数一，已经相对结构体偏移了0x40，然后在这个函数能看到血量、大小等 初始化代码： 由此可知，当前血量偏移：+0x40+0x4 最大血量偏移：+0x40+0x258 尺寸偏移：+0x40+0x214 v26可能表示“坦克种类” 另外，gAiHitPoints之类的是rodata段数据，可以双击跳转到如图所示： 可以理解成常量 现在基址偏移全都拿到了，开始写C语言代码，为了接下来写起来方便，首先封装几个函数： uintptr_t readPtr(uintptr_t addr){ lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, \u0026addr, sizeof(uintptr_t)); return addr; } char readByte(uintptr_t addr){ char res = 0; lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, \u0026res, sizeof(char)); return res; } int readInt(uintptr_t addr){ int res = 0; lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, \u0026res, sizeof(int)); return res; } float readFloat(uintptr_t addr){ float res = 0; lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, \u0026res, sizeof(float)); return res; } void readData(uintptr_t addr, int len, void* target){ lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, target, len); } 关于这部分，可以参考我的这个视频：单机安卓手游绘制教程08-1：用读取文件的函数跨进程读内存 main函数 test函数代码： void test(){ printf(\"test(): \\n\"); uintptr_t gmc = readPtr(so_addr + 0x689CC); uintptr_t p1 = readPtr( gmc + 0x28 * readPtr(gmc + 0x120) + 0x20 ); uintptr_t p2 = readPtr( p1 + 0x20 ); uintptr_t p3 = readPtr( p2 + 0xB890 ); uintptr_t p4 = readPtr( p3 + 0x20 ); int count = readInt(p4 + 0x14) ; printf(\"遍历终止条件： i \u003c %d\\n\", count); printf(\"\\n\"); int i = 0; while( i \u003c count){ uintptr_t p5 = p4 + 0x2d4 * i ; //敌人i的结构体地址 if( readByte(p5 + 0x48) ){ //照着IDA F5之后的代码写就行了. printf(\"敌人id=%2d\\tpos={%f,%f,%f}\\tsize=%f\\thp= %d/%d \\n\", i, readFloat(p5 + 0x19c), readFloat(p5 + 0x19c + 4), readFloat(p5 + 0x19c + 8), readFloat(p5 + 0x40 + 0x214), readInt(p5 + 0x40 + 0x4), readInt(p5 + 0x40 + 0x258) ); } i++; } } 作者：赶码人 https://www.bilibili.com/read/cv15051215?spm_id_from=333.999.0.0 出处：bilibili 最终效果请看视频吧~ 做教程、写文章不容易，若有收获，欢迎给视频点赞~感谢鼓励。 ","date":"2022-01-28","objectID":"/2022/01/10-5%E8%A1%80%E9%87%8F%E5%B0%BA%E5%AF%B8%E5%81%8F%E7%A7%BB%E9%81%8D%E5%8E%86%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["赶码人"],"title":"10-5：血量、尺寸偏移，遍历敌人数组","uri":"/2022/01/10-5%E8%A1%80%E9%87%8F%E5%B0%BA%E5%AF%B8%E5%81%8F%E7%A7%BB%E9%81%8D%E5%8E%86%E6%95%8C%E4%BA%BA%E6%95%B0%E7%BB%84/"},{"categories":null,"content":"单机手游绘制教程11-1：定义socket通信格式 赶码人 创建窗口、ndk编译C语言代码、矩阵算法、敌人数组、基址偏移，终于都讲完了，接下来就只剩下对接C语言端和java绘图端。 这期先简单谈谈，如何定义通信数据的结构。最舒服的方式肯定是java端用jni，两边都定义结构体，这样很直观，也方便解析数据，但jni也有一些学习成本，前面已经提到大小端序、字节转int和float的方法了，那绘图端还是手动解析字节吧。另外，本人C语言编程习惯不是很好（比如函数、变量命名，小驼峰和下划线随缘，etc），代码格式仅供参考。 首先是64字节的矩阵，以及4字节的敌人数量，接下来就考虑每个敌人需要占用多少字节了，本系列教程主题是绘制血量数字，所以要有8字节表示当前血量和最大血量，要绘制血量，还要有12字节的坐标（实际上坐标只需要x和z，这个游戏的y总是0，多传几个字节也无妨）。我打算顺便画个方框，那么就要有敌人的大小，因为坦克看起来似乎都是正方体，4字节就够了（这个后面再说）。还可以加一个结构体地址，这样方便将来对比数据找其他功能。 所以，每绘制一帧，需要传输64+4+(8+12+4)*n字节，接下来先通过C语言实现，定义一个结构体，如图： struct AITank{ int curHp; int maxHp; float x; float y; float z; float size; }; struct{ float matrix[16]; int count; struct AITank obj[50]; } draw_data; 然后如图所示，把前面写过的calc_matrix函数改一改： main函数，把sendto的参数改一改，如图： test函数注释掉，新增一个readAITank，作用类似于calc_matrix，负责往draw_data里面塞数据。 void readAITank(){ uintptr_t gmc = readPtr(so_addr + 0x689CC); uintptr_t p1 = readPtr( gmc + 0x28 * readPtr(gmc + 0x120) + 0x20 ); uintptr_t p2 = readPtr( p1 + 0x20 ); uintptr_t p3 = readPtr( p2 + 0xB890 ); uintptr_t p4 = readPtr( p3 + 0x20 ); int count = readInt(p4 + 0x14); int i = 0, index = 0; while( i \u003c count){ uintptr_t p5 = p4 + 0x2d4 * i ; if( readByte(p5 + 0x48) ){ draw_data.obj[index].x = readFloat(p5 + 0x19c); draw_data.obj[index].y = readFloat(p5 + 0x19c + 4); draw_data.obj[index].z = readFloat(p5 + 0x19c + 8); draw_data.obj[index].size = readFloat(p5 + 0x40 + 0x214); draw_data.obj[index].curHp = readInt(p5 + 0x40 + 0x4); draw_data.obj[index].maxHp = readInt(p5 + 0x40 + 0x258); index++; } i++; } draw_data.count = index; } C代码差不多了，接下来搞接收端。 ds.receive(dp); int count = byteToInt(b, 64); System.out.println(count); for(int i = 0 ; i \u003c count ; i++) { int offset = 68 + i * 24; int curHp = byteToInt(b, offset); int maxHp = byteToInt(b, offset + 4); float x = Float.intBitsToFloat(byteToInt(b, offset + 8)); float y = Float.intBitsToFloat(byteToInt(b, offset + 12)); float z = Float.intBitsToFloat(byteToInt(b, offset + 16)); float size = Float.intBitsToFloat(byteToInt(b, offset + 20)); System.out.printf(\"hp=%d/%d, pos=[%.2f, %.2f, %.2f], size=%.2f\\n\", curHp, maxHp, x, y, z, size); } 成功接收到数据的效果图 （明天是本系列的最后一期，教程09开头的计划目录写的“番外01：从javaswing快速移动到手机端”不做了，没啥可说的，区别就是继承JComponent改成继承View，回调方法是onDraw(Canvas canvas) ，直接用canvas.drawXXX画就完了，然后就是权限申请、悬浮窗···感兴趣自行查资料吧，接下来赶紧搞最后战役连跳飞天，可以先了解一下il2cppdumper和frida，说不定花几小时研究一下，也没必要看我的修复飞天思路了，提前剧透一句话吧，连跳飞天虽然不复杂，但也不会像有些网友猜的直接改坐标那么简单…，大概比搜0搜1复杂一点点吧。 ","date":"2022-01-28","objectID":"/2022/01/11-1%E5%AE%9A%E4%B9%89socket%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F/:0:0","series":null,"tags":["赶码人"],"title":"11-1：定义socket通信格式","uri":"/2022/01/11-1%E5%AE%9A%E4%B9%89socket%E9%80%9A%E4%BF%A1%E6%A0%BC%E5%BC%8F/"},{"categories":null,"content":"单机手游绘制教程11-2：java绘制方框 赶码人 血条没啥好说的，drawLine就完事。游戏本身提供血条了，再画一个显得多余，咱把数字给搞出来就行了。 先把坐标搞明白，咱获取的坐标是一个点，而敌人身上的点多得是。如果获取坐标就是敌人坐标，而不是什么骨骼、武器坐标，那么通常就两种，xyz表示敌人这个立体图形的正中心，要么就是表示敌人脚下平面的正中心，本教程的T游戏是后者这种。 那么如果画一个点上去，这个点就绘制在坦克这个立方体的底面的正中心，前面已经得到了坦克的尺寸size（经过测试，差不多是坦克高度，高度差不多是边长的一半），那么（x，y+size，z）表示坦克立方体的顶面的正中心的点坐标，（x，y，z）和（x，y+size，z）这两个点和矩阵运算得到的结果，符合“近大远小（指的是敌人远近、方框的大小）”，可以用作方框的顶边和底边的屏幕y坐标，再根据敌人的长宽比例，比如FPS的敌人宽高比差不多是0.5，本游戏的宽高比差不多是2，那么结合根据底边中心和顶边中心这两个点计算出的两个屏幕坐标的y坐标的差值，就可以得到方框的宽度，然后再通过这两个点的x坐标就可以得到方框的左边和右边的屏幕x坐标。 经常能看到有人问为啥偏框，情况很多，下图这种比较常见（红色框），框框尺寸没问题，但是总是偏高半个人，说明找到的坐标是敌人中心点坐标，可以读取出这个xyz坐标后，给高度（大多数是y坐标）减去半个人物高度的值就好了。。。总之就是一件事，要用头顶的xyz和脚底的xyz一起和矩阵去运算，才能分别得到头顶在屏幕上的坐标，和脚底在屏幕的坐标….另外，头顶脚底的x和z坐标通常相等，这里可以减少一些运算（本文没体现出来，我不在乎这点运算量…） 这是最常见的画方框思路，画一个方框没啥意思，这里干脆搞个3D框吧，注意接下来这个3D框和敌人朝向无关，角度只和相机有关， 红色的是下面的平面，绿色的是上面的平面 如图，我们需要8个平面坐标系上的点，说白了就是8个3D坐标点转成的8个屏幕上的x,y点，那么我们已经知道底面的中心点是(x,y,z)，对于本系列教程的T游戏，也就是(x,0,z)，1~4这四个点就是(x-size, 0, z-size), (x-size, 0, z+size), (x+size, 0, z-size), (x+size, 0, z+size)，5~8这四个点3d坐标是(x-size, size, z-size), (x-size, size, z+size), (x+size, size, z-size), (x+size, size, z+size)。 如果想搞和朝向相关的3D框，获取到敌人旋转角，把这8个点都绕着y轴旋转这个角度就行了，实际上和y轴没啥关系（因为是旋转角），可以参考这篇：https://blog.csdn.net/sinat_33425327/article/details/78333946 再顺便提一句吧，我前面视频说y表示高度，这是通常情况，比如本游戏，以及unity引擎的游戏。UE4就比较特殊，（好像是）用z表示高度，我也很无语… 理论说完了，其实等于没说，也没啥可说的，接下来搞代码。 首先搞一个类，用来封装数据，这种不到200行的小项目直接弄个静态内部类就行了，为了省事，全都搞成static， static class Role{ public int curHp; public int maxHp; public float size; public float x; public float y; public float z; public int[][] screen = new int[8][2]; public int[] hpPos = new int[2]; } 别忘在Main构造方法里面对role数组初始化 矩阵乘坐标会频繁调用，把3d坐标转屏幕坐标进行封装： 这个本系列教程的T游戏能用，其他游戏不能照搬 算了，直接发了吧，毕竟java端代码不像C语言端那么敏感，也不能直接套在其他游戏： package main; import java.awt.BasicStroke; import java.awt.Color; import java.awt.Font; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.RenderingHints; import java.io.IOException; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JRootPane; import javax.swing.WindowConstants; public class Main extends JFrame{ private static final long serialVersionUID = 1L; private static JComponent view; static class Role{ public int curHp; public int maxHp; public float size; public float x; public float y; public float z; public int[][] screen = new int[8][2]; public int[] hpPos = new int[2]; } static Role[] role = new Role[50]; static int count = 0; public Main() { for(int i = 0 ; i \u003c 50 ; i ++) { role[i] = new Role(); } this.setSize(800, 600); this.setTitle(\"bilibili: 赶码人\"); this.getRootPane().setWindowDecorationStyle(JRootPane.FRAME); this.setUndecorated(true); this.setOpacity(0.5f); this.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE); view = new JComponent() { private static final long serialVersionUID = 1L; @Override protected void paintComponent(Graphics g) { Graphics2D g2d = (Graphics2D)g; g2d.setStroke(new BasicStroke(2)); g2d.setColor(Color.RED); g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON); g2d.setFont(new Font(\"宋体\", Font.PLAIN, 18)); g2d.drawString(\"bilibili: 赶码人\", 30, 30); for(int i = 0 ; i \u003c count ; i ++) { g2d.setColor(Color.RED); g2d.drawLine(role[i].screen[0][0], role[i].screen[0][1], role[i].screen[1][0], role[i].screen[1][1]); g2d.drawLine(role[i].screen[1][0], role[i].screen[1][1], role[i].screen[2][0], role[i].screen[2][1]); g2d.drawLine(role[i].screen[2][0], role[i].screen[2][1], role[i].screen[3][0], role[i].screen[3][1]); g2d.drawLine(role[i].screen[3][0], role[i].screen[3][1], role[i].screen[0][0], role[i].screen[0][1]); g2d.drawLine(role[i].screen[4][0], role[i].screen[4][1], role[i].screen[5][0], role[i].screen[5][1]); g2d.drawLine(role[i].screen[5][0], role[i].screen[5][1], role[i].screen[6][0], role[i].screen[6][1]); g2d.drawLine(role[i].screen[6][0], role[i].screen[6][1], role[i].screen[7][0], role[i].screen[7][1]); g2d.drawLine(role[i].screen[7][0], role[","date":"2022-01-28","objectID":"/2022/01/11-2java%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%86/:0:0","series":null,"tags":["赶码人"],"title":"11-2：java绘制方框","uri":"/2022/01/11-2java%E7%BB%98%E5%88%B6%E6%96%B9%E6%A1%86/"},{"categories":null,"content":"首先需要装一个三方库 labelimg #安装 pip install labelimg #使用 labelimg ","date":"2022-01-28","objectID":"/2022/01/2.-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E8%AE%AD%E7%BB%83%E9%9B%86/:0:0","series":null,"tags":["yolov5"],"title":"2. 自己实现训练集","uri":"/2022/01/2.-%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%E8%AE%AD%E7%BB%83%E9%9B%86/"},{"categories":null,"content":"有两种方式 ","date":"2022-01-28","objectID":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/:0:0","series":null,"tags":["yolov5"],"title":"3. 实现屏幕的实时截图","uri":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/"},{"categories":null,"content":"win32api import cv2 import numpy as np import win32gui import win32ui import win32con import win32api def grab_screen(region=None): hwin = win32gui.GetDesktopWindow() if region: left, top, width, height = region else: width = win32api.GetSystemMetrics(win32con.SM_CXVIRTUALSCREEN) height = win32api.GetSystemMetrics(win32con.SM_CYVIRTUALSCREEN) left = win32api.GetSystemMetrics(win32con.SM_XVIRTUALSCREEN) top = win32api.GetSystemMetrics(win32con.SM_YVIRTUALSCREEN) hwindc = win32gui.GetWindowDC(hwin) srcdc = win32ui.CreateDCFromHandle(hwindc) memdc = srcdc.CreateCompatibleDC() bmp = win32ui.CreateBitmap() bmp.CreateCompatibleBitmap(srcdc, width, height) memdc.SelectObject(bmp) memdc.BitBlt((0, 0), (width, height), srcdc, (left, top), win32con.SRCCOPY) signedIntsArray = bmp.GetBitmapBits(True) img = np.fromstring(signedIntsArray, dtype='uint8') img.shape = (height, width, 4) srcdc.DeleteDC() memdc.DeleteDC() win32gui.ReleaseDC(hwin, hwindc) win32gui.DeleteObject(bmp.GetHandle()) return cv2.cvtColor(img, cv2.COLOR_BGRA2BGR) ","date":"2022-01-28","objectID":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/:1:0","series":null,"tags":["yolov5"],"title":"3. 实现屏幕的实时截图","uri":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/"},{"categories":null,"content":"mss pip install mss import mss import numpy as np import cv2 sct = mss.mss() screen_width = 1920 # 屏幕的宽 screen_height = 1080 # 屏幕的高 GAME_LEFT, GAME_TOP, GAME_WIDTH, GAME_HEIGHT = screen_width // 3, screen_height // 3, screen_width // 3, screen_height // 3 # 游戏内截图区域 RESIZE_WIN_WIDTH, RESIZE_WIN_HEIGHT = screen_width // 5, screen_height // 5 # 显示窗口大小 monitor = { 'left': GAME_LEFT, 'top': GAME_TOP, 'width': GAME_WIDTH, 'height': GAME_HEIGHT } window_name = 'test' while True: img = sct.grab(monitor=monitor) img = np.array(img) cv2.namedWindow(window_name, cv2.WINDOW_NORMAL) # cv2.WINDOW_NORMAL 根据窗口大小设置我们的图片大小 cv2.resizeWindow(window_name, RESIZE_WIN_WIDTH, RESIZE_WIN_HEIGHT) cv2.imshow(window_name, img) k = cv2.waitKey(1) if k % 256 == 27: # ESC cv2.destroyAllWindows() exit('ESC ...') ","date":"2022-01-28","objectID":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/:2:0","series":null,"tags":["yolov5"],"title":"3. 实现屏幕的实时截图","uri":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/"},{"categories":null,"content":"waitKey()函数 waitKey()–这个函数是在一个给定的时间内(单位ms)等待用户按键触发;如果用户没有按下 键,则接续等待(循环) 如下所示: while(1){ if(waitKey(100)==27)break; } 在这个程序中,我们告诉OpenCv等待用户触发事件,等待时间为100ms，如果在这个时间段内, 用户按下ESC(ASCII码为27),则跳出循环,否则,则继续循环 如果设置waitKey(0),则表示程序会无限制的等待用户的按键事件 注意：python下cv.waitKey无响应原因 按下键的时候，焦点要落在窗口上，不能落在cmd窗口上。 另外，一般在imshow()后要使用waitKey()，给图像绘制留下时间，不然窗口会出现无响应情况，并且图像无法显示出来。 int waitKey(int delay=0) - 延时delay = 0 函数则延时无限长，必须有键按下才继续执行。 - 延时delay \u003e 0 函数返回值为按下的键的ASCII码值，超时则返回-1。 也就是说必须在有窗口显示的情况下，waitKey才有作用，否则无效。 比如调用cv.waitKey(0)，如果此时没有活动的窗口，该函数立刻返回-1 ","date":"2022-01-28","objectID":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/:2:1","series":null,"tags":["yolov5"],"title":"3. 实现屏幕的实时截图","uri":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/"},{"categories":null,"content":"namedWindow()函数 用法：cv2.namedWindow(‘窗口标题’,默认参数) 默认参数： cv2.WINDOW_AUTOSIZE+cv2.WINDOW_KEEPRATIO+cv2.WINDOW_GUI_EXPANDED) 参数： （1）cv2.WINDOW_NORMAL：窗口大小可改变。 （2）cv2.WINDOW_AUTOSIZE：窗口大小不可改变。 （3）cv2.WINDOW_FREERATIO：自适应比例。 （4）cv2.WINDOW_KEEPRATIO：保持比例。 ","date":"2022-01-28","objectID":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/:2:2","series":null,"tags":["yolov5"],"title":"3. 实现屏幕的实时截图","uri":"/2022/01/3.-%E5%AE%9E%E7%8E%B0%E5%B1%8F%E5%B9%95%E7%9A%84%E5%AE%9E%E6%97%B6%E6%88%AA%E5%9B%BE/"},{"categories":null,"content":"分享个自用的矩阵乘法工具，只支持4x4矩阵乘4x4矩阵，以及4x4矩阵乘4x1矩阵。 网上也有类似的矩阵在线计算工具，但是没一个用着爽的，比如从CE复制出来的矩阵，粘贴到一些已有的在线计算工具网站上，还要自己添加换行之类的，所以就自己写了一个，界面简单，但是用起来没毛病， 视频的点赞量与粉丝量的比例有点低，原本是想说点赞之后私信领的，但又想了想，这样做有点像那种洗稿营销号，算了…，反正代码量也不多，也是以前自己有需要才做的，直接发吧，只求收藏视频的时候，顺手点个赞~ 复制代码到记事本，另存为后缀改html，再用浏览器打开即可： \u003c!doctype html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003e4*4矩阵计算器\u003c/title\u003e \u003cstyle\u003e td{ min-width: 6em; } \u003c/style\u003e \u003c/head\u003e \u003cbody\u003e \u003cp\u003e仅支持输入4*4矩阵,16个数字,空格隔开,无需换行: \u003c/p\u003e \u003cbutton onclick='identity(\"matrixA\")'\u003e填入单位矩阵\u003c/button\u003e \u003cinput id='matrixA' value=''\u003e \u003cbutton onclick='transpose(\"matrixA\")'\u003e转置\u003c/button\u003e \u003cp\u003e仅支持输入4*4或4*1矩阵,16或4个数字,空格隔开,无需换行: \u003c/p\u003e \u003cbutton onclick='identity(\"matrixB\")'\u003e填入单位矩阵\u003c/button\u003e \u003cinput id='matrixB' value=\"\"\u003e \u003cbutton onclick='transpose(\"matrixB\")'\u003e转置\u003c/button\u003e \u003cbr\u003e\u003cbr\u003e \u003cbutton onclick='calc()'\u003e计算\u003c/button\u003e \u003cp\u003e结果:\u003c/p\u003e \u003ctable id='res'\u003e\u003c/table\u003e \u003cscript\u003e function identity(id){ document.querySelector('#' + id).value = '1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1' } function transpose(id){ let e = document.querySelector('#' + id) let arr = e.value.trim().split(/\\s+/g) if(arr.length != 16){ alert('本工具仅适用于4*4矩阵转置,请检查!(元素个数:' + arr.length + ')') } let res = arr[0] + ' ' res += arr[4] + ' ' res += arr[8] + ' ' res += arr[12] + ' ' res += arr[1] + ' ' res += arr[5] + ' ' res += arr[9] + ' ' res += arr[13] + ' ' res += arr[2] + ' ' res += arr[6] + ' ' res += arr[10] + ' ' res += arr[14] + ' ' res += arr[3] + ' ' res += arr[7] + ' ' res += arr[11] + ' ' res += arr[15] + ' ' e.value = res } function calc(){ let matrixA = document.querySelector('#matrixA') let matrixB = document.querySelector('#matrixB') let res = document.querySelector('#res') let c = [] let a = matrixA.value.trim().split(/\\s+/g).map(parseFloat) let b = matrixB.value.trim().split(/\\s+/g).map(parseFloat) if(a.length != 16){ alert('本程序仅允许4*4矩阵与4*1矩阵相乘!矩阵A的元素个数' + a.length) return } if(b.length == 16){ c.push(a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12]) c.push(a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13]) c.push(a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14]) c.push(a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15]) c.push(a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12]) c.push(a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13]) c.push(a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14]) c.push(a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15]) c.push(a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12]) c.push(a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13]) c.push(a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14]) c.push(a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15]) c.push(a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12]) c.push(a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13]) c.push(a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14]) c.push(a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15]) res.innerHTML = '\u003ctr\u003e' + '\u003ctd\u003e' + c[0] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[1] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[2] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[3] + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[4] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[5] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[6] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[7] + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[8] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[9] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[10] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[11] + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[12] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[13] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[14] + '\u003c/td\u003e' + '\u003ctd\u003e' + c[15] + '\u003c/td\u003e' + '\u003c/tr\u003e' return } if(b.length == 4){ c.push(a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3]) c.push(a[4] * b[0] + a[5] * b[1] + a[6] * b[2] + a[7] * b[3]) c.push(a[8] * b[0] + a[9] * b[1] + a[10] * b[2] + a[11] * b[3]) c.push(a[12] * b[0] + a[13] * b[1] + a[14] * b[2] + a[15] * b[3]) res.innerHTML = '\u003ctr\u003e' + '\u003ctd\u003e' + c[0] + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[1] + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[2] + '\u003c/td\u003e' + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML += '\u003ctr\u003e' + '\u003ctd\u003e' + c[3] + '\u003c/td\u003e' + '\u003c/td\u003e' + '\u003c/tr\u003e' res.innerHTML +","date":"2022-01-28","objectID":"/2022/01/4x4%E7%9F%A9%E9%98%B5%E4%B8%8E4x4%E7%9F%A9%E9%98%B5-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8js%E6%BA%90%E7%A0%81/:0:0","series":null,"tags":["赶码人"],"title":"4x4矩阵与4x4矩阵 乘法计算器，JS源码","uri":"/2022/01/4x4%E7%9F%A9%E9%98%B5%E4%B8%8E4x4%E7%9F%A9%E9%98%B5-%E4%B9%98%E6%B3%95%E8%AE%A1%E7%AE%97%E5%99%A8js%E6%BA%90%E7%A0%81/"},{"categories":null,"content":"MacOS下homebrew install报错： fatal: not in a git directory Error: Command failed with exit 128: git 实际上使用brew -v就会提示如何解决： ","date":"2022-01-28","objectID":"/2022/01/brew%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/:1:0","series":null,"tags":["Python"],"title":"brew常见错误","uri":"/2022/01/brew%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"},{"categories":null,"content":"网上一篇博主写的select，十分透彻，参考linux下多路复用模型之Select模型 本文主要记录了select一些用法和自己写的一个用select的服务器端例子。 ","date":"2022-01-28","objectID":"/2022/01/c-select%E5%88%86%E6%9E%902/:0:0","series":null,"tags":["Socket"],"title":"C++ select分析2","uri":"/2022/01/c-select%E5%88%86%E6%9E%902/"},{"categories":null,"content":"select函数的定义和参数的含义 首先，我们来看看select函数的定义和参数的含义： int select( int nfds, fd_set FAR* readfds,　fd_set * writefds, fd_set * exceptfds,　const struct timeval * timeout) 参数含义： 1. nfds：是一个整数值，是指集合中所有文件描述符的范围，即所有文件描述符的最大值加1，不能错！在Windows中这个参数的值无所谓，可以设置不正确。 2. readfds：（可选）指针，指向一组等待可读性检查的套接口。 3. writefds：（可选）指针，指向一组等待可写性检查的套接口。 4. exceptfds：（可选）指针，指向一组等待错误检查的套接口。 5. timeout：select()最多等待时间，对阻塞操作则为NULL。 返回值： select()调用返回处于就绪状态并且已经包含在fd_set结构中的描述字总数；如果超时则返回0；否则的话，返回SOCKET_ERROR错误，应用程序可通过WSAGetLastError获取相应错误代码。 1. 当返回为-1时，所有描述符集清0。 2. 当返回为0时，表示超时。 3. 当返回为正数时，表示已经准备好的描述符数。 select（）返回后，在3个描述符集里，依旧是1的位就是准备好的描述符。这也就是为什么，每次用select后都要用FD_ISSET的原因。 select函数实现I/O多路复用，可以用来监视多个描述符，之后我们调用FD_ISSET函数确定具体是哪一个描述符准备好了。 那怎样才算准备好了呢？《unix环境高级编程》中，提到： 若对读集中的一个描述符进行的read操作不会阻塞，则认为此描述符是准备好的。 若对写集中的一个描述符进行的write操作不会阻塞，则认为此描述符是准备好的。 若对异常条件集中的一个描述符有一个未决异常条件，则认为此描述符是准备好的。 对于读、写和异常条件，普通文件的文件描述符总是认为准备好的。 操作select函数，还需要以下几个函数配合。 void FD_CLR(int fd, fd_set *set) // 清除set集合中描述符fd int FD_ISSET(int fd, fd_set *set) //判断set集合中描述符fd是否准备好 void FD_SET(int fd, fd_set *set) //将描述符fd添加进集合set(其实是将某一位置1)。 void FD_ZERO(fd_set *set) //将set集全部清除 接下来看一个服务器端运用select函数的例子。 从下面的程序可以看出，服务器端调用函数FD_SET( sockfd, \u0026readfds)把套接字描述符sockfd加入读集合，调用select函数监听了socket套接字是否准备好。当客户端有连接请求时，select会返回一个正数，然后调用FD_ISSET(sockfd,\u0026readfds)判断是哪一个描述符准备好。当然这里只能是socket，因为我们只向读集合添加了一个。接着调用accept接收请求，创建线程去处理客户端的请求。 /*server.c*/ #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003csys/ioctl.h\u003e #include \u003cunistd.h\u003e #include \u003cnetinet/in.h\u003e #define BUFFER_SIZE 4096 #define MAX_QUE_CONN_NM 5 #define PORT 6000 //#define MAXSOCKFD 10 #define FILE_NAME_MAX 512 void recv_mul_file(int sockfd); void* pthread_func(void * arg); int main(int argc,char* argv[]) { int sockfd; int sin_size = sizeof(struct sockaddr); struct sockaddr_in server_sockaddr, client_sockaddr; int i = 1;/* 使得重复使用本地地址与套接字进行绑定 */ /*建立socket连接*/ if ((sockfd = socket(AF_INET,SOCK_STREAM,0))== -1) { perror(\"socket\"); exit(1); } printf(\"Socket id = %d\\n\",sockfd); /*设置sockaddr_in 结构体中相关参数*/ server_sockaddr.sin_family = AF_INET; server_sockaddr.sin_port = htons(PORT); server_sockaddr.sin_addr.s_addr = INADDR_ANY; bzero(\u0026(server_sockaddr.sin_zero), 8);//将内存块（字符串）的前n个字节清零 setsockopt(sockfd, SOL_SOCKET, SO_REUSEADDR, \u0026i, sizeof(i)); /*绑定函数bind*/ if (bind(sockfd, (struct sockaddr *)\u0026server_sockaddr, sizeof(struct sockaddr))== -1) { perror(\"bind\"); exit(1); } printf(\"Bind success!\\n\"); /*调用listen函数*/ if (listen(sockfd, MAX_QUE_CONN_NM) == -1) { perror(\"listen\"); exit(1); } printf(\"Listening....\\n\"); recv_mul_file(sockfd); close(sockfd); return 0; } void recv_mul_file(int sockfd) { fd_set readfds; FD_ZERO(\u0026readfds); FD_SET( sockfd, \u0026readfds); pthread_t tid; struct sockaddr_in client_sockaddr; int client_fd, sin_size = sizeof(struct sockaddr); int MAXSOCKFD = sockfd; while(1) { if(select(MAXSOCKFD + 1,\u0026readfds,NULL,NULL,NULL) \u003e 0) { if(FD_ISSET(sockfd,\u0026readfds)\u003e0) { if ((client_fd = accept(sockfd, (struct sockaddr *)\u0026client_sockaddr, (socklen_t *)\u0026sin_size)) == -1) { perror(\"accept\"); exit(1); } pthread_create(\u0026tid, NULL, pthread_func, \u0026client_fd); } FD_SET( client_fd, \u0026readfds); MAXSOCKFD = (MAXSOCKFD \u003e client_fd? MAXSOCKFD:client_fd); } } } void* pthread_func(void * arg) { //recv file imformation int client_fd; char buff[BUFFER_SIZE]; char filename[FILE_NAME_MAX]; int count; bzero(buff,BUFFER_SIZE); client_fd = *(int *)arg; printf(\"recv from client,client_fd = %d\\n\",client_fd); count=recv(client_fd,buff,BUFFER_SIZE,0); //把接受到到字符放在长度为BUFFER_SIZE的buff地址上，接收成功返回接收到到字节数目 if(count\u003c0) { perror(\"recv\"); exit(1); } strncpy(filename,buff,strlen(buff)\u003eFILE_NAME_MAX?FILE_NAME_MAX:strlen(buff));//把filename地址上的内容复制到地址buff上，第三个参数表明复制多少个字节 printf(\"Preparing recv file : %s\\n\",filename ); //recv file FILE *fd=fopen(filename,\"wb+\"); //告诉函数库，打开的是一个二进制到可写文件，地址在指针filename if(NULL==fd) { perror(\"open\"); exit(1); } bzero(buff,BUFFER_SIZE); //缓冲区清0 int length=0; while(length=recv(client_fd,buff,BUFFER_SIZE,0)) //这里是分包接收，每次接收4096个字节 { if(le","date":"2022-01-28","objectID":"/2022/01/c-select%E5%88%86%E6%9E%902/:1:0","series":null,"tags":["Socket"],"title":"C++ select分析2","uri":"/2022/01/c-select%E5%88%86%E6%9E%902/"},{"categories":null,"content":"Windows 下 C++ 中使用 YoloV5 工具选择 CMake 或者 VS2019 CMake 下载路径 download 其中 VS2019 配置可以见这篇博客 VS2019 配置 LibTorch 和 OpenCV 2.下载 C++ 的 YoloV5 库 YoloV5-LibTorch // 下载 YoloV5-LibTorch git clone https://github.com/ncdhz/YoloV5-LibTorch.git 下载 LibTorch 和 OpenCV 并配置环境变量可以参考 VS2019 配置 LibTorch 和 OpenCV 打开刚才下载下来的项目并修改根目录下的 CMakeLists.txt 文件 打开注解并更改为刚才下载的 LibTorch 和 OpenCV 路径，下面是我电脑上面的 LibTorch 和OpenCV 路径。 新建 build 目录并编译此项目 mkdir build cd build // 下面这行代码在 windows 下依赖于 VS2019 别的系统只需要有 cmake 和 make 就好 cmake .. // 构建项目 （如果你下载的是Debug版本的 LibTorch 不用加 --config Release 是 Release 版本需要加） cmake --build . // 下载项目 后面的 Debug 可以替换成 Release 这取决于上一条命令是否加了 --config Release cmake --install . --config Debug 其中 Linux 系统应该不用这么麻烦直接下面操作应该可以解决问题 // 下面操作我没有在 Linux 系统下测试 主要本人懒下载虚拟机等等 mkdir build cd build cmake .. make make install 测试识别物体 // 先 cd 到根目录 cd bin ./test.exe 这里使用的是 yolov5s 模型。模型可以根据需要进行更改（用官方yolov5库训练模型就好了然后把模型转换成 LibTorch 可以识别的）。 下面画红标的是官方提供的转换工具 通过三种方式把上面介绍的库使用到自己的项目 在 VS2019 中通过复制库的头文件和实现文件使用（其中 VS2019 配置见上面提到的配置文档） 新建头文件和cpp文件 粘贴 src/YoloV5.cpp 中的代码到上面的 YoloV5.cpp 文件中 粘贴 nclude/YoloV5.h 中的代码到上面的 YoloV5.h 文件中 更改 YoloV5.cpp 中头文件引入方式为 “YoloV5.h” 新建 main.cpp 使用 YoloV5 吧 // 复制下面的代码到main.cpp #include \"YoloV5.h\" int main() { // 第二个参数为是否启用 cuda 详细用法可以参考 YoloV5.h 文件 YoloV5 yolo(\"C:/Users/hwx/Documents/Github/YoloV5-LibTorch/test/yolov5s.cuda.pt\", true); // 读取分类标签（我们用的官方的所以这里是 coco 中的分类） // 其实这些代码无所谓哪 只是后面预测出来的框没有标签罢了 std::ifstream f(\"C:/Users/hwx/Documents/Github/YoloV5-LibTorch/test/coco.txt\"); std::string name = \"\"; int i = 0; std::map\u003cint, std::string\u003e labels; while (std::getline(f, name)) { labels.insert(std::pair\u003cint, std::string\u003e(i, name)); i++; } // 用 OpenCV 打开摄像头读取文件（你随便咋样获取图片都OK哪） cv::VideoCapture cap = cv::VideoCapture(0); // 设置宽高 无所谓多宽多高后面都会通过一个算法转换为固定宽高的 // 固定宽高值应该是你通过YoloV5训练得到的模型所需要的 // 传入方式是构造 YoloV5 对象时传入 width 默认值为 640，height 默认值为 640 cap.set(cv::CAP_PROP_FRAME_WIDTH, 1000); cap.set(cv::CAP_PROP_FRAME_HEIGHT, 800); cv::Mat frame; while (cap.isOpened()) { // 读取一帧 cap.read(frame); if (frame.empty()) { std::cout \u003c\u003c \"Read frame failed!\" \u003c\u003c std::endl; break; } // 预测 // 简单吧，两行代码预测结果就出来了，封装的还可以吧 嘚瑟 std::vector\u003ctorch::Tensor\u003e r = yolo.prediction(frame); // 画框根据你自己的项目调用相应的方法，也可以不画框自己处理 frame = yolo.drawRectangle(frame, r[0], labels); // show 图片 cv::imshow(\"\", frame); if (cv::waitKey(1) == 27) break; } return 0; } 点击上面的运行按钮得到的结果和上面有框的图一样 在 VS2019 中通过引用库的方式使用 YoloV5 删除上面的 YoloV5.cpp 和 yoloV5.h （当然没有新建就不用删除了） LibTorch 和 OpenCV 还是要配置的呀（怎么配置就不说了，自己看上面的，其实这几个字已经够写出来了，嘻嘻） 下面引入上面编译好的库 在 VC++目录/包含目录 中添加头文件 在 VC++目录/库目录 中添加 .lib 库 在 输入/附加依赖项 中添加 lib 库名称 修改 main.cpp 文件的引入代码（测试代码和上面一样不重复书写） 测试（和上面测试步骤和结果一样） 直接修改刚才下载下来的项目（略，自己可以仿照 test 书写，还要改一下根目录下的 CMakeLists.txt） ","date":"2022-01-28","objectID":"/2022/01/c-%E4%B8%AD%E4%BD%BF%E7%94%A8-yolov5/:1:0","series":null,"tags":["yolov5"],"title":"C++ 中使用 YoloV5","uri":"/2022/01/c-%E4%B8%AD%E4%BD%BF%E7%94%A8-yolov5/"},{"categories":null,"content":"先声明一下，虽然代码出自cheat engine，但它不仅是用于游戏作弊，还广泛用于病毒查杀、反外挂等程序。 暴力匹配，应该没有更快更好的算法了，毕竟ceserver用的就是这个算法（ 源码位于**/ceserver/native-api.h**，/ceserver/native-api.c ： #ifndef NativeAPI_H_ #define NativeAPI_H_ #define MAX_HIT_COUNT 5000000 DWORD AOBScan(HANDLE hProcess, const char* pattern, const char* mask, uint64_t start, uint64_t end, int inc, int protection, uint64_t* match_addr); #endif #include \"api.h\" #include \"porthelp.h\" #include \"ceserver.h\" #include \"threads.h\" #include \"symbols.h\" #include \"context.h\" #include \"native-api.h\" DWORD AOBScan(HANDLE hProcess, const char* pattern, const char* mask, uint64_t start, uint64_t end, int inc, int protection,uint64_t * match_addr) { RegionInfo rinfo; uint64_t tmp = start; uint64_t tmp2 = tmp; char* MemoryBuff = (char*)malloc(4096); int patternLength = (int)strlen(mask); int result_count = 0; while (tmp \u003c end) { VirtualQueryEx(hProcess, (void*)tmp, \u0026rinfo, NULL); if (rinfo.size == 0) { return -1; } if((rinfo.protection \u0026 protection) != 0) { tmp2 = tmp; while (tmp2 \u003c tmp + rinfo.size) { if (!ReadProcessMemory(hProcess, (void*)tmp2, MemoryBuff, 4096)) { break; } for (int i = 0; i \u003c 4096; i += inc) { for (int k = 0; k \u003c patternLength; k++) { if (!(mask[k] == '?' || pattern[k] == (MemoryBuff[k]))) { goto label; } } match_addr[result_count] = tmp2; result_count++; if (result_count \u003e= MAX_HIT_COUNT)return result_count; label: tmp2 += inc; MemoryBuff += inc; } MemoryBuff -= 4096; } } tmp += rinfo.size; } return result_count; } 不知道你如何看待darkbyte的这段代码，我菜得狠，不敢乱评价，总之就是复制出来不能直接用， 于是我改了改，把关键内容提取出来了，我不是很擅长C语言，仅供参考… int AOBScan(void* addr, int len, const char* pattern, const char* mask, int pattern_len, int inc, long* match_addr, long base_addr) { char* MemoryBuff = (char*)addr; int result_count = 0; for (int i = 0; i \u003c len; i += inc) { for (int k = 0; k \u003c pattern_len; k++) { if ( mask[k] != 0xff \u0026\u0026 pattern[k] != MemoryBuff[i + k] ) { goto label; } } match_addr[result_count] = base_addr + i; result_count++; if (result_count \u003e= MAX_HIT_COUNT){ return result_count; } label:; } return result_count; } 比较基础，但我还是大概解释一下： 参数一：指针，不解释了，（别问为啥不需要pid之类的… 参数二：扫描的那段内存的长度 参数三、四、五：特征码相关，例如特征码是aa bb cc ?? ?? aa bb： char pattern[7] = {0xaa, 0xbb, 0xcc, 0x随便写, 0x随便写, 0xaa, 0xbb}; char mask[7] = {0x随便写, 0x随便写, 0x随便写, 0xff, 0xff, 0x随便写, 0x随便写}; 参数六：内存对齐，通常都是1（速度慢）、2、4、8，具体用哪个，因目标程序而异，也要看你特征码找的O不OK。 参数七：用来存储结果的数组 参数八：读外部进程需要用到，因为变量i是基于参数一 addr的偏移，而参数一是自身进程内存空间的地址…..（好像有点啰嗦了？懂的自然懂） 在我的红米10x （4g版百元机，我意思是 做个 性能参考）上简单测试了一下，运行内存约2GB的某64位程序，过滤好Ca内存（[anon:libc_malloc]），内存对齐8字节，特征码40字节，12个字节是通配符，大概2~3s就能扫描出来全部结果。 ","date":"2022-01-28","objectID":"/2022/01/c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%89%B9%E5%BE%81%E7%A0%81%E6%90%9C%E7%B4%A2-%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8Dce%E7%9A%84aobscan%E5%87%BD%E6%95%B0%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/:0:0","series":null,"tags":["赶码人"],"title":"C语言内存特征码搜索 模糊匹配（CE的AOBScan函数，暴力匹配）","uri":"/2022/01/c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E7%89%B9%E5%BE%81%E7%A0%81%E6%90%9C%E7%B4%A2-%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8Dce%E7%9A%84aobscan%E5%87%BD%E6%95%B0%E6%9A%B4%E5%8A%9B%E5%8C%B9%E9%85%8D/"},{"categories":null,"content":"Homebrew国内如何自动安装（国内地址）（Mac \u0026 Linux） ","date":"2022-01-28","objectID":"/2022/01/homebrew%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/:0:0","series":null,"tags":["Python"],"title":"Homebrew国内如何自动安装","uri":"/2022/01/homebrew%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"自动脚本(全部国内地址)（复制下面一句脚本到终端中粘贴回车) 苹果电脑 常规安装脚本（推荐 完全体 几分钟安装完成）： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" 苹果电脑 极速安装脚本（精简版 几秒钟安装完成）： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)\" speed -\u003e Mac电脑如何打开终端：command+空格 在聚焦搜索中输入terminal回车。 苹果电脑 卸载脚本： /bin/zsh -c \"$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)\" 常见错误去下方地址查看 https://gitee.com/cunkai/HomebrewCN/blob/master/error.md Linux电脑 安装脚本： rm Homebrew.sh ; wget https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh ; bash Homebrew.sh Linux电脑 卸载脚本： rm HomebrewUninstall.sh ; wget https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh ; bash HomebrewUninstall.sh ","date":"2022-01-28","objectID":"/2022/01/homebrew%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["Python"],"title":"Homebrew国内如何自动安装","uri":"/2022/01/homebrew%E5%9B%BD%E5%86%85%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%AE%89%E8%A3%85/"},{"categories":null,"content":"Lua Socket在Windows平台下的使用 在上一篇博文中介绍了VS2015+Lua5.1.5环境的搭建，最后介绍了Lua解释器的创建。本文将继续介绍Lua的一个比较实用的拓展库Lua Socket在Windows下平台的使用。在网上查看了许多关于Lua Socket的安装，发现大部分都是在Linux下的安装，关于在Windows平台下的使用说明很少，而且发现问题挺多。本文将介绍一个极其简单的方式介绍Lua Socket在Windows下的安装使用，亲测可用。 1、首先下载编译好后的Lua Socket库： http://files.luaforge.net/releases/luasocket/luasocket/luasocket-2.0.2 选择： 2、（关键）解压后将socket目录下的core.dll重命名为socket.dll,并将文件夹lua及socket.dll拷贝到LuaTest生成目录下（具体可参考上一篇博文） 3、修改main.lua： -- server.lua local socket = require(\"socket\") local host = \"127.0.0.1\" local port = \"12345\" local server = assert(socket.bind(host, port, 1024)) server:settimeout(0) local client_tab = {} local conn_count = 0 print(\"服务器开启 \" .. host .. \":\" .. port) while 1 do local conn = server:accept() if conn then conn_count = conn_count + 1 client_tab[conn_count] = conn print(\"服务器 A client successfully connect!\") end for conn_count, client in pairs(client_tab) do local recvt, sendt, status = socket.select({client}, nil, 1) if #recvt \u003e 0 then local receive, receive_status = client:receive() if receive_status ~= \"closed\" then if receive then assert(client:send(\"Client \" .. conn_count .. \" Send : \")) assert(client:send(receive .. \"\\n\")) print(\"Receive Client \" .. conn_count .. \" : \", receive) end else table.remove(client_tab, conn_count) client:close() print(\"Client \" .. conn_count .. \" disconnect!\") end end end end 编译运行： 此外，补充一个客户端程序： -- client.lua local socket = require(\"socket\") local host = \"127.0.0.1\" local port = 12345 local sock = assert(socket.connect(host, port)) sock:settimeout(0) print(\"Press enter after input something:\") local input, recvt, sendt, status while true do input = io.read() if #input \u003e 0 then assert(sock:send(input .. \"\\n\")) end recvt, sendt, status = socket.select({sock}, nil, 1) while #recvt \u003e 0 do local response, receive_status = sock:receive() if receive_status ~= \"closed\" then if response then print(response) recvt, sendt, status = socket.select({sock}, nil, 1) end else break end end end ","date":"2022-01-28","objectID":"/2022/01/lua-socket-in-win/:1:0","series":null,"tags":["Socket"],"title":"Lua Socket in Win","uri":"/2022/01/lua-socket-in-win/"},{"categories":null,"content":"使用Lua 在VsCode 环境下 开发 需要使用到 Socket 、Http、Udp、Tcp 开发 都可以使用 C库 LuaSocket ","date":"2022-01-28","objectID":"/2022/01/lua-socket-with-vscode-in-win10/:0:0","series":null,"tags":["Socket"],"title":"Lua Socket with VSCode in Win10","uri":"/2022/01/lua-socket-with-vscode-in-win10/"},{"categories":null,"content":"先下载VSCode 插件以及 Lua 的Windows 运行环境： ","date":"2022-01-28","objectID":"/2022/01/lua-socket-with-vscode-in-win10/:1:0","series":null,"tags":["Socket"],"title":"Lua Socket with VSCode in Win10","uri":"/2022/01/lua-socket-with-vscode-in-win10/"},{"categories":null,"content":"Lua运行环境： https://www.runoob.com/lua/lua-environment.html 安装 一路Next ，放到 ，会自己放到 ：C:\\Program Files (x86)\\Lua\\5.1 目录下 ","date":"2022-01-28","objectID":"/2022/01/lua-socket-with-vscode-in-win10/:2:0","series":null,"tags":["Socket"],"title":"Lua Socket with VSCode in Win10","uri":"/2022/01/lua-socket-with-vscode-in-win10/"},{"categories":null,"content":"下载 LuaSocket http://files.luaforge.net/releases/luasocket/luasocket/luasocket-2.0.2 在自己的项目中创建个文件夹，然后将下载好的 luasocket-2.0.2 解压文件 全都放到 这个文件夹下。 以 创建 LuaSockts2007 文件夹 为例子： 然后再 点击，在我们建立的 VsCode 项目中 加入 Lua Debug 插件的调试 launch.json 配置文件 在 launch.json 文件中录入: { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387 \"version\": \"0.2.0\", \"configurations\": [ { \"type\": \"lua\", \"request\": \"launch\", \"name\": \"Launch\", \"path\": \"${workspaceFolder}/LuaSockts2007/lua/?.lua;C:/Program Files (x86)/Lua/5.1/lua/?.lua;\", //LuaSockts2007+系统Lua运行环境 \"cpath\": \"${workspaceFolder}/LuaSockts2007/?.dll;C:/Program Files (x86)/Lua/5.1/clibs/?.dll;\", // \"path\": \"C:/Program Files (x86)/Lua/5.1/lua/?.lua\", //系统Lua运行环境 // \"cpath\": \"C:/Program Files (x86)/Lua/5.1/clibs/?.dll\", \"luaexe\": \"C:/Program Files (x86)/Lua/5.1/lua.exe\", // \"luaexe\": \"${workspaceFolder}/LuaSockts2007/lua5.1.exe;\", // \"program\": \"${workspaceFolder}/socketMain.lua\", \"program\": \"${workspaceFolder}/socketHttpMain.lua\", } ] } 此时便 可以使用 Luasocket 进行开发或者 调试了 ","date":"2022-01-28","objectID":"/2022/01/lua-socket-with-vscode-in-win10/:3:0","series":null,"tags":["Socket"],"title":"Lua Socket with VSCode in Win10","uri":"/2022/01/lua-socket-with-vscode-in-win10/"},{"categories":null,"content":"完整说明，见引用 https://lunarmodules.github.io/luasocket/reference.html ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["Socket"],"title":"Lua Socket笔记","uri":"/2022/01/lua-socket%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"select用法 等待多个套接字更改状态 socket.select(recvt, sendt [, timeout]) 参数： Recvt是一个带有套接字的数组，用于测试可供读取(接收)的字符 sendt是一个带有套接字的数组，用于测试可供写入(发送)的字符 timeout是等待状态更改的最大时间（以秒为单位）。nil、负或省略的timeout允许函数无限期阻止。 Recvt和sendt也可以是空tables或nil。数组中的非套接字值（或具有非数字索引的值）将被默默忽略。 三个返回值： 一个套接字准备读取(接收)的列表 一个套接字准备写入(发送)的列表 一个错误消息: 如果超时，则错误消息为“timeout”. 如果调用失败，则错误消息为“select failed”. 其它情况为nil。 返回的tables,键为整数,值为套接字本身。 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["Socket"],"title":"Lua Socket笔记","uri":"/2022/01/lua-socket%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"LuaSocket 是 Lua 的网络模块库，它可以很方便地提供 TCP、UDP、DNS、FTP、HTTP、SMTP、MIME 等多种网络协议的访问操作。 它由两部分组成：一部分是用 C 写的核心，提供对 TCP 和 UDP 传输层的访问支持。另外一部分是用 Lua 写的，负责应用功能的网络接口处理。 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:0:0","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"安装LuaSocket 下面介绍两种安装方法 第一种方法：如果你有安装了 Lua 模块的安装和部署工具 LuaRocks，那么一条指令就能安装部署好 LuaSocket： # luarocks install luasocket 第二种方法：如果没安装有 LuaRocks，也可以源码安装。 先把 LuaRocks 下载下来，当前可用的版本是 luasocket-3.0-rc1（luasocket的源码有托管在Github.com）： # git clone https://github.com/diegonehab/luasocket.git 把源码clone下来之后就可以进行本地源码安装，直接进入到luasocket目录进行编译安装了 # cd luasocket # make \u0026\u0026 make install ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:1:0","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"LuaSocket 使用 接下来是LuaSocket扩展的几种使用方法 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:2:0","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"1、socket方式请求 -- socket方式请求 local socket = require(\"socket\") local host = \"100.42.237.125\" local file = \"/\" local sock = assert(socket.connect(host, 80)) -- 创建一个 TCP 连接，连接到 HTTP 连接的标准 80 端口上 sock:send(\"GET \" .. file .. \" HTTP/1.0\\\\r\\\\n\\\\r\\\\n\") repeat local chunk, status, partial = sock:receive(1024) -- 以 1K 的字节块来接收数据，并把接收到字节块输出来 -- print(chunk or partial) until status ~= \"closed\" sock:close() -- 关闭 TCP 连接 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:2:1","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"2、HTTP访问请求 -- http访问请求 http=require(\"socket.http\") result=http.request(\"http://ip.taobao.com/service/getIpInfo.php?ip=123.189.1.100\") print(result) ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:2:2","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"3、SMTP方法发送mail -- smtp方法发送mail local smtp = require(\"socket.smtp\") from = \"\u003cyoumail@126.com\u003e\" -- 发件人 -- 发送列表 rcpt = { \"\u003cyoumail@126.com\u003e\", \"\u003cyoumail@qq.com\u003e\" } mesgt = { headers = { to = \"youmail@gmail.com\", -- 收件人 cc = '\u003cyoumail@gmail.com\u003e', -- 抄送 subject = \"This is Mail Title\" }, body = \"This is Mail Content.\" } r, e = smtp.send{ server=\"smtp.126.com\", user=\"youmail@126.com\", password=\"\\*\\*\\*\\*\\*\\*\", from = from, rcpt = rcpt, source = smtp.message(mesgt) } if not r then print(e) else print(\"send ok!\") end 使用 LuaSocket 还算简单吧，直接用 require 函数加载进来就行，在例如下面几个例子 1）输出一个 LuaSocket 版本信息： local socket = require(\"socket\") print(socket.\\_VERSION) 2）以 socket 的方式访问获取百度首页数据： local socket = require(\"socket\") local host = \"www.baidu.com\" local file = \"/\" -- 创建一个 TCP 连接，连接到 HTTP 连接的标准端口 -- 80 端口上 local sock = assert(socket.connect(host, 80)) sock:send(\"GET \" .. file .. \" HTTP/1.0\\\\r\\\\n\\\\r\\\\n\") repeat -- 以 1K 的字节块来接收数据，并把接收到字节块输出来 local chunk, status, partial = sock:receive(1024) print(chunk or partial) until status ~= \"closed\" -- 关闭 TCP 连接 sock:close() 3）使用模块里内置的 http 方法来访问： local http = require(\"socket.http\") local response = http.request(\"http://www.baidu.com/\") print(response) ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:2:3","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"一个简单的 client/server 通信连接 本来想写成单 server 多 client 的 socket 聊天服务器，不过最后还是卡在客户端的数据更新上，单进程的 while 轮询（poll），一个 io.read 就把服务器数据接收给截断了。 仅靠现有的 LuaSocket 模块不装其他第三方模块，也是很难做一个实时的聊天，虽然有 soket.select 在苦苦支撑，但是这还是一个填不平的坑来了。 可能用上面向并发的 concurrentlua 模块会解决这个数据接收阻塞问题，这个以后再看看，现阶段的成果是：在客户端的终端上敲一些东西后回车会通过 socket 给服务器发送数据，服务器接收到数据后再返回显示在客户端的终端上。 一个简单的东西，纯属练手，代码如下： ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:3:0","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"server端 -- server.lua local socket = require(\"socket\") local host = \"127.0.0.1\" local port = \"12345\" local server = assert(socket.bind(host, port, 1024)) server:settimeout(0) local client\\_tab = {} local conn\\_count = 0 print(\"Server Start \" .. host .. \":\" .. port) while 1 do local conn = server:accept() if conn then conn\\_count = conn\\_count + 1 client\\_tab\\[conn\\_count\\] = conn print(\"A client successfully connect!\") end for conn\\_count, client in pairs(client\\_tab) do local recvt, sendt, status = socket.select({client}, nil, 1) if #recvt \u003e 0 then local receive, receive\\_status = client:receive() if receive\\_status ~= \"closed\" then if receive then assert(client:send(\"Client \" .. conn\\_count .. \" Send : \")) assert(client:send(receive .. \"\\\\n\")) print(\"Receive Client \" .. conn\\_count .. \" : \", receive) end else table.remove(client\\_tab, conn\\_count) client:close() print(\"Client \" .. conn\\_count .. \" disconnect!\") end end end end ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:3:1","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"client端 -- client.lua local socket = require(\"socket\") local host = \"127.0.0.1\" local port = 12345 local sock = assert(socket.connect(host, port)) sock:settimeout(0) print(\"Press enter after input something:\") local input, recvt, sendt, status while true do input = io.read() if #input \u003e 0 then assert(sock:send(input .. \"\\\\n\")) end recvt, sendt, status = socket.select({sock}, nil, 1) while #recvt \u003e 0 do local response, receive\\_status = sock:receive() if receive\\_status ~= \"closed\" then if response then print(response) recvt, sendt, status = socket.select({sock}, nil, 1) end else break end end end http://www.qixing318.com/article/use-lua-extension-libraries-luasocket-cases.html ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%901/:3:2","series":null,"tags":["Socket"],"title":"Lua Socket分析1","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%901/"},{"categories":null,"content":"实例解析lua中的socket（TCP，UDP） 首先，安装lua下的socket库。我在ubuntu下安装测试的。安装完成后会有 /usr/local/lib/lua/5.1/socket/core.so 直接上例子 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:1:0","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"TCP for lua: ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:2:0","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"Server: 1 local socket = require(\"socket.core\") /*require socket module*/ 2 local tcp = socket.tcp() 3 local host = host or '127.0.0.1' 4 local port = '8800' 5 local tcpbind = tcp:bind(host,port) 6 if(tcpbind and tcpbind == 1) then 7 print('Binding to host'..host) 8 else 9 print('Binding error') 10 end 11 local e = tcp:listen(50) 12 if(e and e == 1) then 13 print('listen ok') 14 else 15 print('listen error') 16 end 17 print('waiting connect cli') 18 while 1 do 19 local client = tcp:accept() 20 if(client ~= nil) then 21 print('access success') 22 else 23 print('accept err') 24 end 25 /*等待有至少10字节*/ 26 local revbuff = client:receive(10) 27 print('revbuff:'..revbuff) 28 if(revbuff == 'hello 1111') then 29 local sendcli = client:send('hello lua cli') 30 if(sendcli) then 31 print('sendcli ok') 32 else 33 print('sendcli error') 34 end 35 else 36 print('rec error , not send msg') 37 end 38 39 end 40 tcp:close() ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:2:1","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"Client: 1 local socket = require(\"socket.core\") 2 local tcp = socket.tcp() 3 local host = host or '127.0.0.1' 4 local port = '8800' 5 local clicon = tcp:connect(host,port) 6 tcp:settimeout(4) /*阻塞4s*/ 7 if(clicon) then 8 print('connect '..host..'ok') 9 else 10 print('connect error') 11 end 12 function rec_msg() 13 --local tcprev = tcp:receive(13) 14 local tcprev = tcp:receive(13) 15 if(tcprev) then 16 print('tcprev:'..tcprev) 17 else 18 print('tcp rec err') 19 end 20 end 21 22 while 1 do 23 local tcpsend = tcp:send('hello 111111111') 24 if(tcpsend) then 25 print('tcpsend ok') 26 rec_msg() 27 --break 28 else 29 print('tcpsend err') 30 end 31 end 32 tcp:close() 打印结果： Server: Binding to host127.0.0.1 listen ok waiting connect cli access success revbuff:hello 1111 sendcli ok Client: connect 127.0.0.1ok tcpsend ok tcprev:hello lua cli tcpsend ok tcp rec err tcpsend ok tcp rec err tcpsend ok tcp rec err tcpsend ok tcp rec err . . . ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:2:2","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"UDP for lua: ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:3:0","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"Server: local socket = require(\"socket.core\") 2 local udp = socket.udp() 3 local host = host or '127.0.0.1' 4 local port = '8800' 5 udp:settimeout(10) 6 --local udpbind = udp:bind(host,port) 7 udp:setsockname(host, port) 8 print('waiting client connect') 9 while 1 do 10 local revbuff,receip,receport = udp:receivefrom() 11 if (revbuff and receip and receport) then 12 print('revbuff:'..revbuff..',receip:'..receip..',receport:'..receport) 13 local sendcli = udp:sendto('hello lua cli',receip,receport) 14 if(sendcli) then 15 print('sendcli ok') 16 else 17 print('sendcli error') 18 end 19 else 20 print('waiting client connect') 21 end 22 end 23 udp:close() ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:3:1","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":"Client: 1 local socket = require(\"socket.core\") 2 local udp = socket.udp() 3 local host = host or '127.0.0.1' 4 local port = '8800' 5 udp:settimeout(4) 6 function rec_msg() 7 local recudp = udp:receive() 8 if(recudp) then 9 print('recudp data:'..recudp) 10 else 11 print('recudp data nil') 12 end 13 end 14 while 1 do 15 udp:setpeername(host, port) 16 local udpsend = udp:send('hello 111111111') 17 if(udpsend) then 18 print('udpsend ok') 19 rec_msg() 20 break 21 else 22 print('udpsend err') 23 end 24 end 25 udp:close() 打印结果: Server: waiting client connect revbuff:hello 111111111,receip:127.0.0.1,receport:39532 sendcli ok Client: udpsend ok recudp data:hello lua cli 以上代码就是用lua完成的TCP和UDP通信，用lua脚本写的socket封装解析json数据很方便。欢迎大家尝试。 ","date":"2022-01-28","objectID":"/2022/01/lua-socket%E5%88%86%E6%9E%902/:3:2","series":null,"tags":["Socket"],"title":"Lua Socket分析2","uri":"/2022/01/lua-socket%E5%88%86%E6%9E%902/"},{"categories":null,"content":" macos下简单的socket服务器+客户端 ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:0:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"TCP客户端服务器编程模型： ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:1:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"服务器： 调用socket函数创建套接字 调用bind绑定本地IP和端口 调用listen启动监听（准备好接收客户端链接的队列） 调用accept从已连接队列中提取第一个连接。（如果没有，会阻塞。） 调用I/O函数(read/write)与客户端通讯 调用close关闭套接字。（多个套接字） ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:2:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"客户端： 调用socket创建套接字 调用connect连接服务器 调用I/O函数(read/write)与服务器通讯 调用close关闭套接字 Linux下和Mac下代码一样的，可能有头文件不太一样，用man命令进去查看即可。 功能： 客户端连到服务器，服务器打印连接的客户端IP和端口，返回给客户端当前服务器时间。 服务器加了一个信号捕获函数，ctrl+c停止服务器进程。 如果不写客户端，使用telnet 127.0.0.1 8888 依然可以收到服务器返回的时间字符串。 ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:3:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"服务器代码 time_tcp_server.c： #include \u003csys/socket.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003csignal.h\u003e #include \u003ctime.h\u003e #include \u003cstring.h\u003e #include \u003cnetdb.h\u003e #include \u003carpa/inet.h\u003e #define SERVER_PORT 8888 #define LISTEN_QUEUE_SISE 10 int socketfd; void signal_handler(int signo) { printf(\"this serveice close\\n\"); close(socketfd); exit(1); } void out_clientinfo(const struct sockaddr_in* outsockaddr) { char ipstr[16]; memset(ipstr, 0, sizeof(ipstr)); // 将地址从网络字节序转换为点分十进制 inet_ntop(AF_INET, \u0026outsockaddr-\u003esin_addr.s_addr, ipstr, sizeof(ipstr)); printf(\"Connected by %s(%d)\\n\", ipstr, ntohs(outsockaddr-\u003esin_port)); } void dosomething(int fd) { //获取系统当前时间 long t = time(0); char* times = ctime(\u0026t); size_t size = strlen(times)*sizeof(char); //将时间写回到客户端 if(write(fd, times, size) != size) { perror(\"write to client error\"); } } int main(int argc, char const *argv[]) { if (signal(SIGINT, signal_handler) == SIG_ERR) { perror(\"signal error\"); exit(1); } // 1 sokect // AF_INET ipv4 // SOCK_STREAM tcp if((socketfd = socket(AF_INET, SOCK_STREAM, 0)) \u003c 0) { perror(\"socket error\"); exit(1); } // 2 bind 绑定本地地址和端口 struct sockaddr_in serveraddr; memset(\u0026serveraddr, 0, sizeof(serveraddr)); serveraddr.sin_family = AF_INET;//ipv4 serveraddr.sin_port = htons(SERVER_PORT); //端口 serveraddr.sin_addr.s_addr = htonl(INADDR_ANY);//响应任意网卡的请求 if(bind(socketfd, (struct sockaddr*)\u0026serveraddr, sizeof(serveraddr)) \u003c 0) { perror(\"bind error\"); exit(1); } // 3 listen 启动监听 通知系统接受来自客户端的连接 准备好连接队列 if(listen(socketfd, LISTEN_QUEUE_SISE) \u003c 0) { perror(\"listen error\"); exit(1); } struct sockaddr_in clientaddr; socklen_t clientaddr_len = sizeof(clientaddr); while(1) { // 4 accept 从队列拿出第一个 // clientaddr获取客户端的地址信息，是传出参数 int clientfd = accept(socketfd, (struct sockaddr*)\u0026clientaddr, \u0026clientaddr_len); if (clientfd \u003c 0) { perror(\"accept error\"); continue; } // 5 read/write out_clientinfo(\u0026clientaddr); dosomething(clientfd); // 6 close close(clientfd); } // 6 close return 0; } ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:4:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"客户端代码time_tcp_client： #include \u003csys/socket.h\u003e #include \u003cstdlib.h\u003e #include \u003csys/types.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cunistd.h\u003e #include \u003cnetdb.h\u003e #define SERVER_PORT 8888 #define SERVER_IP 127.0.0.1 int main(int argc, char const *argv[]) { //1 创建socket int socketfd = socket(AF_INET, SOCK_STREAM, 0); if (socketfd \u003c 0) { perror(\"socket error\"); exit(1); } //2 connect struct sockaddr_in serveraddr; memset(\u0026serveraddr, 0, sizeof(serveraddr)); serveraddr.sin_family = AF_INET; serveraddr.sin_port = htons(SERVER_PORT); if(connect(socketfd, (struct sockaddr*)\u0026serveraddr, sizeof(serveraddr)) \u003c 0 ) { perror(\"connect error\"); exit(1); } //3 read write char buf[1024]; //read是阻塞函数 如果服务器没有下发消息，会一直阻塞在这里，知道收到消息。 if (read(socketfd, buf, sizeof(buf)) \u003e 0) { printf(\"%s\",buf); } //4 close close(socketfd); return 0; } 本例只是简单的处理，服务器返回客户端一个时间，然后关闭了socket。 如果要进行双向通信，服务器势必要调用read函数，而read默认阻塞，那么如果客户端不向服务器发送数据，则主线程一直阻塞，其它客户端无法连接成功。这就需要处理高并发问题。 ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:5:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"服务器高并发处理的三种方式 多进程 *https://www.cnblogs.com/lan0725/p/11634709.html* 多线程 https://www.cnblogs.com/lan0725/p/11639142.html I/O多路复用 ","date":"2022-01-28","objectID":"/2022/01/mac-socket/:6:0","series":null,"tags":["Socket"],"title":"Mac Socket","uri":"/2022/01/mac-socket/"},{"categories":null,"content":"sokit是一款非常简单易用的tcp、udp调试工具，主要适用于专业的网络管理使用，它可以轻松查看网内的数据情况，能够有效地接收、发送、转发TCP或UDP数据包。网上大多数版本是基于win下的，linux下也可以编译。 ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:0:0","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"主要特色 服务器模式 用来监听本地端口，接收外部数据包，并且可以回覆自定义数据 客户端模式 用来连接服务器，发送自定义数据包，并接收远程回覆数据 转发器模式 用来监听本地端口，将接收到的数据包发送给指定的远程服务器，也可以在转发数据流中插入自定义数据向双发发送 支持发送ascii字符串数据，以及十六进制表示的原始字节，单次发送的字符数目没有限制 收到的数据会同时以这两种形式显示 ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:1:0","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"sokit数据输入格式 发送区的编辑框内的字符会按照ascii值发送(多字节字符按照UTF8编码)，如果需要发送十六进制原始数据，请将相应数值的ascii表示放进方括号中。例如：[FF AB CD 12 12]，实际发送时会过滤掉方括号本身，以及其中的空格字符。(使用两个连续的 [[ 表示 [ 字符本身) ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:2:0","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"安装 首先安装要安装好homebrew，假如没有安装的同学请看一下 Homebrew常規使用教程 这里容我先装个逼，推广一下自己的仓库，虽然只有几个包： github地址 安装saka仓库 brew tap rangaofei/saka 然后安装软件 brew install sokit 因为要依赖qt，所以安装会稍微慢一点，安装成功后执行命令即可： sokit 启动界面： 测试socket通信界面： ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:3:0","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"特别感谢 这个工具首先感谢sinpolib,该工具是由他用qt来构建的，我不过是重新编译移植到了macos的homebrew下。 同时感谢群友空槐，是他帮我测试brew安装。 同时要感谢掘金同学步一步,是他第一个提出编译有问题的。 ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:4:0","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"相关文章 LayoutTransiton实现简单的录制按钮 cmake使用教程（九）关于安卓的交叉编译 cmake使用教程（八）macro和function cmake使用教程（七）流程和循环 ","date":"2022-01-28","objectID":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/:4:1","series":null,"tags":["Socket"],"title":"mac下的socket调试工具sokit","uri":"/2022/01/mac%E4%B8%8B%E7%9A%84socket%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7sokit/"},{"categories":null,"content":"提示消息，并且窗口置顶 # -*- coding: utf-8 -*- import tkinter as tk # 使用Tkinter前需要先导入 import time # 实例化object，建立窗口window window = tk.Tk() #给窗口的可视化起名字 window.title('标题') #设置正中央位置 screenWidth = window.winfo_screenwidth() # 获取显示区域的宽度 screenHeight = window.winfo_screenheight() # 获取显示区域的高度 width = 300 # 设定窗口宽度 height = 160 # 设定窗口高度 left = (screenWidth - width) / 2 top = (screenHeight - height) / 2 # 宽度x高度+x偏移+y偏移 # 在设定宽度和高度的基础上指定窗口相对于屏幕左上角的偏移位置 window.geometry(\"%dx%d+%d+%d\" % (width, height, left, top)) #设置窗口置顶 window.wm_attributes('-topmost',1) # 在图形界面上设定标签 l = tk.Label(window, text='翻译结束', font=(96), width=30, height=30) # 说明： bg为背景，font为字体，width为长，height为高，这里的长和高是字符的长和高，比如height=2,就是标签有2个字符这么高 # 放置标签 l.pack() # Label内容content区域放置位置，自动调节尺寸 # 放置lable的方法有：1）l.pack(); 2)l.place(); # 主窗口循环显示 window.mainloop() # 注意，loop因为是循环的意思，window.mainloop就会让window不断的刷新，如果没有mainloop,就是一个静态的window,传入进去的值就不会有循环，mainloop就相当于一个很大的while循环，有个while，每点击一次就会更新一次，所以我们必须要有循环 # 所有的窗口文件都必须有类似的mainloop函数，mainloop是窗口文件的关键的关键。 ","date":"2022-01-28","objectID":"/2022/01/python%E4%BD%BF%E7%94%A8tkinter%E7%AA%97%E5%8F%A3%E7%BD%AE%E9%A1%B6/:0:0","series":null,"tags":["yolov5"],"title":"python使用tkinter窗口置顶","uri":"/2022/01/python%E4%BD%BF%E7%94%A8tkinter%E7%AA%97%E5%8F%A3%E7%BD%AE%E9%A1%B6/"},{"categories":null,"content":"下边的是将窗口置顶后import win32gui import win32gui import win32con #获取所有窗口句柄 hwnd_title = {} def get_all_hwnd(hwnd, mouse): if (win32gui.IsWindow(hwnd) and win32gui.IsWindowEnabled(hwnd) and win32gui.IsWindowVisible(hwnd)): hwnd_title.update({hwnd: win32gui.GetWindowText(hwnd)}) win32gui.EnumWindows(get_all_hwnd, 0) for h, t in hwnd_title.items(): if t : print (h, t) #置顶窗口 print(\"置顶窗口\") hwnd = win32gui.FindWindow(None, \"学习通答题助手\") # hwnd = win32gui.FindWindow('xx.exe', None) # 窗口需要正常大小且在后台，不能最小化 win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) # 窗口需要最大化且在后台，不能最小化 # ctypes.windll.user32.ShowWindow(hwnd, 3) win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOACTIVATE | win32con.SWP_NOOWNERZORDER | win32con.SWP_SHOWWINDOW | win32con.SWP_NOSIZE) #取消置顶 #win32gui.SetWindowPos(hwnd, win32.HWND_NOTOPMOST, 0, 0, 0, 0,win32con.SWP_SHOWWINDOW|win32con.SWP_NOSIZE|win32con.SWP_NOMOVE) if __name__ == '__main__': pass 【简单版】 import win32gui import win32con #获取所有窗口句柄 hwnd = win32gui.FindWindow(None, \"学习通答题助手\") # hwnd = win32gui.FindWindow('xx.exe', None) # 窗口需要正常大小且在后台，不能最小化 win32gui.ShowWindow(hwnd, win32con.SW_SHOWNORMAL) # 窗口需要最大化且在后台，不能最小化 # ctypes.windll.user32.ShowWindow(hwnd, 3) win32gui.SetWindowPos(hwnd, win32con.HWND_TOPMOST, 0, 0, 0, 0, win32con.SWP_NOMOVE | win32con.SWP_NOACTIVATE | win32con.SWP_NOOWNERZORDER | win32con.SWP_SHOWWINDOW | win32con.SWP_NOSIZE) # 取消置顶 # win32gui.SetWindowPos(hwnd, win32con.HWND_NOTOPMOST, 0, 0, 0, 0,win32con.SWP_SHOWWINDOW|win32con.SWP_NOSIZE|win32con.SWP_NOMOVE) if __name__ == '__main__': pass ","date":"2022-01-28","objectID":"/2022/01/python%E4%BD%BF%E7%94%A8win32%E7%AA%97%E5%8F%A3%E7%BD%AE%E9%A1%B6/:0:0","series":null,"tags":["yolov5"],"title":"Python使用win32窗口置顶","uri":"/2022/01/python%E4%BD%BF%E7%94%A8win32%E7%AA%97%E5%8F%A3%E7%BD%AE%E9%A1%B6/"},{"categories":null,"content":"pytorch官网 https://pytorch.org ","date":"2022-01-28","objectID":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/:0:0","series":null,"tags":["PyTorch"],"title":"PyTorch 入门实战","uri":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"VOC数据集 http://host.robots.ox.ac.uk/pascal/VOC VOC 2005 http://host.robots.ox.ac.uk/pascal/VOC/databases.htm VOC 2006 http://host.robots.ox.ac.uk/pascal/VOC/download/voc2006 trainval.tar VOC 20071 http://host.robots.ox.ac.uk/pascal/VOC/voc2007/VOCtrainval_06-Nov-2007.tar VOC 2008 http://host.robots.ox.ac.uk/pascal/VOC/voc2008/VOCtrainval_ 14-Jul-2008.tar VOC 2009 http://host.robots.ox.ac.uk/pascal/VOC/voc2009/VOCtrainval 11-May-2009.tar VOC 2010 http://host.robots.ox.ac.uk/pascal/VOC/voc2010/OCtrainval 03-May-2010.tar VOC 2011 http://host.robots.ox.ac.uk/pascal/VOC/voc2011/OCtrainval 25-May-2011.tar VOC 2012 http://host.robots.ox.ac.uk/pascal/VOC/voc2012/VOCtrainval_11-May-2012.tar ","date":"2022-01-28","objectID":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/:1:0","series":null,"tags":["PyTorch"],"title":"PyTorch 入门实战","uri":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"Coco数据集 官网 ","date":"2022-01-28","objectID":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/:2:0","series":null,"tags":["PyTorch"],"title":"PyTorch 入门实战","uri":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"标注数据集 在线: https://www.makesense.ai/ https://cvat.org/ 本地: 精灵标注助手 http://www.jinglingbiaozhu.com 后羿采集 https://www.houyicaiji.com ","date":"2022-01-28","objectID":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/:3:0","series":null,"tags":["PyTorch"],"title":"PyTorch 入门实战","uri":"/2022/01/pytorch-%E5%85%A5%E9%97%A8%E5%AE%9E%E6%88%98/"},{"categories":null,"content":"setsockopt用法详解 在TCP连接中，recv等函数默认为阻塞模式(block)，即直到有数据到来之前函数不会返回，而我们有时则需要一种超时机制使其在一定时间后返回而不管是否有数据到来，这里我们就会用到 ","date":"2022-01-28","objectID":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/:0:0","series":null,"tags":["Socket"],"title":"setsockopt用法","uri":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/"},{"categories":null,"content":"setsockopt()函数： int setsockopt( int socket, //socket是套接字描述符 int level, //设置的选项的级别 int option_name, void* option_value, size_t ，ption_len ); 这里我们要涉及到一个结构： struct timeval { time_t tv_sec;//秒 time_t tv_usec;//微秒 }; struct timeval tv_out; tv_out.tv_sec = 1; tv_out.tv_usec = 0; 填充这个结构后，我们就可以以如下的方式调用这个函数： setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, \u0026tv_out, sizeof(tv_out)); 这样我们就设定了recv()函数的超时机制，当超过tv_out设定的时间而没有数据到来时recv()就会返回0值。 ","date":"2022-01-28","objectID":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/:1:0","series":null,"tags":["Socket"],"title":"setsockopt用法","uri":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/"},{"categories":null,"content":"多路复用机制 多路复用机制，也就是同时监听多个套接字连接。 int select( int n, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout ); 这里涉及到了fd_set结构： typedef struct fd_set { u_int fd_count; int fd_array[FD_SETSIZE]; } fd_count为fd_set结构中包含的套接字个数， fd_array唯一个int 数组，包含了我们要监听的套接字。 首先我们需要使用FD_SET将我们要监听的套接字添加到fd_set结构中： fd_set readfd; FD_SET(fd, \u0026readfd); 然后我们这样调用select函数： select(max_fd + 1, \u0026readfd, NULL, NULL, NULL); FD_ISSET(fd, \u0026readfd); 其中max_fd为我们要监听的套接字中值最大的一个，同时在调用select是要将其加1，readfd即为我们监听的要进行读操作的套接字连接，第三个参数是我们监听的要进行写操作的套接字连接，第四个参数用于异常，而最后一个参数可以用来设定超时，这里同样使用了struct timeval结构，可以实现与前面介绍的同样的效果。这里如果连接进来的话select即返回一个大于零的值，然后我们调用FD_ISSET宏来检测具体是那一个套接字有数据进来(FD_ISSET返回非零值)。 最后介绍的是另一种实现非阻塞的方法，这种方法在有些应用中会起到一定作用，尤其是在select()函数监听的套接字个数超过1024个时(因为fd_set结构在大部分UNIX系统中都对其可以监听的套接字个数作了1024的限制，如果要突破这个限制，必须修改头文件并重新编译内核)，我们就不能使用select多路复用机制。 拿recv()函数来说，我们可以这样进行调用： recv(fd, buf, sizeof(buf), MSG_DONTWAIT); 注意到我们这里采用了MSG_DONTWAIT标志，它的作用是告诉recv()函数如果有数据到来的话就接受全部数据并立刻返回，没有数据的话也是立刻返回，而不进行任何的等待。采用这个机制就可以在多于1024个套接字连接时使用for()循环对全部的连接进行监听。 ","date":"2022-01-28","objectID":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/:2:0","series":null,"tags":["Socket"],"title":"setsockopt用法","uri":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/"},{"categories":null,"content":"各种情况 closesocket（一般不会立即关闭而经历TIME_WAIT的过程）后想继续重用该socket： BOOL bReuseaddr=TRUE; setsockopt(s,SOL_SOCKET ,SO_REUSEADDR,(const char*)\u0026bReuseaddr,sizeof(BOOL)); 如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历 TIME_WAIT的过程： BOOL bDontLinger = FALSE; setsockopt(s,SOL_SOCKET,SO_DONTLINGER,(const char*)\u0026bDontLinger,sizeof(BOOL)); 在send(),recv()过程中有时由于网络状况等原因，发收不能预期进行,而设置收发时限： int nNetTimeout=1000;//1秒 //发送时限 setsockopt(socket，SOL_S0CKET,SO_SNDTIMEO，(char *)\u0026nNetTimeout,sizeof(int)); //接收时限 setsockopt(socket，SOL_S0CKET,SO_RCVTIMEO，(char *)\u0026nNetTimeout,sizeof(int)); 在send()的时候，返回的是实际发送出去的字节(同步)或发送到socket缓冲区的字节 (异步);系统默认的状态发送和接收一次为8688字节(约为8.5K)；在实际的过程中发送数据 和接收数据量比较大，可以设置socket缓冲区，而避免了send(),recv()不断的循环收发： // 接收缓冲区 int nRecvBuf=32*1024;//设置为32K setsockopt(s,SOL_SOCKET,SO_RCVBUF,(const char*)\u0026nRecvBuf,sizeof(int)); //发送缓冲区 int nSendBuf=32*1024;//设置为32K setsockopt(s,SOL_SOCKET,SO_SNDBUF,(const char*)\u0026nSendBuf,sizeof(int)); 如果在发送数据的时，希望不经历由系统缓冲区到socket缓冲区的拷贝而影响 程序的性能： int nZero=0; setsockopt(socket，SOL_S0CKET,SO_SNDBUF，(char *)\u0026nZero,sizeof(nZero)); 同上在recv()完成上述功能(默认情况是将socket缓冲区的内容拷贝到系统缓冲区)： int nZero=0; setsockopt(socket，SOL_S0CKET,SO_RCVBUF，(char *)\u0026nZero,sizeof(int)); 一般在发送UDP数据报的时候，希望该socket发送的数据具有广播特性： BOOL bBroadcast=TRUE; setsockopt(s,SOL_SOCKET,SO_BROADCAST,(const char*)\u0026bBroadcast,sizeof(BOOL)); 在client连接服务器过程中，如果处于非阻塞模式下的socket在connect()的过程中可 以设置connect()延时,直到accpet()被呼叫(本函数设置只有在非阻塞的过程中有显著的 作用，在阻塞的函数调用中作用不大) BOOL bConditionalAccept=TRUE; setsockopt(s,SOL_SOCKET,SO_CONDITIONAL_ACCEPT,(const char*)\u0026bConditionalAccept,sizeof(BOOL)); 如果在发送数据的过程中(send()没有完成，还有数据没发送)而调用了closesocket(),以前我们一般采取的措施是\"从容关闭\"shutdown(s,SD_BOTH),但是数据是肯定丢失了，如何设置让程序满足具体 应用的要求(即让没发完的数据发送出去后在关闭socket)？ struct linger { u_short l_onoff; u_short l_linger; }; linger m_sLinger; m_sLinger.l_onoff=1;//(在closesocket()调用,但是还有数据没发送完毕的时候容许逗留) // 如果m_sLinger.l_onoff=0;则功能和2.)作用相同; m_sLinger.l_linger=5;//(容许逗留的时间为5秒) setsockopt(s,SOL_SOCKET,SO_LINGER,(const char*)\u0026m_sLinger,sizeof(linger)); SO_LINGER 此选项指定函数close对面向连接的协议如何操作（如TCP）。缺省close操作是立即返回，如果有数据残留在套接口缓冲区中则系统将试着将这些数据 发送给对方。 SO_LINGER选项用来改变此缺省设置。使用如下结构： struct linger { int l_onoff; int l_linger; }; ​ 有下列三种情况： l_onoff为0，则该选项关闭，l_linger的值被忽略，等于缺省情况，close立即返回； l_onoff为非0，l_linger为0，则套接口关闭时TCP夭折连接，TCP将丢弃保留在套接口发送缓冲区中的任何数据并发送一个RST 给对方，而不是通常的四分组终止序列，这避免了TIME_WAIT状态； l_onoff 为非0，l_linger为非0，当套接口关闭时内核将拖延一段时间（由l_linger决定）。如果套接口缓冲区中仍残留数据，进程将处于睡眠状态，直 到（a）所有数据发送完且被对方确认，之后进行正常的终止序列（描述字访问计数为0）或（b）延迟时间到。此种情况下，应用程序检查close的返回值是 非常重要的，如果在数据发送完并被确认前时间到，close将返回EWOULDBLOCK错误且套接口发送缓冲区中的任何数据都丢失。close的成功返 回仅告诉我们发送的数据（和FIN）已由对方TCP确认，它并不能告诉我们对方应用进程是否已读了数据。如果套接口设为非阻塞的，它将不等待close完 成。 l_linger的单位依赖于实现，4.4BSD假设其单位是时钟滴答（百分之一秒），但Posix.1g规定单位为秒。 设置套接口的选项。 #include \u003cwinsock.h\u003e int PASCAL FAR setsockopt( SOCKET s, int level, int optname, const char FAR* optval, int optlen); s：标识一个套接口的描述字。 level：选项定义的层次；目前仅支持SOL_SOCKET和IPPROTO_TCP层次。 optname：需设置的选项。 optval：指针，指向存放选项值的缓冲区。 optlen：optval缓冲区的长度。 注释： setsockopt()函数用于任意类型、任意状态套接口的设置选项值。尽管在不同协议层上存在选项，但本函数仅定义了最高的“套接口”层次上的选项。选项影响套接口的操作，诸如加急数据是否在普通数据流中接收，广播数据是否可以从套接口发送等等。 有两种套接口的选项：一种是布尔型选项，允许或禁止一种特性；另一种是整形或结构选项。允许一个布尔型选项，则将optval指向非零整形数；禁止一个选项optval指向一个等于零的整形数。对于布尔型选项，optlen应等于sizeof(int)；对其他选项，optval指向包含所需选项的整形数或结构，而optlen则为整形数或结构的长度。SO_LINGER选项用于控制下述情况的行动：套接口上有排队的待发送数据，且closesocket()调用已执行。参见closesocket()函数中关于SO_LINGER选项对closesocket()语义的影响。应用程序通过创建一个linger结构来设置相应的操作特性： struct linger { int l_onoff; int l_linger; }; 为了允许SO_LINGER，应用程序应将l_onoff设为非零，将l_linger设为零或需要的超时值（以秒为单位），然后调用setsockopt()。为了允许SO_DONTLINGER（亦即禁止SO_LINGER），l_onoff应设为零，然后调用setsockopt()。 缺省条件下，一个套接口不能与一个已在使用中的本地地址捆绑（参见bind()）。但有时会需要“重用”地址。因为每一个连接都由本地地址和远端地址的组合唯一确定，所以只要远端地址不同，两个套接口与一个地址捆绑并无大碍。为了通知WINDOWS套接口实现不要因为一个地址已被一个套接口使用就不让它与另一个套接口捆绑，应用程序可在bind()调用前先设置SO_REUSEADDR选项。请注意仅在bind()调用时该选项才被解释；故此无需（但也无害）将一个不会共用地址的套接口设置该选项，或者在bind()对这个或其他套接口无影响情况下设置或清除这一选项。 一个应用程序可以通过打开SO_KEEPALIVE选项，使得WINDOWS套接口实现在TCP连接情况下允许使用“保持活动”包。一个WINDOWS套接口实现并不是必需支持“保持活动”，但是如果支持的话，具体的语义将与实现有关，应遵守RFC1122“Internet主机要求－通讯层”中第4.2.3.6节的规范。如果有关连接由于“保持活动”而失效，则进行中的任何对该套接口的调用都将以WSAENETRESET错误返回，后续","date":"2022-01-28","objectID":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/:3:0","series":null,"tags":["Socket"],"title":"setsockopt用法","uri":"/2022/01/setsockopt%E7%94%A8%E6%B3%95/"},{"categories":null,"content":"下载所需要的库 LibTorch OpenCV ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:1","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"配置环境变量 LibTorch 配置到 lib 目录就好，OpenCV根据自己选择使用的 vc14 或 vc15 配置到其下面的 bin 目录 ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:2","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"用VS新建一个空项目 ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:3","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"配置 OpenCV 右键项目选择属性 \\2. 更改配置为所有配置并选择 VC++ 目录中的包含目录 \\3. 添加头文件到包含目录 (刚才下载的OpenCV目录) opencv/build/include \\4. 添加库目录并保存 \\5. 添加 OpenCV 库文件名字到 链接器-输入-附加依赖项，其中添加的名字和刚才配置的库目录中的lib文件名相同 \\6. 在源文件添加一个文件测试OpenCV \\7. 添加如下代码进行测试，更改运行环境为 x64 点击运行 #include \u003copencv2/opencv.hpp\u003e int main() { cv::Mat img = cv::imread(\"图片路径\"); cv::imshow(\"\", img); cv::waitKey(0); return 0; } ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:4","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"配置 LibTorch 在属性-VC++目录-包含目录中添加 LibTorch 头文件 \\2. 在属性-VC++目录-库目录中添加 LibTorch 的库目录 \\3. 在属性-链接器-输入-附加依赖项中添加LibTorch的依赖 c10.lib torch.lib torch_cpu.lib torch_cuda.lib \\4. 添加测试代码测试 #include \u003ctorch/torch.h\u003e #include \u003ciostream\u003e int main() { torch::Tensor data = torch::rand({ 3, 3 }); std::cout \u003c\u003c data \u003c\u003c std::endl; std::cout \u003c\u003c torch::cuda::is_available() \u003c\u003c std::endl; return 0; } 我机器上面是有 cuda 的但是这里显示没有 cuda，下面进行 cuda 配置可能有些版本不同 \\5. 配置支持 cuda 在属性-链接器-命令行中添加如下字符串 # 下面是 cuda10 的 /INCLUDE:?warp_size@cuda@at@@YAHXZ # cuda11 可以尝试下面的 /INCLUDE:?searchsorted_cuda@native@at@@YA?AVTensor@2@AEBV32@0_N1@Z 测试 ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:5","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"可能出现问题的解决方案 没有配置环境变量 属性-调试-环境中添加环境变量（换成自己的地址） PATH=\\path\\to\\libtorch\\lib;\\path\\to\\opencv\\build\\x64\\vc15\\bin;%PATH%; ","date":"2022-01-28","objectID":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/:0:6","series":null,"tags":["yolov5"],"title":"VS2019 配置 LibTorch 和 OpenCV","uri":"/2022/01/vs2019-%E9%85%8D%E7%BD%AE-libtorch-%E5%92%8C-opencv/"},{"categories":null,"content":"作者csdn ","date":"2022-01-28","objectID":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/:0:0","series":null,"tags":["yolov5"],"title":"win10 使用TensorRT部署 yolov5-v4.0","uri":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/"},{"categories":null,"content":"win10 使用TensorRT部署 yolov5-v4.0（C++） ","date":"2022-01-28","objectID":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/:1:0","series":null,"tags":["yolov5"],"title":"win10 使用TensorRT部署 yolov5-v4.0","uri":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/"},{"categories":null,"content":"一、环境及文件准备 安装 CUDA+cudnn+TensorRT 【查看上一篇文章】 默认安装Anaconda并安装了pytorch开发环境 默认安装了 vs2019 + opencv + cmake 下载yolov5源码：https://github.com/ultralytics/yolov5/tags 下载yolov5权重：https://github.com/ultralytics/yolov5/releases 下载dirent.h：https://github.com/tronkko/dirent/blob/master/include/dirent.h 或者 点击下载 下载tensorrtx：https://github.com/wang-xinyu/tensorrtx/tags （与自己训练的yolov5-xx版本一致） ","date":"2022-01-28","objectID":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/:1:1","series":null,"tags":["yolov5"],"title":"win10 使用TensorRT部署 yolov5-v4.0","uri":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/"},{"categories":null,"content":"二、编译 yolov5s.wts生成：将tensorrtx源码中的gen_wts.py复制到yolov5源码中并运行，生成.wts模型。 将dirent.h放置在工程目录中（随意放置） 修改CMakeLists.txt #1-10即可，参数详情查看 cmake_minimum_required(VERSION 2.8) #========================================================= project(yolov5) #1 工程名 set(OpenCV_DIR \"E:\\\\opencv3\\\\opencv\\\\build\") #2 opencv目录 set(OpenCV_INCLUDE_DIRS ${OpenCV_DIR}\\\\include) #3 set(OpenCV_LIB_DIRS ${OpenCV_DIR}\\\\x64\\\\vc15\\\\lib) #4 set(OpenCV_Debug_LIBS \"opencv_world3412d.lib\") #5 set(OpenCV_Release_LIBS \"opencv_world3412.lib\") #6 set(TRT_DIR \"E:\\\\Downloads\\\\TensorRT-7.2.1.6.Windows10.x86_64.cuda-11.0.cudnn8.0\\\\TensorRT-7.2.1.6\") #7 set(TRT_INCLUDE_DIRS ${TRT_DIR}\\\\include) #8 set(TRT_LIB_DIRS ${TRT_DIR}\\\\lib) #9 set(Dirent_INCLUDE_DIRS \"F:\\\\yolov5trt\") #10 #========================================================= add_definitions(-std=c++11) option(CUDA_USE_STATIC_CUDA_RUNTIME OFF) set(CMAKE_CXX_STANDARD 11) set(CMAKE_BUILD_TYPE Debug) set(THREADS_PREFER_PTHREAD_FLAG ON) find_package(Threads) # setup CUDA find_package(CUDA REQUIRED) message(STATUS \" libraries: ${CUDA_LIBRARIES}\") message(STATUS \" include path: ${CUDA_INCLUDE_DIRS}\") include_directories(${CUDA_INCLUDE_DIRS}) #### enable_language(CUDA) # add this line, then no need to setup cuda path in vs #### include_directories(${PROJECT_SOURCE_DIR}/include) #11 include_directories(${TRT_INCLUDE_DIRS}) #12 link_directories(${TRT_LIB_DIRS}) #13 include_directories(${OpenCV_INCLUDE_DIRS}) #14 link_directories(${OpenCV_LIB_DIRS}) #15 include_directories(${Dirent_INCLUDE_DIRS}) #16 # -D_MWAITXINTRIN_H_INCLUDED for solving error: identifier \"__builtin_ia32_mwaitx\" is undefined set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11 -Wall -Ofast -D_MWAITXINTRIN_H_INCLUDED\") # setup opencv find_package(OpenCV QUIET NO_MODULE NO_DEFAULT_PATH NO_CMAKE_PATH NO_CMAKE_ENVIRONMENT_PATH NO_SYSTEM_ENVIRONMENT_PATH NO_CMAKE_PACKAGE_REGISTRY NO_CMAKE_BUILDS_PATH NO_CMAKE_SYSTEM_PATH NO_CMAKE_SYSTEM_PACKAGE_REGISTRY ) message(STATUS \"OpenCV library status:\") message(STATUS \" version: ${OpenCV_VERSION}\") message(STATUS \" lib path: ${OpenCV_LIB_DIRS}\") message(STATUS \" Debug libraries: ${OpenCV_Debug_LIBS}\") message(STATUS \" Release libraries: ${OpenCV_Release_LIBS}\") message(STATUS \" include path: ${OpenCV_INCLUDE_DIRS}\") add_executable(yolov5 ${PROJECT_SOURCE_DIR}/yolov5.cpp ${PROJECT_SOURCE_DIR}/common.hpp ${PROJECT_SOURCE_DIR}/yololayer.cu ${PROJECT_SOURCE_DIR}/yololayer.h) #17 target_link_libraries(yolov5 \"nvinfer\" \"nvinfer_plugin\") #18 target_link_libraries(yolov5 debug ${OpenCV_Debug_LIBS}) #19 target_link_libraries(yolov5 optimized ${OpenCV_Release_LIBS}) #20 target_link_libraries(yolov5 ${CUDA_LIBRARIES}) #21 target_link_libraries(yolov5 Threads::Threads) 点击Configure，generate，Open Project 依次编译Debug-x64, Release-x64 ","date":"2022-01-28","objectID":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/:1:2","series":null,"tags":["yolov5"],"title":"win10 使用TensorRT部署 yolov5-v4.0","uri":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/"},{"categories":null,"content":"三、测试 打开终端依次执行：（将权重文件复制到生成的目录下执行） yolov5.exe -s yolov5s.wts yolov5.engine s yolov5.exe -d ../../model/yolov5s.engine ../../test_tmp ","date":"2022-01-28","objectID":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/:1:3","series":null,"tags":["yolov5"],"title":"win10 使用TensorRT部署 yolov5-v4.0","uri":"/2022/01/win10-%E4%BD%BF%E7%94%A8tensorrt%E9%83%A8%E7%BD%B2-yolov5-v4.0/"},{"categories":null,"content":"原文 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"一、简介 Yolov5是基于开源的python学习库Pytorch来做的，如果想要在C++环境下来运行yolov5做目标检测，那么就需要转换成新的框架，其中就包括libtorch、tensorRT ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"二、环境 系统：Windows10 Yolov5：python3.8 + pytorch1.7.0 + cuda11.1 + cudnn11.1 + opencv4.2【默认yolov5运行环境已经安装好了，可参考：windows下Pytorch安装教程】 Libtorch：vs2017 + libtorch-1.7.0-cuda11.0-release + opencv3.4.7 tensorRT：vs2017 + TensorRT-7.2.3.4 + opencv3.4.7 + cmake3.16.4 + dirent ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"三、libtorch ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1、部署 首先说一下使用libtorch，github上能够找到一些用libtorch版的yolov5，附上我使用的程序链接https://github.com/yasenh/libtorch-yolov5 ；真实使用时，需要根据自己的需求去修改程序（注意：配置环境可能也是个头疼的问题）。 具体使用步骤及总结，参考： libTorch环境配置及使用 yolov5-libtorch使用总结 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:4:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2、存在问题 使用官方模型yolov5s模型，检测每帧（分辨率1920*1080）的耗时较长：127ms。 这个检测耗时比pytorch版的yolov5慢了10倍多，pytorch版的yolov5检测每帧耗时11ms左右。 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:5:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"四、tensorRT ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:6:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"1、安装部署vs2017 + opencv3.4.7 + cmake3.16.4 + dirent 这些环境在网上有很多教程，这里就不再多介绍了。 这里说一下dirent，在github官方地址https://github.com/tronkko/dirent 下载下来，解压后备用。 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:7:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"2、安装部署TensorRT （1）从官网下载tensorRT 官网地址：https://developer.nvidia.com/nvidia-tensorrt-download 会需要先登陆才能下载。 注意：下载与cuda版本一致的tensorRT，这里我下载的包名是 （2）解压部署tensorRT 解压后把tensorRT添加到环境变量Path中：E:\\3rd-Part\\TensorRT-7.2.3.4\\lib （3）安装graphsurgeon和uff 在如下的两个目录中找到graphsurgeon和uff 通过anaconda prompt安装它们，安装指令是： pip install graphsurgeon-0.4.5-py2.py3-none-any.whl pip install uff-0.6.9-py2.py3-none-any.whl （4）将TensorRT-7.2.3.4\\include目录中所有的文件，拷贝到cuda的include目录中，我的： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.1\\include （5）将TensorRT-7.2.3.4\\lib目录中所有的文件，拷贝到cuda的lib/64目录中，我的： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.1\\lib\\x64 （6）将TensorRT-7.2.3.4\\lib目录中所有的文件，拷贝到cuda的bin目录中，我的： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.1\\bin （7）使用vs2017打开tensorRT的测试示例TensorRT-7.2.3.4\\samples\\sampleMNIST 示例项目中的环境配置，都是已经配置好的，也会自动识别系统环境变量中的cuda环境；直接右击项目生成即可。 （8）通过anaconda prompt进入TensorRT-7.2.3.4\\data\\mnist目录，运行download_pgms.py文件，下载测试数据（我测试过很多次，都失败了，我已经下载好了一份，点击下载）；下载指令如下： python download_pgms.py （9）运行sampleMNIST项目，如果看到如下画面，说明tensorRT安装部署成功： （10）参考链接： https://www.freesion.com/article/7394364554/ https://blog.csdn.net/lishiyu93/article/details/115526772?spm=1001.2014.3001.5501 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:8:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"3、下载相同版本的yolov5程序和tensorRT程序 一定要下载相同版本的yolov5程序和tensorRT程序。这里用的是yolov5 2.0和tensorRT 2.0。 Git下载指令： git clone -b v3.0 https://github.com/ultralytics/yolov5.git git clone -b yolov5-v3.0 https://github.com/wang-xinyu/tensorrtx.git 如果不想通过git来下载，可以直接去github官网下载： Yolov5的github地址：https://github.com/ultralytics/yolov5 tensorRT程序的github地址：https://github.com/wang-xinyu/tensorrtx 【注：感谢wang-xinyu】 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:9:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"4、.pt模型转换为.wts模型 （1）将tensorrtx/yolov5目录中的gen_wts.py拷贝到yolov5目录下； （2）修改gen_wts.py文件，如下图，在这个文件中默认了.pt模型的路径，以及yolov5模型的类型（yolov5s类型），可根据需要，自行修改； （3）通过anaconda prompt进入yolov5目录，执行“python gen_wts.py”，即可生成.wts文件。 （4）注意：每个版本的tensorRT中gen_wts.py程序可能会不同，比如tensorRT 4.0的gen_wts.py程序如下： 要想生成yolov5s.wts文件，只需执行“python gen_wts.py yolov5s.pt”即可。 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:10:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"5、编译tensorRT程序中yolov5的vs工程 （1）修改tensorrtx\\yolov5\\CMakeLists.txt文件 注：我这有一些已经编译成功的CMakeLists.txt文件，可以直接使用；点击下载 官方给的是基于linux系统的配置，这里需要修改一下： #1：工程名称 #2：opencv路径 #3：tensorRT路径 #4：dirent路径 #5：工程包含目录 #6：tensorRT包含目录 #7：dirent包含目录 #8：opencv包含目录 #9：tensorRT库目录 #10：添加工程文件 #11：添加tensorRT附加依赖项 #12：opencv库目录 #13：cuda附加依赖项 这里参考博文：https://blog.csdn.net/lishiyu93/article/details/115861265 这篇博文中介绍这块的时候，添加了很多项【可根据需要自选添加】： （2）用cmake编译工程 在tensorrtx\\yolov5中创建目录build，用于存放编译生成的工程文件。先点击Configure，在点击Generate，生成成功即可。 （3）编译工程 打开tensorrtx\\yolov5\\build目录下生成的vs工程，右击工程重新生成即可 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:11:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"6、运行tensorRT中yolov5 注：我这里有一个已经编译好的项目示例，点击下载 （1）将生成的yolov5s.wts（或者自定义的.wts模型）文件拷贝到tensorrtx\\yolov5目录； （2）修改类别数参数 默认CLASS_NUM是80，coco数据集中的类别总数,如果用的是yolov5官方的模型，那这里就不需要修改了。如果.wts模型文件是自定义的模型文件【注意：自定义的模型必须是在对应yolov5版本（这里是yolov5 2.0版本）中训练得到的】，可将CLASS_NUM设置成自己模型中的类别总数。 （3）右击项目属性 -\u003e 配置属性 -\u003e 调试 -\u003e 命令参数中输入生成.engine文件的指令： -s yolov5s.wts yolov5s.engine s 运行项目，即可生成yolov5s.engine。注意：生成.engine文件的时间较长，需要耐心等待； 其中 -s表示将.wts文件成功.engine文件； 注意图中的engine_name，初始化的参数STR2(NET)宏定义，默认是s，可自行根据模型类型修改； engine_name名称默认是yolov5s.engine，可根据需要自定义修改。 创建engine文件的方法共四个，分别是s模型、m模型、l模型、x模型。 以s模型为例： 函数中默认了.wts的名称和路径。如果是自己训练的模型，就自己修改成自己模型的名称。 （4）右击项目属性 -\u003e 配置属性 -\u003e 调试 -\u003e 命令参数中输入运行检测的指令： -d yolov5s.engine ./images 此指令的意思是：利用yolov5s.engine检测./images目录中所有的图像； 检测结果如下： （5）如果同时使用多个模型检测时，可以创建全局的类别数量参数g_nCLASS_NUM，而CLASS_NUM在检测时就作废不用了（但是还会用于“创建.engine文件”）。【注意：新版本中，CLASS_NUM只用于wts转换为engine文件，而不用于检测，就是说检测时不依赖任何类别数量参数】 注意：模型检测时都需要修改g_nCLASS_NUM为模型的类别数量；检测时，需要在对应.engine文件加载之前设置g_nCLASS_NUM。 （6）参考博文 https://blog.csdn.net/lishiyu93/article/details/115861265 https://blog.csdn.net/weixin_41552975/article/details/114398669 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:12:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"7、问题汇总 （1）.wts生成.engine文件时，当CLASS_NUM参数值与.wts模型的类别数不相同时，会出现如下错误： “Assertion failed: engine != nullptr” （2）当生成.pt模型的yolov5版本 与 tensorRT程序版本不一致，会出现如下问题： “Parameter check failed at: Network.cpp::nvinfer1::Network::addScale::484, condition: shift.count \u003e 0 ? (shift.values != nullptr) : (shift.values == nullptr)” ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:13:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"8、注意事项 （1）在不同的硬件环境下，引擎文件（.engine）需要重新生成才能使用，wts文件是可以通用的。 举例说明： 我在显卡RTX3070的主机中生成的引擎文件（.engine），放在相同环境下（cuda版本、tensorRT版本、opencv版本等等）的显卡RTX1060的主机上运行，就会出现如下错误： 在显卡RTX1060的主机上用wts文件重新生成引擎文件（.engine），再次调用引擎文件检测，即可正常。 ","date":"2022-01-28","objectID":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:14:0","series":null,"tags":["yolov5"],"title":"Windows下TensorRT-yolov5-使用总结","uri":"/2022/01/windows%E4%B8%8Btensorrt-yolov5-%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"yolov5-libtorch使用总结 Yolov5 libtorch检测版本链接：https://github.com/yasenh/libtorch-yolov5 一、环境 原作者的运行环境是： 而我用的环境：win10 + vs2017 + libTorch1.7.0 + cuda11.1 + opencv3.4.7 正式使用之前，需要将vs2017、libTorch1.7.0、cuda11.1、opencv3.4.7全部安装配置好。 二、配置 1、将libtorch-yolov5-master.zip下载下来解压； 2、用vs2017创建空项目libtorch-yolov5-master，然后将刚刚解压的目录中“ cxxopts.hpp、detector.cpp、detector.h、mian.cpp、utils.h、images目录、weight目录”拷贝到libtorch-yolov5-master根目录； 3、对项目配置opencv环境； 4、对项目配置libtorch环境； （1）包含目录 D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\include D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\include[torch](https://so.csdn.net/so/search?q=torch\u0026spm=1001.2101.3001.7020)\\csrc\\api\\include D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\include\\torch\\csrc\\api\\include\\torch C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.1\\include （2）库目录 D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\lib （3）附加依赖项 asmjit.lib c10.lib c10_cuda.lib c10d.lib caffe2_detectron_ops_gpu.lib caffe2_module_test_dynamic.lib caffe2_nvrtc.lib clog.lib cpuinfo.lib dnnl.lib fbgemm.lib gloo.lib gloo_cuda.lib libprotobuf.lib libprotobuf-lite.lib libprotoc.lib mkldnn.lib torch.lib torch_cpu.lib torch_cuda.lib 5、C/C++语言符合模式，调成“否” 在配置属性–\u003e C/C++ –\u003e 语言 –\u003e 符合模式 选为“否”，即可编译通过； 否则会报错“E1866：特性不适用于任何实体”等等，导致无法编译成功。 三、生成pt模型文件 1、前提 （1）下载pytorch版本的yolov5代码，地址：https://github.com/ultralytics/yolov5； （2）配置好yolov5的环境（anaconda+pytorch1.7.0+cuda11.1+python3.8），将yolov5的train.y和detect.py运行起来（可能需要安装opencv-python等等许多依赖包）； ****注意：****保持pytorch版yolov5的pytorch、cuda版本 与 libtorch版yolov5的libtorch、cuda版本相同。 2、生成模型文件 （1）打开models目录下的export.py文件； （2）程序中默认加载的是yolov5s.pt模型，因为这个模型速度最快，比较轻巧；如果要修改成其他模型，可以手动修改； （3）将yolov5s.pt文件拷贝到models目录下，与export.py文件同级目录；不然运行export.py时会加载不到yolov5s.pt文件; （4）设置model.model[-1].export = False； 默认是True，需要修改为False；不然最终生成的yolov5s.torchscript.pt在libtorch中调用检测时会出现异常中断； （5）安装onnx、coremltools依赖库 通过Anaconda Prompt(Anaconda3)进入yolov5的环境下（通过指令 conda activate 环境名称来激活环境），分别输入以下两个命令来下载安装onnx、coremltools依赖库： pip install -i https://pypi.douban.com/simple onnx pip install -i https://pypi.douban.com/simple coremltools （6）运行export.py，然后就可以在models目录下看到生成yolov5s.torchscript.pt、yolov5s.onnx、yolov5s.mlmodel这三个文件（我的在生成yolov5s.mlmodel时报错了，暂时没去解决；因为最终需要的是yolov5s.torchscript.pt）；相关参考链接 （7）yolov5s.torchscript.pt就是我们需要在libtorch中使用的模型文件； 四、修改libtorch-yolov5-master程序 1、将yolov5s.torchscript.pt拷贝到libtorch-yolov5-master根目录下； 【****注意：****这里加载的模型不是yolov5s.pt模型文件，也不是通过训练得到的best.pt或last.pt模型文件；而是这些模型文件，通过export.py导出的用途libtorch使用的torchscript.pt模型文件】 2、修改参数 在main函数中，将模型参数weights的默认值设置为“yolov5s.torchscript.pt”； 将图像源参数source的默认值设置为“./images/bus.jpg”； 如果想要显示查看检测结果图像，就把view-img参数的默认值设置为true。 3、运行程序，就可以看到运行结果了 *我使用的是默认cpu运行检测，如果想要使用gpu运行检测，则按照原作者的介绍，修改export.py文件，即可生成使用gpu检测的模型文件：* *然后在libtorch版检测程序的main函数中，把gpu参数的默认值修改为true* *最关键的一点，不要忘记使用cmake重编译一遍程序，不然调用不起来cuda。* ****五、****问题汇总 1、无法打开源文件 “cuda.h” 一般出现这个问题，就是因为没有在项目属性的包含目录中添加对应的头文件目录，在libtorch的环境目录中搜索\"cuda.h\"，找到对应的目录添加到项目包含目录中： D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\include\\torch\\csrc\\api\\include\\torch 2、无法打开源文件 ”torch/torch.h” 项目包含目录中添加如下目录： D:\\3rd-Part\\libtorch-1.7.0-cuda11.0-release\\include\\torch\\csrc\\api\\include 3、无法打开源文件 “cuda_runtime.h” 在libtorch的环境目录中搜索\"cuda_runtime.h\"，没有搜索到这个文件，于是查询了下资料知道这些文件是在cuda环境目录下，于是在cuda环境目录下果然搜索到了这些文件，找到对应目录，包含在项目的包含目录中： C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.1\\include 4、E1866：特性不适用于任何实体 在libtorch-1.7.0-cuda11.0-release\\include\\c10\\util\\ArrayRef.h 文件中， 278行C10_DEFINE_DEPRECATED_USING 报错“E1866：特性不适用于任何实体” 解决方法：在配置属性–\u003e C/C++ –\u003e 语言 –\u003e 符合模式 选为“否”，即可编译通过。 5、error ：c2872 std 不明确的符号 解决方法：在配置属性–\u003e C/C++ –\u003e 语言 –\u003e 符合模式 选为“否”，即可编译通过。 6、执行到“auto detections = output.toTuple()-\u003eelements()[0].toTensor();”时异常中断 运行程序后，在detector.cpp文件的Run函数中，执行到代码 “auto detections = output.toTuple()-\u003eelements()[0].toTensor();”时发生异常中断，也不没有异常信息弹出； 经查询，是因为在第三步骤生成pt模型文件时，没有在export.py文件中修改代码“model.model[-1].export = False”导致的；修改代码后，重新导出生成的模型文件；使用新的torchscript.pt模型文件，运行libtorch版检测程序就不会再异常中断了。 另附其他博客中的问题汇总参考链接：使用C++版Pytorch（libTorch）的问题汇总 六、最后 1、找到了另一个人在github上发布了yolov5的libtorch版本，但是目前还没有尝试；这里先把原","date":"2022-01-28","objectID":"/2022/01/yolov5-libtorch%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["yolov5"],"title":"yolov5-libtorch使用总结","uri":"/2022/01/yolov5-libtorch%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":null,"content":"用Pycharm训练yolov5模型过程中踩的坑及解决方法（自用） 稳如poi ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:1:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"首先要确定环境及各种modules版本要一一对应。 比如我的环境是python3.8 pytorch1.8 cuda11.1 openCV4.5.4等等 许多问题都是因为版本不对应造成的。 下面开始记录一下遇到的问题以及最终解决办法。 （Win10，Anaconda，Pytorch，Pycharm） ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:2:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"1.pip install -r requirements.txt安装环境失败 很多时候是因为网络原因，建议更换清华源。 pip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple *pip安装modules因为网络原因失败也可以尝试在后面加： -i https://pypi.tuna.tsinghua.edu.cn/simple 解决 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:3:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"2.Git安装失败：Cannot Run Git https://git-scm.com/download/win 下载客户端安装 Pycharm的file-settings-version control-git里设置git.exe位置 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:4:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"3.一切No moudle named ‘xxx’解决方法 几种方法。 A.尝试pip install xxx 或 pip install xxx -i https://pypi.tuna.tsinghua.edu.cn/simple，如果不行： B.Pycharm的Interpreter settings里开Python Interpreter，点+号搜索名字，然后Install Package 如果不行： C. 1.https://www.lfd.uci.edu/~gohlke/pythonlibs/ ctrl+f搜索xxx的名字下载对应的whl文件（版本一定要对） 2.放入创建好的环境packages文件夹中，打开anaconda prompt，conda activate环境然后pip安装。 **例：**如果要下载win10 64位下python3.8的opencv 比如我的环境名叫pytorch1.8 1.搜索到对应版本并下载，放到你的Anaconda\\env中需要安装的环境名lib\\site-packages文件夹下 2.打开Anaconda Prompt conda activate 你的环境名 进入环境 pip install whl文件名 解决了 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:5:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"4.Pycharm安装Python库报错ERROR: Command errored out with exit status 1 同上。找到whl文件，放入python的pip.exe同级目录。 pip install whl文件名 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:6:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"5.安装visual studio C++ build tools提示安装包丢失或毁坏 度盘/s/1D1jMEChI_ZgmmT4FKRUzWA wpoi 自行下载安装 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:7:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"6.已经在pip install安装modules但是pycharm仍然没有 注意安装和运行的是不是同一个环境 解决方法同3 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:8:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":"7.运行detect.py提示py:141: UserWarning: User provided device_type of cuda, but CUDA is not available. Disabling warnings.warn(User provided device_type of \\cuda, but CUDA is not available. Disabling) 运行不了cuda。 先检查所有版本是不是一一对应。 再检查cuda有没有安装好 ，打开cmd运行nvcc -v 如果都没问题，大概率是pytorch安装问题，检查pytorch或重装 基本遇到的问题就是以上这些，最近正在研究yolov5+deepsort的track加object统计，研究完了发一篇deepsort踩坑集合。 ","date":"2022-01-28","objectID":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/:9:0","series":null,"tags":["yolov5"],"title":"yolov5踩过的坑","uri":"/2022/01/yolov5%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"},{"categories":null,"content":" brew install pyenv pyenv install 2.7.18 export PATH=\"$(pyenv root)/shims:${PATH}\" pyenv global 2.7.18 python --version 如果一切顺利，将可以看到Python 2.8.18的输出。 需要将上述路径添加到环境变量里面，例如： echo 'PATH=$(pyenv root)/shims:$PATH' \u003e\u003e ~/.zshrc ","date":"2022-01-28","objectID":"/2022/01/%E5%AE%89%E8%A3%85python2/:0:0","series":null,"tags":["Python"],"title":"安装python2","uri":"/2022/01/%E5%AE%89%E8%A3%85python2/"},{"categories":null,"content":"#常用命令 pyenv install --list # 列出可安装版本 pyenv install \u003cversion\u003e # 安装对应版本 pyenv install -v \u003cversion\u003e # 安装对应版本，若发生错误，可以显示详细的错误信息 pyenv versions # 显示当前使用的python版本 pyenv which python # 显示当前python安装路径 pyenv global \u003cversion\u003e # 设置默认Python版本 pyenv local \u003cenv\u003e # 当前路径创建一个.python-version文件, 以后进入这个目录自动切换为该版本，注意\u003cenv\u003e 必须为虚拟环境，不能是python版本 pyenv shell \u003cversion\u003e # 当前shell的session中启用某版本，优先级高于global 及 local ","date":"2022-01-28","objectID":"/2022/01/%E5%AE%89%E8%A3%85python2/:1:1","series":null,"tags":["Python"],"title":"安装python2","uri":"/2022/01/%E5%AE%89%E8%A3%85python2/"},{"categories":null,"content":"#使用 `virtualenv #删除虚拟环境 pyenv virtualenv-delete venv pyenv virtualenv-delete venv-3.10.4 ","date":"2022-01-28","objectID":"/2022/01/%E5%AE%89%E8%A3%85python2/:1:2","series":null,"tags":["Python"],"title":"安装python2","uri":"/2022/01/%E5%AE%89%E8%A3%85python2/"},{"categories":null,"content":"标注数据集 在线: https://www.makesense.ai/ https://cvat.org/ (推荐) 本地: 精灵标注助手 http://www.jinglingbiaozhu.com 后羿采集 https://www.houyicaiji.com ","date":"2022-01-28","objectID":"/2022/01/%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86/:1:0","series":null,"tags":["yolov5"],"title":"标注数据集","uri":"/2022/01/%E6%A0%87%E6%B3%A8%E6%95%B0%E6%8D%AE%E9%9B%86/"},{"categories":null,"content":"TCP 服务端 #include \"stdafx.h\" #include \u003cstdio.h\u003e #include \u003cwinsock2.h\u003e #pragma comment(lib,\"ws2_32.lib\") int main(int argc, char* argv[]) { //初始化WSA WORD sockVersion = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(sockVersion, \u0026wsaData)!=0) { return 0; } //创建套接字 SOCKET slisten = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(slisten == INVALID_SOCKET) { printf(\"socket error !\"); return 0; } //绑定IP和端口 sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(slisten, (LPSOCKADDR)\u0026sin, sizeof(sin)) == SOCKET_ERROR) { printf(\"bind error !\"); } //开始监听 if(listen(slisten, 5) == SOCKET_ERROR) { printf(\"listen error !\"); return 0; } //循环接收数据 SOCKET sClient; sockaddr_in remoteAddr; int nAddrlen = sizeof(remoteAddr); char revData[255]; while (true) { printf(\"等待连接...\\n\"); sClient = accept(slisten, (SOCKADDR *)\u0026remoteAddr, \u0026nAddrlen); if(sClient == INVALID_SOCKET) { printf(\"accept error !\"); continue; } printf(\"接受到一个连接：%s \\r\\n\", inet_ntoa(remoteAddr.sin_addr)); //接收数据 int ret = recv(sClient, revData, 255, 0); if(ret \u003e 0) { revData[ret] = 0x00; printf(revData); } //发送数据 char * sendData = \"你好，TCP客户端！\\n\"; send(sClient, sendData, strlen(sendData), 0); closesocket(sClient); } closesocket(slisten); WSACleanup(); return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/:1:0","series":null,"tags":["Socket"],"title":"单路实例","uri":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"TCP客户端 #include \"stdafx.h\" #include \u003cWINSOCK2.H\u003e #include \u003cSTDIO.H\u003e #pragma comment(lib,\"ws2_32.lib\") int main(int argc, char* argv[]) { WORD sockVersion = MAKEWORD(2,2); WSADATA data; if(WSAStartup(sockVersion, \u0026data) != 0) { return 0; } SOCKET sclient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if(sclient == INVALID_SOCKET) { printf(\"invalid socket !\"); return 0; } sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); if (connect(sclient, (sockaddr *)\u0026serAddr, sizeof(serAddr)) == SOCKET_ERROR) { printf(\"connect error !\"); closesocket(sclient); return 0; } char * sendData = \"你好，TCP服务端，我是客户端!\\n\"; send(sclient, sendData, strlen(sendData), 0); char recData[255]; int ret = recv(sclient, recData, 255, 0); if(ret \u003e 0) { recData[ret] = 0x00; printf(recData); } closesocket(sclient); WSACleanup(); return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/:2:0","series":null,"tags":["Socket"],"title":"单路实例","uri":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"UDP服务端 #include \"stdafx.h\" #include \u003cstdio.h\u003e #include \u003cwinsock2.h\u003e #pragma comment(lib, \"ws2_32.lib\") int main(int argc, char* argv[]) { WSADATA wsaData; WORD sockVersion = MAKEWORD(2,2); if(WSAStartup(sockVersion, \u0026wsaData) != 0) { return 0; } SOCKET serSocket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); if(serSocket == INVALID_SOCKET) { printf(\"socket error !\"); return 0; } sockaddr_in serAddr; serAddr.sin_family = AF_INET; serAddr.sin_port = htons(8888); serAddr.sin_addr.S_un.S_addr = INADDR_ANY; if(bind(serSocket, (sockaddr *)\u0026serAddr, sizeof(serAddr)) == SOCKET_ERROR) { printf(\"bind error !\"); closesocket(serSocket); return 0; } sockaddr_in remoteAddr; int nAddrLen = sizeof(remoteAddr); while (true) { char recvData[255]; int ret = recvfrom(serSocket, recvData, 255, 0, (sockaddr *)\u0026remoteAddr, \u0026nAddrLen); if (ret \u003e 0) { recvData[ret] = 0x00; printf(\"接受到一个连接：%s \\r\\n\", inet_ntoa(remoteAddr.sin_addr)); printf(recvData); } char * sendData = \"一个来自服务端的UDP数据包\\n\"; sendto(serSocket, sendData, strlen(sendData), 0, (sockaddr *)\u0026remoteAddr, nAddrLen); } closesocket(serSocket); WSACleanup(); return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/:3:0","series":null,"tags":["Socket"],"title":"单路实例","uri":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"UDP客户端 #include \"stdafx.h\" #include \u003cstdio.h\u003e #include \u003cwinsock2.h\u003e #pragma comment(lib, \"ws2_32.lib\") int main(int argc, char* argv[]) { WORD socketVersion = MAKEWORD(2,2); WSADATA wsaData; if(WSAStartup(socketVersion, \u0026wsaData) != 0) { return 0; } SOCKET sclient = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP); sockaddr_in sin; sin.sin_family = AF_INET; sin.sin_port = htons(8888); sin.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); int len = sizeof(sin); char * sendData = \"来自客户端的数据包.\\n\"; sendto(sclient, sendData, strlen(sendData), 0, (sockaddr *)\u0026sin, len); char recvData[255]; int ret = recvfrom(sclient, recvData, 255, 0, (sockaddr *)\u0026sin, \u0026len); if(ret \u003e 0) { recvData[ret] = 0x00; printf(recvData); } closesocket(sclient); WSACleanup(); return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/:4:0","series":null,"tags":["Socket"],"title":"单路实例","uri":"/2022/01/%E5%8D%95%E8%B7%AF%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"服务端实例1 // 这是多线程编程，这个函数只负责接受消息，不处理。 fd_set fdread; //创建一个文件集合 SOCKET SocketArr[60]; //保存每个链接用户的 socket 的一个数组 SOCKET server_socket; //是保存服务器监听端口的 socket ... // 对服务器网络的初始化，包括初始化 WSA，绑定 ip等等，网上很多，这里不多说，推荐文章： https://www.cnblogs.com/churi/archive/2013/02/27/2935427.html while (true) { FD_ZERO(\u0026fdread); //清除监听文件集中的所有文件 FD_SET(server_socket,\u0026fdread); //将 server_socket 加入监听文件集 for (i = 0; i \u003c 60; i++) //循环将所有已经链接的客户 socket 加入文件集。 if (SocketArr[i] !=-1) FD_SET(SocketArr[i],\u0026fdread); //阻塞式监听，这里只要有一个文件收到信号就不会阻塞 if ((Ret = select(0,\u0026fdread, NULL, NULL, NULL)) == SOCKET_ERROR) { printf(\"selecterrror\"); break; } if (Ret \u003e 0) { //如果服务器端的 socket 发生改变，即收到新建立的连接 if(FD_ISSET(server_socket, \u0026fdread)) { printf(\"新连接\\n\"); //找到一个没有分配的客户socket来保存客户端连接 for (i = 0;i \u003c60; i++) if(SocketArr[i] == -1) break; //用上面找到的没有用的socket来保存客户端连接 if((SocketArr[i] = accept(server_socket, NULL, NULL)) == INVALID_SOCKET) { printf(\"Acceptsocket failed! \"); break; } } printf(\"消息处理\\n\"); //如果客户端的 SocketArr 有变化，即受到客户端发来的数据。 for (i = 0; i \u003c 60;i++) if((SocketArr[i] != -1) \u0026\u0026 (FD_ISSET(SocketArr[i], \u0026fdread))) { //在这里进行消息处理，处理链接为 SocketArr[i]，我的处理是将该信息加入到消息队列，让专门处理信息的线程读队列来处理。 } } } ","date":"2022-01-28","objectID":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/:1:0","series":null,"tags":["Socket"],"title":"多路复用实例","uri":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"服务端实例2 #include \u003cstdio.h\u003e #include\u003cWinSock2.h\u003e #include \u003cWS2tcpip.h\u003e #pragma comment(lib,\"ws2_32.lib\") //加载ws2_32.lib库 int main() { WSADATA wsadata; WORD SockVersion = MAKEWORD(2,2);//初始化socker的版本 if (WSAStartup(SockVersion,\u0026wsadata)!=0)//WSAStartup是绑定socket版本号，指定操作系统调用那个版本的方法 { printf(\"WSAStartup fail\\n\"); return -1; } //创建scoket SOCKET ScoketFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (ScoketFd == INVALID_SOCKET) { printf(\"socket error !\"); return -1; } //绑定IP和端口 struct sockaddr_in SockAddr; SockAddr.sin_family = AF_INET; SockAddr.sin_port = htons(1111); SockAddr.sin_addr.S_un.S_addr = INADDR_ANY; if (bind(ScoketFd, (SOCKADDR*)\u0026SockAddr, sizeof(SOCKADDR)) == SOCKET_ERROR) { printf(\"bind error !\\n\"); return -1; } //开始监听 if (listen(ScoketFd, 10) == SOCKET_ERROR) { printf(\"listen error !\\n\"); return -1; } // select模型 fd_set AllSocketSet; //创建一个文件集合 FD_ZERO(\u0026AllSocketSet); //清空集合 FD_SET(ScoketFd,\u0026AllSocketSet);//将ScoketFd加入sock集合 int ret = 0; //接收数据 SOCKET ClientConFd; struct sockaddr_in ClientAddr; int nSize = sizeof(ClientAddr); char RevData[1024] = { 0 }; while (1) { //设置监听fd可读事件 fd_set ReadFd; fd_set WriteFd; FD_ZERO(\u0026ReadFd); FD_ZERO(\u0026WriteFd); ReadFd = AllSocketSet; WriteFd = AllSocketSet; ret = select(0, \u0026ReadFd, \u0026WriteFd, NULL, NULL);//第一个参数nfds被忽略,是为了兼容版本 if (ret == SOCKET_ERROR) { printf(\"select error\\n\"); return -1; } if (FD_ISSET(ScoketFd, \u0026ReadFd)) //检查ScoketFd是否在这个集合里面, { //select将更新这个集合,把其中不可读的套节字去掉 //只保留符合条件的套节字在这个集合里面 printf(\"start accept new connect\\n\"); ClientConFd = accept(ScoketFd, (SOCKADDR*)\u0026ClientAddr, \u0026nSize);//等待连接，连接后会产生一个行的fd if (ClientConFd == INVALID_SOCKET) { printf(\"accept error !\\n\"); return -1; } else { FD_SET(ClientConFd, \u0026AllSocketSet);//将新产生的fd加入到原先的集合中 } } for (u_int i = 1; i \u003c AllSocketSet.fd_count; ++i)//第一个fd是监听连接的fd,第二个开始是连接上的fd { if (FD_ISSET(AllSocketSet.fd_array[i], \u0026ReadFd))//通过轮询原来的集合，检查ScoketFd是否在ReadFd集合中 { printf(\"接收一个连接：%s \\n\", inet_ntoa(ClientAddr.sin_addr)); //接收数据 ret = recv(AllSocketSet.fd_array[i], RevData, 1024, 0); if (ret == SOCKET_ERROR) { DWORD err = WSAGetLastError(); if (err == WSAECONNRESET)// 客户端的socket没有被正常关闭,即没有调用closesocket { printf(\"Client is forced to close\\n\"); closesocket(AllSocketSet.fd_array[i]); FD_CLR(AllSocketSet.fd_array[i], \u0026AllSocketSet);//把AllSocketSet.fd_array[i]从AllSocketSet集合中删除 break; } else { printf(\"recv fail\\n\"); } } else if (ret == 0)//客户端的socket正常关闭 { closesocket(AllSocketSet.fd_array[i]); FD_CLR(AllSocketSet.fd_array[i], \u0026AllSocketSet); printf(\"Client closes normally\"); } else { printf(\"%s\\n\", RevData);//打印读取的数据 } } if (FD_ISSET(AllSocketSet.fd_array[i], \u0026WriteFd)) { //发送数据 char * SendData = \"hello,TcpClient\"; send(AllSocketSet.fd_array[i], SendData, strlen(SendData), 0); } } } for (u_int j = 0; j \u003c AllSocketSet.fd_count; ++j) { SOCKET socket = AllSocketSet.fd_array[j]; closesocket(socket); } WSACleanup();//终止 DLL 的使用 return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/:2:0","series":null,"tags":["Socket"],"title":"多路复用实例","uri":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"对应客户端2 #include \u003cWINSOCK2.H\u003e #include \u003cSTDIO.H\u003e #pragma comment(lib, \"ws2_32.lib\") int main() { WSADATA wsadata; WORD SockVersion = MAKEWORD(2, 2);//初始化socker的版本 if (WSAStartup(SockVersion, \u0026wsadata) != 0)//WSAStartup是绑定socket版本号，指定操作系统调用那个版本的方法 { printf(\"WSAStartup fail\\n\"); return -1; } //创建scoket SOCKET ScoketFd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); if (ScoketFd == INVALID_SOCKET) { printf(\"socket error !\"); return -1; } //连接服务端 struct sockaddr_in ServerAddr; ServerAddr.sin_family = AF_INET; ServerAddr.sin_port = htons(1111); ServerAddr.sin_addr.S_un.S_addr = inet_addr(\"127.0.0.1\"); if (connect(ScoketFd, (SOCKADDR *)\u0026ServerAddr, sizeof(ServerAddr)) == SOCKET_ERROR) { printf(\"connect error !\\n\"); closesocket(ScoketFd); return 0; } //发送数据到服务端 char * sendData = \"hello，Tcp Server，i'm client\"; send(ScoketFd, sendData, strlen(sendData), 0); //读取服务端数据 char revData[1024] = {0}; int ret = recv(ScoketFd, revData, 1024, 0); if (ret \u003e 0) { printf(\"%s\\n\", revData); } getchar(); closesocket(ScoketFd); WSACleanup(); return 0; } ","date":"2022-01-28","objectID":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/:3:0","series":null,"tags":["Socket"],"title":"多路复用实例","uri":"/2022/01/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AE%9E%E4%BE%8B/"},{"categories":null,"content":"谷歌colab训练自己的数据集YOLOv3 自己电脑的GPU不支持cuda，所以尝试使用谷歌的Colabortory,免费提供GPU，最长运行时间12小时，因此一般需要挂载到谷歌云盘上，储存文件。 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:1:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"数据集 目标检测的数据集需要自己手动标注目标物体位置并对应生成xml文件表示目标框的位置，本文简单介绍windows系统下标注工具LabelImg的使用。 LabelImg下载链接:LabeIImg 下载好labelImg-master.zip后解压得到如下图所示。 shift+右击空白处打开powershell窗口 输入两个命令Pyrcc5 -o resources.py resources.qrc python labelImg.py 可能会出现no module named libs.resources这样的错误，将resources.py拷贝到同级的libs目录下就可以解决了。再输入第二条命令就可以运行成功了。具体使用可以参考这篇windows下使用labelImg标注图像 本次采用的数据集是红细胞的检测，已经标注好的数据链接：已标注好的细胞数据连接，Annotations文件是已经标注好目标框的xml文件，JPEGImages是jpg图片文件。 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:2:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"colab使用 首先需要创建一个谷歌云盘账号，右键空白处-\u003e更多-\u003eGoogle Colabortory,相应目录下会生成一个.ipynb文件，下次使用可直接右键此文件以Google Colabortory方式打开。如果没有Googel Colabortory选项，点击关联更多应用添加。 首先训练自己的数据集需要挂载谷歌云盘，方便文件的传输。点击链接进去，复制代码到下面框中即可。 挂载成功如下图 下面介绍一些简单的文件操作： 设置GPU模式 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:3:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"安装Pytorch colab自带的是tensorflow,因此需要自己从官网复制代码下载pytoch,如下图 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:4:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"配置文件 首先clone项目构建Darknet，输入以下命令 构建好后，右侧文件如下图： ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:5:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"上传并构建数据集 将刚才下载好的数据集上传到/darknet/data/目录下，在谷歌云盘中相应目录下空白处右击上传即可，修改数据集名字为yolov3。 点进Yolov3，创建imagesets空文件夹，imagesets存放图片路径。（忽略labels文件夹） imagesets路径编写生成的txt文件内容如下，每张图片的完整路径。 分割数据集为训练集和测试集，分割后图片的名字存在imagesets下 imagesets下的文件 从xml文件中提取目标框坐标，并存入JPEGImages图片文件夹里，并在yolov3文件夹里生成train.txt和test.txt，与上面生成的不一样，这里是图片的完整路径 生成的labels文件内容如下： ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:6:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"配置文件 在/darknet/data/目录下创建rbc.data和rbc.names文件,如下： 网络结构配置，将/darknet/cfg/目录下的yolov3.cf文件基础上改，可以将yolov3.cf文件复制重命名为yolov3_custom.cfg再存到cfg目录下。修改地方如下，如何修改可参考Yolov3 win10+vs17 运行及训练自己的数据集 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:7:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"开始训练 下载预训练权重 训练，第一行是防止Permission denied错误。这里注意前面构建数据的文件一定要放对路径，不然会报奇奇怪怪的错。训练产生的权重文件自动保存在/darknet/backup中 如中间因不明原因停止可以查看backup目录下最后一次权重是多少（比如yolov3_custom_700.weights），然后运行如下代码就可以了。 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:8:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"用训练出来的权重测试 修改yolov3_custom.cfg为测试模式 随便找一张细胞图片放入/darknet/data文件下（BloodImages_00001.jpg），然后输入下列代码。 得到下列结果，可以看到预测到几个目标： ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:9:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"显示图片 显示预测结果 ","date":"2022-01-28","objectID":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/:10:0","series":null,"tags":["yolov5"],"title":"谷歌colab训练自己的数据集YOLOv3","uri":"/2022/01/%E8%B0%B7%E6%AD%8Ccolab%E8%AE%AD%E7%BB%83%E8%87%AA%E5%B7%B1%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9B%86yolov3/"},{"categories":null,"content":"流程 项目的部署环境搭建 如何实现一个自己的训练集 预先准备 实现屏幕截图 鼠标驱动 研读修改 YOLOv5 源代码 进行重构 ","date":"2022-01-28","objectID":"/2022/01/%E6%B5%81%E7%A8%8B/:0:0","series":null,"tags":["yolov5"],"title":"流程","uri":"/2022/01/%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"某单机手游绘制教程目录导航 莫激动，本文只是把前段时间制作的《某单机游戏显示敌方血量》教程，整理个目录出来。 （但愿本文不会以通知形式推送，因为没啥新鲜内容，不好意思打扰 16:50单机安卓手游分屏绘制教程01: 使用java swing创建透明窗口1531 23视频 赶码人 使用java swing创建透明窗口 其实我现在再看这个视频，感觉挺磨叽的，只是为了创建个窗口，却搞了17分钟视频（录制时间更长），可能是因为当初研究swing透明窗口遇到的坑有点多，折腾了十几小时，所以情不自禁多扯了些东西；如果能用其他语言创建窗口，就没必要看这一集了。 建这个窗口是为了覆盖到游戏画面上，观察绘图位置是否准确，在电脑上创建，是为了研究的时候省事，改完代码一瞬间就能看到效果了；本系列教程目的是研究、交流技术，培养学习兴趣，而不是真正用到这款游戏，或者其他什么游戏当中，更不是为了作弊，所以就这样搞个随意的透明窗口就够了，够咱测试矩阵结果是否正确了。 这个视频说白了就是复制粘贴，想体现编程不完全靠背，记不住的函数就去查就行了，有时候man命令比百度来得快。 后面要用到字节数组转整数、浮点数的代码，这里讲解了代码为啥这样写，当时录制的时候就是想体现一下逻辑运算不常见但是很重要。感兴趣就看。 ida也可以这样免root使用。 演示了root和非root的两种办法，视频末尾探究了一下该游戏的地图大小（人物坐标取值范围）。 再最后聊几句吧，本导航是本系列最后一篇了。 我视频中不是虚拟机，这个其实在教程00（教程00作用相当于大纲，后来删掉了，因为声音不好听）提到过，用的是scrcpy，是个投屏软件。然后每个视频开头的目录，属实是体现了计划赶不上变化，所以，视频开头的几秒那个目录就别看了。 这些教程需要一点点编程基础，大概是普通大学生的C语言课程的期末及格水平就够了，超出了“期末及格水平”的看不懂的地方再去查资料。 如果是想作弊或者是黑灰产，这系列教程是完全没帮助的。也不要问我如何绕过检测，绕过反调试，我没这方面经验，也没能力和游戏厂商对抗，即使略懂一点，也会遵纪守法，不会以任何形式传播。本人坚决反对一切黑灰产行为。 我不是大佬啦，也不是“学霸”，汇编只知道个nop、ldr、mov、bl是干嘛的，没打过CTF，ACM啥的，就是个纯纯业余爱好者，将来大概率是靠java后端或者android应用开发混饭吃… 希望读者能通过单机游戏绘制，体会到编程乐趣。 ","date":"2022-01-28","objectID":"/2022/01/%E6%9F%90%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E7%BB%98%E5%88%B6%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/:0:0","series":null,"tags":["赶码人"],"title":"某单机手游绘制教程目录导航","uri":"/2022/01/%E6%9F%90%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E7%BB%98%E5%88%B6%E6%95%99%E7%A8%8B%E7%9B%AE%E5%BD%95%E5%AF%BC%E8%88%AA/"},{"categories":null,"content":"Colab cd /content/drive/MyDrive/Colab Notebooks/yolov5-6.0 !pip install -r requirements.txt %load_ext tensorboard %tensorboard --logdir=runs/train !unzip baby.v2i.yolov5pytorch.zip -d ./ !python detect.py !python trainFlyboy.py --rect #!python train.py --rect --data=data/coco.yaml #!python trainFlyboy.py --img 640 --batch 16 --epochs 3 --data flyboy.yaml --weights yolov5s.pt !pip install wandb ","date":"2022-01-28","objectID":"/2022/01/%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/:1:0","series":null,"tags":["yolov5"],"title":"详细步骤","uri":"/2022/01/%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4/"},{"categories":null,"content":"最后战役X，获取“飞天”选择框选中状态 赶码人 为了避免读者浪费时间，提前声明：本文仅适用于《最后战役X》这款单机安卓手游。（64位） 搜0搜1也能找到选择框选中状态，但是既然当前已经得到了so的符号，肯定有更快更优雅的办法， 找选择框，最开始想的是搜checkbox，搜不到，那就翻代码，把看着像游戏作者写的函数，都大概浏览一下，比如uidm（猜测是“ui代码”）开头的函数，men开头的函数，诸如此类， unity游戏，xxxxupdate函数很重要，会很频繁的被调用(比如unity中的update函数每帧都会调用一次)，带有update的函数多看看，在men$$FixedUpdate函数能发现一个名字带有UI和toggle的函数，那么就可以积累了，下次再想找选择框，除了搜checkbox，还可以搜toggle，找组件，就搜UI。 之前这篇文章提到过，dump.cs可以直接看到偏移。上图那个注释部分就是根据这个文件写出来的。另外，men是类，FiexdUpdate是这个类的一个方法，通常这种情况，逆向视角看到的参数一，就表示调用这个方法的对象的地址，所以这里a1就是一个men类的实例，0x20的位置就是uidm对象，以此类推，v7是个Toggle对象，名字是rjbd，猜测是“人机不动”。 接下来，双击这个UnityEngine_UI_Toggle__get_isOn，发现获取状态很简单，这个状态就存储在Toggle对象地址的0xF8这个偏移的位置。 咱要找的不是“人机不动”，而是要找飞天的选择框，直接对着UnityEngine_UI_Toggle__get_isOn按X， 有个move的函数，看着就像是和飞天判断有点关系，过去看看： 那么这里就是游戏作者的飞天想法了，看看都做了啥：UnityEngine_Rigidbody__set_useGravity设置重力为0、然后设置了个啥属性，用了UnityEngine_Rigidbody__set_isKinematic这个函数，这个函数有啥功能，我不知道。不扯这些了，赶紧搞到飞天选择框选中状态的基址偏移。 接下来就差a1了，刚才说了，a1可能就是个uidm对象的地址，我没学过unity，但我感觉似乎每个类都有Start方法，百度搜了一下：当Update函数第一次被调用前会调用Start函数 那么作用就类似于构造函数吧，去uidm$$Start函数看看： 注意第91行，这是bss段的数据，libil2cpp.so+A8BDD0，然后93行，窝草，把uidm对象地址直接就放到了[[[libil2cpp.so+A8BDD0]+0xB8]]，这种难度，我不禁想到了这个视频： 那么飞天选中状态的基址偏移就有了：[[[[libil2cpp.so+A8BDD0]+0xB8]]+0x68 ]+ 0xf8 ","date":"2022-01-28","objectID":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E8%8E%B7%E5%8F%96%E9%A3%9E%E5%A4%A9%E9%80%89%E6%8B%A9%E6%A1%86%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81/:0:0","series":null,"tags":["赶码人"],"title":"最后战役X，获取“飞天”选择框选中状态","uri":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E8%8E%B7%E5%8F%96%E9%A3%9E%E5%A4%A9%E9%80%89%E6%8B%A9%E6%A1%86%E9%80%89%E4%B8%AD%E7%8A%B6%E6%80%81/"},{"categories":null,"content":"最后战役X，去除水滴屏挖孔屏黑边 全文总结：给AndroidManifest加个标签 本文是《最后战役X》优化修复系列最后一篇，前面文章已经记录了如何修复飞天选项失效的问题。最终成品的效果和下载，请看这个视频： 00:47最后战役X：优化水滴屏黑边、修复飞天功能300 13视频 赶码人 《最后战役X》是一款单机安卓FPS手游，原作者已经不再进行更新，所以出于研究和学习目的，本玩家对该作品进行逆向、完善，整个过程请参考本系列文章前几篇： 最后战役X(单机手游)连跳飞天思路点击进入查看全文\u003e文章 赶码人 200 16 5 最后战役X，获取“飞天”选择框选中状态点击进入查看全文文章 赶码人 60 5 1 (失败记录)单机手游《最后战役X》修复飞天BUG：尝试改汇编指令点击进入查看全文文章 赶码人 48 6 1 最后战役X(单机手游)飞天日记：改指令实现修复飞天(不含判断)点击进入查看全文\u003e文章 赶码人 38 7 0 最后战役X(单机手游)飞天日记：改指令实现修复飞天(包含“飞天”勾选判断)点击进入查看全文\u003e文章 赶码人 50 6 0 修复飞天功能部分已经写完了，接下来写写去除全面屏、挖孔屏黑边。 并不难，只需要修改AndroidManifest文件，在application标签中，添加几个标签： \u003cmeta-data android:name =\"android.max_aspect\" android:value =\"2.2\" /\u003e \u003cmeta-data android:name=\"notch.config\" android:value=\"portrait|landscape\"/\u003e \u003cmeta-data android:name=\"android.notch_support\" android:value=\"true\"/\u003e 然后就直接编译就可以了··· 再提几个其他的修改的地方吧，我重新打包签名出来的修复版还做了以下更改： 为了能够让原版和修复版共存，这里改了改包名： 另外，干脆把armeabi-v7的文件夹删掉了，因为只修复了64位的so。删掉那个文件夹之后，32位手机可能就无法安装了吧（我没尝试），这样就能避免一些问题，比如“为什么我这里勾选飞天选项之后，仍然不能使用”… 还有就是，把/res/values/strings.xml里面的app_name改了改，去掉了几个字，因为之前的名字实在太长了，这里搞短一点： 本系列到这里就完结了，过一段时间实现一下 这款单机FPS手游的 掉落不掉血，然后再分析一下为啥有时候人机会原地踏步，等等。 ","date":"2022-01-28","objectID":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8E%BB%E9%99%A4%E6%B0%B4%E6%BB%B4%E5%B1%8F%E6%8C%96%E5%AD%94%E5%B1%8F%E9%BB%91%E8%BE%B9/:0:0","series":null,"tags":["赶码人"],"title":"最后战役X，去除水滴屏挖孔屏黑边","uri":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8E%BB%E9%99%A4%E6%B0%B4%E6%BB%B4%E5%B1%8F%E6%8C%96%E5%AD%94%E5%B1%8F%E9%BB%91%E8%BE%B9/"},{"categories":null,"content":"修复单机FPS手游《最后战役X》无法飞天的BUG！ 这是本系列文章第五篇，上篇文章已经修复了飞天，但没有对选择框是否勾选进行判断。 最后战役X(单机手游)连跳飞天思路 最后战役X，获取“飞天”选择框选中状态 (失败记录)单机手游《最后战役X》修复飞天BUG：尝试改汇编指令 最后战役X(单机手游)飞天日记：改指令实现修复飞天(不含判断) 目前的代码如图： 对应的汇编指令： .text:000000000071FF68 .text:000000000071FF68 ; =============== S U B R O U T I N E ======================================= .text:000000000071FF68 .text:000000000071FF68 ; Attributes: bp-based frame .text:000000000071FF68 .text:000000000071FF68 uidm$$jumap ; DATA XREF: .data.rel.ro:0000000000A28828↓o .text:000000000071FF68 .text:000000000071FF68 var_20 = -0x20 .text:000000000071FF68 var_10 = -0x10 .text:000000000071FF68 var_s0 = 0 .text:000000000071FF68 .text:000000000071FF68 ; __unwind { .text:000000000071FF68 STP X22, X21, [SP,#-0x10+var_20]! .text:000000000071FF6C STP X20, X19, [SP,#0x20+var_10] .text:000000000071FF70 STP X29, X30, [SP,#0x20+var_s0] .text:000000000071FF74 ADD X29, SP, #0x20 .text:000000000071FF78 ADRP X20, #byte_A9D621@PAGE .text:000000000071FF7C LDRB W8, [X20,#byte_A9D621@PAGEOFF] .text:000000000071FF80 MOV X19, X0 .text:000000000071FF84 TBNZ W8, #0, loc_71FFA0 .text:000000000071FF88 ADRP X8, #off_A3D7E0@PAGE .text:000000000071FF8C LDR X8, [X8,#off_A3D7E0@PAGEOFF] .text:000000000071FF90 LDR W0, [X8] .text:000000000071FF94 BL sub_4D2878 .text:000000000071FF98 MOV W8, #1 .text:000000000071FF9C STRB W8, [X20,#byte_A9D621@PAGEOFF] .text:000000000071FFA0 .text:000000000071FFA0 loc_71FFA0 ; CODE XREF: uidm$$jumap+1C↑j .text:000000000071FFA0 ADRP X21, #off_A57408@PAGE .text:000000000071FFA4 LDR X21, [X21,#off_A57408@PAGEOFF] .text:000000000071FFA8 LDR X8, [X21] ; UnityStandardAssets.Characters.FirstPerson.FirstPersonController_TypeInfo .text:000000000071FFAC LDR X8, [X8,#0xB8] .text:000000000071FFB0 LDR X20, [X8] .text:000000000071FFB4 MOV W8, #0x41200000 ; Keypatch modified this from: .text:000000000071FFB4 ; CBNZ X20, loc_71FFC0 .text:000000000071FFB8 STR W8, [X20,#0x6C] ; Keypatch modified this from: .text:000000000071FFB8 ; MOV X0, XZR .text:000000000071FFBC NOP ; Keypatch modified this from: .text:000000000071FFBC ; BL sub_4F8DDC .text:000000000071FFC0 LDRB W8, [X20,#0x58] .text:000000000071FFC4 CBNZ W8, loc_720050 .text:000000000071FFC8 LDR X8, [X21] ; UnityStandardAssets.Characters.FirstPerson.FirstPersonController_TypeInfo .text:000000000071FFCC LDR X8, [X8,#0xB8] .text:000000000071FFD0 LDR X20, [X8] .text:000000000071FFD4 CBNZ X20, loc_71FFE0 .text:000000000071FFD8 MOV X0, XZR .text:000000000071FFDC BL sub_4F8DDC .text:000000000071FFE0 ; --------------------------------------------------------------------------- .text:000000000071FFE0 .text:000000000071FFE0 loc_71FFE0 ; CODE XREF: uidm$$jumap+6C↑j .text:000000000071FFE0 LDR X20, [X20,#0x78] .text:000000000071FFE4 CBNZ X20, loc_71FFF0 .text:000000000071FFE8 MOV X0, XZR .text:000000000071FFEC BL sub_4F8DDC .text:000000000071FFF0 ; --------------------------------------------------------------------------- .text:000000000071FFF0 .text:000000000071FFF0 loc_71FFF0 ; CODE XREF: uidm$$jumap+7C↑j .text:000000000071FFF0 MOV X1, XZR .text:000000000071FFF4 MOV X0, X20 .text:000000000071FFF8 BL UnityEngine.CharacterController$$get_isGrounded .text:000000000071FFFC TBZ W0, #0, loc_720050 .text:0000000000720000 LDR X8, [X21] ; UnityStandardAssets.Characters.FirstPerson.FirstPersonController_TypeInfo .text:0000000000720004 LDR X8, [X8,#0xB8] .text:0000000000720008 LDR X20, [X8] .text:000000000072000C CBNZ X20, loc_720018 .text:0000000000720010 MOV X0, XZR .text:0000000000720014 BL sub_4F8DDC .text:0000000000720018 ; --------------------------------------------------------------------------- .text:0000000000720018 .text:0000000000720018 loc_720018 ; CODE XREF: uidm$$jumap+A4↑j .text:0000000000720018 MOV W8, #1 .text:000000000072001C STRB W8, [X20,#0x58] .text:0000000000720020 MOV W8, #0x41200000 ; Keypatch modified this from: .text:0000000000720020 ; LDR X20, [X19,#0xA0] .text:0000000000720024 STR W8, [X20,#0x6C] ; Keypatch modified this from: .text:0000000000720024 ; LDR X19, [X19,#0xB","date":"2022-01-28","objectID":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E9%A3%9E%E5%A4%A9%E6%97%A5%E8%AE%B0%E6%94%B9%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9%E5%8C%85%E5%90%AB%E9%A3%9E%E5%A4%A9%E5%8B%BE%E9%80%89%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["赶码人"],"title":"最后战役X(单机手游)飞天日记：改指令实现修复飞天(包含“飞天”勾选判断)","uri":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E9%A3%9E%E5%A4%A9%E6%97%A5%E8%AE%B0%E6%94%B9%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9%E5%8C%85%E5%90%AB%E9%A3%9E%E5%A4%A9%E5%8B%BE%E9%80%89%E5%88%A4%E6%96%AD/"},{"categories":null,"content":"最后战役X(单机手游)飞天日记：改指令实现修复飞天(不含判断) 赶码人 单机手游《最后战役X》(64位)飞天BUG修复日记 本系列文章正在连载： 最后战役X(单机手游)连跳飞天思路点击进入查看全文\u003e文章 赶码人 174 14 5 最后战役X，获取“飞天”选择框选中状态点击进入查看全文文章 赶码人 50 5 1 (失败记录)单机手游《最后战役X》修复飞天BUG：尝试改汇编指令点击进入查看全文\u003e文章 赶码人 39 5 1 上篇改指令实现修复飞天，没成功，今天有了一点新进展。 第一篇文章得到当前速度基址偏移：[[[libil2cpp.so + A8BDC8]+b8]]+58+14 如果在地面上，直接改这个值是不生效的，只有腾空之后，改这个值才能生效。当时我没注意到这个特点，可能因为当时用frida搞的太顺利了，一心想着按下跳跃才修改，所以没遇到这个问题。这里有一种可能性，人物在地面时，给这个地址写入值，没有生效的另一种可能性是有一个执行频率很高的函数，检测到人物在地面时，就给这个值写入其他值。（具体位置接下来会说）。 还有就是这个+b8之后得到的是啥对象，我也给忽略了，没想到这里。实际上[[[libil2cpp.so + A8BDC8]+b8]]是FirstPersonController，直接在dump.cs就能看到各个偏移实际的意义。 m_Jump，就是上一篇文章那个0x58，这个值锁定成1，那么人物就一直在跳。跳跃完成之后，这个值写入0。具体逻辑肯定在FirstPersonController的某个方法当中；0x6c就是m_MoveDir的y。 接下来就看FirstPersonController的各种update方法（函数）。找到跳跃的逻辑。 来到FixedUpdate，行数不多，去掉变量声明只有150行。可以很轻易的找到一个关于是否在地面的if： 先是判断是否在地面，然后判断是否按过跳跃键 如果在地面上，那么开始执行185行，第186行这里给6C设置了一个值，是偏移2C的负数。 m_StickToGroundForce，看起来是“贴向地面的力”？不知道这一行有啥用，但可以肯定的是，在地面时这一行会频繁的向0x6c写入一个固定值，导致咱在地面上设置y方向速度时并不能生效（或者说咱设置的速度，在控制人物位置的相关指令读取到之前，就被改了）。那就给它nop掉把，这里直接给出偏移和写入的数值：libil2cpp.so+52B394写入1F 20 03 D5，经过尝试，毫无负面影响。 这时再向[[[libil2cpp.so + A8BDC8]+b8]]+58+14写入值，无论是否在地面，都会生效。 相较于上篇文章，这次换个地方改三条指令，就能实现和这个视频相同的效果了。 接下来就是找个合适的地方，看看哪里适合插入判断是否勾选飞天的指令 libil2cpp.so+52B394 写入 1F 20 03 D5 libil2cpp.so+71ffb4 写入 08 24 A8 52 88 6E 00 B9 1F 20 03 D5 ","date":"2022-01-28","objectID":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E9%A3%9E%E5%A4%A9%E6%97%A5%E8%AE%B0%E6%94%B9%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9%E4%B8%8D%E5%90%AB%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["赶码人"],"title":"最后战役X(单机手游)飞天日记：改指令实现修复飞天(不含判断)","uri":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E9%A3%9E%E5%A4%A9%E6%97%A5%E8%AE%B0%E6%94%B9%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E4%BF%AE%E5%A4%8D%E9%A3%9E%E5%A4%A9%E4%B8%8D%E5%90%AB%E5%88%A4%E6%96%AD/"},{"categories":null,"content":"最后战役X(单机手游)连跳飞天思路 赶码人 最后战役X一是款基于unity引擎的单机FPS手游，作者已经不再进行维护。打开游戏后选择“端游界面”，进入游戏即可看到“调试”按钮。这个调试按钮，是游戏作者为玩家提供的“外挂”功能，包含不掉血、无限子弹、飞天、禁止人机移动 这四种功能。其中，飞天功能无法正常使用，所以本文讲讲如何修复无法飞天的BUG。 涉及到的工具：ce+ceserver、frida、il2cppdumper、ida、ADB(其实感觉这个玩机必备工具没必要说的..) 其中有些步骤，网络上教程已经有很多，我在本文不再详细展开，直接给出参考链接； 本文仅供提高编程兴趣，请勿将本文内容用于其他游戏，本文作者不承担任何责任。 如果本教程使你有所收获，请为我的相关视频点个赞，鼓励为爱发电~ 全文总结：在按下跳跃键时，设置y轴方向的速度。 最开始我想的比较简单，猜测有个变量表示是否在地面，那么，在地面搜1，在空中搜0，类型选择1字节，假如游戏的跳跃按钮按下后是判断了这个变量是1才能起跳，所有结果冻结成1，就完事了，但实际上并不能。 同理，再猜测，是否有个变量表示 是否在空中，那么，在地面搜0，在空中搜1，如果游戏逻辑是“按下跳跃后，游戏判断这个变量是0才 跳跃”，那么，所有结果冻结成0，就完事了，但，想得美。 那咋办？找自身坐标呗，找到y坐标之后，肯定不是改这个值，因为这样很不优雅，比如，如果头顶有个天花板，直接就穿透过去了。如果是下读写断点，也没有啥方便的调试工具(ce不兼容arm指令,断点也几乎只能在x86模拟器上使用,而我这里测试了几个模拟器都无法安装该游戏)。 既然这样，只能尝试dump了。 il2dump下载连接：https://github.com/Perfare/Il2CppDumper/releases 装好il2dump之后，参考这篇帖子：https://www.52pojie.cn/forum.php?mod=viewthread\u0026tid=982655 跟着做，导入script.py之后，再接着本文往下看就行了 (哈哈，之前没发现已经有大佬做这么详细的教程，看来我可以少写好几段咯 ) frida安装教程：https://www.bilibili.com/read/cv13148804?spm_id_from=333.999.0.0 (不建议装12的版本,因为不支持ES6的语法写着不舒服,我这里是15.0.8 ； 否则，就把我下文的let改成var) 也建议读者再自己找找其他frida教程，多对照着看. 具体的探索经历就不提了，忘得差不多了，直接聊聊主线： il2cpp.so拖到ida，可以看到很多函数名字都是sub开头的，然后按照刚才的链接，在ida执行script.py之后，就能看到各种函数名。实际上，我前面的绘制系列教程涉及的操作，放到最后战役X还是一样的。 dump之后还能得到一个dump.cs文件，然后根据感觉搜就行了，或者直接看，比如men表示人物，再比如下图这个94798这一行，后面注释有个0x18，这个就表示men对象地址+0x18就是这个对象的血量。再多扯几句，0x38那个zj表示“是否为自己”，什么zj，myca，syd，不得不说，游戏作者的编码风格属于是自带混淆（吐槽归吐槽，我还是很respect这位游戏作者 现在符号有了，咱要搞连跳飞天，直接搜吧，但你会发现搜不出来有价值的函数， 我在这里卡了很久，我甚至搜了tiao，ty，也是没收获，实际上是游戏作者打错单词了，把jump打成了jumap， 搜jumap，好，这下子有了： 这里不提他里面具体都做了啥，光标放函数名这一行，观察这个窗口下方有个状态栏，表示这个函数的地址，0x71FF68，记住它，接下来我们看这个函数被调用的情况，开始搞frida代码，先新建个1.js，内容如下： let so_addr = Module.findBaseAddress(\"libil2cpp.so\") let jump_call = so_addr - 0 + 0x71ff68; Interceptor.attach(new NativePointer(jump_call), { onEnter: function(args){ console.log('uidm__jumap 被调用') }, }) 这段代码，可以让jumap函数被调用后（jumap内部代码被执行之前），在终端/cmd执行我们1.js的onEnter指定的方法（这里是输出个提示）， 先看看它的调用情况如何，比如是否会被调用，如果这个函数确实会被调用，分两种情况， 一个是点击一下跳跃按钮，这个函数就调用一次；另一情况是，输出次数（调用次数）和跳起次数一致，只有能跳起了才有输出。说白了就是，这个函数内部是否进行了\"是否跳起\"的判断。 ADB连接手机，开个终端进入adb打开frida-server，然后再来个终端切换到1.js所在目录，执行下图所示操作，首先是获取游戏pid，然后注入1.js，然后跳就完事了， 会发现只要按下了跳跃键，就会有输出，也就是说，大概率是在这个函数内部，或者是这个函数的内部调用的某个函数中，进行了能否跳起的判断， 但是我nop半天，也没找到，顶多是让连续按下两次跳跃后，人物则会在第一次跳起落地后开始第二次跳跃，这就比较麻烦了， 于是我准备换思路，开始查资料，看游戏开发者会如何实现跳跃，查了查，通常是通过addForce函数执行跳跃，确实也搜到了，但是经过测试，这些函数似乎并没有执行？？ addForce是施加力，力是啥啊，初中物理早忘了，为了严谨我百度搜到了这一段： 牛顿第二定律揭示了力和运动的因果性，力是产生加速度的原因，加速度是力的作用效果，故力是改变物体运动状态的原因。 玩家能在地上走，还持续受到了重力的作用，不多扯了，只要知道，跳起的时候，速度越来越小，方向向上（是一个正数），到最高点，速度为0，然后速度方向向下（负号），速度的值越来越大，直到落地， 所以，jumap这个函数也不算白找，我们可以让这个函数被调用的时候，把自己的速度改了。 可以模糊搜索速度的地址，但是，我观察jumap的代码， 然后就无意得到了人物y方向速度基址偏移，正数是方向向上，负数是方向向下， CE这样表示：[[[libil2cpp.so + A8BDC8]+b8]]+58+14 那么，咱们这样写就行了： let so_addr = Module.findBaseAddress(\"libil2cpp.so\") function vy(){ let baseaddr = ptr(so_addr - 0 + 0xA8BDC8).readLong() let v2 = ptr( ptr(baseaddr + 0xb8).readLong() ).readLong() let vy = ptr(v2 + 0x58 + 0x14) vy.writeFloat(10); } let jump_call = so_addr - 0 + 0x71ff68; Interceptor.attach(new NativePointer(jump_call), { onEnter: function(args){ vy(); }, }) 就是说，只要按一下跳跃键，就把速度写入+10，那么接下来的一小段时间内，咱们会越飞越高，同时速度也在趋近于0，紧接着速度为0，达到最高点，然后速度逐渐向下增大，总之，和普通的跳跃的视觉效果是一样的。 至此为止，本文已经结束了。 这篇文章标题是思路，思路 已经搞完了， 但是还存在两个问题，首先是目前没有开关，也就是说，开启后，关不掉这个功能。获取“飞天”选择框的选中状态，我打算过两天再写，这篇文章截止到这里已经2700字了。 其次，如果关掉frida，或者没有电脑，咱这不就不能连跳了？这就涉及到frida持久化问题，看情况，应该也能放到下一篇文章。 感谢支持~，接下来我会发一个效果视频，包括[[[libil2cpp.so + A8BDC8]+b8]]+58的值在ce看起来的样子。如果本文使你有所收获，请帮忙给效果视频点个赞~~ 效果视频： https://www.bilibili.com/video/BV1Xa41117He ","date":"2022-01-28","objectID":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E8%BF%9E%E8%B7%B3%E9%A3%9E%E5%A4%A9%E6%80%9D%E8%B7%AF/:0:0","series":null,"tags":["赶码人"],"title":"最后战役X(单机手游)连跳飞天思路","uri":"/2022/01/%E6%9C%80%E5%90%8E%E6%88%98%E5%BD%B9x%E5%8D%95%E6%9C%BA%E6%89%8B%E6%B8%B8%E8%BF%9E%E8%B7%B3%E9%A3%9E%E5%A4%A9%E6%80%9D%E8%B7%AF/"},{"categories":["C++"],"content":"C++ 环境设置 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"本地环境设置 如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"文本编辑器 这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。 文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。 通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。 在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 编译器 写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。 C++ 编译器用于把源代码编译成最终的可执行程序。 大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。 最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"安装 GNU 的 C/C++ 编译器 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"UNIX/Linux 上的安装 如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC： $ g++ -v 如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息： Using built-in specs. Target: i386-redhat-linux Configured with: ../configure --prefix=/usr ....... Thread model: posix gcc version 4.1.2 20080704 (Red Hat 4.1.2-46) 如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Mac OS X 上的安装 如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。 Xcode 目前可从 https://developer.apple.com/download 上下载，需要使用 apple ID 登录 。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Windows 上的安装 为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 mingw-w64.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-.exe。 当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。 添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。 当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:3","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"使用 Visual Studio (Graphical Interface) 编译 1、下载及安装 Visual Studio Community 2015。 2、打开 Visual Studio Community 3、点击 File -\u003e New -\u003e Project 4、左侧列表选择 Templates -\u003e Visual C++ -\u003e Win32 Console Application，并设置项目名为 MyFirstProgram。 5、点击 OK。 6、在以下窗口中点击 Next 7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮： 8、右击文件夹 Source File 并点击 Add –\u003e New Item… : 9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add： 10、拷贝以下代码到 main.cpp 中： #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\\n\"; return 0; } 界面如下所示： 11、点击菜单上的 Debug -\u003e Start Without Debugging (或按下 ctrl + F5) : 12、完成以上操作后，你可以看到以下输出： ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 应用说明 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示： $ gcc main.cpp -lstdc++ -o main 下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码： #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 最简单的编译方式： $ g++ helloworld.cpp 由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行： $ ./a.out Hello, world! 通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件： $ g++ helloworld.cpp -o helloworld 执行 helloworld: $ ./helloworld Hello, world! 如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下： $ g++ runoob1.cpp runoob2.cpp -o runoob 生成一个 runoob 可执行文件。 g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件： g++ -g -Wall -std=c++11 main.cpp ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 常用命令选项 选项 解释 -ansi 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 -c 只编译并生成目标文件。 -DMACRO 以字符串\"1\"定义 MACRO 宏。 -DMACRO=DEFN 以字符串\"DEFN\"定义 MACRO 宏。 -E 只运行 C 预编译器。 -g 生成调试信息。GNU 调试器可利用该信息。 -IDIRECTORY 指定额外的头文件搜索路径DIRECTORY。 -LDIRECTORY 指定额外的函数库搜索路径DIRECTORY。 -lLIBRARY 连接时搜索指定的函数库LIBRARY。 -m486 针对 486 进行代码优化。 -o FILE 生成指定的输出文件。用在生成可执行文件时。 -O0 不进行优化处理。 -O 或 -O1 优化生成代码。 -O2 进一步优化。 -O3 比 -O2 更进一步优化，包括 inline 函数。 -shared 生成共享目标文件。通常用在建立共享库时。 -static 禁止使用共享连接。 -UMACRO 取消对 MACRO 宏的定义。 -w 不生成任何警告信息。 -Wall 生成所有警告信息。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 基本语法 C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"实例 #include using namespace std; // main() 是程序开始执行的地方 int main() { cout « “Hello World”; // 输出 Hello World return 0; } 接下来我们讲解一下上面这段程序： C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout « “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"编译 \u0026 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤： 打开一个文本编辑器，添加上述代码。 保存文件为 hello.cpp。 打开命令提示符，进入到保存文件所在的目录。 键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。 现在，键入 ’ a.out’ 来运行程序。 您可以看到屏幕上显示 ’ Hello World ‘。 $ g++ hello.cpp $ ./a.out Hello World 请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。 您也可以使用 makefile 来编译 C/C++ 程序。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的分号 \u0026 语句块 在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 例如，下面是三个不同的语句： x = y; y = y+1; add(x, y); 语句块是一组使用大括号括起来的按逻辑连接的语句。例如： { cout « “Hello World”; // 输出 Hello World return 0; } C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如： x = y; y = y+1; add(x, y); 等同于 x = y; y = y+1; add(x, y); ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 标识符 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、\u0026 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。 下面列出几个有效的标识符： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 关键字 下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 完整关键字介绍可查阅：C++ 的关键字（保留字）完整介绍 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"三字符组 三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。 下面列出了最常用的三字符序列： 三字符组 替换 ??= # ??/ \\ ??’ ^ ??( [ ??) ] ??! | ??\u003c { ??\u003e } ??- ~ 如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"…?\"\"?…“或者转义序列：”…??…\"。 从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs g++仍默认支持三字符组，但会给出编译警告。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的空格 只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。 在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中： int age; 在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中： fruit = apples + oranges; // 获取水果的总数 fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 注释 程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。 C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。 C++ 注释一般有两种： // - 一般用于单行注释。 /*** … */** - 一般用于多行注释。 注释以 // 开始，直到行末为止。例如： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main() { // 这是一个注释 cout \u003c\u003c \"Hello World!\"; return 0; } 也可以放在语句后面： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello World!\"; // 输出 Hello World! return 0; } 当上面的代码被编译时，编译器会忽略 // 这是一个注释 和 // 输出 Hello World!，最后会产生以下结果： Hello World! C++ 注释以 /* 开始，以 */ 终止。例如： #include \u003ciostream\u003e using namespace std; int main() { /* 这是注释 */ /* C++ 注释也可以 * 跨行 */ cout \u003c\u003c \"Hello World!\"; return 0; } 在 /* 和 / 注释内部，//* 字符没有特殊的含义。在 // 注释内，/* 和 */ 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如： /* 用于输出 Hello World 的注释 cout \u003c\u003c \"Hello World\"; // 输出 Hello World */ ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":null,"content":" [ { \"id\": \"62c8c69.94b5c38\", \"type\": \"tab\", \"label\": \"流程1\", \"disabled\": false, \"info\": \"\" }, { \"id\": \"734a0c31.08f244\", \"type\": \"server\", \"name\": \"Home Assistant\", \"version\": 2, \"addon\": true, \"rejectUnauthorizedCerts\": true, \"ha_boolean\": \"y|yes|true|on|home|open\", \"connectionDelay\": false, \"cacheJson\": false, \"heartbeat\": false, \"heartbeatInterval\": 30 }, { \"id\": \"ce89b0ba.bfd2d\", \"type\": \"switch\", \"z\": \"62c8c69.94b5c38\", \"name\": \"点击事件\", \"property\": \"payload.event_type\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"click\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 1, \"x\": 220, \"y\": 220, \"wires\": [ [ \"1c52127a.fa3556\" ] ] }, { \"id\": \"474d42ea.576f9c\", \"type\": \"api-call-service\", \"z\": \"62c8c69.94b5c38\", \"name\": \"次卧灯\", \"server\": \"734a0c31.08f244\", \"version\": 5, \"debugenabled\": false, \"domain\": \"light\", \"service\": \"toggle\", \"areaId\": [], \"deviceId\": [], \"entityId\": [ \"light.ci_wo_da_deng\" ], \"data\": \"\", \"dataType\": \"json\", \"mergeContext\": \"\", \"mustacheAltTags\": false, \"outputProperties\": [ { \"property\": \"payload\", \"propertyType\": \"msg\", \"value\": \"\", \"valueType\": \"data\" } ], \"queue\": \"none\", \"output_location\": \"payload\", \"output_location_type\": \"msg\", \"x\": 910, \"y\": 160, \"wires\": [ [] ] }, { \"id\": \"1c52127a.fa3556\", \"type\": \"switch\", \"z\": \"62c8c69.94b5c38\", \"name\": \"点击开关\", \"property\": \"payload.event.click_type\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"single\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"both\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"double\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"long_click_press\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 4, \"x\": 360, \"y\": 360, \"wires\": [ [ \"7dd933bb.95943c\" ], [ \"28cb228d.96e126\" ], [ \"34ab0a56.44acd6\" ], [ \"fcc8abdb.3d2cd\" ] ], \"outputLabels\": [ \"单键\", \"双键\", \"双击\", \"长按\" ] }, { \"id\": \"58414135.d6009\", \"type\": \"server-events\", \"z\": \"62c8c69.94b5c38\", \"name\": \"所有事件\", \"server\": \"734a0c31.08f244\", \"version\": 1, \"event_type\": \"\", \"exposeToHomeAssistant\": false, \"haConfig\": [ { \"property\": \"name\", \"value\": \"\" }, { \"property\": \"icon\", \"value\": \"\" } ], \"waitForRunning\": true, \"outputProperties\": [ { \"property\": \"payload\", \"propertyType\": \"msg\", \"value\": \"\", \"valueType\": \"eventData\" }, { \"property\": \"topic\", \"propertyType\": \"msg\", \"value\": \"$outputData(\\\"eventData\\\").event_type\", \"valueType\": \"jsonata\" }, { \"property\": \"event_type\", \"propertyType\": \"msg\", \"value\": \"$outputData(\\\"eventData\\\").event_type\", \"valueType\": \"jsonata\" } ], \"x\": 80, \"y\": 360, \"wires\": [ [ \"1c52127a.fa3556\" ] ] }, { \"id\": \"7dd933bb.95943c\", \"type\": \"switch\", \"z\": \"62c8c69.94b5c38\", \"name\": \"单键开关\", \"property\": \"payload.event.entity_id\", \"propertyType\": \"msg\", \"rules\": [ { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_left_158d00012a7b38\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_right_158d00012a7b38\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_left_158d00012a7b53\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_right_158d00012a7b53\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_left_158d000163a494\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_right_158d000163a494\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.switch_158d00015aaa75\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.switch_158d00011c0a7b\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_left_158d000164159e\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_right_158d000164159e\", \"vt\": \"str\" }, { \"t\": \"eq\", \"v\": \"binary_sensor.wall_switch_158d00013ff65f\", \"vt\": \"str\" } ], \"checkall\": \"true\", \"repair\": false, \"outputs\": 11, \"x\": 620, \"y\": 220, \"wires\": [ [ \"474d42ea.576f9c\" ], [ \"474d42ea.576f9c\" ], [ \"b405b932.8717f8\" ], [ \"9297fdb2.68a238\" ], [ \"234c1d79.2e1592\" ], [ \"9a2f5a1c.a59b3\" ], [ \"474d42ea.576f9c\" ], [ \"9297fdb2.68a238\" ], [ \"7cbd2cb8889553d1\" ], [], [ \"ba6b2ebf.48b028\" ] ], \"outputLabels\": [ \"次卧左\", \"次卧右\", \"主卧左\", \"主卧右\", \"阳台左\", \"阳台右\", \"次卧单击\", \"主卧单击\", \"主卧左新\", \"主卧右新\", \"\" ] }, { \"id\": \"9297fdb2.68a23","date":"2022-03-10","objectID":"/2022/03/node-red-json/:0:0","series":null,"tags":["Home Assistant"],"title":"Node-Red Json","uri":"/2022/03/node-red-json/"},{"categories":null,"content":"STEP1：https://bemfa.com/注册账号。 STEP2：打开控制台，选择MQTT设备云。 STEP3：记录下私钥。 STEP4：右上角新建主题，根据文档： 当主题名字后三位是001时为插座设备。 当主题名字后三位是002时为灯泡设备。 当主题名字后三位是003时为风扇设备。 当主题名字后三位是004时为传感器设备。 当主题名字后三位是005时为空调设备。 建议主题名字总不要长于18个字符。 这里创建一个名为：1002的主题。 进入更多设置 右上角更新小爱里你要控制的名字。这里建议使用房间名+灯名的形式。这样你喊比如“小爱同学，关书房灯”这个灯也会被关闭。 STEP5：返回home assistant，到supervisor，安装Node-red插件。 STEP6：进Node-red配置页配置，以下部分需要修改： 1.credential_secret字段配置一个随机的字母或数字即可。 2.修改ssl行为false。 3.最后加入以下代码： require_ssl: false 然后保存，之后启动addon。如果显示502: Bad Gateway，那就等半分钟再进addon。 STEP7：进Node-red，从左侧拉一个mqtt in。双击这个节点，新建MQTT服务器，如图配置。其中客户端ID为STEP3中私钥。 [STEP8：从左边拉一个debug节点，然后两个连起来。单机部署。然后返回STEP4 页面，推送一个“on”命令，看看HA中有什么反应。 STEP9：拖入一个switch节点和一个call service节点，如图配置，然后部署。 STEP10：打开小爱同学APP，下方智能家居页，右上角+，其他平台设备，跳转到米家。找到巴法，绑定巴法云账号密码，同步设备。注意以后每次在巴法云新增设备都要到米家同步一次。 STEP11：喊小爱同学，打开主卧吸顶灯。 现在您已经学会了使用小爱同学控制灯和开关（谷歌、小度音响、天猫精灵同理）。其实巴法云还支持控制风扇、空调、传感器状态轮询，但是要对其发送的内容进行分割，再使用switch分流不同情况交由不同call service处理，会比较复杂。如果对编程和JS稍有了解，应该都可以参照说明文档自己编程了。 课后作业：使用巴法云控制风扇和空调设备。 参考答案： ","date":"2022-03-10","objectID":"/2022/03/%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%88%B1%E5%90%8C%E5%AD%A6%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6home-assistant/:0:0","series":null,"tags":["Home Assistant"],"title":"使用小爱同学语音控制home assistant","uri":"/2022/03/%E4%BD%BF%E7%94%A8%E5%B0%8F%E7%88%B1%E5%90%8C%E5%AD%A6%E8%AF%AD%E9%9F%B3%E6%8E%A7%E5%88%B6home-assistant/"},{"categories":null,"content":"树莓派128G ","date":"2022-03-10","objectID":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/:0:0","series":null,"tags":["Home Assistant"],"title":"树莓派128G","uri":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/"},{"categories":null,"content":"资料 Home Assistant, (1) 系統安裝與簡單上手 https://gogoprivateryan.blogspot.com/2019/01/home-assistant-1-internet-of-things.html 安装Home Assistant踩过的坑 https://blog.csdn.net/u011738895/article/details/105755512 0.75.3 -\u003e 0.112.4 升级笔记 https://bbs.hassbian.com/thread-10764-1-1.html 官网 https://www.home-assistant.io/ ","date":"2022-03-10","objectID":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/:1:0","series":null,"tags":["Home Assistant"],"title":"树莓派128G","uri":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/"},{"categories":null,"content":"安装步骤 下载32位镜像文件 https://www.home-assistant.io/hassio/installation/ 下载balenaEtcher格式工具 https://www.balena.io/etcher 将镜像刷入tf卡 将tf卡插入nas里，在第一分区（**hassio-boot分区）**下新建CONFIG文件夹，内建network文件夹，里面放入my-network文件，写入 [connection] id=my-network uuid=f34a63d1-8dff-44a7-a65f-afa67c3e26cb type=802-11-wireless [802-11-wireless] mode=infrastructure ssid=R6900-2.4G # Uncomment below if your SSID is not broadcasted #hidden=true [802-11-wireless-security] auth-alg=open key-mgmt=wpa-psk psk=19830806 [ipv4] method=auto [ipv6] addr-gen-mode=stable-privacy method=auto 回到 CONFIG/,新建timesyncd.conf，写入以下内容 [Time] NTP=0.pool.ntp.org1.pool.ntp.org2.pool.ntp.org3.pool.ntp.org FallbackNTP=0.pool.ntp.org1.pool.ntp.org2.pool.ntp.org3.pool.ntp.org tf卡插入树莓派，开机 Add-ons内安装Mosquitto broker，不需要改参数 Add-ons内安装Node-RED，需要修改的参数为 npm_packages: - node-red-admin init_commands: - echo 'This is a test' credential_secret: xinqinew ssl: false Add-ons内安装Samba share，需要修改的参数为 username: xinqinew password: '198386' Add-ons内安装SSH \u0026 Web Terminal 集成中安装homekit桥接器 集成中安装mqtt 集成中安装broadlink ip:192.168.0.196 集成中安装xiaomi key:09C5782B397D45DA Tasmota 设置**自动发现 ** 在控制台输入 SetOption59 1 Timezone 8时区 latitude 40 longitude 117 长期口令 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJkZTE4ZTkyZjZkZjc0ZjkxOGY3YzFmNWNmZWRiZTFjMyIsImlhdCI6MTYwMDYyMjg0MiwiZXhwIjoxOTE1OTgyODQyfQ.rptUfcby3M1KexveQZ3DTJEqCzDMCNm44k0zO4PwYuQ eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJmYzgzZmNiYzk1NGE0ZDQyOWFmNDUyY2FkMjE0YTkyNCIsImlhdCI6MTYwNTg2NzUwMywiZXhwIjoxOTIxMjI3NTAzfQ.ZtnNoWlvwIrXB5wHhqZkoexNcgjL6nC1WLQzpgCCK4k 易微联设备接入home assistant教程–官方插件使用说明 原帖 https://github.com/AlexxIT/SonoffLAN#install-with-hacs 打开网址，下载sonoff的插件，丢进自定义插件文件夹config/custom_components。 集成中搜sonoff（可能需要先重启ha），输入易微联的相关账号信息登陆，一定要+86。 ","date":"2022-03-10","objectID":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/:2:0","series":null,"tags":["Home Assistant"],"title":"树莓派128G","uri":"/2022/03/%E6%A0%91%E8%8E%93%E6%B4%BE128g/"},{"categories":null,"content":"Dx系列教程1 ImGui的基础使用 ImGui主题配置 ImGui字体资源使用 实现目标：配置一个ImGui样式，加载自己喜欢的字体，关闭ImGui的布局保存文件 ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/:1:0","series":null,"tags":["ImGui"],"title":"Dx系列教程1","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/"},{"categories":null,"content":"Step1：下载ImGui源码 https://github.com/ocornut/imgui ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/:1:1","series":null,"tags":["ImGui"],"title":"Dx系列教程1","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/"},{"categories":null,"content":"Step2：打开imgui-master\\examples\\example_win32_directx11 目录 ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/:1:2","series":null,"tags":["ImGui"],"title":"Dx系列教程1","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/"},{"categories":null,"content":"Step3：运行ImGui官方Demo ​ 提示 :导入以下两个文件,尽量配置自己的风格 //默认字体配置方式 ImFont* font = io.Fonts-\u003eAddFontFromFileTTF(\"c:\\\\Windows\\\\Fonts\\\\msyh.ttc\", 18.0f, NULL, io.Fonts-\u003eGetGlyphRangesChineseFull()); //内存字体配置方式 ImFont* font = io.Fonts-\u003eAddFontFromMemoryTTF((void*)baidu_font_data, baidu_font_size, 18.0f, NULL, io.Fonts-\u003eGetGlyphRangesChineseFull()); //我的字体样式 inline static void LoadMyStype() { ImGuiStyle* style = \u0026ImGui::GetStyle(); style-\u003eWindowPadding = ImVec2(5, 5); style-\u003eWindowRounding = 0.0f; style-\u003eWindowBorderSize = 0.0f; style-\u003eFramePadding = ImVec2(5, 5); style-\u003eFrameRounding = 0.0f; style-\u003eItemSpacing = ImVec2(12, 8); style-\u003eItemInnerSpacing = ImVec2(8, 6); style-\u003eIndentSpacing = 25.0f; style-\u003eScrollbarSize = 15.0f; style-\u003eScrollbarRounding = 9.0f; style-\u003eGrabMinSize = 5.0f; style-\u003eGrabRounding = 3.0f; style-\u003eScrollbarRounding = 0.0f; style-\u003eColors[ImGuiCol_Text] = ImVec4(0.80f, 0.80f, 0.83f, 1.00f); style-\u003eColors[ImGuiCol_TextDisabled] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f); style-\u003eColors[ImGuiCol_WindowBg] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f); style-\u003eColors[ImGuiCol_ChildBg] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f); style-\u003eColors[ImGuiCol_PopupBg] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f); /*style-\u003eColors[ImGuiCol_Border] = ImVec4(0.80f, 0.80f, 0.83f, 0.88f); style-\u003eColors[ImGuiCol_BorderShadow] = ImVec4(0.92f, 0.91f, 0.88f, 0.00f);*/ style-\u003eColors[ImGuiCol_FrameBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_FrameBgHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f); style-\u003eColors[ImGuiCol_FrameBgActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_TitleBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_TitleBgCollapsed] = ImVec4(1.00f, 0.98f, 0.95f, 0.75f); style-\u003eColors[ImGuiCol_TitleBgActive] = ImVec4(0.07f, 0.07f, 0.09f, 1.00f); style-\u003eColors[ImGuiCol_MenuBarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_ScrollbarBg] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_ScrollbarGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f); style-\u003eColors[ImGuiCol_ScrollbarGrabHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_ScrollbarGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f); style-\u003eColors[ImGuiCol_CheckMark] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f); style-\u003eColors[ImGuiCol_SliderGrab] = ImVec4(0.80f, 0.80f, 0.83f, 0.31f); style-\u003eColors[ImGuiCol_SliderGrabActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f); style-\u003eColors[ImGuiCol_Button] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_ButtonHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f); style-\u003eColors[ImGuiCol_ButtonActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_Header] = ImVec4(0.10f, 0.09f, 0.12f, 1.00f); style-\u003eColors[ImGuiCol_HeaderHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_HeaderActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f); //style-\u003eColors[ImGuiCol_Column] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); //style-\u003eColors[ImGuiCol_ColumnHovered] = ImVec4(0.24f, 0.23f, 0.29f, 1.00f); //style-\u003eColors[ImGuiCol_ColumnActive] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_ResizeGrip] = ImVec4(0.00f, 0.00f, 0.00f, 0.00f); style-\u003eColors[ImGuiCol_ResizeGripHovered] = ImVec4(0.56f, 0.56f, 0.58f, 1.00f); style-\u003eColors[ImGuiCol_ResizeGripActive] = ImVec4(0.06f, 0.05f, 0.07f, 1.00f); style-\u003eColors[ImGuiCol_PlotLines] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f); style-\u003eColors[ImGuiCol_PlotLinesHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f); style-\u003eColors[ImGuiCol_PlotHistogram] = ImVec4(0.40f, 0.39f, 0.38f, 0.63f); style-\u003eColors[ImGuiCol_PlotHistogramHovered] = ImVec4(0.25f, 1.00f, 0.00f, 1.00f); style-\u003eColors[ImGuiCol_TextSelectedBg] = ImVec4(0.25f, 1.00f, 0.00f, 0.43f); style-\u003eColors[ImGuiCol_ModalWindowDarkening] = ImVec4(1.00f, 0.98f, 0.95f, 0.73f); } ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/:1:3","series":null,"tags":["ImGui"],"title":"Dx系列教程1","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1/"},{"categories":null,"content":"Dx系列教程2 ImGui的基础使用 ImGui主题配置 ImGui字体资源使用 实现目标：学会使用ImGui内部控件 绘制默认提供的几何图形和字符串 ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/:1:0","series":null,"tags":["ImGui"],"title":"Dx系列教程2","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/"},{"categories":null,"content":"内存加载字体注意需要提供参数: //字体配置 ImFontConfig f_cfg; f_cfg.FontDataOwnedByAtlas = false; const ImFont* font = io.Fonts-\u003eAddFontFromMemoryTTF((void*)baidu_font_data, baidu_font_size, 18.0f,\u0026f_cfg, io.Fonts-\u003eGetGlyphRangesChineseSimplifiedCommon()); ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/:2:0","series":null,"tags":["ImGui"],"title":"Dx系列教程2","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/"},{"categories":null,"content":"参考源码1: ImGui::Begin(u8\"你好世界 Hello, world!\"); ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None; if (ImGui::BeginTabBar(u8\"mytab\", tab_bar_flags)) { if (ImGui::BeginTabItem(\"tab1\")) { ImGui::Text(u8\"这里是1的内容\"); ImGui::EndTabItem(); } if (ImGui::BeginTabItem(\"tab2\")) { ImGui::Text(u8\"这里是2的内容\"); ImGui::EndTabItem(); } if (ImGui::BeginTabItem(\"tab3\")) { ImGui::Text(u8\"这里是3的内容\"); ImGui::EndTabItem(); } ImGui::EndTabBar(); } ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); ImGui::End(); std::string str = u8\"abcdefg123456绘制字符串\"; auto drawList = ImGui::GetOverlayDrawList(); drawList-\u003eAddRectFilled({ 100.f,100.f }, {200.f,200.f}, ImColor(255,96, 0, 255), 5.f); drawList-\u003eAddText(font, 25.f, { 250.f,100.f }, ImColor(255, 96, 0, 255), str.c_str()); ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/:3:0","series":null,"tags":["ImGui"],"title":"Dx系列教程2","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/"},{"categories":null,"content":"参考源码2 (手动锁帧): class DxTimeControl { public: //初始化函数 DxTimeControl() { s_tStart = s_tFixed = s_tLast = s_tNow = std::chrono::steady_clock::now(); s_tExceptedInvertal = std::chrono::milliseconds(15); } //初始化函数 DxTimeControl(int ms) { ms = (ms \u003c 0 || ms \u003e 20) ? 15 : ms; s_tStart = s_tFixed = s_tLast = s_tNow = std::chrono::steady_clock::now(); s_tExceptedInvertal = std::chrono::milliseconds(ms); } //析构函数 ~DxTimeControl() { } // 获取上一帧与当前帧的时间间隔（秒） float getDeltaTime() { return std::chrono::duration_cast\u003cstd::chrono::microseconds\u003e(s_tNow - s_tLast).count() / 1000.f / 1000.f; } // 获取上一帧与当前帧的时间间隔（毫秒） unsigned int getDeltaTimeMilliseconds() { return static_cast\u003cunsigned int\u003e(std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(s_tNow - s_tLast).count()); } // 获取游戏总时长（秒） float getTotalTime() { return std::chrono::duration_cast\u003cstd::chrono::microseconds\u003e(s_tNow - s_tStart).count() / 1000.f / 1000.f; } // 获取游戏总时长（毫秒） unsigned int getTotalTimeMilliseconds() { return static_cast\u003cunsigned int\u003e(std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(s_tNow - s_tStart).count()); } // 循环周期 void cycleTime(int ms) { s_tExceptedInvertal = std::chrono::milliseconds(ms); }; // 是否达到更新时间 bool isReady() { return s_tExceptedInvertal \u003c std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(s_tNow - s_tFixed); } // 更新当前时间 void updateNow() { // 刷新时间 s_tNow = std::chrono::steady_clock::now(); } // 更新时间信息 void updateLast() { s_tFixed += s_tExceptedInvertal; s_tLast = s_tNow; s_tNow = std::chrono::steady_clock::now(); } // 重置时间信息 void reset() { s_tLast = s_tFixed = s_tNow = std::chrono::steady_clock::now(); } // 挂起线程 void sleep() { // 计算挂起时长 int nWaitMS = s_tExceptedInvertal.count() - static_cast\u003cint\u003e(std::chrono::duration_cast\u003cstd::chrono::milliseconds\u003e(s_tNow - s_tFixed).count()); if (nWaitMS \u003e 1) { // 挂起线程，释放 CPU 占用 std::this_thread::sleep_for(std::chrono::milliseconds(nWaitMS)); } } private: // 游戏开始时间 std::chrono::steady_clock::time_point s_tStart; // 当前时间 std::chrono::steady_clock::time_point s_tNow; // 上一帧刷新时间 std::chrono::steady_clock::time_point s_tLast; // 固定的刷新时间 std::chrono::steady_clock::time_point s_tFixed; // 每一帧间隔 std::chrono::milliseconds s_tExceptedInvertal; }; TODO: 下节课要讲dx了,大家看下什么时dx的顶点缓存 学会使用std的一些东西,自己写个类,重写运算符TODO: 了解下11的特性 遍历器是什么,有什么用 ","date":"2022-02-15","objectID":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/:4:0","series":null,"tags":["ImGui"],"title":"Dx系列教程2","uri":"/2022/02/dx%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B2/"},{"categories":null,"content":"创建窗口 //实例1 ImGui::Begin(\"Hello, world!\"); ImGui::End(); //实例2 static bool flag = true; if(flag) { if(ImGui::Begin(\"Close Window\", \u0026flag)) { //TODO } ImGui::End(); } IMGUI_API bool Begin( const char* name, //相当于窗口的id bool* p_open = NULL, //窗口右上角的X ImGuiWindowFlags flags = 0 //样式 ); 参数1：name，相当于窗口的id，是独一无二的 参数2：p_open，如果设置这个参数，窗口的右上角就会出现一个X按钮来执行关闭窗口的功能。这个参数和X按钮绑定，当X按钮被按下时，p_open被设为false 参数3：flags，这个参数的类型实际上是int，用来指示当前窗口的某个feature是否应该激活 flags是一个整数，表示你需要的样式的和，以下是所有的flag ImGuiWindowFlags_None = 0, ImGuiWindowFlags_NoTitleBar = 1 \u003c\u003c 0, // 禁用标题栏 ImGuiWindowFlags_NoResize = 1 \u003c\u003c 1, // 禁用右下角调整功能 ImGuiWindowFlags_NoMove = 1 \u003c\u003c 2, // 禁止移动窗口 ImGuiWindowFlags_NoScrollbar = 1 \u003c\u003c 3, // Disable scrollbars (window can still scroll with mouse or programmatically) ImGuiWindowFlags_NoScrollWithMouse = 1 \u003c\u003c 4, // Disable user vertically scrolling with mouse wheel. On child window, mouse wheel will be forwarded to the parent unless NoScrollbar is also set. ImGuiWindowFlags_NoCollapse = 1 \u003c\u003c 5, // 通过双击禁止用户折叠窗口 ImGuiWindowFlags_AlwaysAutoResize = 1 \u003c\u003c 6, // Resize every window to its content every frame ImGuiWindowFlags_NoBackground = 1 \u003c\u003c 7, // Disable drawing background color (WindowBg, etc.) and outside border. Similar as using SetNextWindowBgAlpha(0.0f). ImGuiWindowFlags_NoSavedSettings = 1 \u003c\u003c 8, // Never load/save settings in .ini file ImGuiWindowFlags_NoMouseInputs = 1 \u003c\u003c 9, // Disable catching mouse, hovering test with pass through. ImGuiWindowFlags_MenuBar = 1 \u003c\u003c 10, // Has a menu-bar ImGuiWindowFlags_HorizontalScrollbar = 1 \u003c\u003c 11, // Allow horizontal scrollbar to appear (off by default). You may use SetNextWindowContentSize(ImVec2(width,0.0f)); prior to calling Begin() to specify width. Read code in imgui_demo in the \"Horizontal Scrolling\" section. ImGuiWindowFlags_NoFocusOnAppearing = 1 \u003c\u003c 12, // Disable taking focus when transitioning from hidden to visible state ImGuiWindowFlags_NoBringToFrontOnFocus = 1 \u003c\u003c 13, // Disable bringing window to front when taking focus (e.g. clicking on it or programmatically giving it focus) ImGuiWindowFlags_AlwaysVerticalScrollbar= 1 \u003c\u003c 14, // Always show vertical scrollbar (even if ContentSize.y \u003c Size.y) ImGuiWindowFlags_AlwaysHorizontalScrollbar=1\u003c\u003c 15, // Always show horizontal scrollbar (even if ContentSize.x \u003c Size.x) ImGuiWindowFlags_AlwaysUseWindowPadding = 1 \u003c\u003c 16, // Ensure child windows without border uses style.WindowPadding (ignored by default for non-bordered child windows, because more convenient) ImGuiWindowFlags_NoNavInputs = 1 \u003c\u003c 18, // No gamepad/keyboard navigation within the window ImGuiWindowFlags_NoNavFocus = 1 \u003c\u003c 19, // No focusing toward this window with gamepad/keyboard navigation (e.g. skipped by CTRL+TAB) ImGuiWindowFlags_UnsavedDocument = 1 \u003c\u003c 20, // Append '*' to title without affecting the ID, as a convenience to avoid using the ### operator. When used in a tab/docking context, tab is selected on closure and closure is deferred by one frame to allow code to cancel the closure (with a confirmation popup, etc.) without flicker. ImGuiWindowFlags_NoNav = ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus, ImGuiWindowFlags_NoDecoration = ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize | ImGuiWindowFlags_NoScrollbar | ImGuiWindowFlags_NoCollapse, ImGuiWindowFlags_NoInputs = ImGuiWindowFlags_NoMouseInputs | ImGuiWindowFlags_NoNavInputs | ImGuiWindowFlags_NoNavFocus, // [Internal] ImGuiWindowFlags_NavFlattened = 1 \u003c\u003c 23, // [BETA] Allow gamepad/keyboard navigation to cross over parent border to this child (only use on child that have no scrolling!) ImGuiWindowFlags_ChildWindow = 1 \u003c\u003c 24, // Don't use! For internal use by BeginChild() ImGuiWindowFlags_Tooltip = 1 \u003c\u003c 25, // Don't use! For internal use by BeginTooltip() ImGuiWindowFlags_Popup = 1 \u003c\u003c 26, // Don't use! For internal use by BeginPopup() ImGuiWindowFlags_Modal = 1 \u003c\u003c 27, // Don't use! For internal use by BeginPopupModal() ImGuiWindowFlags_ChildMenu = 1 \u003c\u003c 28 // Don't use! For internal use by BeginMenu() 以上内容在im","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Demo窗口 ImGui::ShowDemoWindow(); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"主菜单栏 //ImGui::BeginMainMenuBar(); //ImGui::EndMainMenuBar(); if (ImGui::BeginMainMenuBar()) { if (ImGui::BeginMenu(\"File\")) { if (ImGui::MenuItem(\"Quit\", \"Alt+F4\")) break; ImGui::EndMenu(); } if (ImGui::BeginMenu(\"Edit\")) { if( ImGui::MenuItem(\"TODO\") ){ //do something } ImGui::EndMenu(); } ImGui::EndMainMenuBar(); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"菜单(横排)与菜单项(竖排) if (ImGui::BeginMenu(\"Test Menu\"))//菜单(横排) { ImGui::Menultem(\"Test Menu Item\", NULL, new bool(true));//菜单项(竖排) ImGui::EndMenu(); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"次菜单栏 ImGui::BeginMenuBar(); ImGui::EndMenuBar(); 通过BeginMenuBar()和BeginMenu()来分别定制顶部菜单栏和对应的下拉菜单栏的内容； 注意任意的beginXXX都要对应一个endXXX static bool no_close = false; bool p_open = true; ImGuiWindowFlags JR_window_flags = 0; JR_window flags = ImGuiWindowFlags MenuBar; if (!ImGui::Begin (\"HelloWindow\", \u0026p_open, JR_window_flags)) { ImGui::End(); return 0; } if (ImGui::BeginMenuBar()) { if (ImGui::BeginMenu(\"Test Menu\")) { ImGui::Menultem(\"Test Menu Item\",. NULL, new bool(true)); ImGui::EndMenu(); } ImGui::EndMenuBar(); } ImGui::End(); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Text及Text各种效果 //Text 与 禁用的Text ImGui::Text(\"Text\"); ImGui::TextDisabled(\"Disabled text\"); //格式字串 ImGui::Text(\"haha%d\", 123); //颜色 ImGui::TextColored(ImVec4(255, 0, 0, 255), \"red\"); ImGui::TextColored(ImVec4(0, 255, 0, 255), \"blue\"); ImGui::TextColored(ImVec4(0, 0, 255, 255), \"green\"); ImGui::TextColored(ImVec4(128, 128, 128, 255), \"grey\"); //项目文字(前面带点) ImGui::BulletText(\"aaa\"); ImGui::BulletText(\"bbb\"); ImGui::BulletText(\"ccc\"); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"按钮及事件 if(ImGui::Button(\"I am a Button\")) { // 按钮事件 } ImGui::SameLine();//不换行 //颜色 ImGui::PushStyleColor(ImGuiCol_Button, (ImVec4)ImColor::HSV(0.0f, 0.6f, 0.6f)); ImGui::PushStyleColor(ImGuiCol_ButtonHovered, (ImVec4)ImColor::HSV(0.0f, 0.7f, 0.7f)); ImGui::PushStyleColor(ImGuiCol_ButtonActive, (ImVec4)ImColor::HSV(0.0f, 0.8f, 0.8f)); ImGui::Button(\"Red\"); ImGui::PopStyleColor(3); //箭头按钮 ImGui::ArrowButton(\"##Left\", ImGuiDir_Left);ImGui::SameLine();//不换行 ImGui::ArrowButton(\"##Right\", ImGuiDir_Right); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:7:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"单选框 //实例1 static int a = 0; ImGui::RadioButton(\"RadioButton0\", \u0026a, 0); ImGui::RadioButton(\"RadioButton1\", \u0026a, 1); ImGui::RadioButton(\"RadioButton2\", \u0026a, 2); switch (a) { case 0: printf(\"多选框0被选中\"); break; case 1: printf(\"多选框1被选中\"); break; case 2: printf(\"多选框2被选中\"); break; } //实例2 static int select = -1; ImGui::RadioButton(\"Zero\", \u0026select, 0); ImGui::SameLine(); ImGui::RadioButton(\"One\", \u0026select, 1); ImGui::SameLine(); ImGui::RadioButton(\"Two\", \u0026select, 2); if(select \u003e= 0) { ImGui::Text(\"You Select %d\\n\", select); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:8:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"复选框 //实例1 static bool b = false; ImGui::Checkbox(\"CheckBoxB\", \u0026b); static bool c = false; ImGui::Checkbox(\"CheckBoxC\", \u0026c); //实例2 static bool flag = false; if(ImGui::Checkbox(\"FirstBox\", \u0026flag)) { // do something } if(flag) ImGui::Text(\"the box has been checked\"); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:9:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"折叠框控件 if (ImGui::CollapsingHeader(u8\"文本框\")) { //Todo } if (ImGui::TreeNode(u8\"滑块\")) { //Todo ImGui::TreePop(); } //区别 //CollapsingHeader整个按钮可以点击 //TreeNode只有文字可以点击 ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:10:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"文本框 ImGui::Text(\"Text1\"); ImGui::BulletText(\"Text2\");//文本前有个圆圈 HelpMarker(\"This is a helpMaker\"); static void HelpMarker(const char* desc) { ImGui::TextDisabled(\"(?)\"); if (ImGui::IsItemHovered()) { ImGui::BeginTooltip(); ImGui::PushTextWrapPos(ImGui::GetFontSize() * 35.0f); ImGui::TextUnformatted(desc); ImGui::PopTextWrapPos(); ImGui::EndTooltip(); } } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:11:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"滑块 //实例1 float f = 0.f; ImGui::SliderFloat(\"FloatSlider\", \u0026f, 0.f, 1.f); static int e = 0; ImGui::SliderInt(\"IntSlider\", \u0026e, 0, 100); //非常简单的两个函数 const char* label, float* v, float v_min, float v_max const char* label, int* v, int v_min, int v_max //实例2 static float x = 0.f; static float y = 0.f; static int radius = 0; ImGui::SliderFloat(\"x\",\u0026x,0.f,1080.f); ImGui::SliderFloat(\"y\",\u0026y,0.f,720.f); ImGui::SliderInt(\"Size\",\u0026radius,0,100); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:12:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"Tab菜单(横向子菜单) ImGuiTabBarFlags tab_bar_flags = ImGuiTabBarFlags_None; if (ImGui::BeginTabBar(\"MyTabBar\", tab_bar_flags)) { if (ImGui::BeginTabItem(\"Avocado\")) { ImGui::Text(\"This is the Avocado tab!\\nblah blah blah blah blah\"); ImGui::EndTabItem(); } if (ImGui::BeginTabItem(\"Broccoli\")) { ImGui::Text(\"This is the Broccoli tab!\\nblah blah blah blah blah\"); ImGui::EndTabItem(); } if (ImGui::BeginTabItem(\"Cucumber\")) { ImGui::Text(\"This is the Cucumber tab!\\nblah blah blah blah blah\"); ImGui::EndTabItem(); } ImGui::EndTabBar(); } ImGui::Separator(); ImGui::TreePop(); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:13:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"显示中文 ImFont* font = io.Fonts-\u003eAddFontFromFileTTF( \"c:\\\\Windows\\\\Fonts\\\\msyh.ttc\", //字体文件 18.0f, //控制字体大小 NULL, io.Fonts-\u003eGetGlyphRangesChineseFull() //中文 ); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:14:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"内存加载字体 #include \"baidu_font.hpp\" ImFontConfig f_cfg; f_cfg.FontDataOwnedByAtlas = false; ImFont* font = io.Fonts-\u003eAddFontFromMemoryTTF( (void*)baidu_font_data, //字体文件 baidu_font_size, 18.0f, //控制字体大小 \u0026f_cfg, io.Fonts-\u003eGetGlyphRangesChineseFull() //中文 ); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:14:1","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"生成字体 #终端下运行 binary_to_compressed_c.exe -nocompress baidu.ttf baidu_font \u003e baidu_font.hpp ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:14:2","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"设置不同控件的颜色 ImGuiStyle* style = \u0026ImGui::GetStyle();//先拿到样式指针 // ImColor();//参数123 对应RGB值 参数4对应透明度 0为完全透明 和窗口背景同一个颜色 style-\u003eColors[ImGuiCol_Button] = ImColor(84, 255, 159, 255);//按钮闲置状态下的颜色 style-\u003eColors[ImGuiCol_ButtonActive] = ImColor(255, 0, 0, 255);//按钮按下时候的颜色 style-\u003eColors[ImGuiCol_ButtonHovered] = ImColor(41, 40, 41, 255);//当鼠标放在按钮上的颜色 //一些其他常用控件 style-\u003eColors[ImGuiCol_TitleBg] = ImColor(84 ,255 ,159,255); style-\u003eColors[ImGuiCol_TitleBgActive] = ImColor(255, 0, 0, 255); style-\u003eColors[ImGuiCol_TitleBgCollapsed] = ImColor(0, 0, 0, 130); style-\u003eColors[ImGuiCol_Separator] = ImColor(70, 70, 70, 255); style-\u003eColors[ImGuiCol_SeparatorActive] = ImColor(76, 76, 76, 255); style-\u003eColors[ImGuiCol_SeparatorHovered] = ImColor(76, 76, 76, 255); style-\u003eColors[ImGuiCol_FrameBg] = ImColor(37, 36, 37, 255); style-\u003eColors[ImGuiCol_FrameBgActive] = ImColor(37, 36, 37, 255); style-\u003eColors[ImGuiCol_FrameBgHovered] = ImColor(37, 36, 37, 255); style-\u003eColors[ImGuiCol_Header] = ImColor(0, 0, 0, 0); style-\u003eColors[ImGuiCol_HeaderActive] = ImColor(0, 0, 0, 0); style-\u003eColors[ImGuiCol_HeaderHovered] = ImColor(46, 46, 46, 255); style-\u003eColors[ImGuiCol_Tab] = ImColor(0, 0, 0, 0); style-\u003eColors[ImGuiCol_TabActive] = ImColor(255, 0, 0, 255); style-\u003eColors[ImGuiCol_TabHovered] = ImColor(255, 0, 0, 255); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:15:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"设置不同控件的样式 ImGui::PushStyleVar(ImGuiStyleVar_FrameRounding, 12.0f); ImGui::PushStyleVar(ImGuiStyleVar_GrabRounding, 22.0f); ImGuiStyle* style = \u0026ImGui::GetStyle();//先拿到样式指针 style-\u003eFrameRounding = f; style-\u003eFrameBorderSize = 12.0f; style-\u003eGrabRounding = 12.0f; style-\u003eWindowMinSize = ImVec2(100, 600); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:16:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"绘制线 ImGui::GetForegroundDrawList()-\u003eAddLine( ImVec2(800, 300), //参数1是 x1,y1,也可以写成{800,300} 就不需要这个 ImVec2这个 ImVec2(900, 300), //参数2是 x2,y2 ImColor(84, 255, 159, 255), //参数3是颜色 RGB值和透明度 1.0f //参数4是线条粗细 ); ImGui::GetForegroundDrawList()-\u003eAddLine({ 800,300 }, { 800,400 }, ImColor(84, 255, 159, 255), 1.0f); ImGui::GetForegroundDrawList()-\u003eAddLine({ 900,300 }, { 900,400 }, ImColor(84, 255, 159, 255), 1.0f); ImGui::GetForegroundDrawList()-\u003eAddLine({ 800,400 }, { 900,400 }, ImColor(84, 255, 159, 255), 1.0f); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:17:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"绘制四边形 ImGui::GetForegroundDrawList()-\u003eAddRect( {650,300}, //左上角 {750,400}, //右下角 ImColor(84, 255, 159, 255),//颜色 5.f //圆角弧度 ); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:18:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"绘制文字 auto DrawList = ImGui::GetForegroundDrawList(); DrawList-\u003eAddText(font, font-\u003eFontSize, ImVec2(400, 400), ImColor(255, 255, 255, 255), u8\"你好世界 hello world 123\"); DrawList-\u003eAddText(font1, font1-\u003eFontSize, ImVec2(400, 450), ImColor(84, 255, 159, 255), u8\"我真帅\"); //参数1 是字体指针 //参数2 是字体大小 //参数3 是绘制字体的坐标 //参数4 是字体颜色 //参数5 是要绘制的文字 如果想要绘制中文 记得加上u8 ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:19:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"绘制图片 DrawList-\u003eAddImage( m_srv, //ImTextureTD 图像纹理 {200,200}, //矩形的左上角 {300,300}, //矩形的右下角 {0,0}, //剪切 0-1的小数，表示要渲染的图片在材质的位置 {1,1}, //剪切 0-1的小数，表示要渲染的图片在材质的位置 ImColor(255, 255, 255, 255) //颜色及透明度 ); 首先必须导入stb_image.h //在文件头部包含以下内容 #define STB_IMAGE_IMPLEMENTATION #include \"stb_image.h\" 在适当的位置添加函数LoadTextureFromFile bool LoadTextureFromFile(const char* filename, ID3D11ShaderResourceView** out_srv, int* out_width, int* out_height) { // Load from disk into a raw RGBA buffer int image_width = 0; int image_height = 0; unsigned char* image_data = stbi_load(filename, \u0026image_width, \u0026image_height, NULL, 4); if (image_data == NULL) return false; // Create texture D3D11_TEXTURE2D_DESC desc; ZeroMemory(\u0026desc, sizeof(desc)); desc.Width = image_width; desc.Height = image_height; desc.MipLevels = 1; desc.ArraySize = 1; desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; desc.SampleDesc.Count = 1; desc.Usage = D3D11_USAGE_DEFAULT; desc.BindFlags = D3D11_BIND_SHADER_RESOURCE; desc.CPUAccessFlags = 0; ID3D11Texture2D *pTexture = NULL; D3D11_SUBRESOURCE_DATA subResource; subResource.pSysMem = image_data; subResource.SysMemPitch = desc.Width * 4; subResource.SysMemSlicePitch = 0; g_pd3dDevice-\u003eCreateTexture2D(\u0026desc, \u0026subResource, \u0026pTexture); // Create texture view D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc; ZeroMemory(\u0026srvDesc, sizeof(srvDesc)); srvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM; srvDesc.ViewDimension = D3D11_SRV_DIMENSION_TEXTURE2D; srvDesc.Texture2D.MipLevels = desc.MipLevels; srvDesc.Texture2D.MostDetailedMip = 0; g_pd3dDevice-\u003eCreateShaderResourceView(pTexture, \u0026srvDesc, out_srv); pTexture-\u003eRelease(); *out_width = image_width; *out_height = image_height; stbi_image_free(image_data); return true; } 在需要绘制图片的地方引用以下代码 int my_image_width = 0; int my_image_height = 0; ID3D11ShaderResourceView* my_texture = NULL; bool ret = LoadTextureFromFile(\"d:/ccz.jpg\", \u0026my_texture, \u0026my_image_width, \u0026my_image_height); //bool ret = LoadTextureFromFile(\"./sources/MyImage01.jpg\", \u0026my_texture, \u0026my_image_width, \u0026my_image_height); IM_ASSERT(ret); ImGui::Image((void*)my_texture, ImVec2(my_image_width, my_image_height)); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:20:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"初始化交换链 void InitSwapChain() { AllocConsole(); freopen(\"CON\", \"w\", stdout); SetConsoleTitle((LPCWSTR)\"Hello World\"); //交接链 DXGI_SWAP_CHAIN_DESC scd; ZeroMemory(\u0026scd, sizeof(DXGI_SWAP_CHAIN_DESC)); scd.BufferCount = 1;//设置后缓冲 scd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//设置颜色格式为RGBA scd.BufferDesc.Scaling = DXGI_MODE_SCALING_UNSPECIFIED;//缩放比 scd.BufferDesc.ScanlineOrdering = DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED;//扫描线 scd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;//渲染目标输出 scd.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;//允许模式切换 scd.OutputWindow = g_GamehWnd;//在目标窗口内部绘制另外一个窗口 scd.SampleDesc.Count = 1;//1重采样 scd.SwapEffect = DXGI_SWAP_EFFECT_DISCARD;//常用参数 scd.Windowed = ((GetWindowLongPtr(g_GamehWnd, GWL_STYLE) \u0026 WS_POPUP) != 0) ? FALSE : TRUE; //是否全屏，随目标窗口变化而定 scd.BufferDesc.Width = 1920; scd.BufferDesc.Height = 1080; scd.BufferDesc.RefreshRate.Numerator = 144; //刷新率 scd.BufferDesc.RefreshRate.Denominator = 1; //分母 scd.SampleDesc.Quality = 0; //采样等级 D3D_FEATURE_LEVEL featrueLevel = D3D_FEATURE_LEVEL_11_0; D3D11CreateDeviceAndSwapChain( NULL, D3D_DRIVER_TYPE_HARDWARE, NULL, NULL, \u0026featrueLevel, 1, D3D11_SDK_VERSION, \u0026scd, \u0026pSwapChain, \u0026pDevice, NULL, \u0026pContext); printf(\"hWnd=%X\\n\", g_GamehWnd); printf(\"pSwapChain=%X\\n\", pSwapChain); printf(\"pDevice=%X\\n\", pDevice); printf(\"pContext=%X\\n\", pContext); } BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: ::CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)InitSwapChain, NULL, NULL, NULL); case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:21:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"利用Detours库挂钩MessageBoxA DetourTransactionBegin();//开始HOOK DetourUpdateThread(GetCurrentThread());//刷新当前线程 DetourAttach((PVOID*) \u0026pPointer, pDetour);//要HOOK的函数的函数的地址,以及你自定义的函数的函数地址. DetourTransactionCommit();//提交HOOK 到此为止 HOOK完成 DetourTransactionBegin(); DetourUpdateThread(GetCurrentThread()); DetourDetach((PVOID*) \u0026pPointer, pDetour); DetourTransactionCommit(); int (WINAPI* Real_MessageBoxA)(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType) = MessageBoxA; int WINAPI My_MessageBoxA(_In_opt_ HWND hWnd, _In_opt_ LPCSTR lpText, _In_opt_ LPCSTR lpCaption, _In_ UINT uType) { //return 之前 我们就可以做一些 想要做的事情 lpText = \"Hello World\"; lpCaption = \"111111\"; return Real_MessageBoxA(hWnd, lpText, lpCaption, uType); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:22:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"利用Detours库挂钩游戏Present函数 LONG_PTR* pSwapChainVT = (LONG_PTR*)(pSwapChain);//拿到虚表指针 pSwapChainVT = (LONG_PTR*) (pSwapChainVT[0]); phookD3D11Present = (tD3D11Present)(pSwapChainVT[8]); typedef HRESULT(__stdcall* tD3D11Present) (IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags); static tD3D11Present phookD3D11Present = NULL; HRESULT __stdcall My_D3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) { //做一些自己想要做的事情 //比如一些绘制操作 //比如一些画ui的操作 printf(\"123123\"); return phookD3D11Present(pSwapChain, SyncInterval, Flags); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:23:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"ImGui的初始化 void InitImGui() { ImGui::CreateContext(); ImGuiIO\u0026 io = ImGui::GetIO(); ImFont* font = io.Fonts-\u003eAddFontFromMemoryTTF((void*)alifont_data, alifont_size, 17.0f, NULL, io.Fonts-\u003eGetGlyphRangesChineseFull()); ImGuiStyle* style = \u0026ImGui::GetStyle(); } HRESULT __stdcall My_D3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) { //做一些自己想要做的事情 //比如一些绘制操作 //比如一些画ui的操作 static bool bOnce = false; if (!bOnce) { bOnce = true; //在这个里面 做一些初始化的操作 InitImGui();//初始化IMGUI //这个开关里面 只做 只执行一次的操作 printf(\"bOnce\\n\"); } // 我们可以做一些 需要一直重复的操作 // 比如 我们绘制外挂页面 // 这里到时候就写 绘制外挂页面的代码 printf(\"121123\\n\"); return phookD3D11Present(pSwapChain, SyncInterval, Flags); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:24:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"在游戏内部绘制外挂页面 ID3D11Device* pDevice = NULL;//设备指针 ID3D11DeviceContext* pContext = NULL;//交换链条 IDXGISwapChain* pSwapChain = NULL; //交换链 ID3D11RenderTargetView* g_pRenderTargetView = NULL; HRESULT __stdcall My_D3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) { //做一些自己想要做的事情 //比如一些绘制操作 //比如一些画ui的操作 static bool bOnce = false; if (!bOnce) { bOnce = true; //在这个里面 做一些初始化的操作 InitImGui();//初始化IMGUI //这个开关里面 只做 只执行一次的操作 printf(\"bOnce\\n\"); if (SUCCEEDED(pSwapChain-\u003eGetDevice(__uuidof(ID3D11Device), (void**)(\u0026pDevice)))) { pDevice-\u003eGetImmediateContext(\u0026pContext); }ID3D11Texture2D* renderTargetTexture = nullptr; //获取了缓冲区的地址 if (SUCCEEDED(pSwapChain-\u003eGetBuffer(0, __uuidof(ID3D11Texture2D), (PVOID*)(\u0026renderTargetTexture)))) { //创建目标视图 pDevice-\u003eCreateRenderTargetView(renderTargetTexture, NULL, \u0026g_pRenderTargetView); //释放后缓冲 renderTargetTexture-\u003eRelease(); } //初始化DX11 ImGui_ImplWin32_Init(g_GamehWnd); ImGui_ImplDX11_Init(pDevice, pContext); ImGui_ImplDX11_CreateDeviceObjects(); } //绑定到渲染管线 pContext-\u003eOMSetRenderTargets(1, \u0026g_pRenderTargetView, NULL); ImGui_ImplDX11_NewFrame(); ImGui_ImplWin32_NewFrame(); ImGui::NewFrame(); { //在这里写上我们需要的窗口代码 ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_FirstUseEver); ImGui::SetNextWindowSize(ImVec2(100, 200)); ImGui::Begin(\"Menu\"); ImGui::End(); } ImGui::EndFrame(); ImGui::Render(); ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData()); // 我们可以做一些 需要一直重复的操作 // 比如 我们绘制外挂页面 // 这里到时候就写 绘制外挂页面的代码 printf(\"121123\\n\"); return phookD3D11Present(pSwapChain, SyncInterval, Flags); } HRESULT __stdcall My_D3D11Present(IDXGISwapChain* pSwapChain, UINT SyncInterval, UINT Flags) { //做一些自己想要做的事情 //比如一些绘制操作 //比如一些画ui的操作 static bool bOnce = false; if (!bOnce) { bOnce = true; //在这个里面 做一些初始化的操作 InitImGui();//初始化IMGUI //这个开关里面 只做 只执行一次的操作 printf(\"bOnce\\n\"); if (SUCCEEDED(pSwapChain-\u003eGetDevice(__uuidof(ID3D11Device), (void**)(\u0026pDevice)))) { pDevice-\u003eGetImmediateContext(\u0026pContext); }ID3D11Texture2D* renderTargetTexture = nullptr; //获取了缓冲区的地址 if (SUCCEEDED(pSwapChain-\u003eGetBuffer(0, __uuidof(ID3D11Texture2D), (PVOID*)(\u0026renderTargetTexture)))) { //创建目标视图 pDevice-\u003eCreateRenderTargetView(renderTargetTexture, NULL, \u0026g_pRenderTargetView); //释放后缓冲 renderTargetTexture-\u003eRelease(); } //初始化DX11 ImGui_ImplWin32_Init(g_GamehWnd); ImGui_ImplDX11_Init(pDevice, pContext); ImGui_ImplDX11_CreateDeviceObjects(); } //绑定到渲染管线 pContext-\u003eOMSetRenderTargets(1, \u0026g_pRenderTargetView, NULL); ImGui_ImplDX11_NewFrame(); ImGui_ImplWin32_NewFrame(); ImGui::NewFrame(); { //在这里写上我们需要的窗口代码 ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_FirstUseEver); ImGui::SetNextWindowSize(ImVec2(100, 200)); ImGui::Begin(\"Menu\"); ImGui::End(); } ImGui::EndFrame(); ImGui::Render(); ImGui_ImplDX11_RenderDrawData(ImGui::GetDrawData()); // 我们可以做一些 需要一直重复的操作 // 比如 我们绘制外挂页面 // 这里到时候就写 绘制外挂页面的代码 printf(\"121123\\n\"); return phookD3D11Present(pSwapChain, SyncInterval, Flags); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:25:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"添加ImGui窗口消息响应 UINT_PTR oldWndProc = 0; LRESULT WINAPI WndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam) { extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam); ImGui_ImplWin32_WndProcHandler(hWnd, msg, wParam, lParam); return CallWindowProc((WNDPROC)oldWndProc, hWnd, msg, wParam, lParam); } oldWndProc = SetWindowLongPtrA(g_GamehWnd, GWLP_WNDPROC, (LONG)WndProc); ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:26:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"TabBar控件 ImGui::SetNextWindowPos(ImVec2(0, 0), ImGuiCond_FirstUseEver); ImGui::SetNextWindowSize(ImVec2(200, 400)); if (ImGui::Begin(\"Menu\")) { Menu:oadTab(); ImGui::End(); } void Menu:oadTab() { if (ImGui::BeginTabBar(\"TabBar\")); { if (ImGui::BeginTabItem(u8\"使用说明\")) { ImGui::Text(u8\"我是一个文本框\"); ImGui::EndTabItem(); } if (ImGui::BeginTabItem(u8\"功能设置\")) { if (ImGui::CollapsingHeader(u8\"人物透视\")) { static bool b = true; ImGui::Checkbox(u8\"显示骨骼\", \u0026b); static bool c = true; ImGui::Checkbox(u8\"显示方框\", \u0026c); static bool d = true; ImGui::Checkbox(u8\"显示血量\", \u0026d); static bool e = true; ImGui::Checkbox(u8\"显示护甲\", \u0026e); } if (ImGui::CollapsingHeader(u8\"物品透视\")) { static int a = 0; ImGui::RadioButton(u8\"透视金堆\", \u0026a, 0); ImGui::SameLine(); ImGui::RadioButton(u8\"透视盒子\", \u0026a, 111); } ImGui::EndTabItem(); } ImGui::EndTabBar(); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:27:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"远线程注入 使用进程PID打开进程,获得句柄 使用进程句柄申请内存空间 把dll路径写入内存 创建远程线程,调用LoadLibrary 释放收尾工作或者卸载dll bool RemoteThreadInject(DWORD dwPid) { //1.使用PID打开进程获取权限 HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, NULL, dwPid); printf(\"hProcess=%d\",hProcess); //2.申请内存,写入DLL路径 int nLen = sizeof(WCHAR) * (wcslen(L\"D:\\\\DetoursDemo.dll\") + 1); LPVOID pBuf = VirtualAllocEx(hProcess, NULL, nLen, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE); if (!pBuf) { printf(\"申请内存失败！\\n\"); return false; } else { printf(\"申请内存成功! \\n\"); } //3.写入内存 SIZE_T dwWrite = 0; if (!WriteProcessMemory(hProcess, pBuf, \"D:\\\\DetoursDemo.dll\", nLen, \u0026dwWrite)) { printf(\"写入内存失败！\\n\"); return false; }else { printf(\"写入内存成功! \\n\"); } //4.创建远程线程，让对方调用LoadLibrary HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, pBuf, 0, 0); //5.等待线程结束返回,释放资源 WaitForSingleObject(hRemoteThread, -1); CloseHandle(hRemoteThread); VirtualFreeEx(hProcess, pBuf, 0, MEM_FREE); return true; } int main() { HWND Gameh = FindWindowA(\"Direct3DWindowClass\", \"EmptyProject11\"); DWORD pid = 0; if (Gameh != 0) { GetWindowThreadProcessId(Gameh,\u0026pid); printf(\"Gameh=%d pid=%d\\n\", Gameh, pid); if (pid != 0) { RemoteThreadInject(pid); } } getchar(); } 最好是 既然学了ImGui 最好用ImGui来写一个启动程序 ImGui 肯定是要比我们课堂上演示的黑框框要高大上很多 ","date":"2022-02-15","objectID":"/2022/02/imgui%E5%87%BD%E6%95%B0/:28:0","series":null,"tags":["ImGui"],"title":"ImGui","uri":"/2022/02/imgui%E5%87%BD%E6%95%B0/"},{"categories":null,"content":"ImGui表格用法 https://github.com/ocornut/imgui/issues/3740 ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:1:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"典型流程： 调用BeginTable（）。 可选择调用TableSetupColumn()提交列名/标志/默认值。 可选地调用TableSetupScrollFreeze()来请求对列/行进行滚动冻结。 可选择调用TableHeadersRow()提交标题行。名称从TableSetupColumn()数据中提取。 填充内容： 在大多数情况下，您可以使用TableNextRow() + TableSetColumnIndex(N)开始附加到列中。 如果您使用表格作为一种网格，其中每列都包含相同类型的内容， 您可能更喜欢使用 TableNextColumn() 而不是 TableNextRow() + TableSetColumnIndex()。 如果需要，TableNextColumn()将自动包裹到下一行中。 重要信息：与旧的Colums() API相比，我们需要为第一列调用TableNextColumn()！ 可能的呼叫流程摘要： TableNextRow() -\u003e TableSetColumnIndex(0) -\u003e Text(“Hello 0”) -\u003e TableSetColumnIndex(1) -\u003e Text(“Hello 1”) // OK TableNextRow() -\u003e TableNextColumn() -\u003e Text(“Hello 0”) -\u003e TableNextColumn() -\u003e Text(“Hello 1”) // OK TableNextColumn() -\u003e Text(“Hello 0”) -\u003e TableNextColumn() -\u003e Text(“Hello 1”) // OK：TableNextColumn()会自动进入下一行！ TableNextRow() -\u003e Text(“Hello 0”) // 不行！缺少TableSetColumnIndex（）或TableNextColumn（）！文本不会出现！ 呼叫EndTable（） ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:2:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"简易实例 //在这里，我们将展示三种不同的输出表的方法。 //它们是同样事物的非常简单的变体！ // [方法1]使用TableNextRow()创建新行，使用TableSetColumnIndex()选择列。 // 在许多情况下，这是最灵活、最易于使用的模式 if (ImGui::BeginTable(\"table1\", 3)) { for (int row = 0; row \u003c 4; row++) { ImGui::TableNextRow(); for (int column = 0; column \u003c 3; column++) { ImGui::TableSetColumnIndex(column); ImGui::Text(\"Row %d Column %d\", row, column); } } ImGui::EndTable(); } // [方法2]使用多次调用的TableNextColumn()，而不是使用for循环+ TableSetColumnIndex()。 // 当您有代码手动提交每列的内容时，这通常更方便。 if (ImGui::BeginTable(\"table2\", 3)) { for (int row = 0; row \u003c 4; row++) { ImGui::TableNextRow(); ImGui::TableNextColumn(); ImGui::Text(\"Row %d\", row); ImGui::TableNextColumn(); ImGui::Text(\"Some contents\"); ImGui::TableNextColumn(); ImGui::Text(\"123.456\"); } ImGui::EndTable(); } // [方法3]我们调用TableNextColumn() _before_每个单元格。我们从不调用TableNextRow() // 因为TableNextColumn()将自动包裹并根据需要创建新的鱼子。 // 当您的单元格都包含相同类型的数据时，这通常更方便。 if (ImGui::BeginTable(\"table3\", 3)) { for (int item = 0; item \u003c 14; item++) { ImGui::TableNextColumn(); ImGui::Text(\"Item %d\", item); } ImGui::EndTable(); } ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:3:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"API (as of January 2021) // 开始附加到表格中。仅当BeginTable（）返回true时调用EndTable()！ bool BeginTable(const char* str_id, int columns, ImGuiTableFlags flags = 0, const ImVec2\u0026 outer_size = ImVec2(0.0f, 0.0f), float inner_width = 0.0f); void EndTable(); // 附加到新行的第一个单元格中。 void TableNextRow(ImGuiTableRowFlags row_flags = 0, float min_row_height = 0.0f); // 附加到下一列（如果当前在最后一列，则附加到下一行的第一列）。当 bool TableNextColumn();//列可见。 // 附加到指定的列中。当列可见时返回true。 bool TableSetColumnIndex(int column_n); //表格：标题和列声明 // - 使用TableSetupColumn()指定标签、调整大小策略、默认宽度/重量、ID、各种其他标志等。 // - 使用 TableHeadersRow() 创建一个标题行，并自动为每列提交 TableHeader()。 // 需要标头才能执行：重新排序、排序和打开上下文菜单。 // 上下文菜单也可以使用ImGuiTableFlags_ContextMenuInBody在列正文中提供。 // - 您可以使用TableNextRow() + TableHeader()调用手动提交标头，但这仅在 //一些高级用例（例如，在标题行中添加自定义小部件）。 // - 使用TableSetupScrollFreeze()锁定列/行，以便它们在滚动时保持可见。 void TableSetupColumn(const char* label, ImGuiTableColumnFlags flags = 0, float init_width_or_weight = 0.0f, ImU32 user_id = 0); void TableSetupScrollFreeze(int cols, int rows); //锁定列/行，以便它们在滚动时保持可见。 void TableHeadersRow(); // 根据提供给 TableSetupColumn() + 提交上下文菜单的数据提交所有标头单元格 void TableHeader(const char* label); //手动提交一个标题单元格（很少使用） //表格：排序 // - 调用TableGetSortSpecs()来检索表的最新排序规范。不排序时为空。 // - 当'SpecsDirty == true'时，您应该对数据进行排序。当分类规格发生变化时，情况确实如此 // 自上次通话以来，或第一次。排序后，请务必设置“SpecsDirty = false”，否则您可以 // 浪费地对每一帧的数据进行排序！ // - 终身：不要在多个帧上按住此指针，也不要超过对BeginTable()的任何后续调用。 ImGuiTableSortSpecs* TableGetSortSpecs(); // 获取表的最新排序规范（如果不排序，则为NULL）。 //表格：杂项函数 // - 函数args 'int column_n'将-1的默认值视为传递当前列索引。 int TableGetColumnCount(); // 返回列数（值传递给 BeginTable） int TableGetColumnIndex(); // 返回当前列索引。 int TableGetRowIndex(); // 返回当前行索引。 const char* TableGetColumnName(int column_n = -1); // 如果列没有TableSetupColumn()声明的名称，则返回\"。通过-1使用当前列 ImGuiTableColumnFlags TableGetColumnFlags(int column_n = -1); // 返回列标志，以便您可以查询其启用/可见/排序/悬停状态标志。通过-1使用当前列。 void TableSetBgColor(ImGuiTableBgTarget target, ImU32 color, int column_n = -1); // 更改单元格、行或列的颜色。有关详细信息，请参阅ImGuiTableBgTarget_标志。 ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:4:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"ImGuiTableFlags // ImGui::BeginTable()的标志 // [BETA API] API可能会略有演变！如果您使用此功能，请在发布时更新到下一个版本！ // - 重要！尺寸政策具有复杂而微妙的副作用，比你想象的要多。 //仔细阅读评论/演示+尝试现场演示以熟悉它们。 // - 默认大小策略是： // - 如果 ScrollX 已打开，或者主机窗口具有 ImGuiWindowFlags_AlwaysAutoResize，则默认为 ImGuiTableFlags_SizingFixedFit。 // - 如果 ScrollX 关闭，则默认为 ImGuiTableFlags_SizingStretchSame。 // - 当ScrollX关闭时： // - 表默认为ImGuiTableFlags_SizingStretchSame -\u003e所有列默认为相同重量的ImGuiTableColumnFlags_WidthStretch。 // - 允许列大小策略：拉伸（默认），固定/自动。 // - 固定列通常会获得其要求的宽度（除非表不能全部匹配）。 // - 拉伸列将共享剩余宽度。 // - 混合固定/拉伸列是可能的，但对调整大小行为有各种副作用。 //混合大小策略的典型用途是：任意数量的领先固定列，后跟一两个跟踪拉伸列。 //（这是因为列的可见顺序对它们对手动调整大小的反应有微妙但必要的影响）。 // - 当ScrollX打开时： // - 表默认为ImGuiTableFlags_SizingFixedFit -\u003e所有列默认为ImGuiTableColumnFlags_WidthFixed // - 允许列大小策略：主要修复/自动。 // - 固定列可以根据需要放大。如果需要，表格将显示水平滚动条。 // - 使用自动调整大小（不可调整大小）固定列时，查询内容宽度以使用项目对齐，例如SetNextItemWidth（-FLT_MIN）没有意义，会创建一个反馈循环。 // - 如果 ScrollX 处于打开，使用拉伸列通常没有意义，除非您在 BeginTable() 中指定了“inner_width”的值。 // 如果您为“inner_width”指定一个值，那么实际上，滚动空间是已知的，拉伸或混合固定/拉伸列再次变得有意义。 // - 有关详细信息，请阅读imgui_tables.cpp顶部的文档。 enum ImGuiTableFlags_ { // 特征 ImGuiTableFlags_None = 0, ImGuiTableFlags_Resizable = 1 \u003c\u003c 0, // 启用调整列大小。 ImGuiTableFlags_Reorderable = 1 \u003c\u003c 1, // 在标题行中启用重新排序列（需要调用 TableSetupColumn() + TableHeadersRow() 来显示标题） ImGuiTableFlags_Hideable = 1 \u003c\u003c 2, // 在上下文菜单中启用隐藏/禁用列。 ImGuiTableFlags_Sortable = 1 \u003c\u003c 3, // 启用排序。调用 TableGetSortSpecs() 以获取排序规范。另请参阅 ImGuiTableFlags_SortMulti 和 ImGuiTableFlags_SortTristate。 ImGuiTableFlags_NoSavedSettings = 1 \u003c\u003c 4, // 禁用 .ini 文件中的持久列顺序、宽度和排序设置。 ImGuiTableFlags_ContextMenuInBody = 1 \u003c\u003c 5, // 右键单击​​列 body/contents 将显示表上下文菜单。默认情况下，它在 TableHeadersRow() 中可用。 // 装饰 ImGuiTableFlags_RowBg = 1 \u003c\u003c 6, // 使用 ImGuiCol_TableRowBg 或 ImGuiCol_TableRowBgAlt 设置每个 RowBg 颜色（相当于手动在每行上使用 ImGuiTableBgFlags_RowBg0 调用 TableSetBgColor） ImGuiTableFlags_BordersInnerH = 1 \u003c\u003c 7, // 在行之间绘制水平边框。 ImGuiTableFlags_BordersOuterH = 1 \u003c\u003c 8, // 在顶部和底部绘制水平边框。 ImGuiTableFlags_BordersInnerV = 1 \u003c\u003c 9, // 在列之间绘制垂直边框。 ImGuiTableFlags_BordersOuterV = 1 \u003c\u003c 10, // 在左右两侧绘制垂直边框。 ImGuiTableFlags_BordersH = ImGuiTableFlags_BordersInnerH | ImGuiTableFlags_BordersOuterH, // 绘制水平边框。 ImGuiTableFlags_BordersV = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersOuterV, // 绘制垂直边框。 ImGuiTableFlags_BordersInner = ImGuiTableFlags_BordersInnerV | ImGuiTableFlags_BordersInnerH, // 绘制内边框。 ImGuiTableFlags_BordersOuter = ImGuiTableFlags_BordersOuterV | ImGuiTableFlags_BordersOuterH, // 绘制外边框。 ImGuiTableFlags_Borders = ImGuiTableFlags_BordersInner | ImGuiTableFlags_BordersOuter, // 绘制所有边框。 ImGuiTableFlags_NoBordersInBody = 1 \u003c\u003c 11, // [ALPHA] 在列 Body 中禁用垂直边框（边框将始终出现在 Headers 中）。 -\u003e 可能会转向风格 ImGuiTableFlags_NoBordersInBodyUntilResize = 1 \u003c\u003c 12, // [ALPHA] 禁用列 Body 中的垂直边框，直到悬停以调整大小（边框将始终出现在标题中）。 -\u003e 可能会转向风格 // 大小调整策略（阅读上面的默认值） ImGuiTableFlags_SizingFixedFit = 1 \u003c\u003c 13, // 列默认为 _WidthFixed 或 _WidthAuto（如果可调整大小或不可调整大小），匹配内容宽度。 ImGuiTableFlags_SizingFixedSame = 2 \u003c\u003c 13, // 列默认为 _WidthFixed 或 _WidthAuto（如果可调整大小或不可调整大小），匹配所有列的最大内容宽度。隐式启用 ImGuiTableFlags_NoKeepColumnsVisible。 ImGuiTableFlags_SizingStretchProp = 3 \u003c\u003c 13, // 列默认为 _WidthStretch，默认权重与每列内容宽度成比例。 ImGuiTableFlags_SizingStretchSame = 4 \u003c\u003c 13, // 列默认为 _WidthStretch，默认权重都相等，除非被 TableSetupColumn() 覆盖。 // 调整额外选项的大小 ImGuiTableFlags_NoHostExtendX = 1 \u003c\u003c 16, // 使外部宽度自动适应列，覆盖 outer_size.x 值。仅在禁用 ScrollX/ScrollY 且未使用 Stretch 列时可用。 ImGuiTableFlags_NoHostExtendY = 1 \u003c\u003c 17, // 使外部高度正好停在 outer_size.y 处（防止自动扩展表超出限制）。仅在禁用 ScrollX/ScrollY 时可用。低于限制的数据将被剪裁且不可见。 ImGuiTableFlags_NoKeepColumnsVisible = 1 \u003c\u003c 18, // 当 ScrollX 关闭且表格变得太小时时，禁用保持列始终最低限度可见。如果列可调整大小，则不推荐。 ImGuiTableFlags_PreciseWidths = 1 \u003c\u003c 19, // 禁用将剩余宽度分配给拉伸列（在具有 3 列的 100 宽表上分配宽度：没有此标志：33,33,34。使用此标志：33,33,33）。随着列数的增加，调整大小会显得不那么平滑。 // 剪裁 ImGuiTableFlags_NoClip = 1 \u003c\u003c 20, // 为每个单独的列禁用剪切矩形（减少绘制命令计数，项目将能够溢出到其他列）。通常与 TableSetupScrollFreeze() 不兼容。 // 填充 ImGuiTableFlags_PadOuterX = 1 \u003c\u003c 21, // 如果 BordersOuterV 开启则默认。启用最外边距。如果您有标题，通常是可取的。 ImGuiTableFlags_NoPadOuterX = 1 \u003c\u003c 22, //如果 BordersOuterV 关闭，则为默认值。禁用最外面的填充。 ImGuiTableFlags_NoPadInnerX = 1 \u003c\u003c 23, // 禁用列之间的内部填充（如果 Borde","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:5:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"ImGuiTableColumnFlags // ImGui::TableSetupColumn() 的标志 enum ImGuiTableColumnFlags_ { // 输入配置标志 ImGuiTableColumnFlags_None = 0, ImGuiTableColumnFlags_DefaultHide = 1 \u003c\u003c 0, // 默认为隐藏/禁用列。 ImGuiTableColumnFlags_DefaultSort = 1 \u003c\u003c 1, // 默认为排序列。 ImGuiTableColumnFlags_WidthStretch = 1 \u003c\u003c 2, // 列将拉伸。最好禁用水平滚动（如果表大小调整策略为 _SizingStretchSame 或 _SizingStretchProp，则为默认值）。 ImGuiTableColumnFlags_WidthFixed = 1 \u003c\u003c 3, // 列不会拉伸。最好启用水平滚动（如果表大小策略为 _SizingFixedFit 并且表可调整大小，则默认为）。 ImGuiTableColumnFlags_NoResize = 1 \u003c\u003c 4, // 禁用手动调整大小。 ImGuiTableColumnFlags_NoReorder = 1 \u003c\u003c 5, // 禁用手动重新排序此列，这也将防止其他列跨越此列。 ImGuiTableColumnFlags_NoHide = 1 \u003c\u003c 6, // 禁用隐藏/禁用此列的功能。 ImGuiTableColumnFlags_NoClip = 1 \u003c\u003c 7, // 禁用此列的剪辑（所有 NoClip 列将在同一个绘制命令中呈现）。 ImGuiTableColumnFlags_NoSort = 1 \u003c\u003c 8, // 禁用对该字段进行排序的能力（即使在表上设置了 ImGuiTableFlags_Sortable）。 ImGuiTableColumnFlags_NoSortAscending = 1 \u003c\u003c 9, // 禁用升序排序功能。 ImGuiTableColumnFlags_NoSortDescending = 1 \u003c\u003c 10, // 禁用降序排序功能。 ImGuiTableColumnFlags_NoHeaderWidth = 1 \u003c\u003c 11, // 禁用标题文本宽度对自动列宽的贡献。 ImGuiTableColumnFlags_PreferSortAscending = 1 \u003c\u003c 12, // 首次对该列排序时使初始排序方向为升序（默认）。 ImGuiTableColumnFlags_PreferSortDescending = 1 \u003c\u003c 13, // 首次对该列排序时，初始排序方向为降序。 ImGuiTableColumnFlags_IndentEnable = 1 \u003c\u003c 14, // 输入单元格时使用当前缩进值（默认为第 0 列）。 ImGuiTableColumnFlags_IndentDisable = 1 \u003c\u003c 15, // 输入单元格时忽略当前缩进值（列 \u003e 0 的默认值）。 _within_ 单元格内的缩进变化仍将得到尊重。 // 输出状态标志，通过 TableGetColumnFlags() 只读 ImGuiTableColumnFlags_IsEnabled = 1 \u003c\u003c 20, // 状态：已启用 == 未被用户/api 隐藏（在 _DefaultHide 和 _NoHide 中称为“隐藏”）标志。 ImGuiTableColumnFlags_IsVisible = 1 \u003c\u003c 21, // 状态：可见 == 已启用且未被滚动剪切。 ImGuiTableColumnFlags_IsSorted = 1 \u003c\u003c 22, // 状态：当前是排序规范的一部分 ImGuiTableColumnFlags_IsHovered = 1 \u003c\u003c 23, // 状态：被鼠标悬停 }; ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:6:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"ImGuiTableRowFlags // ImGui::TableNextRow() 的标志 enum ImGuiTableRowFlags_ { ImGuiTableRowFlags_None = 0, ImGuiTableRowFlags_Headers = 1 \u003c\u003c 0 // 识别标题行（设置默认背景颜色 + 其内容的宽度占自动列宽不同） }; ","date":"2022-02-15","objectID":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/:7:0","series":null,"tags":["ImGui"],"title":"ImGui表格","uri":"/2022/02/imgui%E8%A1%A8%E6%A0%BC/"},{"categories":null,"content":"配置环境 下载ImGui源码 ​ https://github.com/ocornut/imgui VS创建项目,新建cpp文件,再导入imgui内的cpp和h文件 导入backends目录下以下文件 半个人 imgui_impl_opengl3.h imgui_impl_opengl3.cpp imgui_impl_opengl3_loader.h imgui_impl_glfw.h imgui_impl_glfw.cpp 郁金香 项目内创建API目录,下载32位glfw并导入API目录 下载glew并导入API目录 属性 C++ » 附加包含目录 链接器 » 常规 » 附加库目录 链接器 » 输入 » 附加依赖项 opengl32.lib glfw3.lib glew32s.lib glut32.lib ","date":"2022-02-15","objectID":"/2022/02/imgui%E6%B5%81%E7%A8%8B/:1:0","series":null,"tags":["ImGui"],"title":"ImGui流程","uri":"/2022/02/imgui%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"OpenGL入门 先上效果图 ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A81/:0:0","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门1","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A81/"},{"categories":null,"content":"环境配置 OpenGL有很多开源库，如常见的glad，glfw，glut等等，这里简述一下他们的区别： glut是一个年代比较久远的窗口管理库，现在已经被glfw替代，不建议使用 glfw，轻量级gl库，针对OpenGL的C语言库，提供最低限度的接口，允许用户创建OpenGL上下文，定义窗口参数，处理用户输入等 glew，函数加载库，年代久远，不建议使用 glad，glew的较先进替代品 所以现在一般采用glad和glfw进行OpenGL开发，两个库的下载链接如下： GLFW:http://www.glfw.org/download.html glad：https://glad.dav1d.de/ 具体环境配置教程网上有很多，这里采用了VS进行配置 记得引入glad.c文件 配置完毕后，在网上找一段测试代码，看看配置是否有问题 #include \u003cglad/glad.h\u003e #include \u003cgl/glfw3.h\u003e #include \u003ciostream\u003e using namespace std; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow* window) { if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) glfwSetWindowShouldClose(window, true); } //创建main函数，实例化glfw窗口 int main() { //实例化glfw窗口，并告诉glfw使用的opengl版本：major 3，minor 3（3.3） glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); //创建窗口对象 GLFWwindow* window = glfwCreateWindow(800, 600, \"OpenGLTest\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); //初始化GLAD if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) { std::cout \u003c\u003c \"Failed to initialize GLAD\" \u003c\u003c std::endl; return -1; } glViewport(0, 0, 800, 600); //注册回调函数，窗口大小改变时候调用 glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); //开始渲染循环 while (!glfwWindowShouldClose(window)) { processInput(window);//输入检测 glfwSwapBuffers(window);//双缓冲绘制 glfwPollEvents(); } glfwTerminate();//资源释放 return 0; } void framebuffer_size_callback(GLFWwindow* window, int width, int height) { glViewport(0, 0, width, height); } 这里注意，glad库必须在glfw库前包含否则会报错，编译后无法运行的同学记得查看自己的项目结构是否为32位(x86) learn opengl官网上的注意事项 请确认是在包含GLFW的头文件之前包含了GLAD的头文件。GLAD的头文件包含了正确的OpenGL头文件（例如GL/gl.h），所以需要在其它依赖于OpenGL的头文件之前包含GLAD。 界面库采用ImGui，比较美观，使用也挺便捷 ImGui：https://github.com/ocornut/imgui 下载压缩包后直接解压到项目里然后包含就行 根据learn-opengl网站的教程进行一个简单的编写 部分代码： //ImGui部分 { static int counter = 0; ImGui::Begin(\"Edit\"); // Create a window called \"Hello, world!\" and append into it. ImGui::Text(\"This is some useful text.\"); // Display some text (you can use a format strings too) ImGui::Checkbox(\"Demo Window\", \u0026show_demo_window); // Edit bools storing our window open/close state ImGui::Checkbox(\"Another Window\", \u0026show_another_window); ImGui::ColorEdit3(\"color\", (float*)\u0026color); // Edit 1 float using a slider from 0.0f to 1.0f ImGui::ColorEdit3(\"clear color\", (float*)\u0026clear_color); // Edit 3 floats representing a color if (ImGui::Button(\"Button\")) // Buttons return true when clicked (most widgets return true when edited/activated) counter++; ImGui::SameLine(); ImGui::Text(\"counter = %d\", counter); ImGui::Text(\"Application average %.3f ms/frame (%.1f FPS)\", 1000.0f / ImGui::GetIO().Framerate, ImGui::GetIO().Framerate); ImGui::End(); } ImGui::Render(); ...... //绘制部分 // 更新uniform颜色 ourShader.setVec4(\"newcolor\", color.x, color.y, color.z, 1); //std::cout \u003c\u003c color.x \u003c\u003c \" \" \u003c\u003c color.y \u003c\u003c \" \" \u003c\u003c color.z \u003c\u003c \" \" \u003c\u003c color.w \u003c\u003c endl; ourShader.use(); glDrawArrays(GL_TRIANGLES, 0, 3); glfwSwapBuffers(window);//双缓冲绘制 //从文件读取顶点着色器和片元着色器 Shader(const char* vertexPath, const char* fragmentPath, const char* geometryPath = nullptr) { // 1. retrieve the vertex/fragment source code from filePath std::string vertexCode; std::string fragmentCode; std::string geometryCode; std::ifstream vShaderFile; std::ifstream fShaderFile; std::ifstream gShaderFile; // ensure ifstream objects can throw exceptions: vShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); fShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); gShaderFile.exceptions(std::ifstream::failbit | std::ifstream::badbit); try { // open files vShaderFile.open(vertexPath); fShaderFile.open(fragmentPath); std::stringstream vShaderStream, fShaderStream; // read file's buffer contents into streams vShaderStream \u003c\u003c vShaderFile.rdbuf(); fShader","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A81/:1:0","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门1","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A81/"},{"categories":null,"content":"基于OpenGL的简单渲染器实现 上次讲到配置完环境，这次先从ImGui开始简单介绍 由于我们使用了GLFW作为窗口管理的库，所以ImGui也是与GLFW相辅相成的 ImGui的使用流程大致如下： ImGui_ImplOpenGL3_NewFrame(); ImGui_ImplGlfw_NewFrame(); ImGui::NewFrame(); { ImGui::Begin(\"Edit\"); // Create a window called \"Hello, world!\" and append into it. //自定义内容 ImGui::End(); } ImGui::Render(); 在了解创建窗口和GUI之前，我们需要先了解一下渲染器的整体流程，这里有所简化 （实例化GLFW窗口，创建窗口对象 -\u003e 初始化GLAD -\u003e 开始渲染循环 -\u003e 资源回收） 我们需要在创建GLFW窗口后，进行ImGui的绘制，所以在main函数中大概是这么一个流程 int main() { //一些准备工作 InitGLFW(); Create_glfw_Window(); ... //---------------------render loop-------------------------------------- while (!glfwWindowShouldClose(window)) { //------------绘制Imgui----------------- RenderImGui(); //------------渲染工作------------------ ...... glfwSwapBuffers(window);//双缓冲绘制 glfwPollEvents(); } //一些资源释放等收尾工作 return 0; } 为了让main函数内的流程更加清晰，我们把绘制GUI和创建窗口的环节单独拎出来，写一个叫GameFrame的头文件来进行管理 namespace GameFrame { //-------------------------glfw window creation------------------------------------- GLFWwindow* Create_glfw_Window() { GLFWwindow* window = glfwCreateWindow(1200, 800, \"OpenGLTest\", NULL, NULL); if (window == NULL) { std::cout \u003c\u003c \"Failed to create GLFW window\" \u003c\u003c std::endl; glfwTerminate(); //return -1; } glfwMakeContextCurrent(window); glfwSwapInterval(1); glfwSetScrollCallback(window, InputManager::scroll_callback); glfwSetCursorPosCallback(window, InputManager::mouse_callback); glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED); return window; } //-------------------------imgui creation------------------------------------- void RenderMainImGui() { ImGui_ImplOpenGL3_NewFrame(); ImGui_ImplGlfw_NewFrame(); ImGui::NewFrame(); { ImGui::Begin(\"Edit\"); // Create a window called \"Hello, world!\" and append into it. ImGui::Text(\"Use 'Left Alter' to focus on window\"); //自定义GUI内容 ImGui::End(); } ImGui::Render(); } } 此时就可以很清晰的把main函数的流程表示为 InitGLFW(); GLFWwindow* window = GameFrame::Create_glfw_Window(); InitImGui(window); while (!glfwWindowShouldClose(window)) { RenderMainImGui()； glClearColor(); ... } //一些收尾工作 了解大致的流程后就可以开始正式开始编写渲染器了 这里推荐learnOpenGl网站，可以根据上面进行渲染的学习，后续还会介绍一些可能会踩到的坑和一些解决方式 LearOpenGL：https://learnopengl-cn.github.io/ ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A82/:1:0","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门2","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A82/"},{"categories":null,"content":"之前我们通过OpenGL绘制简单模型都是通过手动输入顶点数据，然后分配VAO，VBO进行绑定绘制，如果我们想要更模块化的实现这一个绑定过程，并实现从OBJ文件读取定点信息，我们则需要自己定义Mesh类和Model类 （常规的VAO，VBO绑定流程） float quadVertices[] = { // vertex attributes for a quad that fills the entire screen in Normalized Device Coordinates. // positions // texCoords -1.0f, 1.0f, 0.0f, 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0, -1.0f, 1.0f, 0.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 1.0f, 1.0f, 1.0f, 1.0f }; unsigned int quadVAO, quadVBO; glGenVertexArrays(1, \u0026quadVAO); glGenBuffers(1, \u0026quadVBO); glBindVertexArray(quadVAO); glBindBuffer(GL_ARRAY_BUFFER, quadVBO); glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), \u0026quadVertices, GL_STATIC_DRAW); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)0); glEnableVertexAttribArray(1); glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(float), (void*)(2 * sizeof(float))); ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/:0:0","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门3","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/"},{"categories":null,"content":"Mesh类 一个简单的Mesh类需要包含mesh的定点信息还有他所绑定的VAO，VBO class Mesh { public: // mesh Data vector\u003cVertex\u003e vertex; unsigned int VAO; Mesh() = default; // constructor Mesh(vector\u003cVertex\u003e vertices) { this-\u003evertex = vertices; // now that we have all the required data, set the vertex buffers and its attribute pointers. setupMesh(); } private: // render data unsigned int VBO; }; 其次我们要在Mesh类构造的时候设置其顶点信息，setupMesh的函数实现如下 void setupMesh() { // create buffers/arrays glGenVertexArrays(1, \u0026VAO); glGenBuffers(1, \u0026VBO); glBindVertexArray(VAO); // load data into vertex buffers glBindBuffer(GL_ARRAY_BUFFER, VBO); // A great thing about structs is that their memory layout is sequential for all its items. // The effect is that we can simply pass a pointer to the struct and it translates perfectly to a glm::vec3/2 array which // again translates to 3/2 floats which translates to a byte array. glBufferData(GL_ARRAY_BUFFER, vertex.size() * sizeof(Vertex), \u0026vertex[0], GL_STATIC_DRAW); // set the vertex attribute pointers // vertex Positions glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)0); // vertex normals glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, Normal)); // vertex texture coords glEnableVertexAttribArray(2); glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void*)offsetof(Vertex, TexCoords)); } 最后，我们把绘制模型的步骤封装成一个可供外部调用的函数Draw（当然你也可以把Texture封装进Mesh类，然后再Draw函数内调用，这里只讲了简单的实现思路） void Draw(Shader\u0026 shader) { // draw mesh glBindVertexArray(VAO); glDrawArrays(GL_TRIANGLES,0, vertex.size()); glBindVertexArray(0); // always good practice to set everything back to defaults once configured. glActiveTexture(GL_TEXTURE0); } ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/:0:1","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门3","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/"},{"categories":null,"content":"Model类 为了从obj文件读取顶点信息，存入Mesh类，我们需要再定义一个Model类，Model类包含了模型的顶点信息和模型的位置信息 struct Transform { glm::vec3 Position; glm::vec3 Scale; float Rotation[3] = {0}; Transform() { Position = glm::vec3(0); Scale = glm::vec3(1); } }; class Model { public: Mesh* mesh; Transform transform = Transform(); Model(const char* model_path) { loadOBJ(model_path, buffer); mesh = new Mesh(buffer); } glm::mat4 GetModelMatrix() { glm::mat4 model = glm::mat4(1); model = glm::translate(model,transform.Position); model = glm::scale(model, transform.Scale); model = glm::rotate(model, glm::radians(transform.Rotation[0]), glm::vec3(1, 0, 0)); model = glm::rotate(model, glm::radians(transform.Rotation[1]), glm::vec3(0, 1, 0)); model = glm::rotate(model, glm::radians(transform.Rotation[2]), glm::vec3(0, 0, 1)); return model; } private: std::vector\u003cVertex\u003e buffer; }; loadOBJ将从obj文件读取顶点信息并存入缓存buffer，GetModelMatrix则是获取模型的模型空间矩阵，所有模型空间的变换结果将会通过这个函数计算 下面是读取模型信息的过程，obj文件的信息可以通过txt打开，打开后会发现，顶点信息存储在v开头的行，法线信息存储在vn开头的行，uv信息则存储在vt开头的行，最后f是面信息，我们通过obj文件的构成规则进行解析就行： bool loadOBJ( const char* path, std::vector\u003cVertex\u003e\u0026 vertices) { printf(\"Loading OBJ file %s...\\n\", path); std::vector\u003cunsigned int\u003e vertexIndices, uvIndices, normalIndices; std::vector\u003cglm::vec3\u003e temp_vertices; std::vector\u003cglm::vec2\u003e temp_uvs; std::vector\u003cglm::vec3\u003e temp_normals; FILE* file = fopen(path, \"r\"); if (file == NULL) { printf(\"Impossible to open the file ! Are you in the right path ? See Tutorial 1 for details\\n\"); getchar(); return false; } while (1) { char lineHeader[128]; // read the first word of the line int res = fscanf(file, \"%s\", lineHeader); if (res == EOF) break; // EOF = End Of File. Quit the loop. // else : parse lineHeader if (strcmp(lineHeader, \"v\") == 0) { glm::vec3 vertex; fscanf(file, \"%f %f %f\\n\", \u0026vertex.x, \u0026vertex.y, \u0026vertex.z); temp_vertices.push_back(vertex); } else if (strcmp(lineHeader, \"vt\") == 0) { glm::vec2 uv; fscanf(file, \"%f %f\\n\", \u0026uv.x, \u0026uv.y); uv.y = -uv.y; // Invert V coordinate since we will only use DDS texture, which are inverted. Remove if you want to use TGA or BMP loaders. temp_uvs.push_back(uv); } else if (strcmp(lineHeader, \"vn\") == 0) { glm::vec3 normal; fscanf(file, \"%f %f %f\\n\", \u0026normal.x, \u0026normal.y, \u0026normal.z); temp_normals.push_back(normal); } else if (strcmp(lineHeader, \"f\") == 0) { std::string vertex1, vertex2, vertex3; unsigned int vertexIndex[3], uvIndex[3], normalIndex[3]; int matches = fscanf(file, \"%d/%d/%d %d/%d/%d %d/%d/%d\\n\", \u0026vertexIndex[0], \u0026uvIndex[0], \u0026normalIndex[0], \u0026vertexIndex[1], \u0026uvIndex[1], \u0026normalIndex[1], \u0026vertexIndex[2], \u0026uvIndex[2], \u0026normalIndex[2]); if (matches != 9) { printf(\"File can't be read by our simple parser :-( Try exporting with other options\\n\"); fclose(file); return false; } vertexIndices.push_back(vertexIndex[0]); vertexIndices.push_back(vertexIndex[1]); vertexIndices.push_back(vertexIndex[2]); uvIndices.push_back(uvIndex[0]); uvIndices.push_back(uvIndex[1]); uvIndices.push_back(uvIndex[2]); normalIndices.push_back(normalIndex[0]); normalIndices.push_back(normalIndex[1]); normalIndices.push_back(normalIndex[2]); } else { // Probably a comment, eat up the rest of the line char stupidBuffer[1000]; fgets(stupidBuffer, 1000, file); } } // For each vertex of each triangle for (unsigned int i = 0; i \u003c vertexIndices.size(); i++) { // Get the indices of its attributes unsigned int vertexIndex = vertexIndices[i]; unsigned int uvIndex = uvIndices[i]; unsigned int normalIndex = normalIndices[i]; // Get the attributes thanks to the index glm::vec3 vertex = temp_vertices[vertexIndex - 1]; glm::vec2 uv = temp_uvs[uvIndex - 1]; glm::vec3 normal = temp_normals[normalIndex - 1]; Vertex temp(vertex, normal, uv); // Put the attributes in buffers vertices.push_back(temp); } fclose(file); std::cout \u003c\u003c \"Load successful\" \u003c\u003c endl; return true; } 实现了这两个类后，我们直接在main函数中调用即可 ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/:0:2","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门3","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/"},{"categories":null,"content":"调用 Shader ourShader(\"resources/shader/shader.vs\", \"resources/shader/testShader.fs\"); Model nanosuit_model(\"resources/models/nanosuit/nanosuit.obj\"); ... int main() { ... while(!glfwWindowShouldClose(window)) { ... ourShader.setMat4(\"model\", Rendering::model-\u003eGetModelMatrix()); ourShader.setMat4(\"projection\", projection); ourShader.setMat4(\"view\", view); ourShader.setVec3(\"viewPos\", InputManager::camera-\u003ePosition); nanosuit_model.mesh-\u003eDraw(ourShader); } } Shader类和Camera类的实现可参考learnOpenGL网站，InputManager是管理窗口输入的头文件，该头文件定义了一个Camera指针，表示当前窗口控制的主摄像机，并封装了所有输入回调函数。 如果不出错的话，最终即可正确绘制（此处模型的texture是在main函数里绑定的） ","date":"2022-02-15","objectID":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/:0:3","series":null,"tags":["ImGui"],"title":"OpenGL和Imgui整合入门3","uri":"/2022/02/opengl%E5%92%8Cimgui%E6%95%B4%E5%90%88%E5%85%A5%E9%97%A83/"},{"categories":null,"content":"DLL动态链接库及入口函数 ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:1:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"LoadLibrary 加载动态链接库 HMODULE LoadLibraryW( [in] LPCWSTR lpLibFileName //模块名称 ); HMODULE LoadLibraryA( [in] LPCSTR lpLibFileName //模块名称 ); //模块名称可以是库模块（.dll文件）或可执行模块（.exe文件） //返回值 //如果函数成功，返回值是模块的句柄。 //如果函数失败，返回值为NULL。 __stdcall 参数从右向左压入堆栈 APIENTRY 则表明此函数是应用程序的入口点,其实都是__stdcall winapi 表示此函数是普通的winapi函数调用方式,其实都是__stdcall ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:2:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"DLL注入调用CALL CWinApp::InitInstance 初始化函数（一般用于MFC初始化实例） ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:3:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"释放动态链接库 FreeLibrary 释放动态链接库 BOOL FreeLibrary( [in] HMODULE hLibModule ////模块的句柄 ); ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:4:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"释放dll并结束进程 FreeLibraryAndExitThread 释放dll并结束进程 void FreeLibraryAndExitThread( [in] HMODULE hLibModule, //模块的句柄 [in] DWORD dwExitCode //调用线程的退出代码 ); //实例 FreeLibraryAndExitThread(theApp.m_hInstance,(DWORD)theApp.m_hInstance); ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:5:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"DLL宏 DLL_PROCESS_ATTACH 宏 进程载入 // 1 DLL_PROCESS_DETACH 宏 进程卸载 // 0 ","date":"2022-02-21","objectID":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/:6:0","series":null,"tags":["内存","动态链接库DLL"],"title":"动态链接库DLL","uri":"/2022/02/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93dll/"},{"categories":null,"content":"跨进程分配内存 ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:0","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"概览 malloc 在本进程分配内存(堆栈) VirtualAlloc 可在当前进程分配内存 VirtualFree 释放内存 VirtualAllocEx 可在当前进程或者目标进程分配内存 VirtualFreeEx 释放内存 ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:1","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"VirtualAlloc LPVOID VirtualAlloc( [in, optional] LPVOID lpAddress, //要分配的内存的起始地址 [in] SIZE_T dwSize, //内存大小，以字节为单位 [in] DWORD flAllocationType, //内存分配的类型 [in] DWORD flProtect //要分配的页面区域的内存保护 ); ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:2","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"VirtualFree BOOL VirtualFree( [in] LPVOID lpAddress, //指向要释放内存地址的指针 [in] SIZE_T dwSize, //要释放的内存区域的大小，以字节为单位 [in] DWORD dwFreeType //释放的类型 ); ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:3","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"VirtualAllocEx LPVOID VirtualAllocEx( [in] HANDLE hProcess, //申请内存所在的进程句柄 [in, optional] LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 [in] SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 [in] DWORD flAllocationType, //一般用MEM_COMMIT [in] DWORD flProtect //一般用PAGE_READWRITE(读写) ); //实例 LPVOID 目标进程内存地址 = VirtualAllocEx(进程句柄,NULL,1024,MEM_COMMIT,PAGE_EXECUTE_READWRITE); ​ flAllocationType 可取下列值： MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储 MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存） MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用 MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效 MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志） MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98） flProtect 可取下列值 PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访 PAGE_READWRITE 区域可被应用程序读写 PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。 PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域。 PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。 PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限 PAGE_NOACCESS： 任何访问该区域的操作将被拒绝 PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached) 注:PAGE_GUARD和PAGE_NOCHACHE标志可以和其他标志合并使用以进一步指定页的特征。PAGE_GUARD标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个one-shot异常，接着取得指定的访问权限。PAGE_NOCACHE防止当它映射到虚拟页的时候被微处理器缓存。这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。 ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:4","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"VirtualFreeEx BOOL VirtualFreeEx( [in] HANDLE hProcess, //进程句柄 [in] LPVOID lpAddress, //指向要释放内存地址的指针 [in] SIZE_T dwSize, //要释放的内存区域的大小，以字节为单位 [in] DWORD dwFreeType //释放的类型 ); lpAddress ​ 指向要释放的虚拟内存空间首地址的指针。 ​ 如果 dwFreeType 为 MEM_RELEASE, 则该参数必须为VirtualAllocEx的返回值. ​ dwSize ​ 虚拟内存空间的字节数 ​ 如果 dwFreeType 为 MEM_RELEASE，则 dwSize 必须为0 . 按 VirtualAllocEx申请时的大小全部释放。 ​ 如果dwFreeType 为 MEM_DECOMMIT, 则释放从lpAddress 开始的一个或多个字节 ，即 lpAddress +dwSize。 ​ dwFreeType ​ 释放类型，取值见下表： 值 释义 MEM_DECOMMIT 0x400016384D 这种试 仅标示 内存空间不可用，内存页还将存在。 MEM_RELEASE 0x800032768D 这种方式 很彻底，完全回收。 ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:1:5","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"跨进程读写 [WriteProcessMemory](句柄 进程 模块 读写.md) [ReadProcessMemory](句柄 进程 模块 读写.md) ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:2:0","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"跨进程调用代码 CreateRemoteThread 创建远线程 跨进程调用代码 我的实例代码 HANDLE CreateRemoteThread( [in] HANDLE hProcess, //目标进程句柄 [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL [in] SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M [in] LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址(目标进程代码地址) [in] LPVOID lpParameter, //线程参数 [in] DWORD dwCreationFlags, //线程的创建标志 [out] LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); 线程的创建标志. 值 含义 0 线程创建后立即运行 CREATE_SUSPENDED 0x00000004 线程创建后先将线程挂起,直到 ResumeThread 被调用. STACK_SIZE_PARAM_IS_A_RESERVATION0x00010000 dwStackSize 参数指定为线程栈预订大小,如果STACK_SIZE_PARAM_IS_A_RESERVATION没有被指定,dwStackSize 参数指定为线程栈分配大小. //实例 UINT64 nRet64 =0; DWORD lpExitCode=0; HWND 窗口句柄 = FindWindowA(\"WTWindow\",\"Wow\"); DWORD 进程PID =0; GetWindowThreadProcessId(窗口句柄,\u0026进程PID); HANDLE 进程句柄 = OpenProcess(PROCESS_ALL_ACCESS, FALSE,进程PID); //在目标进程分配内存 LPVOID 目标进程内存地址=VirtualAllocEx(进程句柄,NULL,1024,MEM_COMMIT,PAGE_EXECUTE_READWRITE); SIZE_T nWriten =0;//用于返回实际写入字节数 //写入要注入的DLL的路径 BOOL br = WriteProcessMemory(进程句柄,目标进程内存地址,dllFullPathName,strlen(dllFullPathName)+1, \u0026nWriten); HANDLE ht= CreateRemoteThread( 进程句柄, NULL, 0,//0x400000 (LPTHREAD_START_ROUTINE)LoadLibraryA,//LoadLibraryA(\"c:\\\\123.dll\") 目标进程内存地址,//LoadLibraryA(目标进程内存地址) 0, \u0026tid ); ","date":"2022-02-21","objectID":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/:3:0","series":null,"tags":["内存","跨进程"],"title":"跨进程","uri":"/2022/02/%E8%B7%A8%E8%BF%9B%E7%A8%8B/"},{"categories":null,"content":"csrss.exe d: cd D:\\soft\\FeiYuOL\\7.2_64CE feiyuol.com cd D:\\soft\\FeiYuVIP\\OllyICE_32 csrss.exe ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:1:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"基址 main.exe+0xA94B54 //职业 魔法师0 剑士1 弓箭手2 main.exe+0x787480//弓箭手等级 main.exe+0x7DA4E8//弓箭手等级 main.exe+0x7C705C//剑士等级 main.exe+0xA5FE18//地图编号 勇者大陆0 地下城1 冰风谷2 仙踪林3 失落之塔4 竞技场6 亚特兰蒂斯7 死亡沙漠8 //剑士坐标 main.exe+0x792A93C //x main.exe+0x792A940 //y //弓箭手坐标 main.exe+0x79CD0D4;//x main.exe+0x79CD0D8;//Y //法师坐标 main.exe+0x7A1DBC4;//x main.exe+0x7A1DBC8;//Y //第二格物品栏 main +0xabaf7c] +0xa0] + 0x348] +0x98 main +0xabafdc] +0xa0] + 0x348] +0x98 ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:2:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"属性 IGC.DLL +70270//防护值 +70274 //蓝 +70278//能量值 +7027C//红 009350D0 //钱1 00935564 00935CC4 00935E0C 20 1AC EC ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:3:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"坐标转换 中心(320,201) x1,y1为游戏距离 x1每加1则 x加36,y加27 y1每加1则 x加36,y减27 目标坐标$(320+36\\times x1+36\\times y1,201+27\\times x1-27\\times y1)$ 173,125 172,126 172,125 172,96 仓库npc #define 竞技场 0 #define 勇者大陆 1 #define 仙踪林 2 #define 冰风谷1 3 #define 冰风谷2 4 #define 冰风谷3 5 #define 冰风谷4 6 #define 地下城1 7 #define 地下城2 8 #define 地下城3 9 #define 失落之塔1 10 #define 失落之塔2 11 #define 失落之塔3 12 #define 失落之塔4 13 #define 失落之塔5 14 #define 失落之塔6 15 #define 失落之塔7 16 #define 亚特兰蒂斯1 17 #define 亚特兰蒂斯2 18 #define 亚特兰蒂斯3 19 #define 死亡沙漠1 20 #define 死亡沙漠2 21 \u003c60 1 60\u003e= \u003e100 2 \u003e100 3 ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:4:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"组队 队长 196,106 队员 196,107 196,105 195,106 197,106 if (m_pOp-\u003eisColor( 216, 110, 0x090909, 0.95) and m_pOp-\u003eisColor( 210, 204, 0x404040, 0.95) and m_pOp-\u003eisColor( 423, 202, 0xc2c2c2, 0.95) and m_pOp-\u003eisColor( 402, 111, 0x2a2a2a, 0.95)) then ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:5:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"待完成 仓库 “D:\\Program Files (x86)\\奇迹mu怀旧服\\Mu.exe” ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:6:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"买蓝 140（包括140）用小蓝 141-320（包扣320）用中蓝 321+用大蓝 ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:7:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"高价值物品 #define str高价值物品 _T(\"兽角 灵魂 祝福 玛雅 守护天使 卓越的 up+up4 up+up5 up+up6 up+up7 +8 +12 幸运 术 之石 之项 之指\") ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:8:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"填坑 仓库 修理 iMagic if (m_pOp-\u003eisColor( 324, 270, 0xfbebb8, 0.95)) then if (m_pOp-\u003eisColor( 266, 6, 0xa9a9a9, 0.95) and m_pOp-\u003eisColor( 267, 424, 0x747474, 0.95) and m_pOp-\u003eisColor( 611, 425, 0x303030, 0.95) and m_pOp-\u003eisColor( 606, 12, 0x1a1a1a, 0.95)) then Sleep(3000); while (m_pAppItem-\u003eiTarget == _T(\"清理仓库\") and m_bRun == true) { getPosition(); goTarget(172, 96, 0);//仓库坐标 Sleep(300); ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:9:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"BUG 和npc重叠 ","date":"2021-12-30","objectID":"/2021/12/%E5%A5%87%E8%BF%B9/:10:0","series":null,"tags":["脚本"],"title":"奇迹","uri":"/2021/12/%E5%A5%87%E8%BF%B9/"},{"categories":null,"content":"MFC 在其他的类中引用Dlg类方法 不能直接引用，因为类方法是非static的。 ((CtcpclientDlg*)theApp.GetMainWnd())-\u003eaddLog(str); ","date":"2021-12-26","objectID":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/:1:0","series":null,"tags":["脚本"],"title":"C++ MFC 其他函数获得主对话框指针并使用成员的方法","uri":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"A.子对话框得到父对话框的方法 (此方法也可以帮助其他函数获得主对话框) extern CMainApp theApp; CMainDlg* dlg = (CMainDlg*)theApp.m_pMainWnd; 获得主对话框指针就可以调用它的成员的 主对话框创建子对话框时把this传入，那么在子对话框中就可以得到主对话的指针 用GetParent()获取父窗口指针。 设你主对话框类为CMyDialog. CMyDialog *pDlg = (CMyDialog *)GetParent()-\u003eGetParent(); pDlg-\u003e函数或变量; 第一个GetParent()获取的是tab control指针，再通过tab control获取主对话框指针。 ","date":"2021-12-26","objectID":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/:2:0","series":null,"tags":["脚本"],"title":"C++ MFC 其他函数获得主对话框指针并使用成员的方法","uri":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"B.获取对话框的指针–全局变量的使用(推荐) （同时可以对控件进行相应的操作） 假设CMyDialog为对话框类 1.先在CMyDialog.cpp中声明一个全局变量CMyDialog* pDlg; 注意啊！！这里的声明必须在CPP文件中的所有函数外部，不要在.h文件中， 2在OnInitDialog()的时候，pDlg = this; 3.在别的类使用他的时候，在别的类的Cpp中添加extern CMyDialog* pDlg; 4.pDlg-\u003eyourfunction(); ","date":"2021-12-26","objectID":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/:3:0","series":null,"tags":["脚本"],"title":"C++ MFC 其他函数获得主对话框指针并使用成员的方法","uri":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"C.在使用mfc的时候经常遇到自定义类访问主对话框控件的问题，例如自定义类中的方法要输出一段字符串到主对话框的EDIT控件、控制对话框的进度条等 要在自定义的类中访问主对话框空间，须获得主对话的指针。主对话框的对象在app类的InitInstance()方法中声明。查看app类的cpp文件，在InitInstance()方法中有如下语句： CAppDlg dlg; m_pMainWnd = \u0026dlg; 主对话框指针被传给m_pMainWnd成员，按f12查看其定义，发现m_pMainWnd 是在afxwin.h中声明的成员： CWnd*m_pMainWnd; // main window (usually same AfxGetApp()-\u003em_pMainWnd) 由于MFC中的自定义类会自动包含stdafx.h头文件，且stdafx.h包含afxwin.h，因此根据注释，在自定义类中可以直接使用 AfxGetApp()-\u003em_pMainWnd 来获取主对话框的指针。之后可通过 AfxGetApp()-\u003em_pMainWnd-\u003eGetDlgItem( )； 来获得要访问的主对话框控件的指针，以对其进行访问。 ","date":"2021-12-26","objectID":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/:4:0","series":null,"tags":["脚本"],"title":"C++ MFC 其他函数获得主对话框指针并使用成员的方法","uri":"/2021/12/c-mfc-%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0%E8%8E%B7%E5%BE%97%E4%B8%BB%E5%AF%B9%E8%AF%9D%E6%A1%86%E6%8C%87%E9%92%88%E5%B9%B6%E4%BD%BF%E7%94%A8%E6%88%90%E5%91%98%E7%9A%84%E6%96%B9%E6%B3%95/"},{"categories":null,"content":"大漠文件 obj.cpp obj.h dm.dll DmReg.dll ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:1:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"大漠助手类 COpHelper.h COpHelper.cpp ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:2:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"日志(输出跟踪文件) TraceService.h TraceService.cpp ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:3:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"线程文件 CABThread.cpp CABThread.h ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:4:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"MFC管理文件 CAppManager.cpp CAppManager.h ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:5:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"实用工具 utils.cpp utils.h ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:6:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"脚本类 ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:7:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"脚本管理类 CScriptManager.h CScriptManager.cpp ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:8:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"服务核心头文件 ServiceCoreHead.h ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:9:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"Data队列 WHDataQueue.cpp WHDataQueue.h ","date":"2021-12-21","objectID":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/:10:0","series":null,"tags":["脚本"],"title":"脚本常用文件","uri":"/2021/12/%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"0、首先 开始之前，你得找到 雷神模拟器 命令行程序，在安装目录下lsconsole.exe，不管三七二十八，先cmd执行试试，好像还不错，有usage提示的： 一起来看看几个主要命令，大部分命令读者可以自己试试~ ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:1:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"1、launch启动 支持2种启动雷电模拟器的方式 –name顾名思义，应该是模拟器的标题栏的名字，本人经过验证果然如此! –index mnq_idx，模拟器的索引，第一个是0，第二个是1，以此类推。。。。。。 写个例子吧，启动默认模拟器的2种方法： lsconsole.exe launch --name 雷神模拟器 lsconsole.exe launch --index 0 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:2:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"2、quit 退出模拟器 也提供了3种退出方式，和launch对应，不再累述。 lsconsole.exe quit --name 雷神模拟器 lsconsole.exe quit --index 0 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:3:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"3、quitall 退出模拟器 退出所有开着的模拟器。 lsconsole.exe quitall ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:4:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"4、属性设置部分 精彩部分来了，同样，修改属性时也要指定需要修改的是哪个模拟器的属性（多开的情况），仍然采用的是以上的3种方式，雷神提供的属性字段有： modify \u003c–name mnq_name | –index mnq_idx\u003e [–resolution ] // 自定义分辨率 [–cpu \u003c1 | 2 | 3 | 4\u003e] // cpu设置 [–memory \u003c512 | 1024 | 2048 | 4096 | 8192\u003e] // 内存设置 [–manufacturer asus] // 手机厂商 [–model ASUS_Z00DUO] // 手机型号 [–pnumber 13812345678] // 手机号码 [–imei ] // imei设置，auto就自动随机生成 [–imsi ] [–simserial ] [–androidid ] [–mac ] //12位m16进制mac地址 [–autorotate \u003c1 | 0\u003e] [–lockwindow \u003c1 | 0\u003e] 好吧，我写个例子，修改默认模拟器的分辨率为600*360,dpi 160,cpu为1核，内存1024，imei随机，这样写： lsconsole.exe modify –index 0 –resolution 600,360,160 –cpu 1 –memory 1024 –imei auto 注：调用modify需要在模拟器启动前，不然可能不生效 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:5:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"5、新增模拟器 add [–name mnq_name] ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:6:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"6、复制模拟器 copy [–name mnq_name] –from 注意：from参数既可以是名字也可以是索引，判断规则为如果全数字就认为是索引，否则是名字 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:7:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"7、删除模拟器 remove \u003c–name mnq_name | –index mnq_idx\u003e ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:8:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"8、备份，还原命令 backup \u003c–name mnq_name | –index mnq_idx\u003e –file restore \u003c–name mnq_name | –index mnq_idx\u003e –file ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:9:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"9、rename 话说经常改名字是什么梗。。。 rename \u003c–name mnq_name | –index mnq_idx\u003e –title ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:10:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"10、reboot 终于不用先关闭，再延时，然后打开了。 reboot \u003c–name mnq_name | –index mnq_idx\u003e ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:11:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"11**、list2** F:\\BaiZhi\\lsplayer\u003elsconsole.exe list2 0,雷神模拟器,2032678,1704928,1,7456,3500 1,雷神模拟器-1,852422,590830,1,3772,3180 list2命令出来，原来的list,runninglist,isrunning全部可以不要了，而且比原来这3个命令的总和还要强大！ list2一次性返回了多个信息，依次是： 索引，标题，顶层窗口句柄，绑定窗口句柄，是否进入android，进程PID，VBox进程PID 更强大的是，**即使标题相同，也不会错误！**完美一一对应的返回全部信息啦。 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:12:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"12、安装、卸载、启动、关闭命令 installapp \u003c--name mnq_name | --index mnq_idx\u003e --filename “com.android.settings” installapp \u003c--name mnq_name | --index mnq_idx\u003e --packagename “com.android.settings” uninstallapp \u003c--name mnq_name | --index mnq_idx\u003e --packagename “com.android.settings” runapp \u003c--name mnq_name | --index mnq_idx\u003e --packagename “com.android.settings” killapp \u003c--name mnq_name | --index mnq_idx\u003e --packagename “com.android.settings” ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:13:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"13、修改定位信息 locate \u003c–name mnq_name | –index mnq_idx\u003e –LLI 骚年们，去装B吧！想在哪里你就在那里！ 上面的命令需要重启模拟器才生效, 下面这个命令能实时生效(看action命令): action \u003c–name mnq_name | –index mnq_idx\u003e –key call.locate –value 12.3,45.6 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:14:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"14、setprop/getprop/adb setprop \u003c–name mnq_name | –index mnq_idx\u003e –key name –value val getprop \u003c–name mnq_name | –index mnq_idx\u003e –key name（name不为空，get所有属性这样写：getprop –index 0 即可） 也许你已经看出这2个命令似曾相识啦，没错，这2个就是adb的标准命令！大概是雷神为了方便大家，同时保持命令行风格语法的一致而做的包装吧，这极大地减低了各位的学习成本，毕竟adb的命令还是比较复杂的！ 还不止这些，有些是adb做不到的，比如： setprop –index 0 –key “phone.imei” –value “auto” setprop –index 0 –key “phone.imsi” –value “auto” setprop –index 0 –key “phone.simserial” –value “auto” 另外，adb命令解决大家使用-s的麻烦，不需要再关心每个模拟器对应的adb连接端口的概念，比如取某个模拟器中的包列表： lsconsole.exe adb –name “雷神模拟器” –command “shell pm list packages” lsconsole.exe adb –index 0 –command “shell pm list packages” ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:15:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"14、全局设置 lsconsole.exe globalsetting –fps 10 –audio 0 –fastplay 1 fps：模拟器帧率[0, 60] audio：音频，打开=1，关闭=0 fastpaly : 快速显示模式，打开=1，关闭=0 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:16:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"15、downcpu downcpu \u003c–name mnq_name | –index mnq_idx\u003e –rate \u003c0~100\u003e 本人的问道游戏测试，downcpu –index 0 –rate 50，效果很好！ （需要2.0.31以上的模拟器版本） ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:17:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"16、list2 期待已久的命令终于出来了！！！雷电万岁！！！真正解决了我们用户的苦恼啊，有木有！！！ F:\\changzhi\\dnplayer2\u003ednconsole.exe list2 0,雷电模拟器,2032678,1704928,1,7456,3500 1,雷电模拟器-1,852422,590830,1,3772,3180 list2命令出来，原来的list,runninglist,isrunning全部可以不要了，而且比原来这3个命令的总和还要强大！ list2一次性返回了多个信息，依次是： 索引，标题，顶层窗口句柄，绑定窗口句柄，是否进入android，进程PID，VBox进程PID 更强大的是，**即使标题相同，也不会错误！**完美一一对应的返回全部信息啦。 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:18:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"17、reboot 终于不用先关闭，再延时，然后打开了。 reboot \u003c–name mnq_name | –index mnq_idx\u003e ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:19:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18、rename 话说经常改名字是什么梗。。。 rename [–name ] –title ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:20:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"19、action 命令 动态执行动作命令，想做什么，立即执行。 支持安卓内部操作，shell命令操作。 action \u003c--name mnq_name | --index mnq_idx\u003e --key --value call.reboot packagename/null //重启模拟器，启动后并打开 packagename 应用, null 表示不打开任何应用 call.keyboard back/home/menu/volumeup/volumedown //执行安卓按键 call.locate lng,lat //设置地点，经度，维度 call.shake null //摇一摇 例子： dnconsole.exe action --name *** --key call.keyboard --value back dnconsole.exe action --name *** --key call.reboot --value com.android.settings dnconsole.exe action --name *** --key call.locate --value 12.3,45.6 dnconsole.exe action --name *** --key call.shake --value null 如果你是编写apk类型的脚本，也可以这样做； ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:21:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"20、备份，还原命令 backup \u003c–name mnq_name | –index mnq_idx\u003e –file restore \u003c–name mnq_name | –index mnq_idx\u003e –file ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:22:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"21、文字输入命令 （支持中文，2.0.42以上支持，action命令的扩展） 格式参考18 dnconsole.exe action –name *** –key call.input –value *** ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:23:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"22、雷电 adb shell 命令 参考帖子（2.0.44以上支持） https://www.ldmnq.com/forum/forum.php?mod=viewthread\u0026tid=9178 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:24:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"23、断开和连接网络命令 （2.0.53以上版本支持） 断开网络 dnconsole.exe action –name *** –key call.network –value offline 连接网络 dnconsole.exe action –name *** –key call.network –value connect ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:25:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"24、二维码扫描命令 (3.0.8以上版本支持, 需要app先启动扫描,再调用这个命令) filePath 是带有二维码的图片路径 dnconsole.exe qrpicture –name *** –file 3.18版本改名scan. dnconsole.exe scan –name *** –file c:\\xxxx.jpg ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:26:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"25、音量减小命令(启动按键精灵) dnconsole.exe action –name *** –key call.keyboard –value volumedown ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:27:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"26、一键排序 (在多开器配置排序规则, 3.18以上版本支持) dnconsole.exe sortWnd ###3.53模拟器重大更新 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:28:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"27、启动扩展命令 (启动模拟器后自动打开某一应用) dnconsole.exe launchex –index 0 –packagename “com.android.settings” ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:29:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"28、全局设置 dnconsole.exe globalsetting –fps 10 –audio 0 –fastplay 1 –cleanmode 1 fps：模拟器帧率[0, 60] audio：音频，打开=1，关闭=0 fastpaly : 快速显示模式，打开=1，关闭=0 cleanmode ：干净模式，去除广告，打开=1，关闭=0 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:30:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"29、重力感应原始接口 （3.96以上版本支持） 雷电新增的重力感应操作支持了多款游戏，自3.96增加了命令接口，可以自由发挥了。 dnconsole.exe action –name *** –key call.gravity –value x,y,z x,y,z 是三维坐标系下重力感应的数值。 除外，您还可以在界面添加一个重力感应按钮，通过键盘的快捷键控制重力感应。 ","date":"2021-12-21","objectID":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/:31:0","series":null,"tags":["脚本"],"title":"雷电命令","uri":"/2021/12/%E9%9B%B7%E7%94%B5%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"通用 新建控件后,先改ID,然后添加变量,再添加控件事件 graph z([新建控件])--\u003e 改ID--\u003e 添加变量-.-\u003e 添加控件事件 ","date":"2021-12-20","objectID":"/2021/12/mfc/:1:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CDIALOG对话框 新建DIALOG对话框记得添加类 graph z([新建DIALOG对话框])--\u003e 添加类--\u003e z1[style选child]--\u003e z2[border重选]--\u003e z3[添加事件TCN_SELCHANGE] ","date":"2021-12-20","objectID":"/2021/12/mfc/:2:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CEdit 详情 ","date":"2021-12-20","objectID":"/2021/12/mfc/:3:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CListCtrl 详情 公共方法 描述 CListCtrl::SetExtendedStyle 设定清单视图控制项目前的扩充样式。 CListCtrl::GetExtendedStyle 抓取清单视图控制项目前的扩充样式。 CListCtrl::GetItemText 抓取清单视图专案或子专案的文字。 CListCtrl::GetItemCount 抓取清单视图控制项中的专案数。 CListCtrl::DeleteItem 删除控件中的项。 CListCtrl::InsertItem 在列表视图控件中插入新项。 CListCtrl::InsertColumn 在列表视图控件中插入新列。 CListCtrl::SetItemText 更改列表视图项或子项的文本。 CListCtrl::GetSelectionMark 获取选中行的下标 ","date":"2021-12-20","objectID":"/2021/12/mfc/:4:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"重要参数: 视图 ","date":"2021-12-20","objectID":"/2021/12/mfc/:4:1","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"自动排序方法: 控件右键添加事件LVN_COLUMNCLICK (类列表不要选错) 复制并添加相关代码(代码如下) DWORD dwSelColID = 0; bool bASC = true; int static CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort) { CListCtrl* pListCtrl = (CListCtrl*)lParamSort; LVFINDINFO findInfo; findInfo.flags = LVFI_PARAM; findInfo.lParam = lParam1; int iItem1 = pListCtrl-\u003eFindItem(\u0026findInfo, -1); findInfo.lParam = lParam2; int iItem2 = pListCtrl-\u003eFindItem(\u0026findInfo, -1); CString strItem1 = pListCtrl-\u003eGetItemText(iItem1, dwSelColID); CString strItem2 = pListCtrl-\u003eGetItemText(iItem2, dwSelColID); int iItem1Value = _ttoi(strItem1); int iItem2Value = _ttoi(strItem2); if (bASC) return iItem1Value \u003e iItem2Value; else return iItem1Value \u003c iItem2Value; } void CAutoToolTestDlg::OnLvnColumnclickListInfo(NMHDR* pNMHDR, LRESULT* pResult) { LPNMLISTVIEW pNMLV = reinterpret_cast\u003cLPNMLISTVIEW\u003e(pNMHDR); //if (pNMLV-\u003eiSubItem != 0) //只排序指定列 //{ // return; //} if (dwSelColID != pNMLV-\u003eiSubItem) { dwSelColID = pNMLV-\u003eiSubItem; bASC = bASC; } else bASC = !bASC; int count = m_lstApp.GetItemCount(); for (int i = 0; i \u003c count; i++) m_lstApp.SetItemData(i, i); m_lstApp.SortItems(CompareFunc, (LPARAM)(\u0026m_lstApp)); *pResult = 0; } ","date":"2021-12-20","objectID":"/2021/12/mfc/:4:2","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CListBox Public 说明 CListBox::GetCurSel 返回列表框中当前选定字符串的从零开始的索引。 CListBox::GetText 将列表框项复制到缓冲区中。 CListBox::DeleteString 从列表框中删除字符串。 CListBox::AddString 将字符串添加到列表框。 ","date":"2021-12-20","objectID":"/2021/12/mfc/:5:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CTabCtrl ","date":"2021-12-20","objectID":"/2021/12/mfc/:6:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CTraceServiceControl ","date":"2021-12-20","objectID":"/2021/12/mfc/:7:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CRichEditCtrl 重要属性: 多行 垂直滚动 ","date":"2021-12-20","objectID":"/2021/12/mfc/:8:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"CStdioFile 类 class CStdioFile : public CFile ","date":"2021-12-20","objectID":"/2021/12/mfc/:9:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"公共构造函数 “属性” 说明 CStdioFile::CStdioFile 从路径 CStdioFile 或文件指针构造 对象。 ","date":"2021-12-20","objectID":"/2021/12/mfc/:9:1","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"公共方法 “属性” 说明 CStdioFile::Open 已重载。 Open 旨在与默认构造函数一 (CStdioFile 重写 CFile::Open) 。 CStdioFile::ReadString 读取一行文本。 CStdioFile::Seek 定位当前文件指针。 CStdioFile::WriteString 写入一行文本。 ","date":"2021-12-20","objectID":"/2021/12/mfc/:9:2","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"公共数据成员 “属性” 说明 CStdioFile::m_pStream 包含指向打开的文件的指针。 ","date":"2021-12-20","objectID":"/2021/12/mfc/:9:3","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"类视图 graph 类视图--\u003e消息 \u0026 重写 消息--\u003eWM_TIMER 重写--\u003eOnInitDialog \u0026 OnOk \u0026 OnCancel \u0026 OnWndMsg ","date":"2021-12-20","objectID":"/2021/12/mfc/:10:0","series":null,"tags":["脚本","MFC"],"title":"MFC","uri":"/2021/12/mfc/"},{"categories":null,"content":"注册失败 返回值为-2时,VS需要启用管理员模式 ","date":"2021-12-15","objectID":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":["脚本"],"title":"大漠常见问题","uri":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"chm电子书无法查看 复制到本机 ","date":"2021-12-15","objectID":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":["脚本"],"title":"大漠常见问题","uri":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"雷电模拟器 查看句柄 第4项 ","date":"2021-12-15","objectID":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":["脚本"],"title":"大漠常见问题","uri":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"输入文字 常规的用KeyPressStr即可，但是有一些有屏蔽的，可以试试用SendString(hwnd,str) hwnd用GetPointWindow(x,y)或者GetForegroundFocus()等 ","date":"2021-12-15","objectID":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:4:0","series":null,"tags":["脚本"],"title":"大漠常见问题","uri":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"必要函数 ​ CoInitializeEx(NULL, 0);//大漠所需 com组件在线程中调用的时候，需要初始化一下这个函数 。 ​ CoUninitialize(); //大漠所需，析构时释放。 ","date":"2021-12-15","objectID":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:5:0","series":null,"tags":["脚本"],"title":"大漠常见问题","uri":"/2021/12/%E5%A4%A7%E6%BC%A0%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":" graph LR subgraph AI与图色 z1[\"目标检测(种类、位置)\"] --\u003eYOLOV3 \u0026 YOLOV4 \u0026 YOLOV5 z2[\"文字识别 (中文)\"] --\u003etesseract \u0026 paddle百度 静态找图找字 --\u003e 大漠 \u0026 opencv opencv --\u003e 图像处理 \u0026 边缘检测 \u0026 形状匹配 end graph LR z([CApp])--\u003e CAppDialog--\u003e CMainDialog--\u003e z1[\"CDMEngine[-脚本引擎主类-]\"]--\u003e z2[\"CActionManager[-脚本动作管理-]\"] \u0026 z3[\"CAppManager[-目标程序管理-]\"] CMainDialog--\u003e授权处理 \u0026 跟游戏逻辑无关的动作 CAppDialog--\u003eCSettingDialog \u0026 CLoggingDialog ","date":"2021-12-14","objectID":"/2021/12/ai%E4%B8%8E%E5%A4%A7%E6%BC%A0/:0:0","series":null,"tags":["脚本"],"title":"AI与大漠","uri":"/2021/12/ai%E4%B8%8E%E5%A4%A7%E6%BC%A0/"},{"categories":null,"content":"额外需要掌握的知识 ","date":"2021-12-14","objectID":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/:1:0","series":null,"tags":["脚本"],"title":"额外需要掌握的知识","uri":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"容器的使用 list vector map ","date":"2021-12-14","objectID":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/:2:0","series":null,"tags":["脚本"],"title":"额外需要掌握的知识","uri":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"MFC对话框的使用 新建对话框 button tab edit list ","date":"2021-12-14","objectID":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/:3:0","series":null,"tags":["脚本"],"title":"额外需要掌握的知识","uri":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"其它插件 乐玩、天使、图灵 ","date":"2021-12-14","objectID":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/:4:0","series":null,"tags":["脚本"],"title":"额外需要掌握的知识","uri":"/2021/12/%E9%A2%9D%E5%A4%96%E9%9C%80%E8%A6%81%E6%8E%8C%E6%8F%A1%E7%9A%84%E7%9F%A5%E8%AF%86/"},{"categories":null,"content":"火眼 http://www.hyocr.com 7.8字母数字 28分 100元10W分 2.8分 QQ 超人 http://www.chaorendama.com/ 7.8字母数字 1.2分 蜂蜂帮玩 http://feng.suanst.com/ 7.8字母数字 19分 50元7w分 1.5分 ","date":"2021-12-14","objectID":"/2021/12/%E4%BA%91%E6%89%93%E7%A0%81/:0:0","series":null,"tags":["云打码"],"title":"云打码","uri":"/2021/12/%E4%BA%91%E6%89%93%E7%A0%81/"},{"categories":null,"content":"程序如何组织 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:0:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"游戏脚本需要做哪些模块 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:1:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"模拟器/虚拟机管理 单独建类 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:2:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"配置文件 ini文件与txt文件 程序配置.txt 界面配置.txt 默认配置.ini [联众] 用户名= 密码= [授权] 注册码= [模拟器] 锁定模拟器窗口=0 模拟器数量=8 模拟器启动间隔=11 模拟器执行时间最小值=22 模拟器执行时间最大值=33 模拟器切换比例=40 模拟器路径=D：(leidian\\LDPlayer4\\dnconsole.exe 模拟器关闭时间段= ;账号 密码 等级 金币回城 [账户] 数量=4 账户1=18983838383,123456,0,0,0 账广2= 账户3= [挂机点1] 地图=骷牋洞1层|钴髅洞2层|玛法球场|骷髅洞3层1|骷髅洞3层2|狼|比奇矿区 玛法球场=18,25,64,63 狼=103,621|365,601|510,606|507,682|235,643|95,543|167,552|374,554 骷髅洞1层=172,356|207,220|169, 197|112,228|65, 234|30,329|252, 266|214,316 骷镂洞2层=63,310|79,212|74,148|134, 106|162,71|203,65|250,78|232,243 骷髅洞3层1=137,121|179,135|211,170|262,217|309,205|295, 151|329, 102|294,3 骷發洞3层2=68,21|187,299|177,333|179,255|134, 181|218,200|239,279|231, 348 比奇矿区=24,19/ 80,10189,58 88. 891153, 1581 177. 1001179,20 [脚木] 常驻命令=当前地图|玛汰球场|骷镂洞1层|钴镂洞2层|骷髅洞3层|比奇矿区 临时命令=自动交易 角色类型=道士 拾取前宝宝休息=0 一件特修=1 拾取物品=回城券|兽皮 任务列表= 帐号密码 打码 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:3:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"图片资源 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:4:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"线程管理 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:5:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"脚本内容 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:6:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"点击/移动脚本间的协调 ","date":"2021-12-14","objectID":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/:7:0","series":null,"tags":["脚本"],"title":"中控设计","uri":"/2021/12/%E4%B8%AD%E6%8E%A7%E8%AE%BE%E8%AE%A1/"},{"categories":null,"content":"汇编描述","date":"2021-11-23","objectID":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"C++内联汇编常见问题.md","uri":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"定位 { __asm { mov edx,edx mov edx,edx mov edx,edx ... } } ","date":"2021-11-23","objectID":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":null,"title":"C++内联汇编常见问题.md","uri":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"不可直接传值 { __asm { mov eax,[0x01] //错误,不可直接传值 //方法1 mov eax,0x01 //需要通过寄存器来传值 mov eax,[eax] //方法2 mov eax,dword ptr ds:[0x01] } } ","date":"2021-11-23","objectID":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":null,"title":"C++内联汇编常见问题.md","uri":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"传局部变量的地址 { int b =1; int* a = \u0026b; DWORD c = (DWORD)a; __asm { pushad push c ... popad } } ","date":"2021-11-23","objectID":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":null,"title":"C++内联汇编常见问题.md","uri":"/2021/11/c-%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"想必现在小伙伴们电脑都已经升级到 Windows 10 了。不过，你是否发现，你的系统里默默躺着很多系统自带却你从来不用的应用程序呢。这些应用并不会占用多大的空间，有些只是一个启动链接，比如系统自带「迪士尼梦幻王国」游戏，默认不占用多少空间，在你点击后，就会自动下载整个600M的安装包进行安装。 另外，这些自带应用有些都是随系统自动启动的，多少总会占用一点系统资源。 德哥是个强迫症患者，看到这些平时用不着的应用在眼前晃来晃去，总想着除之而后快。 ","date":"2022-03-07","objectID":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/:0:0","series":null,"tags":null,"title":"未分类的常见问题","uri":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"卸载 win10 自带应用的通常方法 卸载这些应用说容易也容易，说不容易也不容易。 最常见的方式，就是点开启动菜单，右键点击你需要卸载的应用，点击卸载即可。 但我们会发现，这些应用有些提供卸载按钮，有些则不提供卸载按钮。 可以卸载应用（邮箱、地图、钱包、新闻、Xbox 等） 不可卸载应用（应用商店、消息、相机、人脉、闹钟、图片、sticky notes、获取帮助、混合现实门户等） 当然，你也可以用控制面板的卸载模块进行卸载。 点击开始菜单，点击设置-应用，找到你要卸载的应用即可。 上面的方法，也适用于自己下载安装的应用程序。 ","date":"2022-03-07","objectID":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/:0:1","series":null,"tags":null,"title":"未分类的常见问题","uri":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"利用第三方应用管理程序进行卸载，比如 CleanMyPC 经常使用 Mac 的小伙伴知道，Mac 上有一款 CleanMyMac 的神器，可以帮你清理你无法清理干净的应用。有个好消息是，这货也出了一款 PC 上的兄弟软件：CleanMyPC。它可以帮你方便的干掉这些难缠的应用。另外，它还有个好处就是可以帮你发现一些 Windows 系统自己发现不了的应用。 不过，CleanMyPC 是一款收费软件，价格还不菲，有些高级功能需要缴费才能使用。 ","date":"2022-03-07","objectID":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/:0:2","series":null,"tags":null,"title":"未分类的常见问题","uri":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"通过 PowerShell 命令行模式来卸载应用 当我们既想省点钱，又想卸载系统那些不提供卸载按钮的自带应用该怎么办呢？ 这时候，就要用到我们的 PowerShell 命令行模式了。 Windows 相比 Linux 和 MacOS，最欠缺的就是命令行模式的灵活性和可编程性太弱。powershell 的诞生，就仿佛给了 Windows 一把瑞士军刀。PowerShell 是一款基于对象的shell, 建立在.Net框架之上, 使命令行用户和脚本编写者可以利用 .NET Framework的强大功能，同时能深入到系统进程中，开展一系列自动化和批处理工作。 下面我们就采用 Windows 10 中 powershell 内置的 Get-AppxPackage 、 Remove-AppxPackage 和 Add-AppxPackage 命令来进行安装卸载操作。 Get-AppxPackage：用于获得 Win 10 系统内置应用信息。 Remove-AppxPackage：用于删除 Win 10 系统内置应用。 Add-AppxPackage：用于安装 Win 10 系统内置应用。 首先，以管理员身份打开PowerShell 如果你的系统是最新版 Windows 10，你只需要按住快捷键 Windows + X，或右键点击左下角的 win 图标，然后从高级用户菜单中选择“Windows PowerShell（管理员）”选项。 若你的 win10 系统没有及时更新，也可能看到的不是 powershell，而是「命令行」。这样的话，你可以按快捷键 Windows + S，输入powershell，然后右键选择「以管理员身份运行」。 获取 Win 10 系统内置应用信息 做任何事情，我们都应该做到有「备」无患。 应用信息备份有两种方式： 一是备份当前已装应用的详细信息 输入命令 Get-AppxPackage ，就可以查看当前用户所有已安装的应用。 将已安装应用列表导出到一个文件，留作备份，可以帮助我们后续重新安装回所需的应用。 复制下面代码到 PowerShell，并输入回车即可： Get-AppxPackage \u003e\u003e D:\\AppxPackage.bak1.txt \u003e\u003e 也可以换成 \u003e，前者是内容追加到文档最后，后者是覆盖文档内容。看您需要合理选择即可。 二是只备份应用包的简称和全称 因为我们重装应用只需要用到应用名称和包全称，其他信息并不需要，所以，我们也可以只备份这两部分内容。 查看应用名称和包全称： get-appxpackage | Select Name, PackageFullName 若要导出为备份，命令如下： get-appxpackage | Select Name, PackageFullName \u003e\u003e D:\\AppxPackage.bak2.txt 没有备份的补救措施 如果你没有备份就直接卸载了，又想不起该应用的包信息。我们也可以通过以下命令来找出系统自带所有安装包的信息： get-appxpackage -allusers 如果你知道该包的大致简称，还可以加上该简称信息，如下： get-appxpackage -allusers *windowscalculator* 你将得到「计算器」应用的所有信息。 用 PowerShell 卸载应用 当你做好备份工作后，你现在就可以开始利用 powershell 进行愉快的卸载安装工作了。 Get-AppxPackage 命令可以帮助你卸载大多数内置的应用程序，甚至那些通常不提供“卸载”选项的应用。但是，请注意，这个技巧不允许你删除一些最重要的内置应用程序，比如 Cortana 和 Edge 浏览器。如果强行删除，只会看到一个报错信息。 下面，我们先尝试一下删除单个应用。 利用 Remove-AppxPackage PackageFullName 命令卸载 首先，我们用前文提到的 Get-AppxPackage | Select Name, PackageFullName 命令获得的应用包全称。 比如你不大玩游戏，想删除 Xbox 应用，那么，就找到「Xbox」对应的应用包全称 再在 PowerShell 输入下面的命令即可： Remove-AppxPackage Microsoft.XboxApp_41.41.18005.0_x64__8wekyb3d8bbwe 打字累的话，PowerShell 支持 Ctrl + C 和 Ctrl + V。 利用通配符（*）结合管道命令进行卸载 另外，还可以使用通配符（*）结合管道符来卸载应用，这样，我们只要输入前面的应用简称即可。 Get-AppxPackage *xboxapp* | Remove-AppxPackage OK，就是这么轻松。 如果你想删除其他应用，只需要将 *xboxapp* 换成你想删除应用的名称即可。 有些应用是不能卸载的 Win10 中那些和系统结合紧密的应用是无法删除的，如果碰到无法删除的应用，则会出现错误提示，比如删除微软小娜「Cortana」： Get-AppxPackage *cortana* | Remove-AppxPackage 将出现如下报错： 常用应用列表 下面我给一个常用应用的列表： 应用名称 对应代码 画图3D 3dbuilder 闹钟和时钟 windowsalarms 计算器 windowscalculator 日历和邮件 windowscommunicationsapps 摄像头 windowscamera 联系人 无法删除 Cortana 无法删除 我的office officehub 入门 getstarted Groove 音乐 zunemusic 地图 windowsmaps Edge 无法删除 棋牌游戏 solitairecollection 记账 bingfinance 电影和电视 zunevideo 新闻 bingnews OneNote onenote 人脉 people Phone Companion windowsphone 照片 photos 应用商店 windowsstore 运动 bingsports 录音 soundrecorder 天气 bingweather Feedback 无法删除 Xbox xboxapp 用 powershell 批量卸载内置应用 是不是感觉一个个卸载应用太麻烦，其实，你完全可以利用通配符 * ，一条命令实现内置应用的批量卸载。 卸载「Xbox」相关的所有应用： Get-AppxPackage *Xbox* | Remove-AppxPackage 卸载所有系统内置应用： Get-AppxPackage * | Remove-AppxPackage 你将在一片红色警告和黄色提示后，重新得到一个干净清爽的系统。 当然，那些 Windows 死活都不愿意你卸载的应用还是没有办法的，因为去掉那些应用，你的系统可能就运行不正常了。 重新安装内置应用 重装单个应用 比如，我们不小心把系统自带的计算器给删除了，那该怎么安装回去呢？ 很简单，我们先找到这个应用的包全名。 命令行下输入： Get-AppxPackage -allusers *windowscalculator* 得到如下信息： 拷贝查到的 InstallLocation，黏贴到如下命令中： Add-AppxPackage -register \"C:\\Program Files\\WindowsApps\\Microsoft.WindowsCalculator_10.1805.1201.0_x64__8wekyb3d8bbwe\\appxmanifest.xml\" -DisableDevelopmentMode 不同的包，替换命令中橘色背景部分的 InstallLocation内容即可。 不用重启电脑，计算器应用又可以使用了。 重装所有内置应用 如果你有一天后悔了，想重装全部应用，又不想一个个复制包全称进行安装。办法也是有的，用管理员权限打开 PowerShell，复制黏贴如下命令并回车即可： Get-AppxPackage -AllUsers| Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \"$($_.InstallLocation)\\AppXManifest.xml\"} 这条命令会将 Windows 10 所有内置的默认应用都重新安装回来。如果看到错误提示，不必理会，重启系统即可。 现在，你的系统是不是已经按照你的要求定制了呢，如果还没有，赶快动手吧！ Enjoy it！^_^ ","date":"2022-03-07","objectID":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/:0:3","series":null,"tags":null,"title":"未分类的常见问题","uri":"/2022/03/%E5%8D%B8%E8%BD%BDwin10%E5%86%85%E7%BD%AE%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"安装 勾选“使用C++的桌面开发” 右边勾选C++ MFC 安装位置中取消勾选“安装后保留下载缓存” ","date":"2021-12-21","objectID":"/2021/12/vs2019%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C/:1:0","series":null,"tags":null,"title":"VS2019安装与注册","uri":"/2021/12/vs2019%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C/"},{"categories":null,"content":"注册 Visual Studio 2019 Professional 专业版： NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y 点击帮助，选择“注册产品” 点击“使用产品密钥解锁” 产品密钥输入：NYWVH-HT4XC-R2WYW-9Y3CM-X4V3Y，点击“应用” ","date":"2021-12-21","objectID":"/2021/12/vs2019%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C/:2:0","series":null,"tags":null,"title":"VS2019安装与注册","uri":"/2021/12/vs2019%E5%AE%89%E8%A3%85%E4%B8%8E%E6%B3%A8%E5%86%8C/"},{"categories":null,"content":"UDD目录丢失 UDD目录不存在，需要手动添加。 ","date":"2021-11-03","objectID":"/2021/11/od%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/:1:0","series":null,"tags":null,"title":"OD加载错误提示","uri":"/2021/11/od%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"},{"categories":null,"content":"个别文件错误 需要打开ollydbg.ini文件，更改相应目录。 ","date":"2021-11-03","objectID":"/2021/11/od%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/:2:0","series":null,"tags":null,"title":"OD加载错误提示","uri":"/2021/11/od%E5%8A%A0%E8%BD%BD%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA/"},{"categories":null,"content":" graph subgraph 一 mac分区 磁盘工具--\u003e 显示所有分区--\u003e 添加分区--\u003e 名称大小随意--\u003e 格式exfat--\u003e 应用--\u003e 重启 end subgraph 二 微pe格式化 重启_ --\u003e 开机按Alt键--\u003e EFI_boot--\u003e DiskGenuis分区工具--\u003e 格式化 end subgraph 三 安装系统 还原安装--\u003e 选映像文件--\u003e 选安装盘--\u003e 勾选修复引导--\u003e 开始安装 end subgraph 四 安装驱动 mac迁移助手--\u003e U盘下载驱动--\u003e 到win下安装 end ","date":"2021-10-28","objectID":"/2021/10/mac%E5%AE%89%E8%A3%85win10/:0:0","series":null,"tags":null,"title":"mac安装win10","uri":"/2021/10/mac%E5%AE%89%E8%A3%85win10/"},{"categories":null,"content":"字体乱码 需要安装 “新宋体” 字体 ","date":"2021-10-28","objectID":"/2021/10/mac%E5%AE%89%E8%A3%85win10/:1:0","series":null,"tags":null,"title":"mac安装win10","uri":"/2021/10/mac%E5%AE%89%E8%A3%85win10/"},{"categories":null,"content":"桌面显示“我的电脑” graph LR 桌面右键--\u003e个性化--\u003e布景主题--\u003e桌面显示设定 ","date":"2021-10-28","objectID":"/2021/10/mac%E5%AE%89%E8%A3%85win10/:2:0","series":null,"tags":null,"title":"mac安装win10","uri":"/2021/10/mac%E5%AE%89%E8%A3%85win10/"},{"categories":null,"content":"如何在 Windows 10 上反转鼠标滚动方向 ","date":"2021-10-28","objectID":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/:1:0","series":null,"tags":null,"title":"如何在 Windows 10 上反转鼠标和触摸板的滚动方向","uri":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/"},{"categories":null,"content":"识别鼠标信息 要在 Windows 10 上识别鼠标识别号，请使用以下步骤： 打开 开始 . 搜索 装置经理 ，单击顶部结果以打开体验。 展开 鼠标和其他指点设备 分支。 右键单击您正在使用的鼠标，然后选择 特性 选项。 点击 细节 标签。 使用“属性”下拉菜单并选择 设备实例路径 选项。 注意鼠标的 VID ID 值——例如， VID_0E0F \u0026 PID_0003 \u0026 MI_01 . 完成这些步骤后，继续执行以下步骤以使用注册表反转鼠标滚动。 ","date":"2021-10-28","objectID":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/:1:1","series":null,"tags":null,"title":"如何在 Windows 10 上反转鼠标和触摸板的滚动方向","uri":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/"},{"categories":null,"content":"反转鼠标滚动方向 要使用注册表反转鼠标滚动方向，请使用以下步骤： 使用 Windows 键 + R 键盘快捷键打开 regedit 命令。 类型 注册表编辑器 ，然后单击 好的 打开 注册表 . 浏览以下路径： ComputerHKEY_LOCAL_MACHINESYSTEMCurrentControlSetEnumHID 小建议： 在 Windows 10 上，您现在可以复制并粘贴注册表地址栏中的路径以快速跳转到关键目标。 如何在 Windows 10 上关闭自动更新 展开与您鼠标的 VID ID 匹配的键（文件夹）——例如， VID_0E0F \u0026 PID_0003 \u0026 MI_01 . 展开可用密钥。 选择 设备参数 钥匙。 双击 人字拖轮 DWORD 并设置值 0 至 1 . 点击 好的 . 重启你的电脑。 完成这些步骤后，当您使用鼠标滚轮向上滚动时，页面也应向上滚动。 将来，如果您改变主意，可以使用相同的说明将鼠标滚轮的翻转方向恢复到其原始设置，但在 第 7 步 , 确保设置值来自 1 至 0 . ","date":"2021-10-28","objectID":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/:1:2","series":null,"tags":null,"title":"如何在 Windows 10 上反转鼠标和触摸板的滚动方向","uri":"/2021/10/%E5%A6%82%E4%BD%95%E5%9C%A8-windows-10-%E4%B8%8A%E5%8F%8D%E8%BD%AC%E9%BC%A0%E6%A0%87%E5%92%8C%E8%A7%A6%E6%91%B8%E6%9D%BF%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%96%B9%E5%90%91/"},{"categories":null,"content":"Windows精简版系统安装注意事项 1.安装完成后首次进入系统，桌面会有一个“Restart.bat”的文件，请使用管理员模式运行该文件，运行期间会让你选择是否精简掉Cortana，建议选择是(也就是输入y并回车)随后系统会自动重启。 2.安装完毕之后请关闭系统更新（方法：win+r运行“services.msc”找到“Windows update”，右键属性，启动类型更改为“禁用”，应用设置即可） 3.如果你发现一些视频网站(如：优酷等)的视频无法正常播放，请进入C盘中的“Windows\\System32\\drivers\\etc”目录下，将文件hosts删除。 4.常见的系统功能及组件被精简的有：Windows Defender,Windows Edge,Cortana,应用商店,以及默认的照片查看与视频播放工具。推荐使用honeyview作为默认照片查看工具，Potplayer作为默认视频播放工具。 OneDrive如何恢复？ 俄罗斯大神精简OneDrive用的方法是在注册表里添加了一个“DisableFileSyncNGSC”，所以我们删除这个键值即可。 按下win+r调出运行，输入“regedit”，在注册表中依次选择 “HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows” 在右侧窗口右键选择“DisableFileSyncNGSC”并删除。 最后重新打开OneDrive或者重装OneDrive即可。 作者：科技迷不满 https://www.bilibili.com/read/cv13357344 出处：bilibili ","date":"2021-10-18","objectID":"/2021/10/lopatkin%E4%BF%84%E5%A4%A7%E7%A5%9Ewindows%E7%B2%BE%E7%AE%80%E7%89%88/:0:0","series":null,"tags":null,"title":"lopatkin俄大神Windows精简版","uri":"/2021/10/lopatkin%E4%BF%84%E5%A4%A7%E7%A5%9Ewindows%E7%B2%BE%E7%AE%80%E7%89%88/"},{"categories":null,"content":"图解DbgView使用 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:0:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"一 DbgView简介 Sysinternals公司的系列调试工具。 debugview 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。 Debug信息捕获软件 可以很方便的捕获系统实时输出的Debug信息，并保存为日志文件。可以远程捕获服务器上的Debug信息。 比较方便开发人员在系统发布前监控一些系统流程和异常，甚至在系统不大的情况下，更能在部署后进行远程监控功能。 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"二 实际操作 Computer菜单下可选择连接的计算机，默认连接本机； 输入IP或名字可连远程计算机； 下面四个按钮，第一个放大镜的，控制捕获的打开或关闭；第二个控制是否捕获系统内核的Debug信息；第三个控制是否捕获Win32应用的Debug信息； 这是本机捕获的情况； 点击漏斗型按钮，打开过滤器设置，在Include中输入TRACE，在Exclude中输入WAIT_TIMEOUT；这样就只显示带字符串“TRACE”的debug信息，不显示带“WAIT_TIMEOUT”的调试信息； 过滤以后的结果； 漏斗型按钮旁边的按钮控制显示记录的条数；下图显示16条； 捕获菜单中，默认捕获的是Win32，Pass-Through，Events；全局Win32，内核等，默认没有捕获； 选项菜单，可以选择是否显示Win32进程ID，是否滚动显示等； ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"三 TRACE宏和Dbgview http://blog.163.com/gou_ya/blog/static/102080580200810274839532/ debugview 1、用debugview，打开debugview，运行你的debug版本程序，可以定位到源文件的某一行。 2、包含stdlib.h crtdbg.h 两个头文件 在程序开始处添加 #define _CRTDBG_MAP_ALLOC 在程序结束处添加 _CrtDumpMemoryLeaks(); 比如 #define _CRTDBG_MAP_ALLOC int main(void) { char *p = new char; return 0; _CrtDumpMemoryLeaks(); } 运行debug版本的程序。在输出信息栏里会有内存泄露信息，可以定位到某一行 以上两种方法不是没种泄露都能定位，如果不能，会输出内存泄露信息和发生泄漏的模块，那就要自己想想，什么地方出现了泄露 TRACE宏对于VC下程序调试来说是很有用的东西，有着类似printf的功能；该宏仅仅在程序的DEBUG版本中出现，当RELEASE的时候该宏就完全消失了，从而帮助你调试也在RELEASE的时候减少代码量。 使用非常简单，格式如下： TRACE(“DDDDDDDDDDD”); TRACE(“wewe%d”,333); 同样还存在TRACE0，TRACE1，TRACE2。。。分别对应0，1，2。。个参数 TRACE信息输出到VC IDE环境的输出窗口（该窗口是你编译项目出错提示的那个窗口），但仅限于你在VC中运行你的DEBUG版本的程序。 TRACE信息还可以使用DEBUGVIEW来捕获到。这种情况下，你不能在VC的IDE环境中运行你的程序，而将BUILD好的DEBUG版本的程序单独运行，这个时候可以在DEBUGVIEW的窗口看到DEBUGVIE格式的输出了。 VC中TRACE的用法有以下四种： 1: TRACE ，就是不带动态参数输出字符串, 类似C的printf(“输出字符串”); 2: TRACE 中的字符串可以带一个参数输出 , 类似C的printf(\"…%d\",变量); 3: TRACE 可以带两个参数输出，类似C的printf(\"…%d…%f\",变量1,变量2); 4: TRACE 可以带三个参数输出，类似C的printf(\"…%d，%d,%d\",变量1,变量2，变量3); TRACE 宏有点象我们以前在C语言中用的Printf函数，使程序在运行过程中输出一些调试信息，使我们能了解程序的一些状态。但有一点不同的是： TRACE 宏只有在调试状态下才有所输出，而以前用的Printf 函数在任何情况下都有输出。和Printf 函数一样，TRACE函数可以接受多个参数如： int x = 1; int y = 16; float z = 32.0; TRACE( “This is a TRACE statement\\n” ); TRACE( “The value of x is %d\\n”, x ); TRACE( “x = %d and y = %d\\n”, x, y ); TRACE( “x = %d and y = %x and z = %f\\n”, x, y, z ); 要注意的是TRACE宏只对Debug 版本的工程产生作用，在Release 版本的工程中，TRACE宏将被忽略。 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:3:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"四 C#中使用 在C#中的使用方法： 将WinDebug.cs加入到项目中，也可以编译成.dll文件引入。然后在程序中需要输出调试信息调用即可。 另外，如果要在运行时应用不输出debug信息，可以将web.config或app.config中的 \u003csystem.web\u003e 设置为false，然后在调用WinDebug的地方就不会再输出Debug信息了 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:4:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"Visual C++免注册调用大漠插件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"1、 注册调用 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:0","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"一、下载大漠插件，并注册到系统 下载地址：https://pan.baidu.com/s/1nCc5jB4izcp_I2J6JLqEKA 提取码：tf1f ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:1","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"二、创建一个空项目 添加main.cpp和main.h，导入插件中的obj.cpp和obj.h文件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:2","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"三、修改obj.cpp中引入的头文件 #include \"stdafx.h\"去除 #include \"main.h要放前面\" ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:3","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"四、更改运行库为“多线程(/MT)” ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:4","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"五、main.h #ifndef MAIN_H #define MAIN_H #include \u003cafx.h\u003e #include \u003cafxwin.h\u003e #include \u003cafxext.h\u003e #include \u003catlbase.h\u003e #include \u003catlstr.h\u003e #include \u003cafxdtctl.h\u003e #include \u003cafxcmn.h\u003e #include \u003cafxdisp.h\u003e #include \"obj.h\" #endif ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:5","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"六、main.cpp #include \"main.h\" #include \"obj.h\" #include \u003ciostream\u003e using namespace std; int main() { CoInitializeEx(NULL, 0);//初始化 AfxWinInit(GetModuleHandle(NULL), NULL, GetCommandLine(), 0); dmsoft* pDm = new dmsoft; pDm-\u003eMoveTo(0, 0); pDm-\u003eRunApp(L\"notepad\", 1); pDm-\u003edelay(3000); pDm-\u003eKeyPressStr(L\"123456789011\", 20); wcout \u003c\u003c (LPCTSTR)(pDm-\u003eVer())\u003c\u003c endl; return 0; } ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:6","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"2、免注册调用 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:0","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"一、创建一个空项目 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:1","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"二、添加main.cpp #include \u003ciostream\u003e #import \"dm.dll\" no_namespace int main() { return 0; } ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:2","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"三、添加dm.dll ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:3","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"四、生成解决方案 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:4","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"五、编译成功后会生成dm.tlh和dm.tli文件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:5","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"六、修改dm.tlh 修改前 修改后 七、main.cpp #include \u003ciostream\u003e //#import \"dm.dll\" no_namespace #include \"Debug\\dm.tlh\" using namespace std; Idmsoft* GetDmObject() { Idmsoft* m_dm = NULL; bool m_bInit = false; //直接加载dll创建对象，避免进行注册文件 typedef HRESULT(_stdcall* pfnGCO)(REFCLSID, REFIID, void**); pfnGCO fnGCO = NULL; HINSTANCE hdllInst = LoadLibrary(L\"dm.dll\"); fnGCO = (pfnGCO)GetProcAddress(hdllInst, \"DllGetClassObject\"); if (fnGCO != 0) { IClassFactory* pcf = NULL; HRESULT hr = (fnGCO)(__uuidof(dmsoft), IID_IClassFactory, (void**)\u0026pcf); if (SUCCEEDED(hr) \u0026\u0026 (pcf != NULL)) { hr = pcf-\u003eCreateInstance(NULL, __uuidof(Idmsoft), (void**)\u0026m_dm); if ((SUCCEEDED(hr) \u0026\u0026 (m_dm != NULL)) == FALSE) return NULL; } pcf-\u003eRelease(); m_bInit = true; } else m_bInit = false; return m_dm; } int main() { Idmsoft* pDm = GetDmObject(); cout \u003c\u003c pDm-\u003eVer() \u003c\u003c endl; //dm-\u003eReg(L\"注册码\", L\"dass\");//收费版本需要注册后才能使用 /*6.1538版本修改内存可直接调用*/ DWORD pid = GetCurrentProcessId(); int handle = (int)GetModuleHandle(L\"dm.dll\"); cout \u003c\u003c \"进程ID:\" \u003c\u003c pid \u003c\u003c \"模块句柄：\" \u003c\u003c handle \u003c\u003c endl; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); int value = 1; bool is = WriteProcessMemory(hProcess, LPVOID(handle + 1078240), \u0026value, 1, NULL); /*调用大漠插件内函数*/ pDm-\u003eMoveTo(0, 0); pDm-\u003edelay(3000); pDm-\u003eKeyPressStr(\"1234567890\", 10); return 0; } 注册码 注册码：3093030f54fe75b8478f7c56fec81fc903841a9 附加码：Z3Ipwoyq5 注朋码：yiging123c12aba5b0179907a750692b023298f12\"ww168168” 注册码: qq760471367f21b0879268408e5096b92cb022804da附加码vvv0000 注册码：zhangxuhvi2d3b98fcd75ac8ee163feadabc6191b85附加码7b666777 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:3:6","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"必要函数 ​ CoInitializeEx(NULL, 0);//大漠所需 com组件在线程中调用的时候，需要初始化一下这个函数 。 ​ CoUninitialize(); //大漠所需，析构时释放。 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:4:0","series":null,"tags":["脚本"],"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"配置文件追加hosts hosts: 'folivora.ai': 127.0.0.1 'www.folivora.ai': 127.0.0.1 'updates.boastr.net': 127.0.0.1 'updates.folivora.ai': 127.0.0.1 ","date":"2021-08-22","objectID":"/2021/08/clash%E9%98%B2%E6%9B%B4%E6%96%B0/:0:0","series":null,"tags":null,"title":"clash防更新","uri":"/2021/08/clash%E9%98%B2%E6%9B%B4%E6%96%B0/"},{"categories":null,"content":"链接 这里可能会失败,可反复尝试 ","date":"2021-08-22","objectID":"/2021/08/icloud%E5%9C%9F%E8%80%B3%E5%85%B6%E5%85%85%E5%80%BC/:0:0","series":null,"tags":null,"title":"iCloud土耳其充值","uri":"/2021/08/icloud%E5%9C%9F%E8%80%B3%E5%85%B6%E5%85%85%E5%80%BC/"},{"categories":null,"content":"第一步：JDK下载 打开Oracle官网，点击 资源–软件下载按钮： 进入下载页面：点击Java选项，跳转到Java相关下载的选项： 选择Java(JDK) for Developers选项，跳转到JDK下载页面。 也可以直接点击JDK下载，进入该页面，在该页面中有多个版本可以供开发者下载，目前我用的是JDK 16，所以，我以JDK 16为例，讲解它的下载，滑到Java SE 16，可以看到下图： ​ 点击红框中的按钮，下载，会跳转到JDK选择的页面： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:1:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第二步：JDK安装 双击JDK安装包，然后按照提示流程一步步操作，直到安装完成。我们可以根据下图标识的路径找到已经安装好的JDK： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:2:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第三步：Java配置环境变量 这是最关键的一步。不只是Java开发需要配置环境，在Android、Flutter等开发中如果配置相关的环境变量，也是根据下述的方法进行的。废话不多说，看下面的描述： 打开终端Terminal 如果是第一次配置环境变量，使用命令 touch .bash_profile 创建一个名为**.bash_profile** 隐藏配置文件; 如果不是第一次配置环境变量，使用命令 open .bash_profile 打开配置文件； 在配置文件中输入下面的内容： JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-16.0.2.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 保存关闭配置文件。 注意：JAVA_HOME的值是JDK安装目录下Home的路径。 继续使用命令 source .bash_profile 使配置文件生效。 ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:3:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第四步：检测环境是否安装成功 输入命令 java -version ，查看JDK的版本，如果输出JDK的版本号，说明JDK环境变量配置成功。 如下图： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:4:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第五步：开发工具安装 JDK安装好后，我们就可以下载安装自己常用的开发工具，然后配置JDK的安装路径，这样就可以开发了。由于开发工具之多，每个开发人员的开发工具又不一样，这里就不再介绍了。 ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:5:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"扩展 Contents目录下的Home文件夹是JDK的根目录； bin目录下存放的是用于开发的一些终端命令工具，例如：javac、java等命令； db目录下是Java开发的一个开源的关系型数据库； include目录下是一些C语言的头文件； jre目录下是JDK所依赖的Java运行时； lib目录下存放JDK开发工具所依赖的一些库文件； man目录下存放JDK开发工具的说明文档。 以上就是关于Java开发的环境搭建！ ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:6:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"Clash for Windows 绕过系统代理 ","date":"2021-08-22","objectID":"/2021/08/macos-%E5%8D%87%E7%BA%A7%E5%88%B0-13-%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%BF%BB%E8%AF%91/:1:0","series":null,"tags":null,"title":"macOS 升级到 13 后无法使用系统翻译","uri":"/2021/08/macos-%E5%8D%87%E7%BA%A7%E5%88%B0-13-%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%BF%BB%E8%AF%91/"},{"categories":null,"content":"设置方式 进入 Settings 页面 点击 System proxy Bypass 右边 Edit 小字打开编辑界面 若要增加绕过 \"sequoia.apple.com\" \"seed-sequoia.siri.apple.com\" 域名，只需在修改编辑界面内容为： bypass: - \"sequoia.apple.com\" - \"seed-sequoia.siri.apple.com\" # 下面字段可不删除 - 127.0.0.1 - ... 点击编辑器右下角保存 bypass 类型为数组，item 为需要绕过的域名或节点，支持通配符* 修改完成后的效果： ","date":"2021-08-22","objectID":"/2021/08/macos-%E5%8D%87%E7%BA%A7%E5%88%B0-13-%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%BF%BB%E8%AF%91/:2:0","series":null,"tags":null,"title":"macOS 升级到 13 后无法使用系统翻译","uri":"/2021/08/macos-%E5%8D%87%E7%BA%A7%E5%88%B0-13-%E5%90%8E%E6%97%A0%E6%B3%95%E4%BD%BF%E7%94%A8%E7%B3%BB%E7%BB%9F%E7%BF%BB%E8%AF%91/"},{"categories":null,"content":"UEFI基地的快速解决方案 根据图片，一步一步… 引导顺序 输入名称：123 当“123”列表添加到上述列表中时，必须从其余列表中删除“V” Apply =\u003e打开弹出窗口 =\u003e单击“确定” 退出 系统重新启动… 等等，看看我的魔法是否成功了…… ","date":"2021-08-22","objectID":"/2021/08/venue-11-no-bootable-devices-found/:0:0","series":null,"tags":null,"title":"VENUE 11 no bootable devices found","uri":"/2021/08/venue-11-no-bootable-devices-found/"},{"categories":null,"content":"![截屏2021-10-15下午4.48.49](https://cdn.jsdelivr.net/gh/xinqinew/pic@main/img/截屏2021-10-15 下午4.48.49.png) ","date":"2021-08-22","objectID":"/2021/08/venue-%E8%A3%85%E6%9C%BA/:0:0","series":null,"tags":null,"title":"VENUE 装机","uri":"/2021/08/venue-%E8%A3%85%E6%9C%BA/"},{"categories":null,"content":"参考 我是如何将 DELL VENUE 11 PRO 5130 平板修复好的 （5130-32位）驱动程序下载 DELL驱动程序检测工具 DELL VENUE 11 PRO系统损坏之后的解决办法 U启动 Rufus推荐 ","date":"2021-08-22","objectID":"/2021/08/venue-%E8%A3%85%E6%9C%BA/:1:0","series":null,"tags":null,"title":"VENUE 装机","uri":"/2021/08/venue-%E8%A3%85%E6%9C%BA/"},{"categories":null,"content":"windows10: 搭建FTP服务器, 实现上传/下载 注: 本教程对 Windows10 专业版(Professional) 完全适用；windows10家庭版配置FTP服务器，仅 创建用户步骤稍有不同，详见如下具体步骤: 找到 控制面板 –\u003e 程序 –\u003e 启动或关闭 windows 功能 打开 IIS(Internet Information Services) 3. 找到 计算机管理： 打开服务和应用程序 –\u003e Internet Information Services；点击 网站 —\u003e 添加FTP站点 输入FTP 站点名称(名称随意)，物理路径选择本地磁盘中的一个位置: 6. 使用cmd命令 ipconfig 查看你的ip地址: 填写IP地址(端口号不必修改)，并选择 无SSL： 身份验证: 勾选匿名、基本; 允许访问: 所有用户； 权限: 勾选 读取、写入; 在 windows防火墙 中，允许 FTP服务器 通过； 通过浏览器访问 ftp://your ip address；work! 注: 若希望通过其他主机访问FTP服务器，需要 关闭防火墙；并且两台主机，要处在同一个 局域网(local area network) 下. 至此，windows10搭建FTP服务器成功！ ","date":"2021-08-22","objectID":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/:1:0","series":null,"tags":null,"title":"WIN10搭建FTP","uri":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/"},{"categories":null,"content":"实现特定用户访问 在成功搭建FTP服务器的基础之上，设置用户名和密码，以实现 用户权限控制，划分使用FTP服务器的用户。 在计算机管理 –\u003e 本地用户和组 –\u003e 用户 —\u003e 创建新用户 用户名/全名保持一致，密码随意； 取消勾选 “用户下次登录时许更改密码”；勾选 “用户不能更改密码”、\"密码永不过期\"，创建！ 点击 FTP 授权规则，删除所有用户； 添加允许授权规则，选择指定的用户，填入刚刚新增的用户名，并勾选用户权限(读取 or 写入): 重启浏览器，输入 ftp://your ip address ，出现登录界面，输入刚刚添加的用户、密码，即可实现特定用户访问. ","date":"2021-08-22","objectID":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/:2:0","series":null,"tags":null,"title":"WIN10搭建FTP","uri":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/"},{"categories":null,"content":"文件上传/下载: 登陆成功后，单击相应文件即可下载！ 在资源管理器中，输入 ftp://your ip address: 端口号； 输入对应的用户名、密码，即可访问对应的工作区！ 4. 直接拖拽或创建，即可实现上传功能！ ","date":"2021-08-22","objectID":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/:3:0","series":null,"tags":null,"title":"WIN10搭建FTP","uri":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/"},{"categories":null,"content":"ps windows10 家庭版与 windows10专业版配置FTP服务器，稍有不同，体现在创建用户时，计算机管理中无 本地用户和组；读者可直接在控制面板 –\u003e 账号，直接创建windows10初始登录账号，即可！ 其余步骤没有相同! ","date":"2021-08-22","objectID":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/:3:1","series":null,"tags":null,"title":"WIN10搭建FTP","uri":"/2021/08/win10%E6%90%AD%E5%BB%BAftp/"},{"categories":null,"content":"获取阿里云盘 refresh_token 登陆阿里云盘网页版 https://www.aliyundrive.com/sign/in 登陆以后F12 复制 refresh_token 留用 ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:1:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"配置 两种配置方式 Jar包运行 点击下载Jar包 java -jar webdav.jar --aliyundrive.refresh-token=\"your refreshToken\" docker运行 docker run -d --name=webdav-aliyundriver --restart=always -p 8080:8080 -v /etc/localtime:/etc/localtime -v /etc/aliyun-driver/:/etc/aliyun-driver/ -e TZ=\"Asia/Shanghai\" -e ALIYUNDRIVE_REFRESH_TOKEN=\"your refreshToken\" -e ALIYUNDRIVE_AUTH_PASSWORD=\"admin\" -e JAVA_OPTS=\"-Xmx1g\" zx5253/webdav-aliyundriver # /etc/aliyun-driver/ 挂载卷自动维护了最新的refreshToken，建议挂载 # ALIYUNDRIVE_AUTH_PASSWORD 是admin账户的密码，建议修改 # JAVA_OPTS 可修改最大内存占用，比如 -e JAVA_OPTS=\"-Xmx512m\" 表示最大内存限制为512m ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:2:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"参数说明 --aliyundrive.refresh-token 阿里云盘的refreshToken，获取方式见下文 --server.port 非必填，服务器端口号，默认为8080 --aliyundrive.auth.enable=true 是否开启WebDav账户验证，默认开启 --aliyundrive.auth.user-name=admin WebDav账户，默认admin --aliyundrive.auth.password=admin WebDav密码，默认admin ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:2:1","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"启动 docker或者jar运行成功后 在浏览器输入： http://127.0.0.1:8080/ 先登陆 输入账号密码 账号默认是admin 密码admin 登陆成功以后 这儿就显示的是你阿里云网盘的所有内容 然后command+k 前面记得一定要加http:// 点击连接 连接 ​ 这样就全部结束了 直接可以用 mac可以通过这种方式实现无感自启 ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:3:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"注意： 如果要用Jar包运行 必须要有java环境 如果要用docker配置 需提前在电脑上安装docker 安装brew：https://brew.sh/index_zh-cn 通过brew安装docker，执行：brew install –cask –appdir=/Applications docker 通过docker允许webdav：https://gitee.com/mirrors/webdav-aliyundriver 中容器允许，注意修改your refreshToken 访问http://127.0.0.1:8080/ 验证下，用户名密码：admin 连接到 WebDAV 服务器：https://support.apple.com/zh-cn/guide/mac-help/mchlp1546/10.13/mac/10.13 本文参考自： https://gitee.com/mirrors/webdav-aliyundriver 感谢大佬们的代码！！！ ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:4:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"亚马逊 AI 编程助手 CodeWhisperer 免费对个人用户开放，提供不限量的代码建议，类似 GitHub Copilot CodeWhisperer 是亚马逊的用几十亿行开源代码训练出来的 AI 工具，它可以根据你的代码注释和现有代码实时生成代码建议。另外还能进行安全漏洞扫描。支持 15 种编程语言（包括 Python、Java 和 JavaScript）以及集成进 VS Code、IntelliJ IDEA、PyCharm 等开发工具。@Appinn 从来都想不到，开源代码居然会被用来干这些事情，真的是 😂 ","date":"2021-08-22","objectID":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/:0:0","series":null,"tags":null,"title":"亚马逊 AI 编程助手 CodeWhisperer","uri":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/"},{"categories":null,"content":"Amazon CodeWhisperer CodeWhisperer 仅针对个人用户免费，企业用户需要订阅使用。除了不限量的代码建议以外，还提供了每月 50 次的代码安全扫描，比如你写了漏洞，它能自动帮你发现。 ","date":"2021-08-22","objectID":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/:1:0","series":null,"tags":null,"title":"亚马逊 AI 编程助手 CodeWhisperer","uri":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/"},{"categories":null,"content":"目前支持的语言： Python Java JavaScript TypeScript C# Rust Go Ruby Scala Kotlin PHP C C++ Shell Scripting SQL 需要注意的是，代码安全扫描目前仅支持 Python、Java 和 JavaScript。 ","date":"2021-08-22","objectID":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/:1:1","series":null,"tags":null,"title":"亚马逊 AI 编程助手 CodeWhisperer","uri":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/"},{"categories":null,"content":"集成环境 Amazon 提供了 VS Code 与 JetBrains 两个插件，都叫做 AWS Toolkit： VS Code Extensions Marketplace JetBrains Marketplace 其它环境请研究用户文档。 以及，使用 CodeWhisperer 需要注册 AWS Builder ID，无论你是否拥有 AWS 或者 Amazon 账号。 ","date":"2021-08-22","objectID":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/:1:2","series":null,"tags":null,"title":"亚马逊 AI 编程助手 CodeWhisperer","uri":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/"},{"categories":null,"content":"使用 青小蛙尝试了一下 VS Code，使用流程是这样的： 安装 AWS Toolkit 登录（VS Code 左边栏找到 AWS，然后在 Developer Tools 里找到 CodeWhisperer，点击 Start） 根据引导注册或登录 然后就好了，在平时编码的时候，能看到底栏的 CodeWhisperer 旁边有对勾，就对了。另外还是在 Developer Tools 的 CodeWhisperer 里面，可以控制开关代码建议（Auto-Suggestions），或开始安全扫描（Security Scan） CodeWhisperer 官网在这里。 原文：https://www.appinn.com/amazon-codewhisperer/ ","date":"2021-08-22","objectID":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/:1:3","series":null,"tags":null,"title":"亚马逊 AI 编程助手 CodeWhisperer","uri":"/2021/08/%E4%BA%9A%E9%A9%AC%E9%80%8A-ai-%E7%BC%96%E7%A8%8B%E5%8A%A9%E6%89%8B-codewhisperer/"},{"categories":["任鸟飞"],"content":" graph subgraph z([劫持注入])--\u003e z1[[看游戏加载哪些dll]]--\u003e z2[OD附加游戏]--\u003e z3[按E打开模块窗口]--\u003e z4([查找可劫持dll\u003cbr\u003e尽量选择SysWOW64目录下的dll\u003cbr\u003e假设为d3d8.dll])--\u003e z6[确定可劫持的dll后\u003cbr\u003e进系统目录或者\u003cbr\u003e游戏目录查找该dll]--\u003e z8[[\"复制dll文件到桌面\"]]--\u003e z9[\"打开AheadLib软件\"]--\u003e 导入dll文件--\u003e 如下图设置--\u003e z10[\"点击“生成”按钮\"\u003cbr\u003e生成cpp代码]--\u003e z17[d3d8.dll改名为d3d8Org.dll]--\u003e z11[\"vs新建\"具有导出项的dll\"\"]--\u003e z12[改成release版本]--\u003e 把之前生成的dll拖入vs中--\u003e 复制全文并粘贴至新建的cpp文件中--\u003e 新建的cpp中的入口函数需要删除--\u003e z13[[\"在入口函数中添加一条代码\u003cbr\u003e LoadLibraryA(“Mydll.dll”);\"]]--\u003e z16[检查代码有无错误并更改\u003cbr\u003e一般就是强制类型转换]--\u003e z14[[生成方案\u003cbr\u003e找到生成的dll\u003cbr\u003e复制到游戏目录]]--\u003e z15([\"把Mydll.dll和d3d8Org.dll也放进游戏目录\"]) end z0([常见可劫持dll]) --- z5[\"特点:容量小 代码少\"] --- d3d8.dll \u0026 d3d8thk.dll \u0026 lpk.dll \u0026 d3d9.dll z7([\"常见dll系统目录\"])---c:\\Windows\\SysWOW64 ","date":"2021-11-15","objectID":"/2021/11/%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5/:0:0","series":null,"tags":["任鸟飞","C++"],"title":"劫持注入","uri":"/2021/11/%E5%8A%AB%E6%8C%81%E6%B3%A8%E5%85%A5/"},{"categories":["任鸟飞"],"content":"天涯明月刀 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"npc等级 npc等级偏移的常见找法： 根据角色的等级偏移到npc对象里查找 通过当前选中怪物的等级来找 普通的方式，到怪物对象中进行偏移遍历 双开账号，通过另一个角色的等级提升进行查找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"npc坐标 遍历npc坐标的几种方式 通过当前怪物血，名字等找到npc遍历，然后在对象周围进行遍历找到坐标。 通过搜索未知初始值来得到当前选中怪，有可能得到的是ID，也有可能得到的是对象，然后追写入的来源，并在周围遍历到坐标。 通过追角色的坐标对象，并在得到对象偏移的代码段下f2断点，f9运行得到一个不同于角色基地址的返回地址，返回后得到npc的遍历。 直接双开角色，查找其中一个的坐标。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"角色速度 如何查找角色的速度，以及变态加速功能的实现： 通过改变角色的速度，比如上马下马，或者跑步走路，有速度值，比如走路100，跑步150，更常见。 通过角色的行走状态，比如走路1，跑步2，上马3 有可能是整数型，也可能是浮点（常见）。 1-10000 （常见） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"角色朝向 角色朝向的几种常见数值： 从-1到1 从-π到π 或者从0到π 从0到360 其他程序员自定义朝向值 朝向在数据中的表现形式： 以一个值会变动的地址同时表现xy朝向，以单独的内存地址表现z朝向 以单独内存地址分别表现xyz朝向 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"遍历背包 遍历背包的几种方式： 遍历背包格子 数组较多 遍历背包物品 二叉数较多 遍历背包格子，通过数量来找，或者通过是否有物品来找 遍历背包物品，通过数量，背包位置，物品名称来找比较方便 另外有些游戏通过发包返回功能call，分析参数也可以物到物品的遍历 站长工具 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"支线任务遍历 通过打怪数量 通过任务标志（接取和放弃任务）常见 通过任务名字或者任务描述 通过接任务或放弃任务call追参数 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"明文发包 首先确定是否为线程发包 然后确定明文包是否可以返回到功能call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能冷却 技能冷却的查找 通过技能冷却标志位查找，常见的有搜索0和1，0和-1，-1就是FFFFFFFF或者字节型就是FF 通过技能冷却时间查找，常见的有从冷却开始时间增加和从冷却开始时间减少。 通过找到技能call并到附近观察跳转，找到判断技能是否冷却的方式。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能名称及相关信息 大部分的游戏，技能的冷却与名字都不在同一个遍历下，为了得到全面的技能信息，需要通过搜索技能名称字符串找到技能的名字遍历，并通过技能ID与技能的其他信息进行关联。 天刀是utf-8的编码方式，需要通过工具将文本型转换成字节集进行搜索。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:9:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能封包 发包找技能call。常见 使用技能，在蓝量上下写入断点。 在技能id上，或者在技能的冷却上下访问或者写入断点。 在技能栏上下访问断点。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:10:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"选中npc和打开npc 封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:11:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"使用物品封包 使用明文包返回到功能call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:12:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"穿装备封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:13:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"游戏小退封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:14:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"喊话call 在喊话内容上下访问断 喊话类型上下访问断 直接通过发包来找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:15:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"喊话坐标的调用 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:16:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"自动复活 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:17:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"寻路 发包返回到寻路 通过目的地坐标，下写入断点直接找到寻路 通过目的地坐标，找到走路call，然后在走路call上下断，返回到寻路 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:18:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"地图遍历 通过当前地图id，下写入断点 通过地图名字，下访问断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:19:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"传送点遍历 通过传送call，跟踪返回参数，找到基地址。 通过传送点的名字来找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:20:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"NPC对话（选项） 通过最后一句话进行一个发包，返回到点击npc选项的call上 选项的内容，下访问断点 通过对话的顺序，下访问或者写入断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:21:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:22:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"剧情标志位 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:23:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"任务细节分析 第一种 怪物名字 或者 打怪数量的文本型 第二种 就是打怪的数量 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:24:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"分解及复刻装备 分解装备 复刻装备 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:25:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之搜索 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:26:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之遍历及购买 通过物品的数量 通过物品名字 通过拍卖页 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:27:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"万能按键call 通过明文包 （通过按键来触发的发包） 通过打开背包或者角色栏，找到标志位，下访问或者写入断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:28:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"日常任务之打坐 通过打坐获得的经验 通过打坐次数（已打坐次数或剩余次数） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:29:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"日常任务之荡寇 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:30:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"动画标志 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:31:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之词缀搜索 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:32:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之词缀遍历 ce内搜索词缀ID，然后分别下断，看哪个会被断下。 直接通过词缀名字进行搜索。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:33:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之上架 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:34:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"控件call 设置按钮，对选项的标志位进行写入 直接通过功能call返回 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:35:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"控件遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:36:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"buff遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:37:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"对象buff和技能预判 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:38:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"摆摊和收摊 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:39:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"代工遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:40:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"摆摊移动call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:41:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"狩猎100%命中 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:42:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"狩猎堆栈检测及关键点 3个重点 找到3个包 条件断点 朝向计算 堆栈检测（结构体内部） x差==x2-x1 y差==y2-y1 z差==(z2-z1)/2 距离==（x差^2^+y差^2^+z差^2^)^0.5^ x朝向==x差/距离 y朝向==y差/距离 z朝向==z差/距离 画江山 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:43:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"加密坐标 搜索加密坐标的解决办法：（注意45度坐标） 搜索类型 换成字符串 （找突破口容易，逆向时困难） 在人物对象下寻找 搜索未知初始值（搜索过程复杂） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:44:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"经验 当前经验 升级经验来搜索 最大经验值 搜索出一堆数据之后，数据一堆一堆得改。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:45:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 循环 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"基于范围的for循环(C++11) 拷贝range的元素时，使用for(auto x : range). 修改range的元素时，使用for(auto \u0026\u0026 x : range). 只读range的元素时，使用for(const auto \u0026 x : range). vector\u003cbool\u003e时使用auto会有问题，对于其他包含代理类的类也会有问题，直接使用for(bool x : vector\u003cbool\u003e) ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"do…while 循环 do { statement(s); }while( condition ); ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"循环控制语句 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"break 语句 C++ 中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case。 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"continue 语句 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"goto 语句 goto 语句一个很好的作用是退出深嵌套例程。例如，请看下面的代码片段： for(...) { for(...) { while(...) { if(...) goto stop; . . . } } } stop: cout \u003c\u003c \"Error in program.\\n\"; 消除 goto 会导致一些额外的测试被执行。一个简单的 break 语句在这里不会起到作用，因为它只会使程序退出最内层循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"无限循环 #include \u003ciostream\u003e using namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 注意：您可以按 Ctrl + C 键终止一个无限循环。 判断 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"switch 语句 switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } switch 语句必须遵循下面的规则： switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"嵌套 switch 语句 switch(ch1) { case 'A': cout \u003c\u003c \"这个 A 是外部 switch 的一部分\"; switch(ch2) { case 'A': cout \u003c\u003c \"这个 A 是内部 switch 的一部分\"; break; case 'B': // 内部 B case 代码 } break; case 'B': // 外部 B case 代码 } ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"? : 运算符 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["博客"],"content":"俺如何为 hugo-theme-even 提供 mermaid 支持 如上是一个利用 mermaid 绘制的 SVG 图形 ，相比于直接在某些软件绘制好再截图，显然利用 mermaid 绘图具备诸多优点： 网站保存的是带 mermaid 的 markdown 文件，不涉及到图片存储。存储占用小。 渲染出图是 SVG 格式，上面的文字可以直接拷贝。 网站数据传输时是使用 mermaid 源码，而不是图片，可以有效减少网站加载过程产生的流量耗费。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:0:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"如何为你的 Hugo 博客引入 mermaid 支持？ 贴士 虽然由于 even theme 更新过慢，似乎久已无更多维护，因此本站已经开始使用 LoveIt 作为主题。 但是对于 even theme 而言，本方法应当依旧适用。 对于这一点，俺可以说前人之述备矣。反手就是一堆参考资料： Diagrams in hugo with mermaid 拓展 Hugo 的 MarkDown 流程图 这些解决方案引入 mermaid 的方法简单素雅，这一套流程可以总结为： 在博客中加载 mermaidJS。具体方法有： 直接在一定会加载的 HTML 文件中引入 \u003cscript\u003e 标签，加载 mermaid。 在部分支持自定义 JavaScript 的主题中，引入 JavaScript 文件。 自定义 ShortCodes，依靠 ShortCodes 实现标签替换。 但是习惯了通过 typora 之类的 MarkDown 拓展编辑器，他们无一例外都支持按照如下风格进行渲染： ```mermaid ... 图表内容 ... ``` 能不能实现它，从而实现更加一颗赛艇的编辑体验呢？ 能的。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:1:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"实现原理 通过阅读 mermaid 的 API 咱们可以得知 mermaidAPI 渲染 mermaid 图形的大致流程： 上述的特定标签是指\u003cdiv class=\"mermaid\"\u003e的 HTML 标签。通过检查页面元素，咱们会发现如今的大部分博客将代码块渲染成如下式样： \u003cpre\u003e\u003ccode class=\"language-语言种类\"\u003e \u003c!-- code --\u003e \u003c/code\u003e\u003c/pre\u003e 也就是说咱们只需要找到形如： \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e \u003c!-- mermaid code --\u003e \u003c/code\u003e\u003c/pre\u003e 的代码块，并将其替换成\u003cdiv class=\"mermaid\"\u003e即可。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:2:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"在 even theme 中的实现 注意 注意： 下文中的 “/” 目录代表 even theme 项目的根目录而不是 *nix 文件系统的 root. 本博客使用的是 even theme. 但是俺相信参照本文在其他博客中进行实现也会大差不差。 俺在自己实现了此种风格之后即向 hugo-theme-even 提出了 PR，even theme 的用户应该可以在不久以后在新版本中得到 mermaid 支持。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"导入 mermaid.min.js 实现应当遵循原理的指示精神，首先咱们需要拥有 mermaid 库。通过观察源码猜测 even 主题在 /static/layouts/partials/scripts.html 中进行 JS 的载入。于是咱们向其中插入能够引入 mermaid 模块的 script 标签。（实际上只要是会被加载的 HTML 文件都可以插） 这个标签在 HTML 文件里随便找个地方插就完事了，如果完全不懂，建议怼到 HTML 文件末尾。 通过 CDN 导入 为了保持文章的时效性，俺不会直接提供该 script 标签，但是你可以在 jsdelivr.com 中找到你中意版本的 mermaid.min.js 并按下右边的 Copy HTML + SRI 按钮即可获得对应的标签。 通过本地文件导入 由于房间里的大象太大挡住了境外CDN的信号，所以你也可以选择本地文件。在网上找到你中意版本的 mermaid.min.js, 下载下来并放在 /static/lib/mermaid/ 目录下（没有就新建一个），这时可以得到对应的 script 标签如下： \u003cscript src=\"{{ \"lib/mermaid/mermaid.min.js\" | relURL }}\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e 本人对境外 CDN 在内地的稳定性持悲观态度，建议中国大陆用户使用此方法。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"替换 HTML 标签 观察 even 主题的源码，咱们可以在 /assets/js/ 目录下发现 main.js 和 even.js。在 even.js 中插入如下代码段： // 插到文件末尾完事了 Even.mermaid = function () { if (!window.mermaid) return; const blocks = document.querySelectorAll(\"pre code.language-mermaid\"); // change all \u003cpre\u003e\u003ccode mamaid\u003e tags to \u003cdiv class=\"mermaid\"\u003e // mermaid will handle the rest! for (let i = 0; i \u003c blocks.length; i++) { if (!window.hljs \u0026\u0026 i % 2 === 0) continue; const block = blocks[i]; const rootElement = window.hljs ? block.parentElement : block.parentElement.parentElement.parentElement.parentElement .parentElement.parentElement.parentElement; var container = document.createElement(\"div\"); const id = `js-mermaid-diagrams-${i}`; container.id = id; container.className = \"align-center mermaid\"; container.textContent = block.childNodes[0].textContent; rootElement.parentElement.replaceChild(container, rootElement); } window.mermaid.mermaidAPI.initialize( window.mermaidOptions ? window.mermaidOptions : { securityLevel: \"loose\", theme: \"base\" } // 替换它可以修改 mermaid 的样式=======↑ ); }; 在 main.js 中插入： // 个人比较喜欢插在 Even.sequence(); 的后面 Even.mermaid(); 现在你应该可以在自己的博客中写 mermaid 了。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"工具推荐 Typora 写 MarkDown 咋能少得了 「Typora」？ Visual Studio Code 俺写这篇文章用的无所不能的编辑器，建议添加插件： Markdown All in One Markdown Preview Enhanced Mermaid Markdown Syntax Highlighting 之所以用 Visual Studio Code，很大程度上是因为它的 Vim 拓展。 “2021年了不会还有人不会用 Vim 吧？” vim ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"auto 存储类 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"static 存储类 静态变量 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"extern 存储类 extern 是用来在另一个文件中声明一个全局变量或函数。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"thread_local 存储类 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } C++运算符 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A– 将得到 9 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A|| B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:9:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"位运算符 p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则： 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：0|0=0; 0|1=1; 1|0=1; 1|1=1; (A | B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则： ~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 \u003e\u003e 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:10:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 \u003e\u003e= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:11:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"杂项运算符 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"逗号运算符 var = (count=19, incr=10, count+1); ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。 箭头运算符与一个指向对象的指针一起使用。 例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; （.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); （-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"指针运算符（\u0026 和 *) 取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作\"取地址运算符\"，这意味着，\u0026var 读作\"var 的地址\"。 间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的运算符优先级 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:13:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["任鸟飞"],"content":"小知识 16进制 4x xx xx xx一般是浮点数（正数） 16进制 Cx xx xx xx一般是浮点数（负数） st0 st1 st2 … 是浮点栈 sar 算术右移 每右移一位，相当于除以一次2 shl 算术左移 每左移一位，相当于乘以一次2 mov ecx,[edx+esi] #当出现两个寄存器的时候，99%其中一个是0 执行到返回 代表已经到达最外层 或者 VM阻断，可堆栈跳出 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"OD指令 dd 查看dword db 查看字节集 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"寄存器 EAX call的返回值 ECX call的参数 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编指令 AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中。 XOR 指令在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中. xor eax,eax #eax清0 xor eax,A3F838C #简单的异或加密（可直接异或解密） TEST 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。 test eax,eax #判断eax是否为0 FLD类似于 PUSH指令 将浮点数据压入协处理器的堆栈中 fld dword ptr [eax+4] #将[eax+4]的值传入st0 FSTP类似于 POP指令 与FST相类似，FSTP执行完后，需要进行堆栈的弹出操作，堆栈将发生变化。 fstp dword ptr [ebp-28] #将st0中的值传入后面的地址[ebp-28],并出栈 FST 将协处理器堆栈栈顶的数据传送到目标操作数中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。 fst dword ptr [ebp-28] #将st0中的值传入后面的地址[ebp-28]，不出栈 FADD类似于 ADD指令 源操作数与目的操作数相加 FDIV 指令执行目的操作数除以源操作数，被除数保存在目的操作数中。目的操作数总是一个寄存器，源操作数可以为寄存器或者内存操作数。其语法与 FADD 和 FSUB 相同。 FXCH 交换寄存器内容 FXCH ;ST0和ST1内容交换 FXCH ST(i) ;ST0和STi内容交换 MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数. MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数. ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:3","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"发包函数 send WSASend sendto send在64位系统上是ws2_32.send WSPSend （在同一个电脑上位置是固定的） DXF单机版 私服 找到WSPSend 附加上口袋西游(或者任何的send发包的软件都可以)，跳到send位置 send 第三个call下断（win7是第三个，win10是第四个），断下后F7进入，这就是WSPSend的位置。 附加到目标进程，跳转到这个地址，下断。 有时WSASend胡乱断，不是真正的发包 ，根据它的特征码，去搜索。查找–\u003e所有命令 ,输入特征码，然后右键–\u003e在每个命令上下设置断点。然后在所有被断下的位置做标记（注释），并取消断点。然后去执行喊话等发包操作，看在哪断下。如果不断，说明在刚才被标记的里面。之后逐一下断测试。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:4","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"线程发包 graph RL d[ ]--\u003ee[\"检测是否真的需要发包(封包的加密解密)\"]--\u003ef[send] 线程发包的特点： 找到发包函数 下断会立刻断下，并且非常频繁 无论做任何动作断下的，我们的返回堆栈都是一样的 找到跳出线程的办法 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:5","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"确定堆栈平衡 方法： 在call的栈上双击 F8步过call 此时看栈上差值 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:6","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"应该熟悉的汇编指令 mov 赋值 和 lea 传址 push 入栈 和 pop 出栈 pushad 和 popad 调用call之前pushad，调用call之后popad，保证寄存器不受影响 add 加法 和 sub 减法 inc 自加1 和 dec 自减1 mul 乘法 div 除法 call 和 retn xor 异或 相同为0，不同为1 and 都是1为1 or 有一个是1为1 xor 是可逆运算，即 A xor B == C 那么 A xor C == B ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:7","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"堆栈详解 什么是堆栈 堆栈就是一种数据项按序排列的数据结构，只能在栈顶对数据项进行插入和删除，其它位置只能改变数值。 特点是先进后出，像个杯子。 堆栈指针寄存器 ESP 栈顶指针 EBP 栈底指针（本层CALL的栈底） ESI 堆栈地址 改变堆栈的操作 影响esp的操作 push eax == sub esp,4 + mov [esp],eax pop eax == mov eax,[esp] + add esp,4 call 1234 == push eip + jmp 1234 retn 8 == pop eip + add esp,8 add esp,xxx sub esp,xxx 堆栈中储存的都是 参数、局部变量、操作中间数 那么我们怎么去找他的来源 例如[ebp-4] [ebp+8] [esp+20] 实例来说明 通过ebp来传递参数和局部变量 头部有push ebp push ebp mov ebp,esp #头部 … … mov esp,ebp #尾部 pop ebp [ebp-8] 第二个局部变量 [ebp-4] 第一个局部变量 [ebp] 保存着上一层的ebp值 [ebp+4] call返回到xxxxxxxx == call xxxxxxxx 相当于 push eip [ebp+8] 第一个参数 [ebp+c] 第二个参数 同时知道了 ebp为什么是栈底指针 四种情况: ebp+10 如果ESP与EBP相差的远，说明ebp不是堆栈地址，而是普通寄存器，10就是偏移，追ebp就可以了 ebp+10 如果相差不远，ebp就是堆栈地址，返回上一层追参数 ebp+0或者ebp+4 需要注意一下，这可能是堆栈检测 ebp-x 说明是局部变量，来源必须是本条到函数头部，或者是这之前的call里面。 通过esp来传递参数和局部变量 头部没有push ebp mov ebp，esp #这样的代码，往往是用esp来表示 sub esp，xxxx #开辟局部变量 算到头部，如果是[esp+]，那么是参数 如果是[esp-]，那么是局部变量，是在本层找来源 更简单的方法是，直接断下看堆栈，看看这个堆栈指针，指向的位置是，上一层返回的上面还是下面。 但是不用全部计算，往往一个call都是自身堆栈平衡的。 我们只需要计算头部的一些堆栈处理。 [esp-8] 第二个局部变量 [esp-4] 第一个局部变量 [esp] 指向call返回到 [esp+4] 第一个参数 [esp+8] 第二个参数 首先要确定 我们要追的[esp+]是参数还是局部变量 两种方法可以确定 一条一条往上推，推到最上面，如果是esp+，那就是参数，如果是esp-那就是局部变量 直接下断，看堆栈，如果在第一个call返回到的下面是参数，在上面是局部变量 如果是局部变量，有两种追法 一条一条向上堆，并根据 影响esp的操作 来计算偏移 需要下两个断点，第一个断点为当前[esp+xx]处，第二个断点为：在头部位置找到 sub esp xxxx,在它的下一条下断。连断两次之后，看esp变化是多少，比如是n，那么在头部要追的就是[esp+xx-n]。 在堆栈内双击esp+xx-n，做个定位，然后在头部断点位置按F8，找哪句改变了堆栈内esp+xx-n的值即可。 如果是参数 看它在堆栈内,第一个call返回到的下面第几个位置，就代表它是上层第几个参数 graph z([\"首先要确定\u003cbr\u003e我们要追的[esp+]\u003cbr\u003e是参数\u003cbr\u003e还是局部变量\"]) --\u003e z1 \u0026 z4 z1{\"方法1\u003cbr\u003e一条一条往上推\u003cbr\u003e推到最上面\"} --\u003e z2 \u0026 z3 z2[\"如果是esp+\"]--\u003ez6 z3[\"如果是esp-\"]--\u003ez5 z4{\"方法2\u003cbr\u003e直接下断\u003cbr\u003e看堆栈\"} --\u003e z4a \u0026 z4b z4a[如果在第一个call\u003cbr\u003e返回到的上面]--\u003e z5 z4b[如果在第一个call\u003cbr\u003e返回到的下面]--\u003e z6 z5[\"局部变量\"]--\u003ez7 \u0026 z9 z6[\"参数\"]--\u003ez14 z7[\"方法1\u003cbr\u003e一条一条向上堆\"]--\u003e z8[\"并根据影响esp的\u003cbr\u003e操作来计算偏移\"] z9[\"方法2\u003cbr\u003e需要下两个断点\"]--\u003e z10[\"第一个断点为:\u003cbr\u003e当前[esp+xx]处\"]--\u003e z11[\"第二个断点为:\u003cbr\u003e在头部位置找到\u003cbr\u003esub esp xxxx\u003cbr\u003e在它的下一条下断\"]--\u003e z12[\"连断两次之后，\u003cbr\u003e看esp变化是多少，\u003cbr\u003e比如是n，\u003cbr\u003e那么在头部要追的就是\u003cbr\u003e[esp+xx-n]\"]--\u003e z13[\"在堆栈内双击esp+xx-n，\u003cbr\u003e做个定位，\u003cbr\u003e然后在头部断点位置按F8，\u003cbr\u003e找哪句改变了堆栈内\u003cbr\u003eesp+xx-n的值即可。\"] z14[\"看它在堆栈内\u003cbr\u003e第一个call返回到\u003cbr\u003e的下面第几个位置，\u003cbr\u003e就代表它是上层\u003cbr\u003e第几个参数\"] ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:8","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"数据结构 一般我们接触的数据结构有三种 数组、链表、二叉树，也就是数据不同的排列方式 二叉树 graph TD; a--\"[a+0]\"--\u003eb; a--\"[a+8]\"--\u003ec; b --\"[[a+0]+0]\"--\u003e d; b --\"[[a+0]+8]\"--\u003e e; c--\"[[a+8]+0]\"--\u003ef; e--\"[[[a+0]+8]+0]\"--\u003eg; 00433FA6 cmp dword ptr [eax+10],esi #可能是ID 00433FA9 jge short 00433FB0 00433FAB mov eax,dword ptr [eax+8] #右 00433FAE jmp short 00433FB4 00433FB0 mov edx,eax 00433FB2 mov eax,dword ptr [eax] #左 00433FB4 cmp byte ptr [eax+231],0 #判断 00433FBB je short 00433FA6 链表 graph LR a--\u003eb[\"[a+x]\"] --\u003ec[\"[[a+x]+x]\"]--\u003ed[\"[[[a+x]+x]+x]\"] 010A1BE0 cmp dword ptr [edx+C],esi #链表循环 010A1BE3 je short 010A1BF8 010A1BE5 mov edx,dword ptr [edx] #链表循环 010A1BE7 test edx,edx 010A1BE9 jnz short 010A1BE0 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:9","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"转移追踪代码 在call内部栈顶下条件断点 [esp]!=0A2BA8C 或者 [esp]!=0A2BA8C \u0026\u0026 [esp]!=0A12D1D 在call内部被追踪处下条件断点，断点内容和上面的相同也可以。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:10","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"跳出系统领空 在OD内存窗口对X地址下断，游戏暂停在系统领空后，跳出系统领空的方法： 在堆栈中查找X，找到后看是不是程序领空，如果不是的话，ctrl+L继续查找下一个。 如果找到程度领空的话，ctrl+f9返回。跳到第5步。 如果找不到的话，可以在堆栈中搜X省略后两位的数据，看能不能搜到。 实在找不到，就在堆栈里肉眼找相近的地址。（前提是程序领空） 找到后，前往“返回到”对应的地址。看“相近的地址”是第几个参数，加上相应的偏移。每有一个参数就加4 。之后就可以正常逆向了。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:11","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编实例 x,z,y [[[D0DF1C]+1C]+28]+3C,40,44 #运行时出错 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] fld [ecx+44] #y 入浮点栈 fld [ecx+40] #z fld [ecx+3C] #x fstp [esp] #x 出浮点栈 fstp [esp+4] #z fstp [esp+8] #y 手动建立一个堆栈的结构体 push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] push [ecx+44] #y push [ecx+40] #z push [ecx+3C] #x push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 add esp,0C #堆栈平衡 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"防检测 调试检测 VM检测（虚拟机） EXE检测 DLL检测 行为检测 抓特征 CRC检测 数据检测 堆栈检测 Call的其它检测 内存检测 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"2D 3D朝向算法 2D平面 传奇 只有8个方向（一个内存地址） 2D平面 剑灵 勇者 均匀的增加了更多角度 （一个内存地址） 2D平面 天刀 射雕 （两个内存地址） 3D球型 天刀狩猎 （三个内存地址） 1/z = 距离/z差 1/x = 距离/x差 距离的平方=z差平方+l的平方 l的平方=x差的平方+y差的平方 3D球型 CF 逆战 （三个内存地址） ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":" #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } ","date":"2021-08-10","objectID":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/:0:0","series":null,"tags":["C++"],"title":"输出您电脑上各种数据类型的大小","uri":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/"},{"categories":["C++"],"content":"runoob C++教程 语言中文网C++教程 ","date":"2021-08-08","objectID":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","非官方教程"],"title":"C++非官方教程","uri":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"一、L\"str\" 如 L\"我的字符串\" 表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 strlen(“asd”) = 3; strlen(L\"asd\") = 6; 二、 _T(“str”) _T(“str”)是一个宏，定义于tchar.h下,他的作用是让你的程序支持Unicode编码。 如果定义了UNICODE 那么_T(“ABCD”) 相当于 L\"ABCD\" ，这是宽字符串。 否则_T(“ABCD”) 就等价于 “ABCD” ","date":"2021-08-08","objectID":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","series":null,"tags":["C++"],"title":"L和_T()的区别","uri":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C++"],"content":"#pragma once 与 #ifndef 解析 为了避免同一个文件被include多次，C/C++中有两种方式，一种是#ifndef方式，一种是#pragma once方式。在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。 方式一： #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 方式二： #pragma once … … // 声明、定义语句 #ifndef的方式受C/C++语言标准支持。它不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。 当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，编译器却硬说找不到声明的状况——这种情况有时非常让人抓狂。 由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。 #pragma once一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。 其好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。大型项目的编译速度也因此提高了一些。 对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。 #pragma once方式产生于#ifndef之后，因此很多人可能甚至没有听说过。目前看来#ifndef更受到推崇。因为#ifndef受C/C++语言标准的支持，不受编译器的任何限制；而#pragma once方式却不受一些较老版本的编译器支持，一些支持了的编译器又打算去掉它，所以它的兼容性可能不够好。一般而言，当程序员听到这样的话，都会选择#ifndef方式，为了努力使得自己的代码“存活”时间更久，通常宁愿降低一些编译性能，这是程序员的个性，当然这是题外话啦。 还看到一种用法是把两者放在一起的： #pragma once #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 看起来似乎是想兼有两者的优点。不过只要使用了#ifndef就会有宏名冲突的危险，也无法避免不支持#pragma once的编译器报错，所以混用两种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑。 选择哪种方式，应该在了解两种方式的情况下，视具体情况而定。只要有一个合理的约定来避开缺点，我认为哪种方式都是可以接受的。而这个已经不是标准或者编译器的责任了，应当由程序员自己或者小范围内的开发规范来搞定。 btw：我看到GNU的一些讨论似乎是打算在GCC 3.4（及其以后？）的版本取消对#pragma once的支持。不过事实上，我手上的GCC 3.4.2和GCC 4.1.1仍然支持#pragma once，甚至没有deprecation warning，倒是GCC2.95会对#pragma once提出warning。 VC6及其以后版本亦提供对#pragma once方式的支持，这一特性应该基本稳定下来了。 ","date":"2021-08-08","objectID":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["C++"],"title":"pragma once与ifndef 解析","uri":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/"},{"categories":["菜鸟C++笔记"],"content":"C++类与对象 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"CEdit类 为Edit控件关联变量 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"CString类 CString 成员函数用法 // CStringA，CStringW CString::GetBuffer //获取字符串地址 char*或者wchar_t* CString::Format格式化函数 //类似printf CString::Empty() //清空 CString::GetLength() //返回字符串长度 字节数 CString::IsEmpty() //判断字符串是否为空 CString::LoadString(资源ID) //加载资源字符串 CDialogEx类 CButton类 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"C++类的构造函数与析构函数 类成员函数 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"枚举类型 enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"extern变量声明 #include \u003ciostream\u003e using namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"全局变量和局部变量 全局变量和和局部变量同名时，可通过域名在函数中引用到全局变量，不加域名解析则引用局部变量。 #include\u003ciostream\u003e using namespace std; int a = 10; int main() { int a = 20; cout \u003c\u003c ::a \u003c\u003c endl; // 10 cout \u003c\u003c a \u003c\u003c endl; // 20 return 0; } 在 VS2013 环境，对全局变量的引用以及重新赋值，直接用全局变量名会出现：count 变量不明确的问题。 在变量名前加上 :: 符号即可。 #include \u003ciostream\u003e using namespace std; int count = 10; //全局变量初始化 int main() { ::count = 1; //全局变量重新赋值 for (;::count \u003c= 10; ++::count) { cout \u003c\u003c\"全局变量count=\"\u003c\u003c ::count \u003c\u003c endl; } return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["C++"],"content":"C++类与对象 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CEdit类 为Edit控件关联变量 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:1","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CString类 CString 成员函数用法 // CStringA，CStringW CString::GetBuffer //获取字符串地址 char*或者wchar_t* CString::Format格式化函数 //类似printf CString::Empty() //清空 CString::GetLength() //返回字符串长度 字节数 CString::IsEmpty() //判断字符串是否为空 CString::LoadString(资源ID) //加载资源字符串 CDialogEx类 CButton类 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:2","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"结构体与联合体(联合类型) struct 结构类型 { int n; char s[1]; double d; }结构类型; union 联合类型1 { int n; char s[1]; //12 double d; }联合类型A; typedef union 联合类型2 { int n; char s[5]; double d; float a; }联合类型B; // 加typedef的话，联合类型B就是别名 // 不加typedef的话，联合类型B就是全局变量 // union 联合类型 所有成员共享一片内存，大小的话，以最大成员需求为准 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:2:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"lstrcpy 与 _tcscpy 拷贝字符串 lstrcpy 既能作用于ASCII又能用于UNICODE， 兼容宏 #ifdef UNICODE #define lstrcpy IstrepyW #else #define lstrepy lstrepyA #endif // !UNICODE _tcscpy MessageBox MessageBoxA MessageBoxW Istropy IstrepyA IstrepyW ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"枚举 enum enum EColor { RED, GREEN, BLUE }; EColor eColor = RED; //===================================================== enum class EColor { RED, GREEN, BLUE }; EColor eColor = EColor::RED; ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:4:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"switch语句 switch(expression){ case constant-expression : statement(s); break; //optional case constant-expression : statement(s); break; //optional // you can have any number of case statements. default : //Optional statement(s); } 实例 #include \u003ciostream\u003e using namespace std; int main () { // local variable declaration: char grade = 'D'; switch(grade) { case 'A' : cout \u003c\u003c \"Excellent!\" \u003c\u003c endl; break; case 'B' : case 'C' : cout \u003c\u003c \"Well done\" \u003c\u003c endl; break; case 'D' : cout \u003c\u003c \"You passed\" \u003c\u003c endl; break; case 'F' : cout \u003c\u003c \"Better try again\" \u003c\u003c endl; break; default : cout \u003c\u003c \"Invalid grade\" \u003c\u003c endl; } cout \u003c\u003c \"Your grade is \" \u003c\u003c grade \u003c\u003c endl; return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:5:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"状态机 enum class 状态机标志位 { EN_状态机标志_学技术， EN_状态机标志_开始上班， EN_状态机标志_写代码， EN_状态机标志_做项目， EN_状态机标志_修BUG， EN_状态机标志_测试， EN_状态机标志_把项目卖给客户， EN_快态机标志_公司挣了1个亿， EN_状态机标志_老板给我升职加薪， }; void FunTest(状态机标志位 状态） { switch(状态) { case 状态机标志位::EN_状态机标志_学技术: break; case 状态机标志位::EN_状态机标志_开始上班: break; case 状态机标志位::EN_狀态机标志_写代码: break; case 状态机标志位::EN_状态机标志_做项目: break; case 状态机标志位::EN_状态机标志_修BUG: break; case 状态机标志位::EN_状态机标志_测试: break; case 状态机标志位::EN_状态机标志_把项目卖给客户: break; case 状态机标志位::EN_状态机标志_公司挣了1个亿: break; case 状态机标志位::EN_状态机标志_老板给我升职加薪: break; default: break; } } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:6:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["GitHub"],"content":"图标fontawesome 图标dashgame 留言板disqus 留言板valine 搜索algolia 自动发布travis google分析 sitemaps.xml检查 ghproxy加速站 ","date":"2021-08-07","objectID":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/:0:0","series":null,"tags":["GitHub","网址整理"],"title":"GitHub网址整理","uri":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/"},{"categories":["Git"],"content":"Git pwd 显示当前目录 git init 初始化仓库 ls -ah 查看隐藏文件及目录 git add \u003cfile\u003e 添加文件 git commit -m \u003cmessage\u003e 提交说明 git status 仓库状态 git diff \u003cfile\u003e 查看差别 git log 日志 git reflog 查看命令历史 git reset --hard commit_id 回退 用HEAD表示当前版本 上一个版本就是HEAD^ 上上一个版本就是HEAD^^ 往上100个版本HEAD~100 git rm \u003cfile\u003e 删除 git checkout -- test.txt 恢复 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"GitHub ssh-keygen -t rsa -C \"youremail@example.com\" 创建SSH Key 登陆GitHub，打开“Account settings”，“SSH Keys”页面。 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 点“Add Key”，你就应该看到已经添加的Key： git remote add origin git@github.com:xinqinew/test.git 本地仓库关联到GitHub仓库 git push -u origin master 首次推送并关联 git push origin master 日常推送 git remote -v 查看远程库信息 git remote rm \u003cname\u003e 与远程库解除关系 git clone git@github.com:xinqinew/test.git 克隆远程库 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"分支 git branch dev 创建分支dev git switch dev git checkout dev 切换分支dev git switch -c dev git checkout -b dev 创建并切换分支dev git branch 查看当前分支 git merge dev 合并dev分支到当前分支 git branch -d dev 删除dev分支 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"标签 git tag \u003cname\u003e 创建标签 git tag 查看所有标签 git tag \u003ctagname\u003e f52c633 对历史打标签 git tag -a \u003ctagname\u003e -m \"message\" 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git show \u003ctagname\u003e 查看标签信息 git tag -d \u003ctagname\u003e 删除标签 git push origin \u003ctagname\u003e 推送指定标签 git push origin --tags 推送所有标签 git push origin :refs/tags/\u003ctagname\u003e 删除远程标签 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"忽略特殊文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class # 不排除.gitignore和App.class: !.gitignore !App.class GitHub官方提供的各种忽略文件配置 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"参考网站-廖雪峰 git-cheat-sheet.pdf ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"git使用总结 Git 分布式版本管理系统 Git 命令清单 workspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区(或本地仓库) Remote: 远程仓库 ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 细崽一个项目和它的整个代码历史 $ git clone [url] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"配置 Git 的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每一个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并将这次删除放入暂存区 $ git rm [file1] [file2] # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上一次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有的diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit,并包括指定文件的新变化 $ git commit --amend [file1] [file2] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:4:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，单依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git cleckout -b [branch] # 新建一个分支，并指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并近当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:5:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] ＃新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] ＃提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，并指向某个tag $ git checkout -b [branch] [tag] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:6:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"查看信息 # 显示有变更的文件 $ git status # 显示当前分支的历史版本 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其”提交说明“必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去的5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --short --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:7:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:8:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区与工作区，与上一次commit保持一致,但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针未指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:9:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"其他 # 生成一个可供发布的压缩包 $ git archive ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:10:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["GitHub"],"content":"首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可)。 等几分钟，等到它显示 “好消息！Cloudflare 正在保护您的站点” 就说明设置成功了。 最后，记得更改此处的文件内容 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/:0:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定Cloudflare及freenom","uri":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/"},{"categories":["GitHub"],"content":"freenom域名申请 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:0:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["GitHub"],"content":"freenom.com设置DNS freenom.com中选择Services-My Domains-\u003eManage Domain 然后选择选择下面的nameservers-\u003ecustom nameservers(enter below) 前面两行分别填入 BROAD.DNSPOD.NET PHONE.DNSPOD.NET 然后点击Change Nameservers 上述操作的意思是,不使用freenom.com的默认DNS,而是授权给DNSpod来处理域名解析 DNSpod设置 进入DNSPOD,实名认证后选择: DNS管理-\u003e我的域名-\u003e添加域名xinqi.cf https://console.dnspod.cn/dns/list 然后点击绿色小按钮右侧的域名xinqi.cf得到 下图: https://console.dnspod.cn/dns/yuchi.ml/record githubpage设置 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:1:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["博客"],"content":"使用Hugo+LoveIt主题搭建博客 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 Hugo 可参考Hugo 官方的 Quick Start ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装二进制（Mac） # 使用brew安装hugo brew install hugo # 创建新项目（网站） hugo new site my_website # 生成用于发布的静态文件（不包含草稿） hugo # 生成用于发布的静态文件（包括草稿） hugo -D # 本地运行网站 hugo server ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"直接使用 Docker # 创建新项目（网站） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo \\ new site my_website # 生成用于发布的静态文件（不包含草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo # 生成用于发布的静态文件（包括草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo -D # 本地运行网站 docker run --rm -it \\ -v $(pwd):/src \\ -p 1313:1313 \\ klakegg/hugo \\ server 可以在镜像后面增加版本号，指定使用的hugo版本 # 比如 docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo:0.82.0 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 LoveIt 主题 # 位于你的博客项目根目录 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 代码克隆成功后在./themes文件夹下应出现LoveIt文件夹。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"项目文件树结构 . ├── archetypes # markdown文章的模版 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，主要发布这个 ├── resources # 通过hugo命令一起生成的资源文件，暂时不知道什么用 ├── static # 静态文件，比如文章中的图片/视频文件、缩略图等 └── themes # 保存可用的hugo主题 通常，我们只会用到以下几个文件夹的东西 config.toml ：保存 hugo 的配置，包括主题的配置等。详细设置见下方 #网站配置 content：保存网站的各种内容，比如文章。 archetypes： 保存文章的 markdown 模版，通常包括文章的前缀注释，是一些在创建新文章时会被用到。 static ：保存文章中用到的静态文件，比如图片、网站缩略图等。 public ：通过hugo命令生成的静态 html 文件、css、js 等。在服务器上发布时主要发布这个文件夹。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置网站设置 配置文件位置：./config.toml 引用 具体的配置条目参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置缩略图 使用的网站：https://realfavicongenerator.net/ 获取缩略图的各种格式 下载到的全部内容 将整个压缩包的文件（包括图片之外的文件）放到./static下 重启浏览器，应该可以看到标签上的缩略图出现了。 浏览器标签出现缩略图 缩略图没生效？ 缩略图未生效的原因可能是浏览器使用了之前的缓存。尝试： 彻底关闭并重启浏览器。 通过这个步骤强制删除缓存。 强制 Chrome 禁用网页缓存。 打开 Chrome 开发者工具。（网页空白处右键-检查，或者按 F12） 在Network栏勾选Disable cache。 或者在设置里找到Preferences -\u003e Network -\u003e Disable cache ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:5:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"开始写第一篇文章 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"文章前缀参数 在每篇 markdown 文章最前面可以用一部分注释来告诉LoveIt主题，这篇文章的属性，譬如文章标签、分类、是否为草稿等。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"将文章前缀参数保存在 markdown 模版中 模版文件位置：./archetypes/default.md 我使用的md模版 --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} draft: true tags: [] categories: [] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: \"\" featuredImagePreview: \"\" license: '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' --- ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成新文章 生成新文章的命令： hugo new posts/文章标题.md 执行完成后，在./content/posts目录下应该可以看到新文件，同时里面已经有 markdown 模版中的文章前缀参数。 技巧 也可以手动复制旧文章来生成新文章，不通过命令。 也可以在content文件夹下建新的文件夹，方便管理。这种情况下生成的静态 Html 文件路由效果如下： . └── content └── about | └── index.md // \u003c- https://example.com/about/ ├── posts | ├── firstpost.md // \u003c- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // \u003c- https://example.com/posts/secondpost/ └── quote ├── first.md // \u003c- https://example.com/quote/first/ └── second.md // \u003c- https://example.com/quote/second/ ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:3","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"本地调试 本地调试命令： hugo server --disableFastRender 本地运行网站 出现成功的提示后在浏览器打开http://localhost:1313即可看到网站。 Bug 如果你看到如图的编译错误，可能是因为你的文章除了前缀参数外没有任何内容。随便写几句话就可以解决这个问题。 有文章为空时的编译报错 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:4","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 Github 仓库 个人建议创建两个仓库： 一个用于托管博客项目源文件，包括配置文件等包含后续可能配置 API KEY 的东西。设置权限为 Private（不公开） 一个用于托管博客编译后生成的静态 Html 文件(即使用 hugo 命令编译生成的public文件夹)，并配置该仓库使用 Github Pages，然后 Github 就会自动检测到它其中的静态Html文件并搭建网站。设置权限为 Public（公开） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第一个仓库 按照常规方式创建仓库即可，反正设置为private权限等级，也没人看得见。 第一个仓库示例，保存博客源代码 链接本地仓库与远端仓库 ## 位于博客源代码根目录 ## 初始化本地Git仓库 git init ## 设置名为Origin的远端Git仓库 git remote add origin {{这里替换成你的仓库在Github Clone用的地址}} ## 选择所有文件 git add -A ## Push到github git push -u origin master 创建.gitignore 在源代码项目中创建.gitignore文件，来防止把生成的静态文件上传。创建位置如下： . ├── .git ├── .github ├── .gitignore \u003c---- 在根目录下 ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes 在.gitignore中写入/public，来防止 Git 将其上传。 cat .gitignore ## 输出 /public ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第二个仓库 创建仓库，注意名称 第二个仓库名字比较重要，必须是{{你的github用户名}}.github.io。 比如我的 Github 名字为JellyZhang,那么我需要创建的仓库名称为JellyZhang.github.io，如图所示。 第二个仓库示例（注意仓库名称与自己用户名对应） 在仓库设置里设置启用Github Pages 找到仓库设置 找到Pages一栏 设置Branch与静态文件位置 这个地方设置Branch为master，静态文件位置为/(root)，原因是我们在下个步骤中会直接将生成的public文件夹中的内容push到master分支的/目录下。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"给源代码仓库添加 Github Action ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 CI 脚本 什么是Github Action? Github Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 在源代码项目根目录下新建.github/workflow/main.yml。(通过 Github Action 网页端操作也可以) . ├── .git ├── .github │ └── workflows │ └── main.yml \u003c---在这里创建 ├── .gitignore ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes main.yml脚本内容： # This is a basic workflow to help you get started with Actions name: CI # Controls when the action will run. on: # Triggers the workflow on push or pull request events but only for the master branch push: branches: [master] pull_request: branches: [master] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs-on: ubuntu-latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Hugo setup # You may pin to the exact commit or the version. # uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2e uses: peaceiris/actions-hugo@v2.4.13 with: # The Hugo version to download (if necessary) and use. Example: 0.58.2 hugo-version: latest # optional, default is latest # Download (if necessary) and use Hugo extended version. Example: true extended: true # optional, default is false - name: Build run: hugo - name: Pushes to another repository uses: cpina/github-action-push-to-another-repository@master env: API_TOKEN_GITHUB: ${{ secrets.API_TOKEN_GITHUB }} with: source-directory: \"public\" destination-github-username: \"这里输入你的Github用户名\" destination-repository-name: \"这里输入你的Github用户名.github.io\" user-email: 这里输入你的Github邮箱 需要自定义的部分 注意on里的 branch 是否和自己的相同，因为现在 Github 默认分支为 main。 同时最后三行内容需要自行替换。 脚本主要做了以下事情： 创建一个 Hugo 环境 使用 hugo 命令编译代码，产生 public 文件夹 将 public 文件 push 到你的Github用户名.github.io仓库。（也就是你之前创建的第二个仓库） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"设置 Push 用的密钥 为了让 Github Action 脚本有权限将代码 Push 到我们的xx.github.io仓库，我们需要申请一个密钥并告诉它。在 Github 设置中找到Developer settings/Personal access tokens 个人密钥设置界面 新建一个密钥，权限设置把Repo打勾。 新建密钥 回到第一个仓库的设置里，选择Secrets（密钥） 仓库密钥设置 新建密钥，将刚才生成的个人密钥填进去，名字设为API_TOKEN_GITHUB(跟 CI 脚本里的名称对应即可) 新建仓库密钥 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"观察效果 在 Push 新修改到第一个仓库后，在Action界面可以看到新的workflow开始运行了。 第一个仓库workflow界面（图中已经完成） 在workflow结束后，可以在第二个仓库看到新的Push 第二个仓库自动push了新的静态页面 在等待 1-2 分钟后，即可在xx.github.io观察到变化。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:3","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置评论系统 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"GitTalk GitTalk是基于 github 的 repo issues 作为数据库来存储评论的。 Love-It主题集成了GitTalk ，需要使用的话只需要在config.toml里填写指定信息就可以了。 首先要去Github -\u003e Settings -\u003e Developer Settings -\u003e OAuth App 里注册一个新的 OAuth App 来给 Gitalk 使用。 两个 Url 填自己博客的地址就行。 注册OAuth App 修改config.toml: [params.page.comment] enable = true \u003c-- 启用评论系统 ... [params.page.comment.gitalk] enable = true owner = \"JellyZhang\" \u003c-- Github用户名 repo = \"blog-comment\" \u003c-- 用来存放评论的repo名称 clientId = \"\" \u003c-- 申请好的OAuth的ClientId clientSecret = \"\" \u003c-- 申请好的OAuth的ClientSecret 升级Gitalk来防止403问题 Gitalk 1.6.2版本 存在一个自身 Bug，它里面用到了一个链接来依赖某个下游，而事实上这个链接是 demo 演示用的，已经因为滥用被取消了，所以需要将 LoveIt 主题使用的 1.6.2 版本改成1.7.2 修改./themes/LoveIt/assets/data/cdn/jsdelivr.yml中的Gitalk的链接： ... metingJS: meting@2.0.1/dist/Meting.min.js # gitalk@1.6.2 https://github.com/gitalk/gitalk gitalkCSS: gitalk@1.7.2/dist/gitalk.min.css \u003c-- 改为1.7.2 gitalkJS: gitalk@1.7.2/dist/gitalk.min.js \u003c-- 改为1.7.2 # valine@1.4.14 https://valine.js.org/ valineJS: valine@1.4.14/dist/Valine.min.js ... 在本地环境看不到生效？ 评论系统在本地运行时不生效，需要 publish 后查看效果。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置搜索系统 LoveIt集成了两种搜索引擎，Lunr和algolia。 两种搜索引擎的区别 参考LoveIt 官方文档 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 我这里记录algolia的配置方法。 首先需要在配置文件中新增Outputs的JSON类型，用于产生index.json文件来提供给搜索引擎。 config.toml: [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] 设置后，在使用hugo命令编译后应该可以在public文件夹下找到index.json 之后在algolia注册账号并创建一个application与index: 创建application, freePlan一般够用 然后在API Keys里找到appID和searchKey: 在API Keys里找到appId与searchKey config.toml: [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"\" \u003c--- 你创建的index的名字 appID = \"\" \u003c--- Application ID searchKey = \"\" \u003c--- Search-Only API Key 然后可以上传生成的index.json到 algolia 来生成索引，实现搜索功能。 手动上传index.json的方法 当然，每次生成完上传index.json未免太过麻烦，况且我们还是用Github Action来自动编译的，因此接下来我们让Github Action来帮我们上传index.json到algolia。 首先生成一个 Admin API Key 用于调用 API 来上传 index.json: 生成Admin API Key 然后修改我们的Github Action的脚本： 在`main.yml`末尾加上： - name: Algolia Index Uploader # You may pin to the exact commit or the version. # uses: rxrw/algolia-index-uploader@294d1d600c4a2197a64903b6161cc80acea1becb uses: rxrw/algolia-index-uploader@v1 with: # Your Algolia IndexPath index_path: public/index.json \u003c-- 生成的index.json位置，默认即可 # Algolia Index Id algolia_index_id: XXXXXXXXX \u003c-- 你的indexId, 即之前获得的`application ID` # Algolia Index Name algolia_index_name: XXXX \u003c--- 你创建的index名字 # Algolia Admin Key algolia_index_admin_key: XXXXXXXXXXXX \u003c--- 上图中获取的admin Key 之后运行脚本即可在algolia在 dashboard 里看到新增的记录。 algolia新增了record 删除文章后需要删除旧Record 每次上传的记录是增量的，意味着不会清除旧的记录。 因此如果删除了发布过的旧文章，需要手动去algolia网站上清理相关的 Object。（也可以使用 Clear 功能全部清除） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:10:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Analytics 网站分析 Google analytics是将用户的动作行为收集后发送到 Google，交由 Google 进行统计与分析，形成看板。 在Google analytics创建媒体资源 –\u003e 添加数据流 –\u003e 网站，之后在数据流详情里获取到衡量ID: 获取衡量ID 之后可以在Dashboard里查看网站的用户行为，有很多内容可以慢慢探索。 Google analytics Dashboard ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:11:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Search Console 首先确定自己的站点地图有正常生成。打开/sitemap.xml链接： sitemap 之后在Google Search Console里填写自己站点地图的链接，可以帮助谷歌爬虫了解网站结构。 上传sitemap 显示`无法获取`? 事实上是没有问题的，谷歌可能有点延迟。可以在bing webmaster tool 导入 Google 的设置，可以看到 bing 是可以立即获取的。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:12:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"参考文献 LoveIt 官方文档 Hugo 官方文档 刷新 Chrome 缓存 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:13:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"GitHub Pages 不仅不花钱，而且还有免费的证书拿，可以说是相当划算的。但有个问题就是 GitHub 的服务器都部署在海外，也就是说在国内访问本博客的速度的速度会比较慢 (Ping 下来 100 到 200 多毫秒)。 解决这一问题的最优解就是使用 CDN。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:0:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"CDN 是什么？ 内容分发网络（英语：Content delivery network 或 Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 —— 维基百科 简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。 世界上的 CDN 服务提供商有很多，七牛云、阿里云、腾讯云等等都提供了 CDN 服务，它们有的收费有的部分免费。我今天选择的 CDN 服务来自于 Cloudflare。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:1:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"Why Cloudflare？ Cloudflare 是全球最大的 DNS 服务提供商之一 (号称是全球最快的 DNS 1.1.1.1 就是它们搞的)。除此之外他们还提供 CDN、SSL 证书、DDos 保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。我今天要使用的就是免费版的 SSL 证书以及 CDN 服务。 除了 Cloudflare 比较 NB 以外选择他的另一个更重要的原因是国内的 CDN 无一例外都要要求域名在公安局备过案。作为一个遵纪守法的好市民，我肯定是不怕什么公安局备案的，我主要是觉得太麻烦了。并且在公安局备案后，放到网站上的那个小图标有点丑 ,,Ծ‸Ծ,, ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:2:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"配置 CDN 首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)，有钱也可以选择收费的，提供的服务更多。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可) 等几分钟，等到它显示 Great news! Cloudflare is now protecting your site 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:3:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"设置 SSL 证书 除了免费的 DNS 和 CDN 以外，Cloudflare 还提供了免费的 SSL 证书。 Cloudflare 的 SSL 证书默认是已经开启了的。不过最好还是在 Crypto 页面将 Always Use HTTPS 勾选上，这个选项可以自动在访问你的网站时将所有的 http 的链接重定向到相应的 https 链接上。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:4:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":null,"content":"欢迎留言！😄 ","date":"2021-08-04","objectID":"/message-board/:0:0","series":null,"tags":null,"title":"留言板","uri":"/message-board/"},{"categories":null,"content":" st=\u003estart: 开始框 op=\u003eoperation: 处理框 cond=\u003econdition: 判断框(是或否?) sub1=\u003esubroutine: 子流程 io=\u003einputoutput: 输入输出框 e=\u003eend: 结束框 st-\u003eop-\u003econd cond(yes)-\u003eio-\u003ee cond(no)-\u003esub1(right)-\u003eop st=\u003estart: 开始框 op=\u003eoperation: 处理框 cond=\u003econdition: 判断框(是或否?) sub1=\u003esubroutine: 子流程 io=\u003einputoutput: 输入输出框 e=\u003eend: 结束框 st(right)-\u003eop(right)-\u003econd cond(yes)-\u003eio(bottom)-\u003ee cond(no)-\u003esub1(right)-\u003eop ","date":"2021-08-04","objectID":"/2021/08/flow%E6%B5%81%E7%A8%8B%E5%9B%BE/:0:0","series":null,"tags":["GitHub","Flow流程图"],"title":"Flow流程图","uri":"/2021/08/flow%E6%B5%81%E7%A8%8B%E5%9B%BE/"},{"categories":["博客"],"content":"Hugo使用algolia搜索 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"背景 在将hexo迁移到hugo后我就开始折腾博客搜索了，下面的配置正对loveit主题配置 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"开启algolia搜索 在config.toml中添加下面字段，xxxxx是必填，你可以参考loveit主题中的config.toml # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] # algolia注册的索引名称 index = \"xxxxx\" # 在你注册完成后，点击API Keys就能看见下面的参数 appID = \"xxxxx\" searchKey = \"xxxxx\" ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"自动提交索引到algolia 又又用到了npm,好在集成到travis中眼不见为净。 在config.toml同级目录下运行npm init，一路回车即可。 修改npm int生成的package.json添加下面字段 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在config.toml同级目录添加.env文件并添加下面字段 ❯ cat .env ALGOLIA_APP_ID=U9QMQ70DKL ALGOLIA_INDEX_NAME=gaojila.github.io ALGOLIA_INDEX_FILE=public/index.json 修改.travis.yml文件如下 language: go go: - \"1.8\" # 指定Golang 1.8 install: # 安装最新的hugo - wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb - sudo dpkg -i hugo*.deb # 安装搜索插件 - npm install atomic-algolia --save-dev script: # 运行hugo命令 - hugo # 生成索引命令 - echo \"ALGOLIA_ADMIN_KEY=$ALGOLIA_ADMIN_KEY\" \u003e\u003e .env - npm run algolia after_script: # 部署 - cd ./public - git init - git config user.name \"[gaojila]\" - git config user.email \"[redgaojila@gmail.com]\" - git add . - git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\" # Github Pages - git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master # Github Pages - git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tags env: global: # Github Pages - GH_REF: \"github.com/gaojila/gaojila.github.io\" deploy: provider: pages # 重要，指定这是一份github pages的部署配置 skip-cleanup: true # 重要，不能省略 local-dir: public # 静态站点文件所在目录 # target-branch: master # 要将静态站点文件发布到哪个分支 github-token: $GITHUB_TOKEN # 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis # fqdn: # 如果是自定义域名，此处要填 keep-history: true # 是否保持target-branch分支的提交记录 on: branch: master # 博客源码的分支 在travis中添加变量$ALGOLIA_ADMIN_KEY ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"参考链接 aligolia的其他配置可以看下面的链接 dreamsafari.info nashome.cn ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"Hugo使用travis自动发布","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Hugo使用travis自动发布 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"背景 从hexo迁移到hugo后，发布博客开始变的繁琐，没有hexo -d这样的快捷部署，但是好在有travis这样的免费CI平台，在使用travis来部署博客的确快捷了很多，只需要发布源码即可。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Github获取token 记下 Token 的值 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"设置Travis CI 使用github帐号注册一个travis帐号，登录在hugo仓库上打上，然后再点击setting 然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"编写.trabis.yml language: go go: - \"1.8\" # 指定Golang 1.8 install: # 安装最新的hugo - wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb - sudo dpkg -i hugo*.deb script: # 运行hugo命令 - hugo after_script: # 部署 - cd ./public - git init - git config user.name \"[gaojila]\" - git config user.email \"[redgaojila@gmail.com]\" - git add . - git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\" # Github Pages - git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master # Github Pages - git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tags env: global: # Github Pages - GH_REF: \"github.com/gaojila/gaojila.github.io\" deploy: provider: pages # 重要，指定这是一份github pages的部署配置 skip-cleanup: true # 重要，不能省略 local-dir: public # 静态站点文件所在目录 # target-branch: master # 要将静态站点文件发布到哪个分支 github-token: $GITHUB_TOKEN # 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis # fqdn: # 如果是自定义域名，此处要填 keep-history: true # 是否保持target-branch分支的提交记录 on: branch: master # 博客源码的分支 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 hugo 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色代表正在部署 红色 代表部署失败 灰色 代表部署被取消 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:4:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"相关文章 使用 Travis CI 自动部署 Hugo 博客 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:5:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"通过 Travis CI 来部署 Hugo 或者 Hexo 博客可能在配置的时候会麻烦一点，但配置好后确实是方便了不少。特别是对于 Hugo 这种没有部署插件的静态网站生成器，只能手动部署到 GitHub。 网上有很多关于用 Travis 自动部署 Hexo 的文章，却没看到几篇关于 Hugo，虽然原理都差不多，但细节上还是有很多容易让小白头疼的地方，所以今天我就来教教如何用 Travis 来自动部署 Hugo。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"正文 废话不多说，我们开始吧！ ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置代码仓库 首先确保你的 GitHub 上有这两个仓库：用来部署博客的 [用户名].github.io 和 用来存放 “源码” 的 Blog 这里与别的使用 Travis 自动部署博客教程稍微有点不同，别人家大多上将博客的源码放在 [用户名].github.io 的分支上，而不是向我一样开两个仓库 开两个仓库的好处有： 结构更清晰。与博客相关的内容都在 Blog 仓库里， [用户名].github.io 只用来提供一个 GitHub Pages 的服务 「源码」存放在 master 分支下，clone 更快 我不知道上我的原因还是 GitHub 或是 Git 的原因，我从 GitHub clone 除 master 分支以外的分支时，下载速度贼慢，只有几百 kb 每秒，clone 一个 「源码」 都至少要半个多小时 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:1","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"申请 Token 然后要去 GitHub 上申请一个新的 personal access token。 Token description 也就是 Token 的名字，可以随便填。然后一定要勾选上 repo 上的所以项目，然后别的项目一个都不要选。点 Generate token 生成 Token。 然后记下 Token 的值，也就是我打码的那一部分 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:2","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置 Travis CI 接着来到 Travis CI，使用 GitHub 帐号登录；然后为 Blog 仓库打上 ☑，然后点 setting。 然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击 Add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:3","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"编写 .travis.yml 在 Blog 的目录下创建并编辑一个 .travis.yml 文件。这个文件的作用是告诉 Travis CI 如何部署你的博客的 language: go go: - \"1.8\" # 指定Golang 1.8 # Specify which branches to build using a safelist # 分支白名单限制：只有 master 分支的提交才会触发构建 # branches: # only: # - master install: # 安装最新的hugo - wget https://github.com/gohugoio/hugo/releases/download/v0.51/hugo_0.51_Linux-64bit.deb - sudo dpkg -i hugo*.deb # 安装主题 - git clone [你使用的主题的 Git 地址] script: # 运行hugo命令 - hugo after_script: # 部署 - cd ./public - git init - git config user.name \"[你的名字]\" - git config user.email \"[你的邮箱]\" - git add . - git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\" # Github Pages - git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master # Github Pages - git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tags env: global: # Github Pages - GH_REF: [用来部署博客的 Git 地址] deploy: provider: pages # 重要，指定这是一份github pages的部署配置 skip-cleanup: true # 重要，不能省略 local-dir: public # 静态站点文件所在目录 # target-branch: master # 要将静态站点文件发布到哪个分支 github-token: $GITHUB_TOKEN # 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis # fqdn: # 如果是自定义域名，此处要填 keep-history: true # 是否保持target-branch分支的提交记录 on: branch: master # 博客源码的分支 Copy 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 Blog 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色 代表正在部署 红色 代表部署失败 灰色 代表部署被取消 然后再去你的博客，如果没有出什么偏差的话就说明部署成功了 | ・ω・’） 以后的话就只需要把写好的文章推送到 Blog 仓库 下就可以了，就不需要再自己编译然后手动推送了 甚至连 Hugo 都可以不要装 | ・ω・’） ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:4","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"附录 以及一些坑 (:з)∠) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"添加 .gitignore 文件 在 Hugo 本地编译时会产生 public 文件夹，但是这个文件夹中的内容对于 Blog 仓库 来说是不需要的 (包括用来存放主题的 themes 文件夹和主题产生的 resources 文件夹也是不需要的) 我们可以用一个.gitignore 文件来排除这些内容 在 Blog 目录下创建并修改 .gitignore，然后提交到 GitHub public/* themes/* resources/* Copy ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:1","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"Travis CI 的分支白名单 我给你的 .travis.yml 文件中有怎么一段 # Specify which branches to build using a safelist # 分支白名单限制：只有 master 分支的提交才会触发构建 branches: only: - master Copy 这一段的作用是限制触发构建的分支。这在正常开发中是很重要的配置，特别是在团队 (多人) 开发的场景中。 不过这里不存在这个场景，并且如果配置错了会出很大的问题，很容易坑到小白， 比如说我 (:з)∠) 所以默认就给注释掉了。 如果你晓得这是干啥的，并且觉得有必要的话，可以考虑开启 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:2","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"相关文章 使用 Hugo + GitHub Pages 搭建个人博客 为 Hugo 添加谈笑风生区 (Gitalk) 为 Hugo 博客添加字数统计 Leavelt 主题优化 为博客添加独立域名 为博客添加免费的 CDN (Cloudflare) 为 LeaveIt 主题添加阅读进度条 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":null,"content":"模板 ","date":"2021-08-04","objectID":"/2021/08/md%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["GitHub","博客"],"title":"md模板","uri":"/2021/08/md%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"万能代码安装说明 将以下代码放置在您希望 Disqus 加载的地方： \u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e \u003cscript\u003e /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://xinqinew.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); \u003c/script\u003e \u003cnoscript\u003ePlease enable JavaScript to view the \u003ca href=\"https://disqus.com/?ref_noscript\"\u003ecomments powered by Disqus.\u003c/a\u003e\u003c/noscript\u003e （推荐）使用您的 CMS 或平台的动态值编辑推荐的配置变量部分。 请参阅我们的文档以了解为什么定义标识符和 url 对防止重复线程很重要。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"如何显示评论计数 在网站关闭\u003c/body\u003e标签之前放置以下代码： \u003cscript id=\"dsq-count-scr\" src=\"//xinqinew.disqus.com/count.js\" async\u003e\u003c/script\u003e 将 #disqus_thread 附加到链接中的 href 属性。 这将告诉 Disqus 查找哪些链接并返回评论计数。 例如：\u003ca href=\"http://foo.com/bar.html#disqus_thread\"\u003eLink\u003c/a\u003e ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:2:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"设置完成！ 恭喜你，你安装完Disqus！这里有几页可以帮助您开始使用Disqus。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:3:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"安装Lovelt博客","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Lovelt博客 下载地址 安装文档 参考-晓的记忆 LoveIt参考站2 LoveIt参考站3 LoveIt参考站4 参考1 参考2 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"1 准备 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2 安装 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.1 创建你的项目 hugo new site LoveIt cd LoveIt ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.2 安装主题 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt git submodule add https://ghproxy.com/https://github.com/dillonzq/LoveIt.git themes/LoveIt # 代理 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:2","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:3","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:4","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:5","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:6","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3 配置 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"google搜索优化 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源，如https://skyao.io/learning-hugo/。会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。 进入资源页面，点\"索引\"下的\"站点地图\"，在\"添加新的站点地图\"处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://skyao.io/learning-hugo/sitemap.xml。 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo 最终还是投入Hugo的怀抱，原因是： 熟悉和欣赏Go 发现一个超级喜欢的Hugo主题 - LoveIt 本文记录下博客从Jekyll迁移到Hugo的过程。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:0:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"创建项目 安装Hugo sudo pacman -S hugo 创建名称为Demo的新项目 hugo new site Demo 添加主题（此为必需步骤，可以选择其他主题） cd Demo \u0026\u0026 git init \u0026\u0026 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 也可以自行下载主题，放置于 Demo/themes 目录下 但作为submodule添加进Git项目是一个更好的方式 创建示例文章 hugo new posts/first.md 产生的文件位于是 Demo/content/posts/first.md 启动Hugo服务 hugo server 本地预览访问 http://localhost:1313/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:1:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"文章迁移 hugo import jekyll /Volumes/video/GitHub/xinqinew.github.io /Volumes/video/GitHub/Eureka2 Hugo提供了迁移命令import，可以方便地将Jekyll项目转换为Hugo项目，包括文章和其他静态资源文件。 命令格式是hugo import jekyll JEKYLL_ROOT_PATH TARGET_PATH，其中 JEKYLL_ROOT_PATH 是Jekyll项目主目录，TARGET_PATH 是新生成的Hugo项目目录。 以我的一篇文章为例，原Jekyll项目中的位置是 _post/2020-07-29-cpp-template-notes.md，Hugo项目中的位置是 content/post/2020-07-29-cpp-template-notes.md，需要注意的是，迁移前后文件名保持一致，划重点后面用到。 Jekyll Front Matter --- layout: post title: C++类与模板 categories: [ 编程语言 ] tags: [ C++, Template ] --- Hugo Front Matter --- categories: - 编程语言 date: \"2020-07-29T00:00:00Z\" tags: - C++ - Template title: C++类与模板 --- 同时需要注意，Jekyll和Hugo在FrontMatter变量的定义有区别，划重点。 Jekyll Hugo date post文件名或FrontMatter指定，FrontMatter重写前者 FrontMatter指定 title post文件名指定 FrontMatter指定，即文章标题 filename N/A 即文件名（不包含扩展名） section N/A content下的目录名 以 2020-07-29-cpp-template-notes.md 为例， 对于Jekyll，date是 2020-07-29，title是 cpp-template-notes； 对于Hugo，date是 2020-07-29，title是 C++类与模板，filename是 2020-07-29-cpp-template-notes。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:2:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"URL规则 URL规则在全局配置文件（config.toml）的 permalinks 进行配置，也可以使用文章HugoFrontMatter的 url 变量指定（优先级高于前者）。 需要保证，无论URL规则是否变化，都能通过原始URL访问到文章。 对于迁移后的三种情形： 保持原有URL规则 如果原Jekyll的permalink配置使用 title 变量，相应地在Hugo下使用 filename 变量，由于迁移前后文件名保持一致，这将破坏原有的URL规则，可以采取两个方案： 使用HugoFrontMatter的 url 变量指定原始URL 去除迁移后文件名的date部分 个人采用第一种，因为通过文件名可以区分哪些是迁移前的文章。 老文章保持原有URL规则，新文章采用新的URL规则 老文章使用HugoFrontMatter的 url 变量指定原始URL，新文章采用全局 permalinks 配置，这种方式实现起来最简单，但URL规则不统一，看着很不规范，不推荐！ 采用新的URL规则 如果原Jekyll的permalink配置使用 title 变量，使用HugoFrontMatter的 url 变量指定新URL； 使用HugoFrontMatter的 aliases 变量指定原始URL，实现页面重定向。 对于我的博客，原Jekyll的URL规则是 permalink: /:year/:month/:day/:title 在Hugo下使用了新的URL规则 [permalinks] posts = \"/:section/:year/:month/:day/:filename/\" JekyllFrontMatter --- layout: post title: C++类与模板 categories: [ 编程语言 ] tags: [ C++, Template ] --- HugoFrontMatter --- title: C++类与模板 categories: - 编程语言 tags: - C++ - Template date: 2020-07-29 00:00:00+08:00 url: /posts/2020/07/29/cpp-template-notes/ aliases: - /2020/07/29/cpp-template-notes/ --- Hugo import命令无法满足我的场景，而且HugoFrontMatter变量按照首字符顺序排序，看着实在难受，本着轮子能造就造的原则，写了一个转换工具，仅对_posts下文章进行转换，有需要可以尝试下，项目地址是 https://github.com/caosiyang/convert-jekyll-to-hugo ，嗯，这个硬广阔以：） ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:3:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"GitHub Pages发布 执行hugo命令，在 public 目录下生成静态网站，push里面的内容到github就可以了。 Hugo官方提供的方案是submodule方式，如下： $ rm -rf public $ git submodule add -b master https://github.com/\u003cUSERNAME\u003e/\u003cUSERNAME\u003e.github.io.git public $ hugo 发布新的Hugo页面时遇到了问题，顺便说一下吧。 之前我的博客项目已经托管在GitHub，我把原repo重命名了（暂且称“A\"），新建一个repo（暂且称为“B”），名字是.github.io，然后push页面，之后浏览，“首页/分类/标签/关于”页面都是正常的，而“文章”页面还是原始的Jekyll生成的页面，初以为是缓存问题，过了一晚还这样，怀疑跟A有管，把A删除，问题仍然存在，之后又把B删除，重新建repo和push，恢复正常。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:4:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"博客历程回顾 最初产生写博客的想法是2011年，试用了当时几个流行的技术博客平台（csdn/cnblogs/cppblog），最终选择了cnblogs。 2015年了解到GitHub Pages可以搭建博客，当时已经在用GitHub，所以不假思索地转过去，使用Jekyll搭建了新博客，看了很多主题，选了一个并进行小改，但并不满意，最后抱着学习前端的想法，自己写了一个相当相当粗糙的主题，凑合用着了。 后来先后了解到Hexo和Hugo，同为热门的静态网站生成工具，前者node.js实现，后者Go实现，看过它们的主题，感觉都比Jekyll的好看，也很玄学，但迟迟没有折腾，现在想来，能坚持更博就不错了。 2020年是不平凡的一年，新冠疫情爆发，我的工作生活发生了很大变化，在一段闲暇的日子里，又开始琢磨博客，在看到一个相当中意的Hugo主题，坚定了我转到Hugo的决心，于是有了现在的博客。 参考文档 https://gohugo.io/tools/migrations/ https://gohugo.io/commands/hugo_import_jekyll/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:5:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"安装docsy主题","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装docsy主题 下载并安装npm ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"作为npm模块 您可以npm使用hugo-bin. 这会添加hugo-bin到您的node_modules文件夹并将依赖项添加到您的package.json文件中。要安装 Hugo 的扩展版本： npm install hugo-extended --save-dev ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装 PostCSS 要构建或更新站点的 CSS 资源，您还需要PostCSS创建最终资产。如果您需要安装它，您必须在您的机器上安装最新版本的NodeJS，以便您可以使用npmNode 包管理器。默认情况npm下，在您运行的目录下安装工具npm install： sudo npm install -D autoprefixer sudo npm install -D postcss-cli ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"选项 1：复制 Docsy 示例站点 该示例站点为您提供了一个很好的起点构建您的文档的网站，并预先配置为使用Docsy主题为Git的子模块。您可以通过以下方式复制示例站点： 使用 GitHub 用户界面 使用命令行 使用 GitHub 用户界面 这是最简单的方法，因为 Docsy 示例站点存储库是一个模板存储库。要创建您自己的 Docsy 示例站点存储库副本： 转到repo 页面并单击Use this template。 在存储库名称字段中输入您为新存储库选择的名称。您还可以添加可选的Description。 单击从模板创建存储库以创建新存储库。恭喜，您现在拥有一个 Docsy 站点存储库！ 要使用 Hugo 在本地测试您复制的站点，或进行本地编辑，您还需要制作新存储库的本地副本。为此，请使用git clone, 替换https://github.com/my/example.git为您的存储库的网址（不要忘记使用，--recurse-submodules否则您将不会下拉生成工作站点所需的一些代码）： cd /Volumes/video/GitHub/Hugo git clone --recurse-submodules --depth 1 https://github.com/xinqinew/Docsy.git //git clone --recurse-submodules --depth 1 https://ghproxy.com/https://github.com/xinqinew/Docsy.git cd Docsy hugo server 您现在可以编辑站点源文件的本地版本。要预览您的站点，请转到站点根目录并运行hugo server（请参阅 MacOS 上的已知问题）。默认情况下，您的站点将在 http://localhost:1313/ 上可用。要将更改推送到您的新存储库，请转到您的站点根目录并使用git push. ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 错误：too many open files或fatal error: pipe failed 默认情况下，MacOS 允许少量打开的文件描述符。对于较大的站点，或者当您同时运行多个应用程序时，当您运行hugo server以在本地预览站点时，您可能会收到以下错误之一： POSTCSS v7 及更早版本： ERROR 2020/04/14 12:37:16 Error: listen tcp 127.0.0.1:1313: socket: too many open files POSTCSS v8 及更高版本： fatal error: pipe failed 解决方法 暂时允许更多打开的文件： 通过运行查看您当前的设置： sudo launchctl limit maxfiles 65535通过运行以下命令增加对文件的限制。如果您的站点文件较少，您可以选择设置较低的软 ( 65535) 和硬 ( 200000) 限制。 sudo launchctl limit maxfiles 65535 200000 ulimit -n 65535 sudo sysctl -w kern.maxfiles=200000 sudo sysctl -w kern.maxfilesperproc=65535 请注意，您可能需要为每个新 shell 设置这些限制。 详细了解这些限制以及如何使它们永久化。 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:4","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装Eureka博客","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Eureka博客 官方文档 cd /Volumes/video/GitHub/Eureka git init git submodule add https://github.com/wangchucheng/hugo-eureka.git themes/eureka 切换版本方法如下: cd themes/eureka git checkout v0.8.2 #git checkout \u003ceureka_version\u003e #eureka_version 替换成版本号 接下来，将exampleSite中的config文件夹复制到项目根目录下，对config文件夹的内容进行配置。配置后删除原先的config.toml文件即可。 如果你是新建的Hugo项目，content文件夹下默认没有内容。你可以将exampleSite中的content文件夹复制到项目根目录下预览主题效果。 完成以上步骤后使用以下命令即可在浏览器中预览项目： hugo server 草稿不会被Hugo部署，所以你需要将内容头部的draft属性设为false或使用hugo server -D预览网站。 内容管理 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"目录结构 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文章页 文章内容为Eureka默认的文章结构，因此新建文章页时不需指定其类型。 hugo new posts/\u003cyour_post.md\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文档页 新建文档页时需指定其类型为docs。 hugo new -k docs docs/\u003cyour_doc\u003e/\u003cyour_page.md\u003e 如果你此前没有创建过文档类型的内容，你需要先生成文档列表： hugo new -k docs docs ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建作者页 新建作者页时需指定其类型为authors。 hugo new -k authors authors/\u003cyour_author\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客 http://themes.jekyllrc.org/ https://jekyllthemes.io/ jekyll-rtd-theme minimal-mistakes/ flexible-jekyll ","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装先决条件 在 Mac 和 Windows 上，下载并安装Docker Desktop。在 Linux 上，安装Docker 引擎和Docker compose。 安装可能需要您重新启动计算机以使更改生效。 安装 git。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从文档示例模板创建存储库 文档示例存储库提供了一个基本的站点结构，您可以将其用作创建自己文档的起点。 使用docsy-example模板 创建自己的存储库。 通过克隆新创建的存储库，将代码下载到本地机器。 将工作目录更改为新创建的文件夹： cd docsy-example ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"构建并运行容器 文档示例存储库包括一个Dockerfile，可用于运行站点。 构建docker镜像： docker-compose build 运行已构建的图像： docker-compose up 在网页浏览器中打开地址http://localhost:1313以加载文档示例主页。您现在可以对源文件进行更改，这些更改将在浏览器中实时重新加载。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"清理 要清理系统并删除容器映像，请按照以下步骤操作。 使用Ctrl + C停止Docker作曲。 移除生成的图像 docker-compose rm ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言"],"content":"植物大战僵尸","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","series":null,"tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":["易语言"],"content":"植物大战僵尸 .版本 2 .程序集 窗口程序集_启动窗口 .程序集变量 process, 整数型 .程序集变量 BaseAddress, 整数型 .程序集变量 setoff1, 整数型 .程序集变量 setoff2, 整数型 .程序集变量 PlantAddress, 整数型 .程序集变量 ZombiesAddress, 整数型 .程序集变量 图像x, 整数型 .程序集变量 图像y, 整数型 .程序集变量 真实x, 整数型 .程序集变量 真实y, 整数型 .子程序 _选择框_不消耗阳光_被单击 .如果 (选择框_不消耗阳光.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“90 90”)) .否则 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“2b f3”)) .如果结束 .子程序 __启动窗口_创建完毕 process ＝ 进程_取进程句柄 (“PlantsVsZombies.exe”) BaseAddress ＝ 内存_读整数型 (process, 十六到十 (“6aa00c”)) ' 基址 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) ' 一级偏移 PlantAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“ac”)) ' 植物 ZombiesAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“90”)) ' 僵尸 时钟_监视进程.时钟周期 ＝ 3000 按钮割草机CALL.禁止 ＝ 真 .子程序 _按钮_阳光9999_被单击 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) 内存_写整数型 (process, setoff1 ＋ 十六到十 (“5560”), 9999) .子程序 _选择框_无冷却_被单击 .如果 (选择框_无冷却.选中 ＝ 真) 时钟1.时钟周期 ＝ 1000 .否则 时钟1.时钟周期 ＝ 0 .如果结束 .子程序 _时钟1_周期事件 .局部变量 onePlant, 整数型 .局部变量 Index, 整数型 .局部变量 setoffPlant, 整数型 setoffPlant ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .计次循环首 (10, Index) ' onePlant ＝ 内存_读整数型 (process, setoffPlant+十六到十(\"4c\") ＋ (Index － 1) × 80) 内存_写整数型 (process, setoffPlant ＋ 十六到十 (“4c”) ＋ (Index － 1) × 80, 5000) ' 无冷却 .计次循环尾 () .子程序 _选择框_无冷却1_被单击 .如果 (选择框_无冷却1.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“E9 CB 6B 2A 00 90 90”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“C7 47 24 88 13 00 00 83 47 24 01 8B 47 24 E9 24 94 D5 FF”)) .否则 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“83 47 24 01 8B 47 24”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00”)) .如果结束 .子程序 _选择框_自动收集_被单击 .如果 (选择框_自动收集.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 01”)) .否则 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 00”)) .如果结束 .子程序 _选择框_子弹叠加_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“90 90 90 90 90 90”)) .否则 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“0F 85 98 FE FF FF”)) .如果结束 .子程序 _按钮_更改卡槽_被单击 .局部变量 setoffxxx, 整数型 setoffxxx ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .如果真 (卡槽组合框.现行选中项 ＝ 0) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 1) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 2) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 18) .如果真结束 .如果真结束 .子程序 _按钮_种植CALL_被单击 asm_置代码 () asm_pushad () asm_push (-1) ' 固定-1 asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID asm_mov_eax_常数 (到整数 (编辑框_y.内容)) ' Y asm_push (到整数 (编辑框_x.内容)) ' X asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) asm_push_ebp () ' ebp asm_mov_ebx_常数 (十六到十 (“40d120”)) asm_call_ebx () ' call asm_popad () asm_ret () asm_调用函数2 (process, asm_取代码 ()) .子程序 _按钮_乱种CALL1_被单击 .局部变量 坐标x, 整数型 .局部变量 坐标y, 整数型 .局部变量 index1, 整数型 .局部变量 index2, 整数型 .局部变量 index3, 整数型 坐标x ＝ 0 坐标y ＝ 0 .计次循环首 (3, index3) .如果 (index3 ＝ 1) 编辑框_植物ID.内容 ＝ “38” .否则 .如果 (index3 ＝ 2) 编辑框_植物ID.内容 ＝ “40” .否则 编辑框_植物ID.内容 ＝ “43” .如果结束 ​ .如果结束 ​ .计次循环首 (6, index1) ​ .计次循环首 (6, index2) ​ asm_置代码 () ​ asm_pushad () ​ asm_push (-1) ' 固定-1 ​ asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID ​ asm_mov_eax_常数 (坐标y ＋ index1 － 1) ' Y ​ asm_push (到整数 (坐标x ＋ index2 － 1)) ' X ​ asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) ​ asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) ​ asm_push_ebp () ' ebp ​ asm_mov_ebx_常数 (十六到十 (“40d120”)) ​ asm_call_ebx () ' call ​ asm_popad () ​ asm_ret () ​ asm_调用函数2 (process, asm_取代码 ()) ​ .计次循环尾 () ​ .计次循环尾 () .计次循环尾 () .子程序 _选择框_重叠种植_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 ","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/:0:0","series":null,"tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":null,"content":"知识点描述","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"知识点 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"小知识 ptr 强制类型转换 lea 指令可以用来将一个内存地址直接赋给目的操作数，例如： lea eax,[ebx+8] 就是将ebx+8这个值直接赋给eax mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。 通用寄存器 32 位 16 位 8 位（高） 8 位（低） EAX AX AH AL EBX BX BH BL ECX CX CH CL EDX DX DH DL 32 位 16 位 32 位 16 位 ESI SI EBP BP EDI DI ESP SP 特殊用法 乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。 CPU 默认使用 ECX 为循环计数器。 ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。 ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。 高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。 状态标志位 进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。 溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。 符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。 零标志位（ZF），算术或逻辑操作产生的结果为零时，设置该标志位。 辅助进位标志位（AC），算术操作在 8 位操作数中产生了位 3 向位 4 的进位时，设置该标志位。 奇偶校验标志位（PF），结果的最低有效字节包含偶数个 1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行 错误检测。 64位通用寄存器 操作数大小 可用寄存器 8 位 AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L 16 位 AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W 32 位 EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D 64 位 RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15 整数常量 h 十六进制 r 编码实数 q/o 八进制 t 十进制（备用） d 十进制 y 二进制（备用） b 二进制 26 ;十进制 26d ;十进制 11010011b ;二进制 42q ;八进制 42o ;八进制 1Ah ;十六进制 0A3h ;十六进制 整型常量表达式 运算符 名称 优先级 () 圆括号 1 +,- 一元加、减 2 *, / 乘、除 3 MOD 取模 3 +, - 加、减 4 保留字列表。 $ PARITY? DWORD STDCALL ? PASCAL FAR SWORD @B QWORD FAR16 SYSCALL @F REAL4 FORTRAN TBYTE ADDR REAL8 FWORD VARARG BASIC REAL10 NEAR WORD BYTE SBYTE NEAR16 ZERO? C SDORD OVERFLOW? CARRY? SIGN? 定义段 .DATA 伪指令进行标识： .data .CODE 伪指令标识的程序区段包含了可执行的指令： .code .STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小： .stack 100h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令 一条指令有四个组成部分： 标号（可选） 指令助记符（必需） 操作数（通常是必需的） 注释（可选） 不同部分的位置安排如下所示： [label: ] mnemonic [operands] [;comment] ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"标号 数据标号 count DWORD 100 代码标号 target: mov ax,bx ... jmp target ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:1","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令助记符 助记符 说明 助记符 说明 MOV 传送（分配）数值 MUL 两个数值相乘 ADD 两个数值相加 JMP 跳转到一个新位置 SUB 从一个数值中减去另一个数值 CALL 调用一个子程序 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:2","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"操作数 示例 操作数类型 示例 操作数类型 96 整数常量 eax 寄存器 2+4 整数表达式 count 内存 STC 指令没有操作数： stc ;进位标志位置 1 INC 指令有一个操作数： inc eax ;EAX 加 1 MOV 指令有两个操作数： mov count, ebx ;将 EBX 传送给变量 count IMUL 指令有三个操作数，第一个是目的操作数，第二个和第三个是进行乘法的源操作数： imul eax,ebx,5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:3","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"注释 单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。 块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。 COMMENT ! This line is a comment. This line is also a comment. ! ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:4","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"NOP（空操作）指令 .data ;此为数据区 sum DWORD 0 ;定义名为sum的变量 .code ;此为代码区 main PROC mov eax,5 ;将数字5送入而eax寄存器 add eax,6 ;eax寄存器加6 mox sum,eax INVOKE ExitProcess,0 ;结束程序 main ENDP ; AddTwo.asm -两个 32 位整数相加 .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .code main PROC mov eax,5 ;将数字5送入eax寄存器 add eax,6 ;eax寄存器加6 INVOKE ExitProcess,0 main ENDP END main 第 3 行是 .386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。 第 4 行选择了程序的内存模式（flat），并确定了子程序的调用规范（称为 stdcall）。其原因是 32 位 Windows 服务要求使用 stdcall 规范。 第 5 行为运行时堆栈保留了 4096 字节的存储空间，每个程序都必须有。 第 6 行声明了 ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode。 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:5","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"汇编伪指令回顾 CODE 的下一行声明程序的入口 .code main PROC ENDP 伪指令标记一个过程的结束。 main ENDP END 伪指令标记一个程序的结束，并要引用程序入口： END main ; AddTwo.asm - adds two 32-bit integers. ; Chapter 3 example .386 .model flat,stdcall .stack 4096 ExitProcess PROTO,dwExitCode:DWORD 00000000 .code 00000000 main PROC 00000000 B8 00000005 mov eax, 5 00000005 83 C0 06 add eax,6 invoke ExitProcess,0 00000008 6A 00 push +000000000h 0000000A E8 00000000 E call ExitProcess 0000000F main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:6","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据类型以及数据定义详解 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"内部数据类型 类型 用法 BYTE 8 位无符号整数，B 代表字节 SBYTE 8 位有符号整数，S 代表有符号 WORD 16 位无符号整数 SWORD 16 位有符号整数 DWORD 32 位无符号整数，D 代表双（字） SDWORD 32 位有符号整数，SD 代表有符号双（字） FWORD 48 位整数（保护模式中的远指针） QWORD 64 位整数，Q 代表四（字） TBYTE 80 位（10 字节）整数，T 代表 10 字节 REAL4 32 位（4 字节）IEEE 短实数 REAL8 64 位（8 字节）IEEE 长实数 REAL10 80 位（10 字节）IEEE 扩展实数 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:1","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据定义语句 数据定义语法如下所示： [name] directive initializer [,initializer]… 下面是数据定义语句的一个例子： count DWORD 12345 伪指令 用法 伪指令 用法 DB 8位整数 DQ 64 位整数或实数 DW 16 位整数 DT 定义 80 位（10 字节）整数 DD 32 位整数或实数 ;AddTowSum.asm .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .data sum DWORD 0 .code main PROC mov eax,5 add eax,6 mov sum,eax INVOKE ExitProcess,0 main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:2","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 BYTE 和 SBYTE 数据 value1 BYTE 'A' ;字符常量 value2 BYTE 0 ;最小无符号字节 value3 BYTE 255 ;最大无符号字节 value4 SBYTE -128 ;最小有符号字节 value5 SBYTE +127 ;最大有符号字节 value6 BYTE ? ;变量 val1 DB 255 ;无符号字节 val2 DB -128 ;有符号字节 多初始值 list BYTE 10,20,30,40 偏移量 数值 0000 10 0001 20 0002 30 0003 40 list BYTE 10,20,30,40 BYTE 50,60,70,80 BYTE 81,82,83,84 list1 BYTE 10, 32, 41h, 00100010b list2 BYTE 0Ah, 20h, 'A', 22h list1与list2不同进制，但值相同 定义字符串 greeting1 BYTE \"Good afternoon\",0 greeting2 BYTE 'Good night',0 0作为结束标记 greeting1 BYTE \"Welcome to the Encryption Demo program \" BYTE \"created by Kip Irvine.\",0dh, 0ah BYTE \"If you wish to modify this program, please \" BYTE \"send me a copy.\",0dh,0ah,0 十六进制代码 0Dh 和 0Ah 也被称为 CR/LF （回车换行符）或行结束字符。 greeting1 BYTE \"Welcome to the Encryption Demo program \" 和 greeting1 \\ BYTE \"Welcome to the Encryption Demo program \" 行连续字符（\\）把两个源代码行连接成一条语句，它必须是一行的最后一个字符。上面的语句是等价的。 DUP 操作符 BYTE 20 DUP ( 0 ) ;20 个字节，值都为 0 BYTE 20 DUP ( ? ) ;20 个字节，非初始化 BYTE 4 DUP ( \"STACK\" ) ; 20 个字节： ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:3","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 WORD 和 SWORD 数据 word1 WORD 65535 ;最大无符号数 word2 SWORD -32768 ;最小有符号数 word3 WORD ? ;未初始化，无符号 val1 DW 65535 ;无符号 val2 DW -32768 ;有符号 也可以使用传统的 DW 伪指令 myList WORD 1,2,3,4,5 偏移量 数值 0000 1 0002 2 0004 3 0006 4 0008 5 array WORD 5 DUP (?) ; 5 个数值，未初始化 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:4","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 DWORD 和 SDWORD 数据 val1 DWORD 12345678h ;无符号 val2 SDWORD -2147483648 ;有符号 val3 DWORD 20 DUP (?) ;无符号数组 val1 DD 12345678h ;无符号 val2 DD -2147483648 ;有符号 pVal DWORD val3 myList DWORD 1,2,3,4,5 偏移量 数值 0000 1 0004 2 0008 3 000C 4 0010 5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:5","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 QWORD 数据 quad1 QWORD 1234567812345678h quad1 DQ 1234567812345678h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:6","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"C++关键字描述","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/","series":null,"tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["C++"],"content":"C++关键字 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量\"自动\"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ’ 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: const double pi(3.14159); 或 const double pi = 3.14159; 10. const_cast用法： const_cast\u003ctype_id\u003e (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是\"继续循环\"之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是\"禁止单参数构造函数\"被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： extern “C” 声明语句 extern “C” { 声明语句块 } 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： reinpreter_cast (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 size","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","series":null,"tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["博客"],"content":"Jekyll 插入图片","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","series":null,"tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["博客"],"content":"Jekyll 插入图片 用 Markdown 插入图片是一件很简单的事，只需要这样写： ![AltText](/path/to/img.jpg) 然而，如果你需要进行更多的控制，情况立刻变得复杂了起来。由于 Markdown 秉持结构和样式分离的原则，你无法在插入图片时控制其大小。要达到这样的目的，你需要使用普通的 \u003cimg\u003e 标签： \u003cimg src=\"/path/to/img.jpg\" width=\"100\" height=\"100\" alt=\"AltText\" /\u003e 相对前一种语法，后者明显麻烦许多。所幸这种情况一般都是极少数。一般来说，我们只需要使用前一种语法。然而，有一种状况会让你需要大量使用后一种语法 —— Retina 屏幕的截图。一张 100pt * 100pt 的截图事实上是 200px * 200px。贴到文章里之后，电脑又会以 200pt * 200pt 的大小来渲染。你的截图立刻变得大而模糊。为了避免这种状况，你需要手动计算图片的实际大小，然后使用 HTML 语法插入图片。当你需要插入大量图片时，这一工作很快变得枯燥而难以忍受。 当然，你可以通过指定比例从而避免手工计算大小： \u003cimg src=\"/path/to/img.jpg\" width=\"50%\" alt=\"AltText\" /\u003e 虽然免去了计算大小，你依然需要使用冗长的 HTML 语法。能不能用 Markdown 语法来做这件事呢？ 我们知道有些 Markdown 方言支持调整图片大小，例如： Mou: ![AltText](/path/to/img.jpg =100x) MWeb: ![AltText-w100](/path/to/img.jpg) ... 显然，这些在 Jekyll 中都是不支持的。不过，我们有更好的方法： ![AltText @2x]() 只需添加 @2x 后缀，图片就会自动缩放为50%大小 这显然不是 Markdown 或 Jekyll 的功能，在你的博客中使用不会有任何效果。真正的魔法在 CSS 样式表中： .post-container img[alt~=\"@2x\"] { zoom: 50%; } 我们用到了 CSS 中的属性选择器，它可以对拥有指定属性的 HTML 元素设置样式。在这里，我们对 alt 中包含 @2x 的所有图片添加了 zoom: 50% 属性。 同理，你也可以为 iPhone * Plus 的截图设置三倍缩放： .post-container img[alt~=\"@3x\"] { zoom: 33%; } ","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/:0:0","series":null,"tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid教程收录","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid教程收录 时间管理、头脑风暴、阅读、会议记录神器-Mermaid Mermaid英文教程 Mermaid在线编辑器 Mermaid，就像用 Markdown 码字一样，高效制作简易流图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:0:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid - 流程图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"基本结构 圆角矩形 表示“开始”与“结束” 矩形表示行动方案、普通工作环节用 菱形表示问题判断或判定（审核/审批/评审）环节 用平行四边形表示输入输出 箭头代表工作流方向 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"流程图与节点的创建 graph 流程图声明 graph S[声明一个流程图] graph s(\"开始(START)\") 语法：id(\":转义字符;\") graph s(\"开始:#9829;\") ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"各方向 graph TB s[开始]--\u003e e[结束] graph BT s[开始]--\u003e e[结束] graph LR s[开始]--\u003e e[结束] graph RL s[开始]--\u003e e[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"节点形状 graph a[矩形] b(圆角矩形) c([体育场]) d[(圆柱)] e((圆形)) graph f{菱形} g{{6}} h\u003e非对称] i[/平行四边形/] j[/梯形\\] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:4","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"线条形状 graph g[开始] --- h[结束] a[开始] -.- b[结束] c[开始] === d[结束] e[开始] --\u003e f[结束] i[开始] -.-\u003e j[结束] k[开始] ==\u003e l[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:5","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"带文字的链接线 graph a[开始] --过程1--- b[结束] c[开始] --\u003e|过程2| d[结束] e[开始] -.过程3.-\u003e f[结束] g[开始] ==过程4==\u003e h[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:6","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"关系链 graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] s--走路--\u003e o[永辉超市]--付钱--\u003e e graph LR s[家] --走路--\u003eP[菜市场]--走路--\u003eL[水果店]--走路--\u003e j[超市]--\u003es graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e s s--网上--\u003e o[永辉超市]--付钱--\u003e s 正常写法 graph z[张三]--\u003eC[内卷] z--\u003eD[躺平] L[李四]--\u003eC[内卷] L--\u003eD 简易写法 graph z[张三] \u0026 L[李四]--\u003eC[内卷] \u0026 D[躺平] 不美观 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--\u003e|躺平|N[喝快乐水] 美观:加长某一项 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X---\u003e|躺平|N[喝快乐水] 增加层级:再加长 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--躺平----\u003eN[喝快乐水] 可用—-\u003e 链接线会增加3个层级的长度 一下是各个类型连接线增加层级长度语法 增加层级长度 1 2 3 实线 — —- —– 带箭头的实线 –\u003e —\u003e —-\u003e 粗实线 === ==== ===== 带箭头的粗实线 ==\u003e ===\u003e ====\u003e 虚线 -.- -..- -…- 带箭头的虚线 -.-\u003e -..-\u003e -…-\u003e ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:7","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"子图表 subgraph graph 节点关系 subgraph title //子图表的名称 子图表的节点关系 end //子图标结束标志 graph TB c1--\u003ea2 subgraph 表1 a1--\u003ea2 end subgraph 表2 b1--\u003eb2 end subgraph 表3 c1--\u003ec2 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:8","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"交互 为节点添加事件 以及点击跳转 这个现在还不是很好用 var callback = function(){ alert('A callback was triggered'); } 源代码： graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 生成效果： graph LR A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 注释 %% 源代码 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C 生成效果 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:9","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"添加样式 方式1 语法： style id key:value,key:value 源代码： graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式2 定义样式 class 语法：classDef className 样式定义 应用 :::classname 源代码： graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式3 css class形式添加样式 定义 \u003cstyle\u003e .cssClass \u003e rect{ fill:red; stroke:#FFFF00; stroke-width:4px; } \u003c/style\u003e 实例： 源代码 graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; 生成效果： graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:10","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid - 时序图（序列图） ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"基本结构 角色 Actor 系统角色 可是是人或者其他系统子系统 对象 Object 交互过程中扮演的角色 一般位于时序图顶部 生命线 Lifeline 生命线代表时序图中的对象在一段时期内的存在 控制焦点 Activation 控制焦点代表时序图中的对象执行一项活动的时期 消息 Message 定义交互和协作中交换信息的类 基本对象声明 sequenceDiagram participant 张三 participant 李四 对象声明-别名 Aliases sequenceDiagram participant Z as 张三 participant L as 李四 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"消息 Message 语法：participant1 箭头 participant2：消息内容 sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003eL:我是没有箭头的实线 L--\u003eZ:我是没有箭头的虚线 Z-\u003e\u003eL:带箭头的实线 L--\u003e\u003eZ:带箭头的虚线 Z-xL:带x箭头实线 L-)Z:结束时候 带箭头的实线 Z--)L:结束时候 带箭头的虚线 线型对照表 线形 含义 -\u003e 无箭头的实线 –\u003e 没箭头的虚线 -» 带箭头的实线 –» 带箭头的实线 -x 带x号箭头实线 –x 结尾x号箭头实线 -) 结束 带箭头的实线 –) 结束 带箭头的虚线 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"控制焦点 Activations 语法： activate participant //激活 消息 deactivate participant //释放激活 这个有一些抽象我们用一个场景来去理解 场景1： ``` 张三：hi李四你还好么 // 李四听了开始回话 此时李四是激活状态 开始进行对话 李四：hi张三我可以听到你，我很好，不用担心。 //李四会话结束 不会再跟张三有活动 此时李四的激活状态被释放 ``` 源代码： ``` ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L ``` ``` 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L 场景2： 张三：hi李四你还好么 张三：你可以听到我说话么 //李四开始回话 被激活 李四：hi张三我可以听到你 李四：不用担心我 复制代码 源代码： ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图-批注 Note 语法： 单个对象： Note 位置 of participant:批注内容 多个对象： Note 位置 角色名称1，角色名称2:批注内容 位于对象左侧： 源代码 ```mermaid sequenceDiagram participant 张三 Note left of 张三 :我是张三 生成效果 sequenceDiagram participant 张三 Note left of 张三 :我是张三 ```mermaid sequenceDiagram participant 张三 Note right of 张三 :我是张三 sequenceDiagram participant 张三 participant 李四 Note over 张三,李四 :我是张三 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:4","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图-逻辑循环 Loop 交互过程中表示某些循环的环节 语法： loop 循环描述 循环内容 end //结束标记 复制代码 场景： 李四跟张三是好朋友 李四生病了 张三很关心他 每过一小时 为了不让张三如此担心 李四就约定每一个小时给张三发消息 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:5","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图 抉择（Alt）\u0026选项（Opt） 组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。 Alt 抉择 用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else.. 只能发生一种情况 语法： alt 第一种情况描述 具体发生的动作 else 剩余情况描述 具体发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 如果李四生病了他会说：我不是很好 如果李四很健康他会说：我很好 又是很好的一天 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end opt 选择\" 包含一个可能发生或不发生的序列 就是一种场景有可能发生也有可能不发生 语法： opt 情况描述 有可能发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 李四会可能会说谢谢你的问候也可能不会说 这个并无法预测 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:6","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图 并行关系 par 并行处理: 一个对象同时发出的交互动作 基本语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end 复制代码 场景： participants: 张三 李四 王五 张三 在下午5点分别给李四和王五分一条信息：内容是吃了么 李四回复：吃了 张三回复：没吃 复制代码 源代码 ```mermaid sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 生成效果 sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 嵌套语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end par 动作描述1 participant3 -\u003e\u003e participant4:内容 and 王五发消息给A8 participant3 -\u003e\u003e participant5:内容 end 复制代码 场景： participants: 张三 李四 王五 赵六 A8 王五明天请吃饭 张三发消息问李四明天去不去 同时发消息给王五问明天都有哪些人参加 王五发消息给赵六:明天一起吃饭8 同事也发消息给A8告诉他让他带着小伙伴一起 复制代码 源代码 ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 生成效果 sequenceDiagram participant 张三 participant 李四 participant 王五 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 背景高亮 语法： rect rgba(0,213,123) 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end 生成效果： sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:7","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"类图 classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:3:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"状态图 stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:4:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"实体关系图 erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:5:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"用户旅程图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:6:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"gantt图 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:7:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"饼图 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:8:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"需求图 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:9:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["C++"],"content":"指针读写内存","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","series":null,"tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"指针读写内存 #include \u003ccstdio\u003e #define BASE 0x00417000 int g_a = 111; //0x00417000 int g_b = 222; //0x00417004 int g_c = 333; //0x00417008 typedef struct T3 { int a1; //偏移0 int a2; //偏移4 int a3; //偏移8 }TYPE3; int main(int argc, char const *argv[]) { //指针读内存 int* p1=(int*)0x00417000; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,333 printf(\"B:%d,%d,%d \\n\",*(p1+0),*(p1+1),*(p1+2)); //B:111,222,333 printf(\"C:%d,%d,%d \\n\",p1[0],p1[1],p1[2]); //C:111,222,333 printf(\"D:%d,%d,%d \\n\",*(int*)0x0041700,*(int*)0x00417004,*(int*)0x0041708); //D:111,222,333 //用指针向内存地址写入数据 *(p1+2)=11567; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,11567 p1[2]=22567; printf(\"B:%d,%d,%d \\n\",g_a,g_b,g_c ); //B:111,222,22567 *(int*)(0x0041700+8)=333678; printf(\"C:%d,%d,%d \\n\",g_a,g_b,g_c ); //C:111,222,333678 TYPE3* p3 =(TYPE3*)0x00417000; printf(\"%p,%p,%p \\n\",\u0026p3-\u003ea1,\u0026p3-\u003ea2,\u0026p3-\u003ea3); //111,222,333678 printf(\"%d,%d,%d \\n\",p3-\u003ea1,p3-\u003ea2,p3-\u003ea3); //111,222,333678 printf(\"p3=%p,p3+1=%p,sizeof(TYPE3)=%X \\n\",p3,p3+1,sizeof(TYPE3)); //p3=00417000,p3+1=0041700C,sizeof(TYPE3)=C printf(\"p3=%p,p3+2=%p,sizeof(TYPE3)=%X \\n\",p3,p3+2,sizeof(TYPE3)); //p3=00417000,p3+2=00417018,sizeof(TYPE3)=C printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+sizeof(TYPE3)*2); //\u003e\u003e\u003e:p3+2=417018 =417018 printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+0xC*2); //\u003e\u003e\u003e:p3+2=417018 =417018 return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"字符的输入与输出","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"字符的输入与输出 \\b 退格 \\f 走纸换页 \\r 回车 \\t 横向跳格(ctrl-i) ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"格式化字符 %c 字符 %d 十进制整数 %s 字符串 %S or %ws 宽字符串 %x 十六进制整数 %p 指针或地址 %o 八进制整数 %f 小数(浮点数) %u 无符号十进制整数 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"scanf输入 scanf(\"%s\",\u0026str1); ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"C++知识点","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"C++知识点（一） ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:0:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"L\"“替换成_T(”\") 使用正则表达式 查找 L(\\\".+?\\\") 替换成 _T($1) ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:1:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"阻断函数 getchar() //等待键盘输入回车 sysem(\"pause\")//任意键继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:2:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"常用函数 #pragma once //防止头文件被重复编译 #pragma warning(disable:4996)//忽略C4996错误 printf(\"Hello World!\") //输出函数 atoi(arg) //字符串转整数 Sleep(arg) //等待 MessageBeep(1); //播放系统音乐,方便OD定位 __declspec(naked) //裸体函数 void *memcpy(void *str1, const void *str2, size_t n) //内存copy(读取与写入) //str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 //str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 //n -- 要被复制的字节数。 //返回值 -- 该函数返回一个指向目标存储区 str1 的指针。 void *memset(void *s, int ch, size_t n); //内存设置 //将s中当前位置后面的n个字节,用 ch 替换并返回 s 。 size_t strlen(const char *string); //计算给定字符串的长度 (ANSI) size_t wcslen(const wchar_t * str); //strlen函式的宽字节版 (Unicode) BOOL CloseHandle( HANDLE hObject //对象句柄 );//关闭对象句柄。 setlocale(LC_ALL, \"chs\"); //需要实现本地化，以实现中文正常输出 GetLastError(); //最后一次的出错代码 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:3:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"用汇编来调用CALL int pcall =(int)MessageBoxC; __asm { push 0 //4 push 0 //3 push 0 //2 push 0 //1 call dword ptr ds:[MessageBoxA] //第一种 mov eax,MessageBoxB call eax //第二种 call pcall //第三种 ;分号 注释语句 } ds 为数据段寄存器 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:4:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"循环 break; //退出循环 continue; //跳到循环首部,循环继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"其它 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_In_ 表示是一个输入参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_Out_ 表示是一个输出参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026arg 引用 1.必须传变量 2.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:3","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026变量 取变量地址运算符 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:4","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"*arg 指针 1.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:5","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"冒号: 冒号代表标签,常用于goto跳转 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:6","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"typedef 关键字，作用是为一种数据类型定义一个新名字 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:7","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"三元运算子 条件式 ? 条件式为true时执行的陈述句 : 条件式为false时执行的陈述句 int ret, a = 10, b = 11; bool flag = true; if (flag) ret = a; else ret = b; 等价于 ret = flag ? a : b; ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:8","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"const 声明变量是不变的 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:9","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"define 定义宏,可用于起别名,也可带参数,如 #define hanshu(a,b) (a+b) ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:10","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"指针 LPSTR char* LPCSTR const char* LPCTSTR const TCHAR* LPTSTR TCHAR* LP = 指针 C = const 只读 TSTR = TCHAR ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:11","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"HINSTANCE “句柄型”数据类型。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:12","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"static 关键字 定义静态变量或静态函数,生存周期和全局变量一样,作用域和局部变量一样,初始化仅执行一次. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:13","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"char* 定义字符串 char p[256]=\"hijk\"; //可读写 char src2[]=\"opq\"; //可读写 char *p=\"abcd\"; //只读 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcpy 字符串复制(wcscpy宽字节版) char *strcpy(char* dest, const char *src); 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 strcpy_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcat 字符串连接(wcscat宽字节版) extern char *strcat(char *dest, const char *src); strcat_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:3","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strstr 查找字符串(wcsstr宽字节版) string strstr( string1，string2) ​ strstr返回一个指针，指向string2在string1中首次出现的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:4","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strchr 查找字符(wcschr宽字节版) char *strchr(const char *str, int c) 在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:5","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcmp 字符串比较(wcscmp宽字节版) extern int strcmp(const char *s1,const char *s2); 当s1\u003cs2时，返回为负数； 当s1=s2时，返回值= 0； 当s1\u003es2时，返回正数. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:6","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"c_str() string转const char* ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:8:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"以下仅了解 strrev strncmp strncmpi strerror strncpy strnicmp ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:8:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"Unicode字符串(wchar)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:9:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"wchar_t 宽字符 wchar_t c1='A'; //单个字符不用加\"L\" wchar_t wStr[]=L\"这是一段中文\"; //字符串前要加\"L\" wchar_t appName[5]=TEXT(\"test\"); //可以用TEXT()方法将char转换成wchar_t char是8位字符类型,wchar_t数据类型一般为16位或32位,wchar_t所能表示的字符数远超char型。 如果你想使用ANSI字符串，那么请使用这一套写法： char szString[100]; strcpy(szString,\"test\"); 如果你想使用Unicode字符串，那么请使用这一套： wchar_t szString[100]; wcscpyszString,L\"test\"); 如果你想通过定义_UNICODE宏，而编译ANSI或者Unicode字符串代码： TCHAR szString[100]; _tcscpy(szString,_TEXT(\"test\")); ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:9:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"相关函数见 多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:9:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"TCHAR兼容型字符串及常用函数 TCHAR ANSI Unicode TCHAR char wchar_t _tcscpy() strcpy() wcscpy() _tmain() main() wmain() _tWinMain() WinMain() wWinMain() _T\"str\" “str” L\"str\" _tprintf() printf() wprintf() _tcslen() strlen() wcslen() ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["GitHub"],"content":"GitHub回退历史版本","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"GitHub回退历史版本 前提是本地已经有了git的origin master库或者克隆需要回退的代码到本地。 ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:0","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"1. 查询历史对应不同版本的ID ，用于回退使用 git log --pretty=oneline 假设查到历史版本的id是 ： 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:1","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"2. 恢复到历史版本 git reset --hard 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:2","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"3. 把修改推到远程服务器 git push -f -u origin master ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:3","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"4. 重新更新 git pull ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:4","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"Git与GitHub绑定","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/","series":null,"tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["GitHub"],"content":"Git与GitHub绑定 终端输入ssh-keygen -t rsa命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 密钥和公钥生成后，把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！ 在 Git Bash 中输入ssh -T git@github.com进行测试： ","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/:0:0","series":null,"tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["博客"],"content":"Hugo常用命令","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":null,"tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"Hugo常用命令 新建章节 hugo new –kind chapter /_index.md 新建文件 hugo new //_index.md hugo new /.md hugo new posts/.md 解除环境限制 hugo serve -e production 生成指定模板的样例文章 hugo new –kind post-bundle posts/my-post 实时预览 hugo serve –disableFastRender ","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"安装hugo博客","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装hugo博客 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Generate new site 要產生一個新的 web site 內容，可直接執行 hugo new site ssg-site 執行後會建立一個名為 ssg-site 的資料夾，包含以下內容 . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾（可先暫時不管）。 config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。(也支援 yaml 與 json 格式) content: 放置 Markdown 文章與網頁內容的資料夾。 data: 儲存一些 configuration 檔案的地ㄌㄌ方，協助建構靜態網頁(也先不管)。 layouts: 儲存產生的網頁 layout 樣板(之後範例使用其他的 theme，先不管)。 static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。 themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:1","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Import Hugo themes Hugo 並沒有預設的 theme，所以在建立好內容資料夾後，需自行建立 theme 或使用其他 theme，在這我們已 Mainroad theme 做範例。 # 將 mainroid theme 加入 themes/ 中 cd /Users/xinqinew/ssg-site git clone https://github.com/Vimux/Mainroad.git themes/mainroad 除了使用 git 指令外，直接從 Github 上下載最新原始檔案壓縮檔，解壓縮後放到 themes 資料夾中。此外對 git 熟悉的是使用者也可用 git submodule 或 git subtree 等方式管理外部引入的 theme repo。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:2","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Configuration Hugo 在生成 SSG 時會使用到 config.toml 檔案的設定內容。我們可以將之前 Mainroad theme 中的 config.toml 修改後加以使用 # 將 mainroid 的 config.toml 覆蓋原先的預設值 cp themes/mainroad/exampleSite/config.toml . 之後編輯 config.toml 內容，將其修改為自己想要的內容。更詳細的 configuration 設定可參考 Hugo 官方文件 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:3","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新增 Blog 文章 我們可以手動新增 Markdown 文件 hugo new post/hello-world.md 之後會在 ./content/post/hello-world.md 的位置新增一個 Markdown 文件，其中預設內容會根據 archetype/default.md 這個樣板檔案內容加以建立。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:4","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"預覽內容 先將 ./content/post/hello-world.md 內容修改為 --- title: \"Hello World\" date: 2018-07-06T16:00:21+08:00 categories: - \"Blog\" tags: - \"Hugo\" draft: true --- # Hello World. Post example 之後執行以下指令 hugo server --buildDrafts 若在 Markdown 的 Front Matter，加入 draft: true，代表該篇文章為草稿不會被 Hugo 轉換為網頁。因此可在指令後加入 --buildDrafts 來轉換草稿文件。 執行成功後會在 localhost:1313 建立一個暫時的網頁，可接載在瀏覽器網址列輸入預覽結果。 Hugo Mainroad theme 結果預覽 1313 為 Hugo 的預設 Port，可以使用 --port xxx 來指定使用其他 Port ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:5","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成靜態內容 Hugo 要生成靜態網頁內容只執行 hugo 指令即可 hugo 執行後生成的網頁內容會自動加入 public 資料夾中。 public 為預設資料夾，若要修改可在 config 檔案中設定 publishDir 參數指定輸出位置。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:6","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"從 Jekyll 轉移到 Hugo 如果要從其他的 SSG 轉換到 Hugo，官方也提供了一些轉換方式。以從 Jekyll 轉換到 Hugo 為例，只要執行 hugo import jekyll [jekyll_root_path] [target_path] 就會將 Jekyll 轉換為 Hugo 格式資料夾。但這方式也不是沒問題，原先在的 Jekyll 的 theme 無法直接在 Hugo 使用，且有部分 Front Matter 無法正確轉換，因此建議還是手動轉移較好。而因爲個人轉移時選用的 theme 為 Mainroad，在過程中也遇到了一些問題，在此提出來以供參考。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Markdown Front Matter 由於 Hugo 與 Jekyll 所使用的 Front Matter 設定不同，有些部分需要每個檔案逐一修改內容，如 categories 或 tags 的內容，之前使用的 voyager theme 在執行時會成格式不對，需修改將其改為 List 結構，如在 Jekyll 中， categories: posts 是可行的，但換到 Hugo 的 Mainroad theme 時，需使用 List 結構才行，如 categories: [\"posts\"] 才可正常產生靜態網頁，否則會出現錯誤。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Math equation support 在加入數學式的支援花了一些時間去解決，主要分為兩個問題 - Markdown 轉換成 HTML 以及 Mainroad theme 的 CSS conflict 問題。 Markdown parser support 在加入數學式時，我們習慣直接使用 Latex 語法在 Markdown 中，這樣可以更容易寫出方便的數學式。而 Hugo 預設的 Markdown parser Blackfriday(使用 Go 語言實作的 Markdown parser) 會進行某些預先處理，造成 MathJax 無法正確顯示內容以及斷行的問題。因此需要將原先的 Blackfriday parser 更換成 Mmark，即在 Markdown 文件中使用 Latex 數學式語法。方法為將檔案副檔名命名為 *.mmark，或是在 Markdown Front Matter 中加入 markup: \"mmark\" 來指定使用 Mmark 處理 Markdown 文件。更詳細的內容可參考官網說明。 Katex support 雖然 Mainroad theme 雖然有支援 MathJax，但該 theme 的 CSS style 中有部分和 Katex 的 CSS 設定衝突，造成當把 Mainroad 中的 MathJax 部分的樣板原始碼換成支援 Katex 後，在顯示 Matrix 時會造成跑版。詳情狀況可參考個人發在 GitHub 上的 Issue #1445。在 Katex 小組了解問題並經過 Mainroad 作者修改樣板後即解決了該問題。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Syntax highlighting 要在 Hugo 中讓程式碼有高亮效果，可在 config 檔案中加入以下設定 # use Chroma for syntax highlight pygmentsCodeFences = true # 啟動 Code Fence 區域的高亮效果 pygmentsCodefencesGuessSyntax = true # 對沒有指定程式類型的 Code Fence 自行推導語言類型 pygmentsStyle = \"fruity\" # 指定使用的高亮風格，如 vim 或 fruity 等(預設為 \"monokai\") 若想換成其他風格可參考這裡的格式，將 pgmentsStyle 的設定修改為該風格 Hugo 就會用該風格顯示 Markdown 中 Code Fence 區段的內容。其他設定可參考 Hugo 官網關於 Syntax Hightlighting 的章節。 pygment 為原先 Hugo 所使用的 Syntax Hightlighting 工具， 在 Hugo 0.28 版後改為 Chroma 為預設內容，但設定檔仍維持原先的格式。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"首頁大綱內容 Mainroad 的 Markdown 文件顯示在列表中的大綱內容，會是最前面段落開始一直延續到預設長度為止，這在排版上會很難看，因此可以手動在 Markdown 文件中加入 ` ` 標籤隔開大綱與主題內容，如下範例 ...{大綱內容}... \u003c!--more--\u003e ...{文章內容}... 這樣在首頁的列表中就只會顯示大綱內容的部分。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:4","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Disqus Support Hugo 本身所產生的內容為靜態網頁，若要有像留言板之類的動態內容就必須藉助外部服務。Hugo 本身支援 Disqus 這個知名的 Blog 留言服務樣板，只要建立帳號取得 shortname，在 config 檔案中設定完成即可。若使用的 theme 有支援應該能正確顯示 disqusShortname = \"yourdiscussshortname\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:5","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Google Analysis support 和 Disqus 相同，Hugo 也有內部支援 Google Analysis 來統計你網站的流量與人潮。只要去 Google Analysis 申請一組 Tracking Id 並在 config 中加入設定。如 使用的 theme 有支援該功能則會自動設定 googleAnalytics = \"yourtrackingid\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:6","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Reference Hugo Mainroad theme Disqus Katex 从Jekyll迁移到Hugo，Hugo不完全指南 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"\u003c\u003e尖括号","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/","series":null,"tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"\u003c \u003e尖括号 我习惯将尖括号用于指定类型，作为参数: vector\u003cint\u003e vecOfInts ; 但是在rapidjson中，有这样的代码: document.Parse\u003c0\u003e(json) ; document.Parse方法的签名是: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 我不知道您可以在尖括号内传递值-认为尖括号仅用于类型名称。 这里的代码在做什么，为什么他在尖括号中传递一个值？ 这是一个好主意吗？什么时候？ 最佳答案 这里有两个不同的因素。 首先，可以定义除类型以外的参数化模板。例如，这是一个简单的数组类型: template \u003ctypename T, size_t N\u003e struct Array { T arr[N]; }; 我们可以这样使用 Array\u003cint, 137\u003e myArray; 我们知道vector\u003cint\u003e和vector\u003cdouble\u003e是不同的类型。但是现在我们还必须指出，Array\u003cint,137\u003e和Array\u003cint,136\u003e是不同的类型。 其次，使用模板时，编译器必须能够为所有模板参数找出一个值。使用模板类时，这就是为什么通常指定所有模板参数的原因。例如，您不说vector x，而是说类似vector\u003cdouble\u003e x。使用模板函数时，大多数时候编译器可以找出参数。例如，要使用std::sort，您只需说出类似 std::sort(v.begin(), v.end()); 但是，您也可以写 std::sort\u003cvector\u003cint\u003e::iterator\u003e(v.begin(), v.end()); 更明确地说。但是有时候，您有一个模板函数，对于该函数，并非所有参数都可以被找出来。在您的示例中，我们有: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 注意，不能仅从函数的参数推导parseFlags模板参数。因此，要调用该函数，必须指定template参数，否则编译器将无法确定该参数。这就是为什么你会写类似 Parse\u003c0\u003e(myString); 此处，0是模板参数(在编译时解析)，而myString是实际参数(在运行时解析)。 实际上，您可以使用结合了一些类型推断和一些显式类型参数的方法。例如，在Boost中，有一个函数lexical_cast可以在字符串类型之间进行转换。从非字符串类型转换为字符串类型的函数签名是 template \u003ctypename Target, typename Source\u003e Target lexical_cast(const Source\u0026 arg); 在这里，如果您调用lexical_cast，则编译器可以确定Source是什么，但如果没有一些提示，就无法推断出Target。因此，要使用lexical_cast，您需要编写类似 std::string myString = boost::lexical_cast\u003cstd::string\u003e(toConvertToString); 更一般而言，编译器说您必须指定一定数量的模板参数(可选为0)，它将尝试推断其余的参数。如果可以的话，太好了!如果不是，则为编译时错误。如果需要，可以使用此代码编写类似的函数 template \u003cint IntArgument, typename TypeArgment\u003e void DoSomething(const TypeArgument\u0026 t) { /* ... */ } 要调用此函数，您必须像这样调用它: DoSomething\u003cintArg\u003e(otherArg); 在这里，这是可行的，因为您必须显式告诉编译器IntArgument是什么，但是编译器可以从TypeArgument的参数类型推导DoSomething。 ","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/:0:0","series":null,"tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/","series":null,"tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例 雙端隊列或雙頭隊列是序列容器，兩端都有擴展和收縮功能。它們類似於向量，但是在元素的結尾和開始處插入和刪除時效率更高。與向量不同，可能無法保證連續的存儲分配。 deque::clear() clear()函數用於刪除雙端隊列容器的所有元素，從而使其大小為0。 用法: dequename.clear() Parameters : No parameters are passed. Result : All the elements of the deque are removed ( or destroyed ) 例子： Input :mydeque = {1, 2, 3, 4, 5} mydeque.clear(); Output:mydeque = {} Input :mydeque = {} mydeque.clear(); Output:mydeque = {} 錯誤和異常 1.它沒有異常拋出保證。 2.傳遞參數時顯示錯誤。 // CPP program to illustrate // Implementation of clear() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; mydeque.clear(); // Deque becomes empty // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： No Output deque::erase() erase()函數用於從指定位置或範圍中刪除容器中的元素。 用法: 1. _**dequename.erase(position)**_ 2. _**dequename.erase(startingposition, endingposition)**_ **Parameters :** Position of the element to be removed in the form of iterator. or the range specified using start and end iterator. **Result :** Elements are removed from the specified position of the container. 例子： Input : mydeque{1, 2, 3, 4, 5}, iterator= 2 mydeque.erase(iterator); Output : 1, 2, 4, 5 Input : mydeque{1, 2, 3, 4, 5, 6, 7, 8}, iterator1= 3, iterator2= 6 mydeque.erase(iterator1, iterator2); Output : 1, 2, 3, 8 錯誤和異常 1.如果位置有效，則沒有異常拋出保證。 2.否則顯示未定義的行為。 從特定位置移除元件 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it; it = mydeque.begin(); mydeque.erase(it); // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 2 3 4 5 刪除範圍內的元素 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it1, it2; it1 = mydeque.begin(); it2 = mydeque.end(); it2--; it2--; mydeque.erase(it1, it2); // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 4 5 應用 給定一個整數列表，從雙端隊列中刪除所有偶數元素並打印雙端隊列。 Input :1, 2, 3, 4, 5, 6, 7, 8, 9 Output :1 3 5 7 9 _Explanation - 2, 4, 6 and 8 which are even are erased from the deque_ 算法 1.循環運行，直到雙端隊列大小為止。 2.檢查每個位置的元素是否可被2整除，如果是，則刪除該元素並遞減迭代器。 3.打印最終雙端隊列。 // CPP program to illustrate // Application of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }; deque\u003cint\u003e::iterator i; i = mydeque.begin(); while (i != mydeque.end()) { if (*i % 2 == 0) /* Not a good idea to erase inside loop, if you delete last element, mydeque.end() cannot be found resulting in infinite loop */ mydeque.erase(i); i++; } // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 1 3 5 7 9 clear() VS erase()。什麽時候使用什麽？ **clear()**從雙端隊列容器中刪除所有元素，從而使其大小為0。使用clear()函數刪除雙端隊列中的所有元素。 **erase()**另一方麵，“函數”用於從容器中刪除特定元素或從容器中刪除一係列元素，從而通過刪除元素的數量來減小其大小。 ","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/:0:0","series":null,"tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque insert()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_insert/","series":null,"tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque insert()用法及示例 deque::insert(函数是C++中的内置函数，用于在双端队列中插入元素。 insert()函数可以通过三种方式使用： 通过在一个位置插入新元素val来扩展双端队列。 通过在双端队列中插入n个新值val来扩展双端队列。 通过在(first，last)范围内插入新元素来扩展双端队列。 用法: deque_name.insert (iterator position, const value_type\u0026 val); deque_name.insert (iterator position, size_type n, const value_type\u0026 val); deque_name.insert (iterator position, InputIterator first, InputIterator last); 参数 position–指定要插入元素的位置。 val–指定要分配给新插入元素的值。 n–指定要插入的元素数。每个元素都初始化为val的副本。 first, last–指定迭代器，该迭代器指定要插入的元素范围。范围包括first和last之间的所有元素，包括first指向的元素，但last指向的元素。 返回值 该函数返回一个迭代器，该迭代器指向新插入的元素中的第一个。 示例1: // CPP program to illustrate the // deque::insert() function // insert elements by iterator #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; it = dq.insert(it, 10); // 1 10 2 3 4 5 std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 2 3 4 5 示例2: // CPP program to illustrate the // deque::insert() function // program for second syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); // 0 0 1 2 3 4 5 dq.insert(it, 2, 0); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 0 0 1 2 3 4 5 示例3: // CPP program to illustrate the // deque::insert() function // program for third syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; vector\u003cint\u003e v(2, 10); // 1 10 10 2 3 4 5 dq.insert(it, v.begin(), v.end()); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 10 2 3 4 5 ","date":"2021-07-24","objectID":"/2021/07/deque_insert/:0:0","series":null,"tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque 用法与示例","date":"2021-07-24","objectID":"/2021/07/deque/","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 用法与示例 本篇將介紹如何使用 C++ std deque 以及用法與範例，C++ std::deque 是一個雙向佇列(double-ended queue)，在頭尾兩端插入及刪除十分快速，在中間插入刪除元素比較費時。 std::deque 是 double-ended queue 而不是 double linked list，底層實做是用間接索引的方式實現的，類似一個 map 索引到若干個固定大小的資料區塊(連續記憶體空間)，利用兩次索引達成跟 vector 一樣的隨機訪問功能。 以下將依序介紹幾個 std::deque 容器常用的用法範例，分別為 deque 常用功能 範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 範例2. push_back 自定義類別 範例3. 用 for 迴圈遍歷 deque 容器 範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 deque 的優點與缺點 要使用 deque 容器的話，需要引入的標頭檔: \u003cdeque\u003e ","date":"2021-07-24","objectID":"/2021/07/deque/:0:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 常用功能 以下為 std::deque 內常用的成員函式 修改器 push_back: 把一個元素添加到尾端 push_front: 把一個元素插入到頭端 pop_back: 移除最後一個元素(尾端) pop_front: 移除第一個元素(頭端) insert: 插入元素 erase: 移除某個位置元素, 也可以移除某一段範圍的元素 clear: 清空容器裡所有元素 容量 empty: 回傳是否為空 size: 回傳目前長度 元素存取 [i]: 隨機存取索引值為i的元素 back: 取得最後一個元素 front: 取得第一個的元素 迭代器 begin:回傳指向第一個元素(頭端)的迭代器 cbegin:回傳指向第一個元素(頭端)的迭代器(const) end:回傳指向最後一個元素(尾端)的迭代器 cend:回傳指向最後一個元素(尾端)的迭代器(const) rbegin:回傳指向最後一個元素(尾端)的反向迭代器 crbegin:回傳指向最後一個元素(尾端)的反向迭代器(const) rend:回傳指向第一個元素(頭端)的反向迭代器 crend:回傳指向第一個元素(頭端)的反向迭代器(const) ","date":"2021-07-24","objectID":"/2021/07/deque/:1:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 以下範例為push_back(), pop_front(), push_front(), pop_back() 用法， 其中 push_back() 與 pop_front() 應該是最常用到的函式了。 另外使用 deque 相對於 queue 的好處是deque可以使用隨機訪問的功能 [i]。 std-deque.cpp // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } 輸出內容如下： 0 2 3 4 0 2 3 ","date":"2021-07-24","objectID":"/2021/07/deque/:2:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例2. push_back 自定義類別 以下範例為 std::deque 容器使用 push_back() 來推放 Student 自定義類別的範例，使用 push_back() 來放進 deque 的最尾端，這個範例限制 deque 最多塞3個，多的會用 pop_front() 給 pop 掉，最後再將 deque 容器的所有的元素印出來。 // g++ std-deque2.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; class Student { public: Student(int id) { this-\u003eid = id; } int id; }; std::deque\u003cStudent\u003e d; void deque_push_back(Student a) { d.push_back(a); if (d.size() \u003e 3) { d.pop_front(); } } int main() { Student a1(1), a2(2), a3(3), a4(4); deque_push_back(a1); deque_push_back(a2); deque_push_back(a3); deque_push_back(a4); // 印出 deque 內所有內容, c++11 才支援 for (auto \u0026i : d) { cout \u003c\u003c i.id \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/deque/:3:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例3. 用 for 迴圈遍歷 deque 容器 以下範例是用 for 迴圈配合 deque 容器的迭代器，去遍歷 deque 並且把值印出來，前兩種是從頭印到尾，後兩種是從尾印到頭。從頭端印到最尾端就是使用 begin() 搭配 end() ，從最尾端印到頭端就是使用 rbegin() 搭配 rend() 。 這裡的 begin() / end() 與 cbegin() / cend() 有什麼不同呢？begin() / end() 是回傳 iterator，而 cbegin() / cend() 是回傳 const_iterator，iterator 可以修改元素值，const_iterator 則不可修改，簡單說就是回傳的東西能不能被修改的差異，要用哪種就自行判斷要用哪種了。 cbegin(), cend(), crbegin(), crend() 是 C++11 新增的，要使用時記得編譯器要加入-std=c++11選項。 第一個 for 迴圈裡面的迭代器使用懶人快速寫法auto it = d.begin();，其全名為std::deque\u003cint\u003e::iterator it = d.begin();，如果不想寫這麼長的話，就可以像我一樣用 auto 的懶人快速寫法。 // g++ std-deque3.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 //for (std::deque\u003cint\u003e::iterator it = d.begin(); it != d.end(); ++it) { for (auto it = d.begin(); it != d.end(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從頭到尾 for (auto it = d.cbegin(); it != d.cend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.rbegin(); it != d.rend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.crbegin(); it != d.crend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } 輸出 1 2 3 4 1 2 3 4 4 3 2 1 4 3 2 1 ","date":"2021-07-24","objectID":"/2021/07/deque/:4:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 以下範例是用 while 迴圈在 deque 容器裡搜尋/尋找數字為3，這裡的 auto 懶人快速寫法如上範例解釋相同就不贅述了。 在 while 迴圈裡如果有找到就印個有找到的訊息，假如整個 while 迴圈都沒找到，最後可以判斷 it == d.end() 代表整個 deque 容器都遍歷過了也沒有找到，就印個沒找到的訊息。 // g++ std-deque4.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 int find_num = 3; //std::deque\u003cint\u003e::iterator it = d.begin(); auto it = d.begin(); while (it != d.end()) { if (*it == find_num) { cout \u003c\u003c \"Found \" \u003c\u003c find_num \u003c\u003c endl; break; } it++; } if (it == d.end()) { cout \u003c\u003c \"Not found \" \u003c\u003c find_num \u003c\u003c endl; } return 0; } 輸出 Found 3 如果將 find_num 變數改成 5 去搜尋/尋找的話則會找不到，輸出結果會變成 Not found 5 ","date":"2021-07-24","objectID":"/2021/07/deque/:5:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 的優點與缺點 deque 的優點 可以再兩端進行 push 和 pop 操作 支持隨機訪問[i] deque 的缺點 佔用記憶體較多 ","date":"2021-07-24","objectID":"/2021/07/deque/:6:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque和queue容器","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque和queue容器 标准模板库 STL 提供了两种容器：deque 和 queue，以实现和队列类似的数据 结构。deque 是一个双端队列。它类似于矢量，但允许在前端和后端高效地访问值。队列抽象数据类型就像栈抽象数据类型：它实际上是一个容器适配器。 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:0:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque容器 可以将 deque 容器想象成一个矢量，但它可以快速访问前端以及后端的元素（和矢量一样，deque 也可以使用 [] 运算符访问元素）。 图 1 deque 成员函数 使用双端队列 ADT 的程序必须包含 deque 头文件。由于本节更关心它与队列类似的特性，所以就来集中讨论一下 push_back、pop_front 和 front 成员函数，如图 1 所示。它们的示例和相应描述如表 2 所示。 成员函数 示例和描述 push_back iDeque.push back(7); 接受一个值作为参数插入到 deque 中。 参数被插入在最后一个元素之后（被推到 deque 后面） pop_front iDeque.pop front(); 删除 deque 的第一个元素并丢弃它 pop_front cout « iDeque.front() « endl; front 返回对 deque 第一个元素的引用 下面的程序演示了双端队列容器的使用： // This program demonstrates the STL deque container. #include \u003ciostream\u003e #include \u003cdeque\u003e u[sin](http://c.biancheng.net/ref/sin.html)g namespace std; int main() { deque\u003cint\u003e iDeque; cout \u003c\u003c \"I will now enqueue items. . . \\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iDeque.push_back(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while (!iDeque.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iDeque.front() \u003c\u003c endl; iDeque.pop_front(); } return 0; } 程序输出结果： I will now enqueue items. . . Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:1:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"queue容器适配器 queue 容器适配器可以建立在矢量、链表或者双端队列的基础上。默认情况下，它使用一个双端队列作为其基础。 queue 支持的插入和删除操作与栈 ADT 所支持的类似：push、pop 和 front。但是，它们的表现有所不同。queue 版本的 push 始终在队列的后面插入一个元素。queue 版本的 pop 始终从结构的前面删除一个元素。front 函数返回队列前面的元素的值。 下面的程序演示了一个队列。由于该队列的声明没有指定适配哪一种类型的容器，所以该队列将建立在一个双端队列上。 //This program demonstrates the STL queue container adapter. #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; int main() { queue\u003cint\u003e iQueue; cout \u003c\u003c \"I will now enqueue items...\\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iQueue.push(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while(!iQueue.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iQueue.front () \u003c\u003c endl; iQueue.pop (); } return 0; } 程序输出结果： I will now enqueue items… Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:2:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"ifndef详解","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef详解 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef是\"if not defined\"的简写 #ifndef起到的效果是防止一个源文件多次包含同一个头文件, 而不是防止两个源文件包含同一个头文件。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:0","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"一、防止头文件的重复包含和编译 #ifndef \u003c标识\u003e #define \u003c标识\u003e ...... ...... #endif 标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的\".“也变成下划线，如：stdio.h #ifndef _STDIO_H #define _STDIO_H ...... ...... #endif ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:1","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"二、便于程序的调试和移植 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #ifndef 标识符 #define 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #if 表达式 程序段 1 #else 程序段 2 #endif 它的作用是当“表达式”值为真时，编译“程序段1”，否则编译“程序段2”。 注：以上三种形式中#else不是强制的，可省略；当然，当#else后需要嵌套#if时，可以使用预处理命令#elif，它相当于#else#if。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:2","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"queue 和 deque的区别","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/","series":null,"tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue 和 deque的区别 从使用的角度来讲主要差别就是： deque支持push_front、pop_front、push_back、pop_back。 queue支持push_back、pop_front。 deque是双端队列 #include\u003cdeque\u003e template\u003ctypename T,typename Allocator=std::allocator\u003cT\u003e\u003eclass deque; 支持push_front、pop_front、push_back、pop_back等几种操作的。queue是容器适配器，他的声明是 #include\u003cqueue\u003e template\u003ctypename T,typename Container=std::deque\u003cT\u003e\u003eclass queue; 类型Container是用来存储元素的，相当于是这个queue的实现。这个queue模板看起来像是包装了这个Container类型，只提供一些特殊的接口，使他看起来想一个queue。 模板参数Container需要满足顺序容器的条件，而且必须支持front、back、push_back、pop_front操作，标准容器中有deque和list满足。也就是说标准容器中deque和list可以封装成queue。 ","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/:0:0","series":null,"tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue与deque示例","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"queue与deque示例 queue ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:0:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例1：queue #include \"stdafx.h\" #include \u003ciostream\u003e #include \u003cqueue\u003e using namespace std; int _tmain(int argc, _TCHAR* argv[]) { queue\u003cint\u003e myQueue; cout \u003c\u003c myQueue.empty() \u003c\u003c endl; cout \u003c\u003c myQueue.size()\u003c\u003c endl; myQueue.push(1); myQueue.push(2); myQueue.push(3); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; myQueue.pop(); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; return 0; } 运行结果： 1 0 1 3 2 3 queue没找到迭代器 deque: deque是双向队列Double ended queue；can be accessed with random access iterator deque是双端队列，是可以在两端扩展和收缩的连续容器。一般deque的实现是基于某种形式的动态数组，允许单个元素用随机获取 迭代器随机读取，数组容量自动管理。 因此它有和vector相似的函数，但在序列的开始也有高效的插入和删除。但不像vector，deque的元素并不是严格连续存储的。 vector和deque有相似的接口和相似的目的，但内部实现截然不同。 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:1:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例二：deque #include \"stdafx.h\" #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int _tmain(int argc, _TCHAR* argv[]) { deque\u003cint\u003e myDeque; myDeque.push_front(1); myDeque.push_front(2); myDeque.push_back(3); myDeque.push_back(4); myDeque.push_back(5); myDeque.push_front(6); myDeque.pop_back(); deque\u003cint\u003e::iterator myItor; for(myItor=myDeque.begin(); myItor!=myDeque.end(); myItor++) cout\u003c\u003c*myItor\u003c\u003cendl; return 0; } 执行结果： 6 2 1 3 4 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:2:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例3:deque 随机访问 // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:3:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"typedef起小名","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/","series":null,"tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"typedef起小名 C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 实例 #include \u003cstdio.h\u003e #include \u003cstring.h\u003e typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book; int main( ) { Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 typedef vs #define #define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： 实例 #include \u003cstdio.h\u003e #define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： TRUE 的值: 1 FALSE 的值: 0 ","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/:0:0","series":null,"tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"笔记queue与deque","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/","series":null,"tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["C++"],"content":"笔记queue与deque queue操作： queue\u003cint\u003eq; //创建一个int型空队列q q.empty(); //判断队列是否为空，为空返回true q.push(s); //将变量s从队尾入队 q.pop(); //将队头元素弹出 q.front(); //只返回队头元素 q.back(); //只返回队尾元素 q.size(); //返回队列中元素个数 queue两端访问,队尾插入,队首删除。 deque操作： deque\u003cint\u003e dq; //创建一个数双端队列dq dq.empty(); //判断队列是否为空，为空返回true dq.push_front(s);//将s从队头入队 dq.push_back(s);//将s从队尾入队，和普通队列方式一样 dq.front(); //只返回队头元素 dq.back(); //只返回队尾元素 dq.pop_front(); //将队头元素弹出 dq.pop_back(); //将队尾元素弹出 dq.size(); //返回队列中元素个数 dq.clear(); //将队列清空 dq.insert();//插入新元素,最多有四个参数 //迭代器 dq.begin(); //回傳指向第一個元素(頭端)的迭代器 dq.cbegin(); //回傳指向第一個元素(頭端)的迭代器(const) dq.end(); //回傳指向最後一個元素(尾端)的迭代器 dq.cend(); //回傳指向最後一個元素(尾端)的迭代器(const) dq.rbegin(); //回傳指向最後一個元素(尾端)的反向迭代器 dq.crbegin(); //回傳指向最後一個元素(尾端)的反向迭代器(const) dq.rend(); //回傳指向第一個元素(頭端)的反向迭代器 dq.crend(); //回傳指向第一個元素(頭端)的反向迭代器(const) deque两端访问,两端插入,两端删除。 auto it = d.begin();其全名為std::deque\u003cint\u003e::iterator it = d.begin(); ","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/:0:0","series":null,"tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["C++"],"content":"常用头文件","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/","series":null,"tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"常用头文件 stdafx.h MFC预编译(旧版) pch.h MFC预编译(新版) stdio.h 输入输出 process.h 进程 stdlib.h 声明了数值与字符串转换函数, 伪随机数 生成函数, 动态内存分配函数, 进程控制函数等公共函数 Windows.h windows系统函数(如:Sleep) string.h ANSI,多字节字符串 wchar.h Unicode,宽字符串 tchar.h 混合ANSI和Unicode字符串 pthread.h 多线程 \u003ccmath\u003e 数学 \u003cctime\u003e 时间 \u003cthread\u003e 标准的线程库 “iso646.h” and代替\u0026\u0026 等 iostream.h 用于控制台输入输出头文件 fstream.h 用于文件操作的头文件 complex.h 用于复数计算的头文件。 ","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/:0:0","series":null,"tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":null,"content":"今天在调试一个测温模块的时候遇到十六进制的高位和低位组合，板子通过串口发送指令给模块，并读取模块返回的温度值，但是模块返回的是一个十六进制的报文，实际温度值是分为两个十六进制数的，高位在前，低位在后，比如返回的是0x01,0x2e，实际的温度用十六进制表示就是0x012e，十进制就是302,实际温度值除以10就可以了。但是写代码的时候突然就迷糊了，刚开始想到的是两个数相与就可以了，但是用计算器折腾了一番，发现不行，经过一番冥思苦想终于搞定了，记录一下，以免下次又忘记。 ","date":"2021-07-24","objectID":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/:0:0","series":null,"tags":null,"title":"十六进制数高位和低位的结合与分离","uri":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/"},{"categories":null,"content":"分离高位和低位 先看一下怎么分离高位和低位，这个百度一下方法还是挺多的。以0x1234为例，取出它的高位与低位 #include\u003cstdio.h\u003e int main(int argc, char **argv) { int a = 0x1234; int b[2]; b[0] = (a \u0026 0xff00) \u003e\u003e 8;//取高位 b[1] = a \u0026 0xff;//取低位 printf(\"%02x %02x\\n\", b[0], b[1]); return 0; } ","date":"2021-07-24","objectID":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/:1:0","series":null,"tags":null,"title":"十六进制数高位和低位的结合与分离","uri":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/"},{"categories":null,"content":"高位和低位组合 #include\u003cstdio.h\u003e int main(int argc, char **argv) { int a = 0x12; int b = 0x34; int c; c = (a \u003c\u003c 8) | b;//先将高位左移，在与低位相与 printf(\"%x\\n\", c); return 0; } ","date":"2021-07-24","objectID":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/:2:0","series":null,"tags":null,"title":"十六进制数高位和低位的结合与分离","uri":"/2021/07/%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0%E9%AB%98%E4%BD%8D%E5%92%8C%E4%BD%8E%E4%BD%8D%E7%9A%84%E7%BB%93%E5%90%88%E4%B8%8E%E5%88%86%E7%A6%BB/"},{"categories":["WOW"],"content":"64位Call的参数","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"64位Call的参数 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:0:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call上层 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+20+8_0 参数5 rsp+20+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:1:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call内 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+28+8_0 参数5 rsp+28+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:2:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["C++"],"content":"cin和cout输入输出","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"TRACE 调试输出 TRACE(_T(\"大漠版本号:%s\\n\"),dm-\u003eVer()); ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"cin和cout输入输出 适用于控制台 简单的输入输出代码示例： #include\u003ciostream\u003e using namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number:\"\u003c\u003cendl; cin\u003e\u003ex; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"Please input a float number:\"\u003c\u003cendl; cin\u003e\u003ey; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果如下（↙表示按下回车键）： Please input an int number: 8↙ The int number is x= 8 Please input a float number: 7.4↙ The float number is y= 7.4 cin 连续输入示例 #include\u003ciostream\u003e using namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number and a float number:\"\u003c\u003cendl; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果： Please input an int number and a float number: 8 7.4↙ The int number is x= 8 The float number is y= 7.4 ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"信息提示框 MessageBox 与 AfxMessageBox ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"MessageBox 信息提示框 //原型 int MessageBox( HWND hWnd, //hWnd：父视窗(Parent Window)的Handle如果为NULL则设为非强制回应模式(Modeless) LPCTSTR lpszText, //lpszTex：表示在讯息框内显示的内容 LPCTSTR lpszCaption = NULL, //lpszCaption：讯息框标题(预设为空) UINT nType =MB_OK //nType：讯息框的风格 ); //实例 CString Stemp; Stemp.Format(_T(\"%d\"),a); MessageBox(Stemp); MessageBox(\"这是最简单的讯息框\"); MessageBox(\"这讯息框是自订标题\", \"这是标题\"); MessageBox(\"这讯息框有确定取消按钮\", \"这是标题\", MB_OKCANCEL ); MessageBox(\"这讯息框有警告图示\", \"这是标题\", MB_ICONEXCLAMATION ); MessageBox(\"这讯息框有确定取消按钮搭配警告图示\", \"这是标题\", MB_ICONEXCLAMATION | MB_OKCANCEL ); ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:1","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"AfxMessageBox 信息提示框 //双原型： int AfxMessageBox( LPCTSTR lpszText, //lpszText：表示在讯息框内显示的内容，讯息框的标题为应用程式名称。 UINT nType = MB_OK, //nType：为讯息框中显示的按钮和图示的组合，可以使用 | (或) 来组合各种风格。 UINT nIDHelp = 0 //nIDHelp：讯息的说明内容ID，0表示使用系统预设说明内容。 ); int AFXAPI AfxMessageBox( UINT nIDPrompt, //nIDPrompt：表示在讯息框内显示的字串表(String Table)资源ID，使用时会自动从字串表载入字串。 UINT nType = MB_OK, //同上 UINT nIDHelp = (UINT) –1 //同上 ); //实例 #define IDS_STR_TABLE \"这是使用字串表\"; CString str = \"这是直接使用字串\"; AfxMessageBox(IDS_STR_HELLO); AfxMessageBox(str); AfxMessageBox(\"这是加入按钮及图示的讯息框\", MB_YESNO | MB_ICONSTOP); ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:2","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"下列属性两者皆适用： 按钮风格(nType)： MB_ABORTRETRYIGNORE 讯息框中显示Abort、Retry、Ignore按钮 MB_ABORTRETRYIGNORE 讯息框中显示Abort、Retry、Ignore按钮 MB_OK 显示OK按钮 MB_OKCANCEL 显示OK、Cancel按钮 MB_RETRYCANCEL 显示Retry、Cancel按钮 MB_YESNO 显示Yes、No按钮 MB_YESNOCANCEL 示Yes、No、Cancel按钮 图示风格(nType)： MB_ICONINFORMATION 显示一个i图标，表示提示 MB_ICONEXCLAMATION 显示一个惊叹号，表示警告 MB_ICONSTOP 显示手形图标，表示警告或严重错误 MB_ICONQUESTION 显示问号图标，表示疑问 回传值(对应不同按钮点选)： IDABORT 按下放弃(Abort) IDCANCEL按下取消(Cancel) IDIGNORE 按下忽略(Ignore) IDNO 按下否(No) IDOK 按下确定(OK) IDRETRY 按下重试(Retry). IDYES按下是(Yes). ","date":"2021-07-23","objectID":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:3","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"class 类","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/","series":null,"tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["C++"],"content":"class 类 #include \u003cstdio.h\u003e //通过class关键字类定义类 class Student{ public: //类包含的变量 char *name; int age; float score; //类包含的函数 void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; int main(){ //通过类来定义变量，即创建对象 class Student stu1; //也可以省略关键字class //为类的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; //调用类的成员函数 stu1.say(); return 0; } 类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象” ","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/:0:0","series":null,"tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"如何使用 GitHub pages 首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。 进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。 创建成功之后，点击右上角的 Settings 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题 这里我们就随意选择一个主题 Cayman，来看看他的效果是什么样的 选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。 在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。 到这里如果你只是想做一个例如可以随时在互联网上访问的简历，那么你只需要 GitHub Pages 项目的主页修改你 index.md 文件就可以了，比如我给出的这个模板。 修改完后，点击上图中左下角的 Commit Changes，然后访问你的自定义域名你就可以看到如下的样式了。 如果你想做一个功能更丰富的博客，那我们继续往下走。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"配置自定义域名并免费使用 HTTPS 在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。 首先在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名 blog.moyu.life 通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 brick713.GitHub.io。添加完成后等待 DNS 解析的生效（DNS 的解析记录生效到全球可能需要几分钟时间）。 之后重新回到最开始进入过的 Settings 界面，找到 GitHub Pages 的设置，填写我们刚刚建立的子域名，以我自己的 blog.moyu.life 举例，点击保存。 保存后 GitHub 需要一定的时间生成证书并确认域名的解析是否正常，我们只需要耐心的等待即可，成功后显示结果如下 现在我们再访问 blog.moyu.life 就会发现，我们的自定义域名和 HTTPS 都生效了！可以看到证书是由著名的机构 Let’s Encrypt 提供的。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:1","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站的同步 现在我们已经有了一个基本功能健全的网站了，接下来我们需要试着对博客的内容进行管理，并且给博客添加一些更个性化的设置，官方提供两种方式： 命令行方式（Mac 和 Windows 确保拥有 Git 环境） 桌面客户端形式（需要安装官方提供的客户端） 如果你没有任何 Git 的基础，也不想进行一些繁琐的配置，那么我推荐你使用桌面客户端的形式进行管理，如果你有一定的技术基础，那么 Git 的方式则更适合你。这里我两种方法都介绍一下。 首先在命令行中切换到你自定义的路径下，然后 Clone 下来你的项目（操作需要在 Mac 的 Terminal 中完成，Windows 系统可以使用 Git-bash。）这里注意这里的 path 和 username 需要根据你个人情况进行替换。 cd ~/Path git clone https://GitHub.com/username/username.GitHub.io 接着进入你的项目的文件中，并创作一个文章。 cd username.GitHub.io echo \"Hello World 我爱这个世界\" \u003e index.md 然后按照 Git 提交内容的流程，将我们的新创作的文章上传。 git add --all git commit -m \"Firs Push\" git push -u origin master 这里可能会碰到下面的情况： 按照他的提示我们把注册 GitHub 的邮箱和用户名依次输入即可： git config user.email \"你的邮箱\" git config user.name \"你的用户名\" 之后他可能会让你输入你的 GitHub 账号和密码，不用担心，正常输入即可。当我们看到这样的提升就证明提交成功了。 可以去我们的网站主页看看是不是起了变化。 如果你是使用GitHub 桌面客户端 那么就更简单了，下载安装了客户端之后，按照客户端的提示正常登陆你的 GitHub 账号。然后 Clone 下来你的 GitHub Pages 项目。 等待 Clone 完成后，界面上会显示几种管理修改你的项目的方式。 这里我选择使用 Sublime Text 进行管理，把开始的 index.md 里的内容改为 Hello World 我也爱这个世界 保存，然后在客户端上我们能看到文件的变化，我们先点击左下角的 Commit to master，再点击 Fetch origin 就可以将内容上传。 然后你发现你的主页也发生了相应改变了。到这里你基本上就掌握了网站管理的基本流程和文章发布的基本流程，下面我们要开始来学会使用静态模板系统来管理博客了。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:2","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 的生成工具 经历了上面的步骤，现在你的已经有了一个简单的页面了，可是他还远远未满足我们的需求，我们需要利用静态模板系统来让生产接管你博客的文章的生成，让你把更多的经历投入在创作里。下面就 GitHub 官方推荐的 Jekyll 为例子来展开讲讲。 因为 Jekyll 是基于 Ruby 的静态网页生成系统，因此我们首先得安装 Ruby 环境，在 Mac 下我们可以使用的 Homebrew 来进行安装。如果是其他操作系统，可以去参考 Ruby 官方安装文档进行安装。 brew install ruby command not found: brew问题解决方案 安装brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 看到==\u003e Installation successful!就说明安装成功了。 最后更新下： brew update 等 Ruby 安装完毕后再执行以下命令完成 Jekyll 的安装。 sudo gem install jekyll bundler 然后进入你 Clone 下来的 GitHub Pages 项目的路径 cd /Volumes/video/GitHub/xinqinew.github.io 执行以下命令： jekyll new . --force 完成后，Jekyll 会在你指定的目录下生成好所有文件，你可以使用 bundle exec jekyll serve 命令，然后就可以通过访问 127.0.0.1:4000 查看初始界面的样子了。 默认的界面看起来非常的简陋也很丑，但是没关系，你可以在这些网站里根据自己的喜好找到一些美观的主题http://jekyllthemes.org/、https://jekyllthemes.io/、http://themes.jekyllrc.org/。 安装方法很简单，一般情况下只需要下载主题包解压后完整的，复制到你的 GitHub Pages 的项目目录里，并覆盖你之前的文件即可，有些特殊的主题要参考作者给的安装步骤，这里我随意的更换了一个主题。 主题里的所有关键性配置都在 _config.yml 文件中，你可以根据个人的喜好和不同主题支持的功能来修改具体的内容，这里就不做展开。 到这里完整的搭建的流程已经结束了，你已经可以正常访问你一路配置下来的博客了，接下来你只需要找一个趁手的 Markdown 编辑器来编辑在你本地 GitHub Pages 项目中的 _posts 文件夹里的文章，并使用前面提到的两种方式将文章同步到 GitHub 上即可。需要注意的是，文章的内容和标题需要按照 Jekyll 的格式进行写作。 文章的文件名遵循下面的格式： 年-月-日-标题.markdown 文章内容顶部必须有下面的 YAML 头信息： --- layout: post title: Blogging Like a Hacker --- ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:3","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"尾巴 其实除了 Jekyll 还有非常多的第三方的静态模板系统来搭建 GitHub Pages。比如： Node.js 编写的 Hexo Go 编写的 Hugo Python 编写的 Pelican 以及更人性化的 Gridea 他们在各自的基础上实现了更多的功能，比如分析统计、搜索、评论系统、广告、分享系统等。喜欢折腾的同学不妨可以尝试尝试，未来如果有机会希望能更详细的给大家分享一下。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["GitHub"],"content":"Github汉化及常用插件","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"Github汉化及常用插件 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:0:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"插件 Sourcegraph Sourcegraph 可以让你在线学习代码，可以查看变量、函数等的定义和引用情况。把指针放到想查看的变量名上，它会自动显示寻找定义和引用的提示框，点击即可。 Octotree 查看整个项目的结构 油猴 Refined GitHub ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"汉化 桌面版一键汉化 下载版 chrome版汉化 GitHub那些事儿 Hexo + GitHub Pages 搭建博客 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:2:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["Markdown"],"content":"Markdown语法","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"GitBook默认使用Markdown语法。 下面这些可以作为一个快速参考和展示。更多完整的信息，请参考 John Gruber’s original spec 和 Github-flavored Markdown info page。 标题 H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H2 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H3 H4 H5 H6 对于H1和H2，有下划线样式可供选择： Alt-H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:1","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Alt-H2 强调 强调，又叫做斜体，使用 星号 或 下划线。 重点强调，又叫做粗体，使用 星号 或 下划线。 使用 星号和_下划线_ 组合使用强调。 删除线使用两个波浪线。划掉这个 列表 在这个例子中，前导空格和尾部空格显示为圆点 : ⋅) 有序列表的第一项 另外一个项 ..* 无序子列表 事实上序号不起作用，那只是一个数字而已 ..1. 有序子列表 最后一个项 …你可以适当的缩紧列表项中的段落。注意上面的空行和前导空格（至少一个，但是这里我们使用三个来对齐原始的Markdown内容）。 …换行而不形成段落，你需要使用两个尾部空格。.. …注意这行是分开的，但还在同一个段落中。.. …（这个违背了不需要尾部空格的典型的GFM换行行为）。 无序列表可以使用星号 或者减号 或者加号 链接 有两种创建链接的方式。 内嵌式链接 带标题的内嵌式链接 引用式链接 相对引用一个库文件 你可以在引用式链接定义中使用数字 或者空着什么都不写 link text itself 用来说明引用链接的文字可以放在后面。 脚注 Markdown默认使用的脚注样式链接不会在页面中显示。有时包含一个读者可见的非超链接注脚很有用。对于这样的注脚，GitBook支持的一种简单的语法。 Text prior to footnote reference.1 这是我们的logo（停留查看标题） 内嵌式 Logo Title Text 1 引用式 Logo Title Text 2 代码和语法高亮 代码块是Markdown规范的一部分，但是语法高亮不是。然而，很多渲染器，比如GitHub的和这里的Markdown，都支持语法高亮。支持那种语言以及语言的名字应该怎样写随渲染器的不同而变化。这里的Markdown支持许语言；查看完整的列表，以及如何写语言的名字，请参考 highlight.js 演示页. 内嵌 代码 有 反引号 包含它. 代码块要么被包含三个反引号 ``` 的行包围，要么被四个空格缩进。推荐仅仅使用被包围的代码块，它们使用方便并且只有它们支持语法高亮。 var s = \"JavaScript语法高亮\"; alert(s); s = \"Python语法高亮\" print s 没有指明语言，所有没有语法高亮。 让我们随便写个标签试试 \u003cb\u003etag\u003c/b\u003e 表格 表格不是Markdown规范的核心部分，但是它是GFM的一部分，这里的Markdown也支持它。 冒号可以用来对其列。 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. 外部的管道符 (|) 是可选的，而且不需要优雅的排列Markdown。你还可以在表格中内嵌其他Markdown。 Markdown Less Pretty Still renders nicely 1 2 3 块引用 在邮件中块引用中很方便用来仿真文本的回复。 这行是同一个块的一部分。 引用结束 当这行很长的文字被包裹的时候，它依然会被恰当的引用。让我们继续写下去来确保包裹它时对于每个人来说它足够长。你可以在块引用中使用其它Markdown。 内嵌HTML You can also use raw HTML in your Markdown, and it’ll mostly work pretty well. 你同样可以在Markdown中使用HTML，并且它能很好的工作。 Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. 水平线 三个或者更多… 连字符 星号 下划线 换行符 关于学习换行符是如何工作的，我的建议是去亲身实践并总结 – 敲击 键一次（也就是插入一个换行符），然后再敲击它两次（也就是插入两个换行），看一下发生了什么。不久你就能学会它。“Markdown Toggle” 是你的朋友。 这里有一些东西可以尝试一下： 我们以这行作为开始。 This line is separated from the one above by two newlines, so it will be a separate paragraph. 这行与上面那行被两个换行符分隔，所以它会成为一个 单独的段落。 This line is also a separate paragraph, but… This line is only separated by a single newline, so it’s a separate line in the same paragraph. 这行同样是一个单独的段落，但是… 这行仅仅被一个换行符分隔，所以它是一个在 同一段落 中的单独的行。 Youtube视频 视频不能被直接添加，但你可以添加一个链接至视频的图片，像这样： 或者，使用纯Markdown，但是会丢失掉图片的大小和边框： Comment to include in footnote. 图片 ↩︎ ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"namespace 命名空间","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","series":null,"tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"namespace 命名空间 namespace 是C++中的关键字，用来定义一个命名空间，语法格式为： namespace name{ //variables, functions, classes } name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。 namespace Li{ //小李的变量定义 FILE fp = NULL; } namespace Han{ //小韩的变量定义 FILE fp = NULL } Li::fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using Li::fp; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han :: fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using namespace Li; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp #include \u003cstdio.h\u003e //将类定义在命名空间中 namespace Diy{ class Student{ public: char *name; int age; float score; public: void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; } int main(){ Diy::Student stu1; stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; stu1.say(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"printf输出","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 函式原型： int printf ( const char * format, … ); 引數說明： %[flags][width][.precision][length]specifier %[旗標][寬度][.精度][長度修飾]資料型態 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"1. 資料型態 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 必填欄位 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.1) 字元/字串 %c, %C : 字元, char c; %s : 字元陣列, char buffer[MAX_PATH]; %S : 字元陣列(Unicode), wchar buffer[MAX_PATH]; [註] %C / %S 並未被收在標準函式庫裡，屬 MSVC 特殊支援。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:1","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.2) 整數 %d, %i : 10進制整數 , int x; [lemma] %u : 10進制無號數, unsigned int x; %o : 8進制無號數, unsigned int x; %x, %X : 16進制無號數, 小寫x輸出為\"abcdef\", 大寫 X 輸出為 \"ABCDEF\", unsigned x; %lld, %I64d : long long int, __int64 輸出型態 (註：vc6.0 下只有 __int64，沒有long long int) %llu, %I64u : unsigned long long int 輸出型態 [lemma] %d : dec; %i : integer，於 scanf 時有部份差異 (%d 只接受10進位, %i 可接受指定進位，如 0x23, 045)，但於 printf 時 %d, %i 並無顯著差異 (感謝 Jacob Lee 補充指導) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:2","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.3) 浮點數 %e, %E : 浮點數使用科學符號表示之,指數將帶正負號, float x,doubley; %f : 單精度浮點數(預設輸出精度6位), float x; (註 : 對 printf 而言, %f/%lf 可適用於 double / float) %lf : 倍精度浮點數(預設輸出精度6位), double x; %llf, %LF : 雙倍精度浮點數(預設輸出精度6位), long double x; %g, %G : 由系統決定是否採科學符號表示。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:3","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.4) 特殊 原創：edisonx.pixnet.net %p : 變數位置。 ex: int a=0, printf(\"%p\", \u0026a); 即 printf(\"%08x\", \u0026a); %n : 輸出至緩衝區之長度, ex: char str[]=\"test\", int len, printf(\"%s%n\", a, \u0026len); 輸出4bytes,len = 4 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:4","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.5) C99新增 \u003c 建議 k spec. 最清楚 \u003e (註 : C99 新增了一些資料型態在 inttypes.h / stdint.h 裡面，有興趣搜尋 n1256.pdf 下載下來 K 標準， in section 7.8 。當然 MSVC 不支援 C99 是眾所皆知的事。) 部份原則還是掌握了 %i, %u, %d, %x，另由於這部份在 printf 會顯得很亂，故直接做範例對應。掌握一原則：新的資料型態在 printf 前三個字母一定是 PRI。 “%” PRIdN , “%” PRIiN: 以十進位有號數顯示 intN_t 系列之數值。ex : int8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRId8 \" \\n\", i8); int8_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIi16 \" \\n\", i16); int8_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRId32 \" \\n\", i32); int8_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIi64 \" \\n\", i64); 另上述將 PRIdN / PRIiN ，換成 PRIoN / PRIuN / PRIxN / PRIXN ，便可轉對 uintN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdLEASTN , “%” PRIiLEASTN: 以十進位有號數顯示 int_leastN_t 系列之數值。ex : int_least8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdLEAST8 \" \\n\", i8); int_least16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiLEAST16 \" \\n\", i16); int_least32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdLEAST32 \" \\n\", i32); int_least64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiLEAST64 \" \\n\", i64); 另上述將 PRIdLEASTN / PRIiLEASTN ， 換成 PRIoLEASTN/ PRIuLEASTN/ PRIxLEASTN/ PRIXLEASTN， 便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 \"%\" PRIdFASTN , \"%\" PRIiFASTN: 以十進位有號數顯示 int_fastN_t 系列之數值。ex : int_fast8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdFAST8 \" \\n\", i8); int_fast16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiFAST16 \" \\n\", i16); int_fast32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdFAST32 \" \\n\", i32); int_fast64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiFAST64 \" \\n\", i64); 另上述將 PRIdFASTN / PRIiFASTN ，換成 PRIoFASTN/ PRIuFASTN/ PRIxFASTN/ PRIXFASTN，便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdMAX , “%” PRIdPTR : 分別顯示整數最大值與指標型態。 [註 : 特別注意 inttypes.h 裡面之型態，printf 引數和 scanf 引數差很多，一樣掌握一原則，新的資料型態在 scanf 前三個字母一定是 SCN， 如 intN_t 系列，scanf 用的是 “%” SCNdN / “%” SCNiN ； uintN_t 系列，scanf 用的是 “%” SCNoN / “%” SCNuN / “%” SCNxN / “%” SCNXN ； int_fastN_t / int_leastN_t 等系列資料型態便不贅述。 ) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:5","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"2. 寬度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位net %m : 指定輸出之寬度。ex: int a=2, b=10; printf(\"%d%5d\", a, b); 輸出為 \"2 10\" (2與10之間有3個空白，因10為5個文字寬度)。 %* : 以引數方式代入指定輸出之寬度。ex: int a=2, width=10; printf(\"%*d\",width, a); 輸出為 \" 2\" (10個文字寬度)。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"3. 長度修飾 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %h : 將數字視為 short int (%hd) 或 unsigned int (%hu), 此修飾只對整數型態之 %hi, %hd, %ho, %hu, %hx, %hX 有效。 且針對 char 可用 %hhd，unsigned char 可用 %hhu。 (註 : MSVC 認得 %hd / %hu / %hhd / %hhu , 但在 gcc 下會發出認不得的警告 ) %l : 將數字視為 long int (%ld) 或 unsigned long int (%lu), 此修飾只對整數型態之 %li, %ld, %lo, %lu, %lx, %lX 有效。 %L : 此修飾只對浮點數型態之 long double 有效, 可用於修飾 %Le, %LE, %Lf, %Lg, %LG。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"4. 精度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %.n : 欲輸出小數點後幾位數,即顯示之精度,此修飾只對浮點數資料型態有效(f,F,e,E,g), 若使用其它整數型態 (i, d, o, u, x, X) 則將 n 視為 0, 即不輸出小數位數。ex: double a=2.1234, printf(\"%.2lf\", a); 輸出則為 \"2.12\" 。 %.* : 和 %.n 相似，但其 n 值可用變數引入。ex: double a=1.3456, int preci=2, printf(\"%.*lf\",preci, a); 輸出則為 \"1.35\" 。 %m.n: 這是寬度和精度合用之方法, 代表輸出會有小數點後 n 位， 且整個輸出文字寬 m 個字(包含小數點、正負號及數字)。ex: double c = -102.34567, printf(\"%10.3lf\", c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 %*.*: 和上一說明一樣, 但寬度與精度可用引數決定。ex: double c = -102.34567, int m=10, int n=3; printf(\"%*.*lf\", m, n, c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"5. 旗標 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %- : 原本輸出預設為向右對齊，使用後輸出向左對齊, 需與[寬度]配合使用。ex: char buf[] = \"Test\"; printf(\"%-10s\"); 輸出結果為 \"Test \"， Test 後面將保留6個空白。 %+ : 需為數值型之資料型態，強制輸出正負號，可與 '-' 旗標合用。 ex: double a = 3.4567: printf(\"%-+8.2lf\", a); // '-'使輸出靠左對齊, '+'強調輸出正負號, 整體寬度為8, 小數點顯示2位。 輸出結果為 \"+3.46 \" %0 : 若輸出之左半部為空白處, 則進行補0, (所以這不能和 '-' 合用) ex: unsigned int x = 122; printf(\"%05u\", x); // 寬度為5, 前半空白補零 輸出結果為 \"00122\" %# : 對進制加上前綴符號, 只對 %o, %x 有用, %#o為8進制,前綴符號為 0, %#x為16進制,前綴符號為 0x, %#X前綴符號則為 0X。ex: unsigned int a = 15; printf(\"%u %#o %#X\", a, a, a); 輸出結果為 \"15 017 0XF\" %(空白): 若數字為正號, 則會在該數字前面加上一空白，(故不可與 ‘+’ 合用)。 ex: int a=10; printf(\"% -5d\"); // 寬度5, 向左對齊, 保留正號位置 輸出結果為 \" 10 \" ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"queue用法详解","date":"2021-07-23","objectID":"/2021/07/queue/","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue用法详解 只能访问 queue 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。 许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO 准则处理的序列来说，使用 queue 容器适配器都是好的选择。 图 1 展示了一个 queue 容器及其一些基本操作： 图 1 queue容器 queue 的生成方式和 stack 相同，下面展示如何创建一个保存字符串对象的 queue: std::queue\u003cstd::string\u003e words; 也可以使用拷贝构造函数： std::queue\u003cstd::string\u003e copy_words {words}; // A duplicate of words stack、queue 这类适配器类都默认封装了一个 deque 容器，也可以通过指定第二个模板类型参数来使用其他类型的容器： std::queue\u003cstd::string, std::list\u003cstd::string\u003e\u003ewords; 底层容器必须提供这些操作：front()、back()、push_back()、pop_front()、empty() 和 size()。 ","date":"2021-07-23","objectID":"/2021/07/queue/:0:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 操作 queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同： front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026 obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T\u0026\u0026 obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 swap(queue \u0026other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 queue 模板定义了拷贝和移动版的 operator=()，对于所保存元素类型相同的 queue 对象，它们有一整套的比较运算符，这些运算符的工作方式和 stack 容器相同。 和 stack 一样，queue 也没有迭代器。访问元素的唯一方式是遍历容器内容，并移除访问过的每一个元素。例如： 1. std::deque\u003cdouble\u003e values {1.5, 2.5, 3.5, 4.5}; std::queue\u003cdouble\u003e numbers(values); 2. 3. while (!numbers, empty()) 4. { 5. std ::cout \u003c\u003c numbers. front() \u003c\u003c \" \"; // Output the 1st element 6. numbers. pop(); // Delete the 1st element 7. } 8. std::cout \u003c\u003c std::endl; 用循环列出 numbers 的内容，循环由 empty() 返回的值控制。调用 empty() 可以保证我们能够调用一个空队列的 ftont() 函数。如代码所示，为了访问 queue 中的全部元素，必须删除它们。如果不想删除容器中的元素，必须将它们复制到另一个容器中。如果一定要这么操作，我们可能需要换一个容器。 ","date":"2021-07-23","objectID":"/2021/07/queue/:1:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 容器的实际使用 这里汇集了一些使用 queue 容器的示例。这是一个用 queue 模拟超市运转的程序。结账队列的长度是超市运转的关键因素。它会影响超市可容纳的顾客数——因为太长的队伍会使顾客感到气馁，从而放弃排队。在很多情形中——医院可用病床数会严重影响应急处理设施的运转，也会产生同样的队列问题。我们的超市模拟是一个简单模型，灵活性有限。 可以在头文件 Customer.h 中定义一个类来模拟顾客： 1. // Defines a customer by their time to checkout 2. #ifndef CUSTOMER_H 3. #define CUSTOMER_H 4. 5. class Customer 6. { 7. protected: 8. size_t service_t {}; // Time to checkout 9. public: 10. explicit Customer(size_t st = 10) :service_t {st}{} 11. 12. // Decrement time remaining to checkout 13. Customer\u0026 time_decrement() 14. { 15. if (service_t \u003e 0) 16. --service_t; 17. return *this; 18. } 19. bool done() const { return service_t == 0; } 20. }; 21. #endif 这里只有一个成员变量 service_t，用来记录顾客结账需要的时间。每个顾客的结账时间都不同。每过一分钟，会调用一次 time_decrement() 函数，这个函数会减少 service_t 的值，它可以反映顾客结账所花费的时间。当 service_t 的值为 0 时，成员函数 done() 返回 true。 超市的每个结账柜台都有一队排队等待的顾客。Checkout.h 中定义的 Checkout 类如下： 1. // Supermarket checkout - maintains and processes customers in a queue 2. #ifndef CHECKOUT_H 3. #define CHECKOUT_H 4. #include \u003cqueue\u003e // For queue container 5. #include \"Customer.h\" 6. 7. class Checkout 8. { 9. private: 10. std::queue\u003cCustomer\u003e customers; // The queue waiting to checkout 11. public: 12. void add(const Customer\u0026 customer) { customers.push(customer); } 13. size_t qlength() const { return customers.size(); } 14. 15. // Increment the time by one minute 16. void time_increment() 17. { 18. if (!customers.empty()) 19. { // There are customers waiting... 20. if (customers.front().time_decrement().done()) // If the customer is done... 21. customers.pop(); // ...remove from the queue 22. } 23. }; 24. 25. bool operator\u003c(const Checkout\u0026 other) const { return qlength() \u003c other.qlength(); } 26. bool operator\u003e(const Checkout\u0026 other) const { return qlength() \u003e other.qlength(); } 27. }; 28. #endif 这相当于自我解释。queue 容器是 Checkout 唯一的成员变量，用来保存等待结账的 Customer 对象。成员函数 add() 可以向队列中添加新顾客。只能处理队列中的第一个元素。 每过一分钟，调用一次 Checkout 对象的成员函数 time_increment(}，它会调用第一个 Customer 对象的成员函数 time_decrement() 来减少剩余的服务时间，然后再调用成员函数 done()。如果 done() 返回 true，表明顾客结账完成，因此把他从队列中移除。Checkout 对象的比较运算符可以比较队列的长度。 为了模拟超市结账，我们需要有随机数生成的功能。因此打算使用 random 头文件中的一个非常简单的工具，但不打算深入解释它。我们会在教程后面的章节深入探讨 random 头文件中的内容。程序使用了一个 uniform_int_distribution() 类型的实例。顾名思义，它定义的整数值在最大值和最小值之间均匀分布。在均匀分布中，所有这个范围内的值都可能相等。可以在 10 和 100 之间定义如下分布： std::uniform_int_distribution\u003c\u003e d {10, 100}; 这里只定义了分布对象 d，它指定了整数值分布的范围。为了获取这个范围内的随机数，我们需要使用一个随机数生成器，然后把它作为参数传给 d 的调用运算符，从而返回一个随机整数。 random 头文件中定义了几种随机数生成器。这里我们使用最简单的一个，可以按如下方式定义： std::random_device random_number_engine; 为了在 d 分布范围内生成随机数，我们可以这样写： auto value = d(random_number_engine); // Calls operator()() for d value 的值在 d 分布范围内。 完整模拟器的源文件如下： 1. // Simulating a supermarket with multiple checkouts 2. #include \u003ciostream\u003e // For s[tan](http://c.biancheng.net/ref/tan.html)dard streams 3. #include \u003ciomanip\u003e // For stream manipulators 4. #include \u003cvector\u003e // For vector container 5. #include \u003cstring\u003e // For string class 6. #include \u003cnumeric\u003e // For accumulate() 7. #include \u003calgorithm\u003e // For min_element \u0026 max_element 8. #include \u003crandom\u003e // For random number generation 9. #include \"Customer.h\" 10. #include \"Checkout.h\" 12. u[sin](http://c.biancheng.net/ref/sin.html)g std::string; 13. using distribution = std::uniform_int_distribution\u003c\u003e; 15. // Output histogram of service times 16. void histogram(const std::vector\u003cint\u003e\u0026 v, int min) 17. { 18. string bar (60, '*'); // Row of asterisks for bar 19. for (size_t i {}; i \u003c v.size(); ++i) 20. { 21. std::cout \u003c\u003c std::setw(3) \u003c\u003c i+min \u003c\u003c \" \" // Service time is index + min 22. \u003c\u003c std::setw(4) \u003c\u003c v[i] \u003c\u003c \" \" // Output no. of occurrences 23. \u003c\u003c bar.substr(0, v[i]) // ...and that no. of asterisks 24. \u003c\u003c (v[i] \u003e static_cast\u003cint\u003e(bar.size()) ? \"...\": \"\") 25. \u003c\u003c std::endl; 26. } 27. } 29. int main() 30. { 31. std::random_device random_n; 33. // Setup minimum \u0026 maximum checkout periods - times in minutes 34. int service_t_min {2}, service_t_max {15}; 35. distribution service_t_d {service_t_min, service_t_max}; 37. // Setup minimum \u0026 maximum number of customers at store ","date":"2021-07-23","objectID":"/2021/07/queue/:2:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"std命名空间","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","series":null,"tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"std命名空间 使用命名空间 std： #include \u003ccstdio\u003e int main(){ std::printf(\"http://c.biancheng.net\\n\"); return 0; } 不使用命名空间 std： #include \u003ccstdio\u003e int main(){ printf(\"http://c.biancheng.net\\n\"); return 0; } 演示了如何使用 C++ 库进行输入输出： #include \u003ciostream\u003e #include \u003cstring\u003e int main(){ //声明命名空间std using namespace std; //定义字符串变量 string str; //定义 int 变量 int age; //从控制台获取用户输入 cin\u003e\u003estr\u003e\u003eage; //将数据输出到控制台 cout\u003c\u003cstr\u003c\u003c\"已经成立\"\u003c\u003cage\u003c\u003c\"年了！\"\u003c\u003cendl; return 0; } 运行结果： C语言中文网↙ 6↙ C语言中文网已经成立6年了！ 在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明. #include \u003ciostream\u003e void func(){ //必须重新声明 using namespace std; cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ //声明命名空间std using namespace std; cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中 #include \u003ciostream\u003e //声明命名空间std using namespace std; void func(){ cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"struct 结构体","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/","series":null,"tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["C++"],"content":"struct 结构体 #include \u003cstdio.h\u003e //定义结构体 Student struct Student{ //结构体包含的成员变量 char *name; int age; float score; }; //显示结构体的成员变量 void display(struct Student stu){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", stu.name, stu.age, stu.score); } int main(){ struct Student stu1; //为结构体的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5; //调用函数 display(stu1); return 0; } 结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。### ","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","series":null,"tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["常见问题"],"content":"sublimetext常见问题","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"sublimetext常见问题 下载安装 汉化 1.点击tools—install package control 2.preferences—package control 3.选择 “Package Control: Install Package” 4.搜索LocalizedMenu并安装 乱码 推荐使用 Package Control 查找 ConvertToUTF8 进行自动下载安装与更新。 Mac使用Sublime撸C++代码 这两款软件让你在Mac上也能写C++ ","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"GitHub上传代码.gitignore文件应过滤内容 *.ipch .vs *.pch *.exe *.pdb ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"解决VS生成sdf和ipch文件太大占用空间问题 [工具]—\u003e[选项]—\u003e[文本编辑器]—\u003eC/C++]—\u003e[高级]—\u003e[回退位置]里面的三项属性值按下图进行修改，其中回退路径随便设置。 设置个回退路径这样可比较好管理这些庞大的臃肿的文件，可以定期清理它们，释放磁盘空间 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"Visual Assist X 安装 Visual AssistX是一款非常好的Microsoft Visual Studio插件，它可以完全集成到您的Microsoft开发环境中，升级了您的IDE， 在不改变编程习惯的同时就可以感受到Visual Assist X为您带来的好处。 软件支持Microsoft Visual Studio 2003-2017，C/C++，C#，ASP，VisualBasic，Java和HTML等语言，能自动识别各种关键字、系统函数、成员变量、 自动给出输入提示、自动更正大小写错误、自动标示错误等。使用Visual Assist X有助于提高开发过程的自动化和开发效率。 官网： https://www.wholetomato.com/ 破解版链接: https://pan.baidu.com/s/1jXlvYiKOclkRTP35HlQpGA 提取码: g3u3 1.下载完解压缩，点击VA_X_Setup2341_2.exe进行安装 安装界面，我这装的是2012, Visual Assist自动帮我识别出来. 如果安装有多个vs，这里会有多项被勾选，也可以根据需要去除相应vs安装本插件 点击Install 耐心等待安装 出现下面界面表示安装完成，点OK 复制破解补丁 破解补丁在安装包的Crack目录下的VA_X.dll 6.打开C盘，搜索VA_X.dll 己搜索到VA_X.dll 8.右键打开文件位置 用Crack目录下的VA_X.dll替换掉即可 运行Vs, 可以看到菜单栏多了个VASSISTX,工具条多了几个相应快捷按钮 设置可以点击任务栏上的蕃茄按钮，也可以从菜单中选择Visual Assist Options Visual AssistX停用可以点击Enable/Disable Visual Assit 点击后临时停用插件，重启VS后还会重新加载 12.Visual Assist X卸载 vs菜单工具-\u003e扩展和更新，然后找到Visual Assist 点击卸载即可 备注：Visual Assist X 无法从控制面板-\u003e卸载程序 进行卸载 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"禁止win10五笔输入法的shift切换功能 方法一：win10系统添加开机启动项 使用组合键win+R打开运行窗口，输入“shell:startup”打开启动项文件夹。 可以把软件快捷方式复制到“启动项文件夹|”中。 方法二：注册表添加启动项 1、打开运行，输入“regedit”，打开注册表。 2、在注册表中找到如下位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run，右键“Run”新建一个字符串类型的键值。 3、右键新建的键值，选择“修改”，将数值名称改为 你要启动的程序名称如：ctfmon.exe，数值数据改为 程序所在位置的路径 如：C:\\windows\\system32\\ctfmon.exe (直接不能修改名字的，可以先点击重命名，改好名字，再点击修改，修改数值数据) ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"如何彻底关闭win10系统windows defender实时保护功能？ 如何彻底关闭win10系统windows defender实时保护功能？ Windows Defender是微软系统自带的杀毒工具，默认是开启的，在win10系统之前，是可以手动关闭的，但到了win10后你只能临时关闭，当你重启电脑后它还会自动开启，而且即便你不重启，由于windows defender有实时保护功能，一段时间后还会自动启动。 那么，如何彻底关闭windows defender实时保护功能呢？下面IT技术资料分享网小编就给大家分享解决方法。 1：在我们的电脑上按win+R键，打开运行，win键都是在键盘的最下一行。 2：打开之后在里面输入gpedit.msc，点击确定，打开本地组策略编辑器。 3：在本地组策略编辑器上点击“计算机配置-管理模板-Windows组件-Windows Defender”，在窗口右侧找到“关闭Windows Defender”， 4：这时双击打开关闭Windows Defender，选择“已启用”点击确定。 5：这时关闭本地组策略编辑器，再打开设置里的Windows Defender，可以看到实时保护是关闭的。 6：重启电脑再次打开设置Windows Defender查看，这时还是关闭的。它就不会自动打开了。同样打开一些软件时，也不会提示恶意软件了。 7：还有一种方法是安装第三方杀毒软件windows defender就会自动停止运行。 ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:2:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10专业版用户激活方法 请在CMD下依次输入以下命令： slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX slmgr /skms kms.03k.org slmgr /ato ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:3:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"永久关闭自动更新 打开 开始 . 搜索 gpedit.msc 并单击顶部结果以启动 本地组策略编辑器 . ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:4:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"字体乱码 需要安装 “新宋体” 字体 ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:5:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"将Ctrl和Alt互换 在 win10 中 powertoys 可以实现这个功能。将它安装后，可以通过它的“键盘管理器”功能实现按键的映射，无需修改注册表，也无需做其他的设置，很简便 ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:6:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["WOW"],"content":"WOW部分功能代码","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"WOW部分功能代码 ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:0:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色名字 // pcall5(对象地址,0,1,0,0);//返回名字地址 void CPAGE1::OnBnClickedButton() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase64 = (UINT_PTR) LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387c88)+0x200);//角色对象 TPCALL5 pcall5 =(TPCALL5)(pBase64+0xA7640); // TPCALL5 pcall5 = (TPCALL5)((UINT_PTR) LoadLibraryA(\"Wow.exe\")+0xA7640); char szpAscii[256]={0}; // char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); char *putf8Name =(char*) pcall5(pRoleObj,0,1,0,0); utf8ToAscii(putf8Name,szpAscii); m_edt_strA=szpAscii; UpdateData(FALSE);//把变量的数据更新到窗口 //UpdateData(TRUE);//把窗口的数据更新到变量 } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历怪物列表 void 遍历怪物列表() { UINT64 exeBase = (UINT64)LoadLibraryA(\"Wow.exe\"); for (UINT i=0;i\u003c=0x7F;i++)//7F可能不是 对象数量 对象的分类编号 { // UINT64 vrax=0; UINT64 vrax = R8(R8(R8(exeBase+0x2387C88)+0x30)+0x10+i*3*8); if (vrax == 0 ) { break; } // else//vrdx !=0 // { // vrax = vrdx; // } UINT64 vrcx = (UINT64)R4(R8(R8(exeBase+0x2387C88)+0x30)+i*3*8);//+28 while((vrax\u00261)==0) { //遍历同类链表 //rcx = dword([[wow.exe+0x2387C88]+0x30]+i*3*8) //0x28 //+198]+20 //float x,y,z UINT64 pNode198 = R8(vrax+0x198); float x = R4F(pNode198+0x20); float y = R4F(pNode198+0x24); float z = R4F(pNode198+0x28); char buf[2048]; char asciiObjName[2048]={0}; char *pObjName=GetObjName(vrax); if (pObjName\u0026\u0026pNode198) { utf8ToAscii(pObjName,asciiObjName); } sprintf_s(buf,\"yjx:[%d] vrax=%p (%f,%f,%f) vrcx=%llx name=%p %s\\r\\n\",i,vrax,x,y,z,vrcx,pObjName,asciiObjName); MessageBoxA(0,buf,\"while\",0); vrax = R8(vrcx+vrax+8); //链表 } } } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取对象名字 char* GetObjName(UINT64 vrcx) { char *putf8Name=NULL; __try { UINT64 pBase64 = (UINT_PTR)LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387C88)+0x200); TPCALL5 pcall5 = (TPCALL5)(pBase64+0x8AE040); char szpAscii[256]={0}; putf8Name = (char*)pcall5(vrcx,0,1,0,0); }__except(1) { } return putf8Name; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"使用技能 void TGCALL::UseActionCall(UINT32 SkillID,UINT64* argBuf40,UINT64 *TargetID16) { typedef UINT64 (*TPCALL4)(UINT64 arg1,UINT64* arg2,UINT64 arg3,UINT64* arg4); TPCALL4 pcall=(TPCALL4)(GameBase::GetExeBase()+0x77DC40); __try { pcall(SkillID,argBuf40,0,TargetID16); }__except(1) { MessageBoxA(0,\"ERROR 0x77DC40\",\"错误\",MB_OK); } return; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"火球术 void CPAGE1::OnBnClickedButtonFire() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0,0}; // 0x006FCC00007B4493 /*ID1*/,0x204D880000001140 /*ID2*/};//目标怪物的ID TGCALL::UseActionCall(0x00000085,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:1","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"霜甲术 void CPAGE1::OnBnClickedButtonIce() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0/*ID1*/,0/*ID2*/}; //目标怪物的ID TGCALL::UseActionCall(0x000000A8,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:2","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"捡物 void CPAGE1::OnBnClickedButtonPick() { // TODO: 在此添加控件通知处理程序代码 TPCALL4 pcall4 = (TPCALL4)(GameBase::GetExeBase()+0xF2A620); pcall4(0,0,0,0); pcall4(1,0,0,0); pcall4(2,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"搜索选中怪身上的物品 void CPAGE1::OnBnClickedButtonSeachgoods() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase = R8(GameBase::GetExeBase()+0x21E2858); UINT64 ID1 = R8(pBase+0x30); UINT64 ID2 = R8(pBase+0x38); UINT64 arg1[40] = {ID1,ID2,0,0}; //通过选中对象ID 查找对象 TPCALL4 pcallGetObj1=(TPCALL4)(GameBase::GetExeBase()+0xB66AB0); UINT64 vrax = pcallGetObj1((UINT64)arg1,0,0,0);//一个参数 char buf[1024]; sprintf_s(buf,\"vrax=%llx \\r\\n\",vrax); TPCALL4 pcall =(TPCALL4)(R8(R8(vrax)+0x2C0));//2C0 右键单击 打开搜索物品的窗口 pcall(vrax,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:6:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色对象地址 UINT64 GameBase::GetRoleObj()//返回角色对象地址 { // return R8(R8(GetExeBase()+0x2387C88)+0x200); TPCALL2 pcall2 = (TPCALL2)(GameBase::GetExeBase()+0x1127550); const char *vrcx = \"player\"; return pcall2((UINT64)vrcx,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:7:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客 jekyll-rtd-theme 安装配置及写作 测试文档 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装时终端出现问题的解决办法 清空Gemfile文件内容 终端运行 bundle update Gemfile文件添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 终端再次运行 bundle update ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"一.安装 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"a.基于本地主题 1.清空Gemfile文件内容,并添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 2.将以下内容添加到您的网站 _config.yml title: Your awesome title lang: en description: Write an awesome description for your new site here theme: jekyll-rtd-theme ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:1","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"b.基于远程主题 将以下内容添加到您的 github 存储库 _config.yml remote_theme: rundocs/jekyll-rtd-theme 删除任何其他theme或remote_theme条目 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:2","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"二.设置侧边栏(子目录) 在根目录新建子目录 子目录中必须有一个README.md 排序 _config.yml中添加以下内容 readme_index: with_frontmatter: true 在需要排序的文件中添加 格式头 --- sort: 1 # follow a certain sequence of letters or numbers --- ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"三.在README文件中列出文件 在README文件中添加 如果要列出子目录的所有文件则添加 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"四.语法 思维导图 graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 笔记 这是笔记 支持 Markdown, 文本可以是**粗体**, _斜体, or ~~删除线~~. [链接](https://github.com) 是蓝色的,且没有下划线 `inline code` [`inline code inside link`](#) 提示 它比面包盒还大.. 警告 强烈的散文可能会引起极度的脑力消耗。强烈建议读者酌情决定. 危险 疯狂的科学家在工作！ 更新 sudo bundle install sudo bundle update sudo bundle update jekyll ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:5:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"常用API函数","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"常用API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"模拟鼠标 LRESULT SendMessage(HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam); 其中Msg可以为WM_LBUTTONDOWN或WM_LBUTTONUP,表示对鼠标的软件模拟操作(虽然兼容性和安全性不如硬件模拟的mouse_event，但不改变移动鼠标指针) 故一般写作SendMessage(hwnd, WM_LBUTTONUP/WM_LBUTTONDOWN, 0, Y坐标\u003c\u003c16+X); Msg也可以为WM_CLOSE,表示关闭窗口,其后的两个参数传0即可. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL注入 CreateThread 将在主线程的基础上创建一个新线程 HANDLE CreateThread(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD ,LPDWORD); VirtualAllocEx 向指定进程申请内存 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); GetProcAddress 获得指定的动态链接库(DLL)中的输出库函数地址 FARPROC GetProcAddress( [in] HMODULE hModule, //包含函数或变量的DLL模块的句柄 [in] LPCSTR lpProcName //函数或变量名称，或函数的序数值 );//返回值是导出函数或变量的地址 //如果函数失败，返回值为NULL GetModuleHandleA 获得指定模块的模块句柄 HMODULE GetModuleHandleA( [in, optional] LPCSTR lpModuleName //加载模块的名称（.dll或.exe文件） );//返回值是指定模块的句柄。 //如果函数失败，返回值为NULL CreateRemoteThread 创建一个在其它进程地址空间中运行的线程 HANDLE CreateRemoteThread( [in] HANDLE hProcess, //目标进程句柄 [in] LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL [in] SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M [in] LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址(目标进程代码地址) [in] LPVOID lpParameter, //线程参数 [in] DWORD dwCreationFlags, //线程的创建标志 [out] LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); GetExitCodeThread 检索指定线程的终止状态。 BOOL GetExitCodeThread( [in] HANDLE hThread, //线程句柄 [out] LPDWORD lpExitCode //指向变量的指针，以接收线程终止状态。 ); //返回值 //如果函数成功，返回值为非零。 //如果函数失败，返回值为零。 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL劫持 __asm{ } 执行括号内的汇编代码 JMP EAX 将EIP跳转到EAX执行，劫持DLL后要获取真正的原函数地址，使用时要进行跳转 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GDI绘图 HDC GetDC(HWND hWnd); 检索显示设备上下文环境的句柄 CDC CDC类定义的是设备上下文对象的类 CPoint CDC::MoveTo(int x,int y); CPoint CDC::LineTo(int x,int y); 绘制直线 BOOL CDC::Ellipse(int x1,int y1，int x2,int y2); 绘制圆形 BOOL CRgn::CreateRectRgn(int x1,int y1,int x2,int y2); 建立方形区域 BOOL CRgn::CreateEllipticRgn(int x1,int y1,int x2,int y2) 建立圆形区域 int CombineRgn(CRgn pRgn1,CRgn pRgn2,int nCombineMode ); 合并区域(圆点准心为使得中间透明采取大圆-小圆的区域) BOOL FillRgn(CRgn pRgn,CBrush pBrush ); 填充形状 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"设置钩子API HHOOK WINAPI SetWindowsHookEx（ _In_ int idHook，　//设置钩子的类型.意思就是我要设置的钩子是什么钩子. 可以是监视窗口过程.可以是监视消息队列. _In_ HOOKPROC lpfn，　//根据钩子类型.设置不同的回调函数. _In_ HINSTANCE hMod，　//钩子设置的Dll实例句柄,就是DLL的句柄 _In_ DWORD dwThreadId　//设置钩子的线程ID. 如果为0 则设置为全局钩子. ）;　//HHOOK 返回值. 是一个钩子过程句柄. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"输入与输出 #include \u003ciostream\u003e //输出 int a =1; printf(\"Hello \\n\"); printf(\"%d\",a); //输入 scanf_s(\"%d\",\u0026a); //输入一个值，并赋值给a ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"其它API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"MoveWindow BOOL MoveWindow( HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint ); 改变指定窗口的位置和大小 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:1","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindow BOOL IsWindow(HWND hWnd)； 判断是否是有效窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:2","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindow BOOL ShowWindow(HWND hWnd, int nCmdShow); 显示隐藏窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:3","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindowAsync BOOL ShowWindowAsync(HWND hWnd，int nCmdshow)； 异步显示窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:4","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowVisible BOOL IsWindowVisible(HWND hWnd); 获取窗口可视状态,即显示或隐藏 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:5","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsZoomed BOOL IsZoomed(HWND hWnd)； 窗口是否是最大化 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:6","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowUnicode BOOL IswindowUnicode(HWND hwnd)； 判断窗口字符集 由RegisterClassA 还是RegisterClassW注册 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:7","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"CloseWindow BOOL CloseWindow(HWND hWnd); 关闭窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:8","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"WindowFromPoint HWND WindowFromPoint(POINT Point)； 获取指定坐标处的窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:9","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ChildWindowFromPoint HWND ChildWindowFromPoint (HWND hWndParent, POINT Point); 获取指定窗口 坐标处子窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:10","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetWindowText Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount); // int 如果函数成功，返回值是拷贝的字符串的字符个数，不包括中断的空字符；如果窗口无标题栏或文本，或标题栏为空，或窗口或控制的句柄无效，则返回值为零。 // hWnd：带文本的窗口或控件的句柄。 // lpString：指向接收文本的缓冲区的指针。 // nMaxCount：指定要保存在缓冲区内的字符的最大个数，其中包含NULL字符。如果文本超过界限，它就被截断。 获取窗口标题字符串 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:11","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetClassName int GetClassName( HWND hWnd, //窗口的句柄及间接给出的窗口所属的类。 LPTSTR IpClassName, //指向接收窗口类名字符串的缓冲区的指针。 int nMaxCount //指定由参数lpClassName指示的缓冲区的字节数。如果类名字符串大于缓冲区的长度，则多出的部分被截断。 ); // 返回值: 如果函数成功，返回值为拷贝到指定缓冲区的字符个数：如果函数失败，返回值为0 获取窗口注册的类名,由RegisterClass注册时的名字 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:12","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"BringWindowToTop B00L BringWindowToTop(HWND hWnd); 窗口激活并切换到Z序顶层 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:13","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnableWindow BOOL EnableWindow(HWND hWnd，BOOL bEnable); 是否接收键盘鼠标消息 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:14","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnumChildWindows BOOL EnumChildWindows(HWND hWndParent,WNDENUMPROC lpEnumFunc, LPARAM lParam); 遍历子窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:15","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowPos WINUSERAPI BOOL WINAPI SetWindowPos(HWND hWnd,HWND hWndInsertAfter,int X,int Y,int cx, int cy, UINT uFlags); 窗口位置设置 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:16","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowText BOOL SetWindowText(HWNDhwnd,LPCTSTRlpString); 设置窗口标题,SetWindowText也分A和W两种 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:8:17","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/","series":null,"tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串 让喊话内容支持中文 //AnsiToUtf8.h #pragma once //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); //AnsiToUtf8.cpp #include \"stdafx.h\" #include \"AsciiToUTF8.h\" #include \u003cWindows.h\u003e /* //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); */ DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf) { int WLength = MultiByteToWideChar(CP_ACP, 0, Ansi, -1, NULL, 0); LPWSTR pszW = (LPWSTR) _alloca((WLength+1) * sizeof(WCHAR)); //Ansi字符串转Unicode字符串 MultiByteToWideChar(CP_ACP, 0, Ansi, -1, pszW, WLength); //计算UTF8转换所需要空间大小 int ALength = WideCharToMultiByte(CP_UTF8, 0, pszW, -1, NULL, 0, NULL, NULL); //LPSTR pszA = (LPSTR)_alloca( ALength + 1); WideCharToMultiByte(CP_UTF8, 0, pszW, -1, szpUtf8Buf, ALength, NULL, NULL); szpUtf8Buf[ALength]=0; szpUtf8Buf[ALength+1]=0; //pszA[ALength] = 0; return ALength;//返回UTF8字符串长度 } char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr) { //预算-缓冲区中多字节的长度 //CP_OEMCP int ansiiLen =WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,nullptr,0,nullptr,nullptr); //给指向缓冲区的指针变量分配内存 //把szpUnicodeStr里存放的Unicode编码字串 转成ASCII存放到 szpAsciiStr缓冲区 //CP_OEMCP WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,szpAsciiStr,ansiiLen,nullptr,nullptr); return szpAsciiStr; } WCHAR* utf8ToUnicode(IN char*szpUtf8,OUT WCHAR*szpUniCode) { //预算_缓冲区中宽字节的长度 //CP_UTF8 963页码 int unicodeLen = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); //给指向缓冲区的指针变量分配内存 WCHAR *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); //开始向缓冲区转换字节 //CP_UTF8 963页码 也可能 MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,pUnicode,unicodeLen); wcscpy_s(szpUniCode,unicodeLen,pUnicode); free(pUnicode); return szpUniCode; } //注意此函数没检测缓冲区大小 char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii) { int iSizeUtf8 = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); WCHAR*putf8Buf =(WCHAR*)malloc(sizeof(WCHAR)*iSizeUtf8); utf8ToUnicode(szpUtf8,putf8Buf); UniCodeToAscii(putf8Buf,szpAscii); return szpAscii; } BOOL CharToHex(OUT char*szpBufHex,BYTE c) { BYTE bLow =0; BYTE bHigh = 0; bLow = c%16;//取低位0..15 bHigh = c/16;//取高位0..15 if (bHigh\u003e9) { szpBufHex[0]='A'+bHigh-10;//'B' } else//0..9 { szpBufHex[0]='0'+bHigh;//'0'+2='2' } if (bLow\u003e9)//a,b,c,e,f { szpBufHex[1]='A'+bLow-10;//'B' } else//0..9 { szpBufHex[1]='0'+bLow;//'0'+2='2' } szpBufHex[2]=0;//0 return TRUE; } DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf) { //1 //01 for (DWORD i=0;i\u003c nbDataSize;i++) { //提高速度 CharToHex(\u0026szpHexBuf[i*2],nbData[i]); } return TRUE; } ","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["WOW"],"content":"句柄 进程 内存 ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"窗口句柄 HWND FindWindow( LPCTSTR IpClassName， //窗口的类名 LPCTSTR IpWindowName //窗口的标题 ); //返回窗口句柄 HWND FindWindowW(//使用Unicode字符集 LPCTSTR IpClassName， LPCTSTR IpWindowName //IpWindowName前要加L,如L”魔兽世界“ ); HWND FindWindowA(//使用多字节字符集 LPCTSTR IpClassName， LPCTSTR IpWindowName ); HWND FindWindowEx( //获得一个窗口的句柄，该窗口的类名和窗口名与给定的字符串相匹配 HWND hwndParent, //要查找子窗口的父窗口句柄 可为NULL HWND hwndChildAfter, //子窗口句柄 可为NULL LPCTSTR lpszClass, //窗口的类名 可为NULL LPCTSTR lpszWindow //窗口的标题 可为NULL ); //如果hwndParent为NULL，则函数以桌面窗口为父窗口，查找桌面窗口的所有子窗口。 //如果hwndParent为HWND_MESSAGE，函数仅查找所有消息窗口。 //子窗口必须为hwndPareRt窗口的直接子窗口而非后代窗口。 //如果hwndChildAfter为NULL，查找从hwndParent的第一个子窗口开始。 //如果hwndParent 和 hwndChildAfter同时为NULL，则函数查找所有的顶层窗口及消息窗口。 HWND FindWindowExA( //使用多字节字符集 HWND hwndParent, HWND hwndChildAfter, LPCTSTR lpszClass, LPCTSTR lpszWindow ); 通过类名或窗口名查找，返回窗口句 ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:1","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"进程ID和线程ID DWORD GetWindowThreadProcessId( HWND hWnd, //被查找窗口的句柄. LPDWORD lpdwProcessId //进程号的存放地址 ); //返回线程号 得到窗口句柄后通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:2","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"进程句柄 HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId); 打开一个已存在的进程对象，并返回进程的句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:3","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"写入内存 三种方式： 函数WriteProcessMemory（远程跨进程） BOOL WriteProcessMemory( HANDLE hProcess, //进程句柄 LPVOID lpBaseAddress, //内存首地址 LPVOID lpBuffer, //指向要写的数据的指针 DWORD nSize, //字节数 LPDWORD lpNumberOfBytesWritten //这个是返回实际写入的字节 ); 能写入某一进程的内存区域。入口区必须可以访问，否则操作将失败 指针读取 （需要注入） 格式: *(读取类型*)地址 封装函数 BYTE 内存_读字节型(DWORD 内存地址) { if(IsBadReadPtr((void*)内存地址,sizeof(BYTE))==0) //验证是否具有读取访问权限 { return *(BYTE*)内存地址; } return 0; } WORD 内存_读2字节型(DWORD 内存地址) { if(IsBadReadPtr((void*)内存地址,sizeof(WORD))==0) //验证是否具有读取访问权限 { return *(WORD*)内存地址; } return 0; } DWORD 内存_读4字节型(DWORD 内存地址) { if(IsBadReadPtr((void*)内存地址,sizeof(DWORD))==0) //验证是否具有读取访问权限 { return *(DWORD*)内存地址; } return 0; } FLOAT 内存_读浮点型(DWORD 内存地址) { if(IsBadReadPtr((void*)内存地址,sizeof(FLOAT))==0) //验证是否具有读取访问权限 { return *(FLOAT*)内存地址; } return 0; } char* 内存_读字符串(CHAR* 内存地址) { if(IsBadReadPtr((void*)内存地址,sizeof(char))==0) //验证是否具有读取访问权限 { return 内存地址; } return 0; } IsBadReadPtr详情 验证是否具有读取访问权限 内联汇编（需要注入） ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:4","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"读取内存 BOOL ReadProcessMemory( HANDLE hProcess, //目标进程句柄 LPCVOID lpBaseAddress, //要读取的起始地址 LPVOID lpBuffer, //存放读取数据的地址 DWORD nSize, //要读取的字节数 LPDWORD lpNumberOfBytesRead //存放实际读取字节大小 ); //返回值 成功非0,失败0 根据进程句柄读入该进程的某个内存空间lpBaseAddress的nSize字节，并写入缓冲区lpBuffer，多次计算基址和偏移即可 ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:1:5","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"加载模块 GetModuleHandleA 获得应用程序或动指定模块的模块句柄 HMODULE GetModuleHandleA( [in, optional] LPCSTR lpModuleName //加载模块的名称（.dll或.exe文件） );//返回值是指定模块的句柄。 //如果函数失败，返回值为NULL //实例 DWORD B =(DWORD)GetModuleHandleA(\"ELEMENTCLIENT.EXE\"); ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:2:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"遍历模块 int 遍历进程模块(DWORD 进程PID) { HMODULE hMods[1024]; //20*sizeof(HMODULE) HANDLE 进程句柄; DWORD cbNeeded; unsigned int i; //Print the proess identifier. printf(\"\\nprocess ID: %u\\n\",进程PID); //Get a handle to the process. 进程句柄=OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程PID); if (NULL == 进程句柄) return 1; //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return 0; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:3:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取窗口句柄 HWND CFINDCODE::GetGameHwnd(void) { HWND hNext = FindWindowExA(HWND_DESKTOP,0,0,0); HWND h2 = FindWindowExA(HWND_DESKTOP,hNext,0,0); int i =0; while(h2) { char buf[256]={0}; GetWindowTextA(h2,buf,256); if (strstr(buf,szGameSubCaption)) { break; } h2 = FindWindowExA(HWND_DESKTOP,h2,0,0); } return h2; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:4:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取进程ID DWORD CFINDCODE::GetPID() { HWND h=GetGameHwnd(); DWORD dwpid=0; GetWindowThreadProcessId(h,\u0026dwpid); return dwpid; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:5:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取进程句柄 HANDLE CFINDCODE::GetGameHp() { DWORD dwPid = GetPID(); HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS,0,dwPid); // printf(\"hp=%hp, pid=%d\\r\\n\",hp,dwPid); return hp; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:6:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取EXE模块起始地址 UINT_PTR CFINDCODE::GetExeBase() { UINT_PTR exeBase64=NULL; HMODULE hMods[1024]; //20*sizeof(HMODULE) DWORD cbNeeded; unsigned int i; HANDLE 进程句柄=GetGameHp(); //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //如果是“*.exe”的模块,直接返回基址 if (strstr(szModName,\".exe\")) { exeBase64 = (UINT_PTR)hMods[i]; } //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); // printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return exeBase64; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:7:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取EXE结束地址 UINT_PTR CFINDCODE::GetExeEnd() { // HANDLE 进程句柄=GetGameHp(); // UINT_PTR 模块基址 = GetExeBegin(); // MEMORY_BASIC_INFORMATION meminfo; // //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 // SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); // UINT_PTR 结束地址=(UINT_PTR)meminfo.AllocationBase+meminfo.RegionSize; // printf(\"GetExeEnd: AllocationBase=%llx,RegionSize=%X 结束地址=%llx \\r\\n\",meminfo.AllocationBase,meminfo.RegionSize,结束地址); // return 结束地址; return GetExeBase()+GetExeSize(); } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:8:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["WOW"],"content":"获取EXE模块大小 SIZE_T CFINDCODE::GetExeSize(); { static SIZE_T nSize=0; if (nSize) { /* code */ return nSize; } HANDLE 进程句柄=GetGameHp(); UINT_PTR 模块基址 = GetExeBase(); MEMORY_BASIC_INFORMATION meminfo; //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); nSize = meminfo.RegionSize; CloseHandle(进程句柄); return nSize; } ","date":"2021-07-23","objectID":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/:9:0","series":null,"tags":["WOW"],"title":"句柄 进程 模块 读写","uri":"/2021/07/%E5%8F%A5%E6%9F%84-%E8%BF%9B%E7%A8%8B-%E6%A8%A1%E5%9D%97-%E8%AF%BB%E5%86%99/"},{"categories":["博客"],"content":"LoveIt - 1前期准备","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"前言 这篇教程介绍了如何搭建这样效果的博客。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"所需步骤 可以从这样的角度出发： 注册域名。 使用CDN加快网站访问速度。 网站内容需要部署在服务器或对象存储平台上。 重要的是放什么内容。博客需要选择框架，或自己开发。 框架确定后，选择主题，或自己开发。 配置主题。 发表第一篇Hello World！ 在这个过程中，前期准备阶段包括：框架选择、主题选择、注册域名、备案和CDN配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"博客框架 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"框架选择 Wordpress 缺点：不安全。 主题推荐：Sakura Hexo 缺点：渲染生成文章速度不如Hugo。 主题推荐：matery Hugo The world’s fastest framework for building websites. ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"结论 选择Hugo框架。 静态博客方便备份。 用Markdown写文章，方便以后迁移。 缺点，使用对象存储服务需要支付流量费，存在被DDOS的风险。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"下载 Hugo和Hugo extend区别 Hugo extend支持Sass/SCSS。下载地址 Windows可考虑使用scoop下载, 安装与升级很方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"Hugo主题 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt 功能很全面的一个主题，支持很多功能，节省了不少自己折腾的时间。LoveIt主题介绍 安装主题有两种方案，如果不修改主题配置和模板，可以直接添加添加子模块，这样比较简单。 修改主题会麻烦一些，但是可以让自己的博客与众不同。需要将Fork到自己的仓库，有一个缺点，fork后添加的submodule是自己的仓库，使用Dependabot需要手动和上游同步之后，才会触发blog仓库更新检查。所以不适用Dependabot。 不修改主题模板 添加子模块到blog仓库的themes目录下。 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 可设置Dependabot自动合并主题更新，参考：About Dependabot version updates和Automate Theme Update。 Fork主题后进行DIY fork主题到自己的仓库。 添加子模块： git submodule add \u003c自己仓库的url\u003e \u003cpath\u003e 设置上游进行同步，在主题目录中执行 git remote add upstream \u003c上游主题的url\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"toha toha是一个非常适合做个人简历的主题。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"注册域名 万网注册域名。 配置DNS解析，域名邮箱解析等可能存在冲突。 参考DNS解析冲突规则 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"HTTPS证书 使用HTTPS证书避免HTTP劫持风险，劫持https请求需要伪造证书。 阿里云可申请免费HTTPS证书，但是一个子域名需要单独申请一个证书。 Chrome浏览器HTTP网站显示“不安全”，是怎么回事? 谷歌从Chrome 56版本浏览器开始对使用HTTP协议传输密码信息的网站进行“不安全”警告；而2018年7月，谷歌Chrome 68将对所有HTTP网站显示“不安全”警告。随着Chrome浏览器的版本升级，会有越来越多的用户看到HTTP网站的“不安全”警告。来源：https://www.sohu.com/a/242732942_188485 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"备案 IPC备案 公安备案 如果在万网购买的域名，备案过程很简单，按要求填写信息，上传照片即可。注意照片要合要求，否则可能会被打回来重新上传。 香港，国外的服务器不需要备案。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"CDN 购买CDN资源包，加速域名访问。静态博客不需要购买动态请求次数。 以上步骤完成后，将域名解析到CDN，CDN加速源站或对象存储服务（在部署阶段介绍）。访问域名，确定CDN是否加速。 通过ping命令查看IP是否为CDN的IP。 打开Chrome控制台，查看返回包头是否有X-Cache字段。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:7:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt - 2部署","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"前言 完成前期的准备工作后，在部署阶段需要配置服务器或对象存储服务。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储和服务器对比 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储平台 国内有阿里云OSS、腾讯COS、又拍云、七牛云等。国外有Github Pages、Netlify、Azure、Google等，其中Github Pages免费，但是有个说法：Github屏蔽百度爬虫，使用Github Pages的网站百度搜不到。 对象存储平台也可以做为Markdown图床，配合CDN，加快图片加载速度。 笔者的服务器是阿里家的，所以对象存储也用了阿里云OSS。 阿里云OSS部署参考 Hugo 静态网站部署及免费 HTTPS 证书配置 OSS常用工具汇总 对象存储的配置非常简单，哈喽沃德先生的这篇文章已经很详细了，按照这篇文章可以完成上传操作。文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 需要注意的是，上传的Bucket要设置为公共读权限，同时限制Refer，做好防盗链。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器 平时有使用VPS需求，可选择使用VPS。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对比 对象存储： 优点：便宜，不需要搭建环境。 缺点：流量费用，要考虑图床的防盗链。 服务器： 优点各种踩坑😔，可以提升技能。 费用： 对象存储平台不考虑流量费：7.2元/年。 阿里云服务器，学生党及年龄小于等于24岁：10元/月；不满足以上条件的个人：121元/月。 结论 对象存储上手简单，成本低。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器环境 不使用服务器部署的读者，可跳过这部分。 操作系统Ubuntu 更新安装源 apt update 修改hostname hostnamectl --static set-hostname localhost 重启 安装软件 apt install git apt install nginx apt install rz apt install unzip ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"SSH安全配置 安全组限制IP通过SSH远程登陆。如果使用Github Action安全组无法限制，Github Action的服务器部署在Azure上，官方文档中包含几万行IP段，不适合做限制。 修改22端口。由于第一个原因，只能修改端口。否则Massscan3分钟全网段扫描，触发SSH口令暴力破解，几乎每天都有告警。注意！修改之后，确定其他端口可以登陆再关闭22端口。 配置SSH key避免执行git命令时用户密码验证。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"Nginx配置 root权限启动。避免前端访问403的问题。/etc/nginx/nginx.conf中启动配置的用户与实际启动nginx的用户需要保持一致，可修改为低权限用户启动。 如果Nginx版本存在漏洞，以root权限启动，存在被拿到root权限的风险。 配置 /etc/nginx/nginx.conf ... include /etc/nginx/conf.d/*.conf; # 注释下面这行。如果sites-enabled/路径下存在默认配置文件，可能覆盖/etc/nginx/conf.d/default.conf配置 # include /etc/nginx/sites-enabled/*; ... 配置 /etc/nginx/conf.d/default.conf server { listen 80; server_name www.xiaodejiyi.com xiaodejiyi.com; # 注意www和没有www都要配置 index index.html index.htm; root /var/www/html/public; location / { root /var/www/html/public; index index.html; } error_page 404 /404.html; } ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"上传 将blog的public目录压缩为zip格式，使用rz命令上传到服务器上，unzip命令解压到Nginx配置的网站根目录中。 正常情况下，域名解析到CDN，CDN设置源站IP。到这一部可以访问域名，查看部署结果。如果blog配置未完成，可以先上传一张图片做测试。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"参考 阿里云帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"LoveIt - 3主题配置","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"前言 博客部署完成后，恭喜你可以发表第一篇：Hello world！但是LoveIt这么好用的主题，不配置一番可惜了。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"基本功能配置 主题配置最好参考已有的配置，比如LoveIt作者写的介绍，还有主题目录下的配置文件\\themes\\LoveIt\\exampleSite\\config.toml文件。 笔者认为一些配置项解释的不够清楚，所以将网站的源码放在了Github上，仅供参考。 下面介绍其中一些配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"双语言配置 配置后需要每篇文章存在多个语言的文件，否则会报错。 例如：content\\about\\index.en.md、content\\about\\index.zh-cn.md ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"Gravatar头像 gravatar头像注册，需要使用wordpress帐号，注册帐号时，有些邮箱的邮件会被过滤，使用163邮箱等了1个多小时方才收到注册的邮件。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"图片画廊功能 在配置文件config.toml中开启lightgallery # 是否使用 lightgallery lightgallery = true 或者在文章的头部参数中设置lightgallery: true 最后文章中的图片引用格式为：![weichat](/images/weichat-logo_500px.png \"公众号\")，注意路径后面要加\"内容\"。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"搜索配置 使用algolia作为搜索引擎，因为lunr的加载速度会让你等到花都谢了。虽然algolia需要上传index.json，但是可以使用Algolia Atomic简化操作。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"评论系统设置 国内不能用disqus，不过还有Valine评论系统。留言可以设置邮件提醒功能，但是LeanCloud的云引擎域名需要使用自己的域名并配置DNS解析。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息设置 首页的社交信息，不同语言的界面，可分别设置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息拓展 以微信公众号为例。 在config.toml的社交信息中添加 # 作者的社交信息设置 [social] ... Wechat = \"https://img.xiaodejiyi.com/img/wechat%20logo_500px.png\" ... 配置themes\\LoveIt\\assets\\data\\social.yml: # 064: wechat wechat: # weight值排序 Weight: 2 Title: 公众号 Newtab: true Icon: Simpleicons: wechat 其中图标可参考其他形式，如： # Src形式 cnblog: Weight: 1 Prefix: https://www.cnblogs.com/ Title: 博客园 Icon: # themes\\LoveIt\\assets\\svg\\icons\\cnblog.svg Src: svg/icons/cnblog.svg # fontawesome class形式 mastodon: Weight: 56 Prefix: https://mastodon.social/ Title: Mastodon Icon: Class: fab fa-mastodon fa-fw # Simpleicons googlescholar: Weight: 54 Template: https://scholar.google.com/citations?%v Title: Google Scholar Icon: # themes\\LoveIt\\assets\\lib\\simple-icons Simpleicons: googlescholar ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"使用站长工具，向搜索引擎提交网站地图 让搜索引擎收录网站内容。 百度搜索资源平台 https://ziyuan.baidu.com/site/index#/ Google search console https://search.google.com/search-console/about?hl=zh-CN # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [verification] google = \"xxxxxxxxxxxxxxxx\" bing = \"\" yandex = \"\" pinterest = \"\" baidu = \"code-xxxxxxx\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站统计与分析 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站流量分析 分析网站点击流量，访客IP等数据。 Google Analytics 百度统计 注册后，需要先添加DNS解析，验证域名所有权，可能会与其他解析记录存在冲突。 解决方法，暂停其他解析，验证所有权通过后，在网站分析中配置ID，最后删除验证的DNS解析，重新开启其他冲突的解析记录。 # Google网站分析配置 [analytics] enable = true # Google Analytics [analytics.google] id = \"G-xxxxxxx\" # 是否匿名化用户 IP anonymizeIP = true 百度统计需要在网站代码中加入百度的统计代码，可以在themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中添加以下代码。 {{- /* baidu Analytics */ -}} \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); # 需要修改为自己的url hm.src = \"https://hm.baidu.com/hm.js?9c04b6d35915817e67da8ad2fdcfbfdf\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e # 下面网站访问数量统计中，友盟+和51LA也可以加在这里。 {{- /* 51la Analytics */ -}} \u003cscript type=\"text/javascript\" src=\"//js.users.51.la/21009067.js\"\u003e\u003c/script\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站访问数量统计 对比样式之后，选择了51LA统计。也可以用JS修改统计的样式。 这三个访问统计都需要在网站代码中加入统计的JS代码。注册后，获取JS统计代码，可以和网站流量分析中百度分析一样加到themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中。 不算子 样式： 本文总阅读量929966次 本站总访问量3152598次 本站总访客数672421人 友盟+ 互联网数据服务平台缔元信和CNZZ合并成为友盟+。 样式： 站长统计 | 今日IP[43] | 今日PV[191] | 昨日IP[31] | 昨日PV[133] | 当前在线[5] 51LA 样式： 总访问量 21,195，本月访问量 2,820，昨日访问量 93，今日访问量 103，当前在线 4 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"归档页面文章总数 在themes\\LoveIt\\layouts\\_default\\section.html中添加以下代码： \u003c!-- articles --\u003e \u003cspan style=\"font-size:.8rem;font-weight:500;\"\u003e {{- len ( where .Site.RegularPages \"Section\" \"posts\" ) | dict \"Nums\" | T \"totalPageNums\" -}} \u003c/span\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [totalPageNums] other = \"共 {{ .Nums }} 篇文章\" # themes\\LoveIt\\i18n\\en.toml [totalPageNums] other = \" {{ .Nums }} articles\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站总字数统计 参考Hugo 总文章数和总字数。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"底部链接设计 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"关于知识共享许可协议 可以看这篇“知识共享”（CC协议）简单介绍，笔者最终决定采用：知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站运行时间 在themes\\LoveIt\\layouts\\partials\\footer.html中加入以下代码。 {{- /* Hugo and LoveIt */ -}} {{- if ne .Site.Params.footer.hugo false -}} \u003cdiv class=\"footer-line\"\u003e # 运行时间在这里 \u003cspan id=\"timeDate\"\u003e{{ T \"worktime\" }}\u0026nbsp;|\u0026nbsp;\u003c/span\u003e \u003cscript\u003e var now = new Date(); function createtime() { var start_time= new Date(\"09/16/2020 00:00:00\"); now.setTime(now.getTime()+250); days = (now - start_time ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); var worktime = document.getElementById(\"timeDate\").innerHTML.replace(/time/, Math.floor(days)); document.getElementById(\"timeDate\").innerHTML = worktime ; } createtime(); \u003c/script\u003e {{- $hugo := printf `\u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener noreffer\" title=\"Hugo %v\"\u003eHugo\u003c/a\u003e` hugo.Version -}} {{- $theme := .Scratch.Get \"version\" | printf `\u003ca href=\"https://github.com/dillonzq/LoveIt\" target=\"_blank\" rel=\"noopener noreffer\" title=\"LoveIt %v\"\u003e\u003ci class=\"far fa-kiss-wink-heart fa-fw\"\u003e\u003c/i\u003e LoveIt\u003c/a\u003e` -}} {{- dict \"Hugo\" $hugo \"Theme\" $theme | T \"poweredBySome\" | safeHTML }} \u003c/div\u003e {{- end -}} i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [worktime] other = \"运行 time 天\" # themes\\LoveIt\\i18n\\en.toml [worktime] other = \"Almost time days.\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"小徽章 如果你喜欢这样的小徽章，前往shield进行DIY吧！参考动态小牌子制作 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"第三方库配置 使用jsdelivr加速第三方库文件的加载。 LoveIt主题对cdn文件的加载过程是这样的。 配置文件中补充cdn文件名称，可以直接复制主题的cdn文件到blog的assets/data/cdn/目录下。 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\"jsdelivr.yml\") # 位于 \"themes/LoveIt/assets/data/cdn/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/cdn/\" data = \"\" themes\\LoveIt\\layouts\\partials\\init.html中读取cdn文件中的数据，.Scratch.Set \"cdn\" $cdn设置全局变量，之后在其他文件中使用.Scratch.Get \"cdn\"获取cdn数据。 themes\\LoveIt\\layouts\\partials\\assets.html将cdn中的第三方库渲染后，追加在页面结尾部分。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"调用JS的三种方法 查找jsdelivr已有的第三方库，加入jsdelivr.yml中。 在themes\\LoveIt\\layouts\\partials\\assets.html中添加jquery.min.js，需要jquery文件位于assets\\js\\jquery.min.js。 {{- /* custom jquery */ -}} {{- $source := $cdn.jqueryJS | default ( resources.Get \"js/jquery.min.js\" ) -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} 配置文件中添加第三方库配置 # 第三方库配置 [page.library] [page.library.css] # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" # css路径：assets\\css\\custom.css customCSS = \"css/custom.css\" [page.library.js] # someJavascript = \"some.js\" # 位于 \"assets/\" # 或者 # someJavascript = \"https://cdn.example.com/some.js\" customJS = \"js/custom.js\" 完成以上配置后，可满足很多功能需求。但如果要拓展主题功能，像分类，列表页面，则需要学习Hugo语法。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"LoveIt - 4功能拓展","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"前言 本文介绍一些拓展功能，如文章页面功能增加二级菜单，相关文章推荐和赞赏。另外，使用脚本会大大简化写作后的上传流程。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"文章页面功能 这部分功能的拓展主要是用前端的JS和CSS，如果对前端不了解，可以参考放在Github上的网站源码。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"二级菜单 导航栏放都太多链接不分主次，不够简洁。尝试多种方案后，做出了现在的二级菜单。 使用bootstrap框架 引入了太多样式，界面被扰乱，不够友好。 Select标签 样式单一，不能修改。 Hover属性 多个二级菜单不能使用相同参数的绝对定位，拓展太麻烦。 最终方案是：引入Jquery，使用Jquery的slideToggle()方法。可拓展，不影响原有界面。步骤如下。 调整下拉菜单的样式 /* dropdown menus css*/ .dropdown { position: relative; display: inline; margin: 0px; } .dropdown-menu { position: absolute; left: 0; z-index: 1000; float: left; min-width: auto; padding: 2px 1px; font-size: 14px; text-align: left; list-style: none; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu-mobile { width: 100%; position: relative; background: transparent; text-align: center; } .dropdown-menu.show { display: block; } .dropdown-item { display: block; margin: .4rem 0.5rem; clear: both; font-weight: 400; color: #212529; text-align: inherit; white-space: nowrap; background-color: transparent; line-height: 1.5rem; } .btn { vertical-align: inherit; font-weight: 400; color: #212529; text-align: center; -webkit-user-select: none; user-select: none; background-color: transparent; font-size: 1rem; border-radius: .25rem; } /* dropdown menus css*/ 调用JS $(\".dropdown\").each(function() { $(this).on(\"click\", function(e) { // 收起其他菜单 if (isMobile()) { $(\".menu\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } else { $(\".menu-inner\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } e.stopPropagation(); var downmenu = $(this).children(\"div\"); // 展开菜单 downmenu.slideToggle(\"fast\"); // 点击其他地方，隐藏菜单 if (downmenu.is(\":visible\")) { $(document).one(\"click\", function() { downmenu.slideUp(\"fast\"); }); } }); }); # 移动端 function isMobile(){ return window.matchMedia(\"only screen and (max-width: 680px)\").matches; } 修改菜单模板，详细代码参考header.html \u003cdiv class=\"menu\" style=\"overflow: visible\"\u003e \u003cdiv class=\"menu-inner\"\u003e {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\" style=\"display: inline;\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu\" style=\"display: none;\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active {{ end }}\" href=\"{{ $url }}\"{{ with .Title }} title=\"{{ . }}\"{{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e {{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} {{- end -}} {{- /* Mobile header */ -}} {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu dropdown-menu-mobile\" style=\"display: none\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item\" href=\"{{ $url }}\" title=\"{{ .Title }}\"{{ i","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"相关文章推荐 参考Related Content themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*see also*/ -}} # 显示tag分类相关的前5篇文章 {{ $related := .Site.RegularPages.RelatedIndices . \"tags\" | first 5 }} {{ with $related }} \u003cdiv id=\"related-article\"\u003e \u003cp\u003e{{- T \"seeAlso\" -}}\u003c/p\u003e \u003cul\u003e {{ range . }} \u003cli\u003e\u003ca href=\"{{ .RelPermalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/div\u003e {{ end }} ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"赞赏 赞赏功能需要在data\\imgURL.toml中添加图片的URL。 alipay = \"https://img.xiaodejiyi.com/img/alipay.jpg\" weichatPay = \"https://img.xiaodejiyi.com/img/wechat%20pay.jpg\" 然后在模板文件themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /* sponsor */ -}} \u003cdiv style=\"text-align:center;margin-bottom:30px;\"\u003e \u003ch5 style=\"font-weight:600;margin-bottom:10px;\"\u003e「\u0026nbsp;{{- T \"thanksSponsor\" -}}\u0026nbsp;」\u003c/h5\u003e \u003cbutton id=\"rewardButton\"\u003e\u003cspan\u003e{{- T \"tips\" -}}\u003c/span\u003e\u003c/button\u003e \u003cdiv id=\"QR\" style=\"display: none;\"\u003e \u003cdiv id=\"wechat\" style=\"display:inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"wechat_qr\" src=\"{{ .Site.Data.imgURL.weichatPay }}\" alt=\"WeChat Pay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"weichatTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003cdiv id=\"alipay\" style=\"display: inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"alipay_qr\" src=\"{{ .Site.Data.imgURL.alipay }}\" alt=\"Alipay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"aliTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"版权声明 themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*copyright*/ -}} \u003cdiv id=\"copyright-container\"\u003e \u003cul class=\"post-copyright\"\u003e \u003cli class=\"post-copyright-author\"\u003e \u003cstrong\u003e{{- T \"articleAuthor\" -}}：\u003c/strong\u003e\u003ca href=\"{{ $.Site.Author.link | default .Site.Home.RelPermalink }}\" target=\"_blank\"\u003e{{ T \"penname\" }}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-link\"\u003e \u003cstrong\u003e{{- T \"articleLink\" -}}：\u003c/strong\u003e\u003ca href=\"#\" target=\"_blank\" title=\"{{ .Title }}\"\u003e{{- .Permalink | safeHTML -}}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-license\"\u003e \u003cstrong\u003e{{- T \"copyRight\" -}}：\u003c/strong\u003e {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e 需要使用T函数翻译并且根据不同语言传递参数。 [copyRightMsg] other = \"本站所有文章除特别声明外，均采用 {{ .preCopyRight }} 转载请注明来自 {{ .afterCopyRight }} \" .Site.Params.footer.license在config.toml中设置: license = 'https://creativecommons.org/licenses/by-nc-sa/4.0/' ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"同步文章到服务器 如果需要了解同步文章到对象存储平台，请参考Hugo 静态网站部署及免费 HTTPS 证书配置和OSS常用工具汇总。 文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 文章同步到服务器的步骤如下。 本地创建博客文章 配置SSH免密登陆 使用Python脚本生成网站静态资源，提交变更 Github Action使用rsync同步网站静态资源到服务器，并使用atomic-algolia同步index.json到Algolia。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"创建文章 在archetypes目录下的创建模板文件，使用hugo new --kind post-bundle posts/my-post生成指定模板的样例文章，不需要每次复制文章头部参数。 archetypes\\post-bundle\\index.md文件内容。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"SSH免密登陆 注意！服务器端要配置authorized_keys。参考设置 SSH 通过密钥登录 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"注册Algolia 使用Algolia搜索引擎为博客提供搜索功能。参考搜索配置 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"本地同步与备份脚本 在博客目录下执行该脚本，先推送blog到Github的blog仓库，再本地备份。(相信看到这里的读者都有Github帐号了) import time import os, sys def main(msg): # 备份blog/ print(\"*\"*10+\"push blog/\"+\"*\"*10, end=\"\\n\\n\") # 生成静态页面 os.system('hugo') # 需要安装Git os.system('git add .') os.system('git commit -m \"{}\"'.format(msg)) os.system('git push') local_back = input('\\n本地备份？提示: y\\n') if local_back == 'y': #7z、winrar压缩参数是一样的，只有winrar的话，7z换成winrar也可以运行 os.system(r'7z a D:\\src\\xxxxx.rar D:\\src\\xxxxx') os.system(r'move D:\\src\\code\\xxxxx.rar D:\\backup\\xxxxx') print('本地备份完成！') print('over...') if __name__ == '__main__': msg = input('commit: ') main(msg) 如果需要安装Git，试试Scoop，它用来安装应用程序非常方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"Github Action blog/文件根目录下创建package.json文件，并在scripts模块中加入\"algolia\": \"atomic-algolia\"。 { \"name\": \"algolia\", \"version\": \"0.2.0\", \"description\": \"atomic-algolia package\", \"private\": true, \"scripts\": { \"algolia\": \"atomic-algolia\" } } 在Github的Blog仓库中添加Secrets变量 同步index.json到Algolia需要配置如下变量： ALGOLIA_ADMIN_KEY ALGOLIA_APP_ID ALGOLIA_INDEX_NAME rsync同步需要配置如下变量 HOST PORT USER REMOTE_PATH Nginx中配置的网站根目录 SSH_KEY 使用Github Action，创建workflow，复制以下代码。 name: deploy_blog on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps: - name: Check Out uses: actions/checkout@v2 #同步blog搜索 - name: Use Node.js uses: actions/setup-node@v1 with: node-version: '12.x' - name: Install automic-algolia env: ALGOLIA_APP_ID: ${{ secrets.ALGOLIA_APP_ID }} ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }} ALGOLIA_INDEX_NAME: zh-cn ALGOLIA_INDEX_FILE: \"./public/index.json\" run: | npm install atomic-algolia npm run algolia # 同步英语文章的json - name: en json env: ALGOLIA_APP_ID: ${{ secrets.ALGOLIA_APP_ID }} ALGOLIA_ADMIN_KEY: ${{ secrets.ALGOLIA_ADMIN_KEY }} ALGOLIA_INDEX_NAME: en ALGOLIA_INDEX_FILE: \"./public/en/index.json\" run: | npm run algolia - name: deploy to server uses: AEnterprise/rsync-deploy@v1.0 env: DEPLOY_KEY: ${{ secrets.SSH_KEY }} # avzr参数，增量备份本地文件。-delete 删除目标地址中本地没有的文件 ARGS: \"-avzr --delete\" SERVER_PORT: ${{ secrets.PORT }} FOLDER: \"./public/\" SERVER_IP: ${{ secrets.HOST }} USERNAME: ${{ secrets.USER }} SERVER_DESTINATION: ${{ secrets.REMOTE_PATH }} 如果出现问题，先在本地创建linux虚拟机，测试rsync命令，确定服务器同步是否正常。 代码改变世界，现在，写作多么简单。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:5","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo官方文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"LoveIt - 5页面模板","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"前言 最初在制作友链界面时，没有学习Hugo框架，一头雾水。网上有关的教程甚少，只能去学一遍Hugo。 在学习Hugo的过程中，了解了列表模板，分类模板。开发了几个功能页面，如：留言板，友链，记忆分类等。 本文介绍这些功能页面。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"里程碑页面 首先需要了解头部参数type，通过type指定文章使用的模板类型，默认为page类型。 要注意特殊模板的文章放在一般content根目录下，模板放在layouts目录下。 里程碑界面依据themes\\LoveIt\\layouts\\posts\\single.html修改，删除赞赏，相关文章推荐等功能。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- .Scratch.Delete \"this\" -}} {{- $params := .Scratch.Get \"params\" -}} {{- $toc := $params.toc -}} {{- if eq $toc true -}} {{- $toc = .Site.Params.page.toc | default dict -}} {{- else if eq $toc false -}} {{- $toc = dict \"enable\" false -}} {{- end -}} {{- /* Auto TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"toc\" id=\"toc-auto\"\u003e \u003ch2 class=\"toc-title\"\u003e{{ T \"contents\" }}\u003c/h2\u003e \u003cdiv class=\"toc-content{{ if eq $toc.auto false }} always-active{{ end }}\" id=\"toc-content-auto\"\u003e\u003c/div\u003e \u003c/div\u003e {{- end -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e \u003ci class=\"fas fa-monument fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} \u003c/h1\u003e {{- /* Static TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003cdiv id=\"post-footer\"\u003e\u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 这个模板也可以制作“爱情故事”。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"关于页面 相对里程碑界面，关于界面又删除了目录。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e{{ .Title }}\u003c/h1\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c!-- 这里的版权声明是根据文章内容添加的，可删除 --\u003e {{- /*copyright*/ -}} {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 类似的留言板页面可以使用默认的\"page\"类型。如果页面中有标题，同时不希望有目录，“关于”页面的模板更合适。或者使用头部参数toc: false禁用目录。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"列表模板 列表页面是在文章的头部自定义参数，在模板中渲染。例如友链模板，参考LoveIt-extend/content/links/index.zh-cn.md。 头部参数需要按照yml文件的格式，注意不能用tab缩进。 links: me: name: 我 weight: 1 people: - name: 朤尧 url: https://www.xiaodejiyi.com/ avatar: https://www.gravatar.com/avatar/ae94c8d8ca3d56eb035a3e62c2595150?s=240\u0026d=mp description: just do sth i should do. friends: name: 朋友 weight: 2 people: links模板为： \u003c!-- links按照weight排序，排序后改变了原来的数组结构，相当于weight变为key值，其他数据组成value --\u003e {{- range $weight, $website := sort .Params.links \"weight\" -}} \u003ch3 id=\"{{ $website.name }}\" tabindex=\"-1\" style=\"outline: none;\"\u003e\u003ca href=\"#{{ $website.name }}\"\u003e\u003c/a\u003e{{ $website.name }}\u003c/h3\u003e \u003cul style=\"list-style: none;\" id=\"firendLink\"\u003e {{- range $website.people -}} \u003cli\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"media\"\u003e \u003cdiv class=\"media-left\"\u003e\u003cimg src=\"{{ .avatar }}\" width=\"55\"\u003e\u003c/div\u003e \u003cdiv class=\"media-content\"\u003e \u003ci class=\"fa fa-user-ninja fa-fw\"\u003e\u003c/i\u003e \u003c!-- . 是 当前作用域 --\u003e {{ .name }}\u0026nbsp;\u003ci class=\"fa fa-link fa-fw\"\u003e\u003c/i\u003e \u003ca href=\"{{ .url }}\" target=\"_blank\"\u003e{{ .url }}\u003c/a\u003e \u003cp\u003e{{ .description }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/li\u003e {{- end -}} \u003c/ul\u003e {{- end -}} 不过这里有一个Bug，content\\links\\index.zh-cn.md正文部分不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 生成目录的代码： \u003c!-- 修改前的侧边目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e \u003c!-- 修改后links的目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e {{- /* modify director */ -}} {{- range $weight, $website := sort .Params.links \"weight\" -}} {{- $groupName := dict \"Content\" $website.name \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003cli\u003e\u003ca href=\"#{{ $groupName }}\"\u003e{{ $groupName }}\u003c/a\u003e\u003c/li\u003e {{- end -}} \u003c/ul\u003e \u003c/nav\u003e \u003c/div\u003e \u003c/div\u003e 问题不大，还能用。同理，可以使用列表模板制作说说，相册，视频页面，只是样式设计上不同。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"分类模板 分类模板，需要考虑模板的渲染顺序，这个顺序很长，参考Hugo’s Lookup Order，而且需要其他背景知识，如type的详细分类等等。 不过，按照以下步骤，你不需要深入研究这个复杂的顺序。 在config.toml中配置分类 categories和tags为默认分类 [taxonomies] # 左边单数，右边复数形式 category = \"categories\" tag = \"tags\" booklist = \"booklist\" 创建样例文章 在文章的头部参数中添加分类，注意要有中括号： categories: [\"demo1\"] tags: [\"demo2\"] booklist: [\"demo3\"] 创建分类模板 首先要覆盖主题默认的分类模板，分析默认模板themes\\LoveIt\\layouts\\taxonomy\\list.html的代码： ... {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} {{- printf \"%v - %v\" (T $taxonomy | default $taxonomy) .Title -}} {{- end -}} ... 可以发现，默认模板中包含了category,tag和其他，这三种模板。 所以覆盖需要将这个模板拆开，复制到博客的layouts目录下，分别命名为：categories,tags,taxonomy。内容上可以不修改，也可以将if语句剪枝。例如layouts\\categories\\list.html： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 覆盖之后，创建booklist分类的模板，复制categories分类的模板，修改为： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"booklist\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 是的，将if判断的category改为booklist，再换个Font Awesome图标。不要忘了还有layouts\\booklist\\terms.html也要改，同样修改if判断，改标题，改图标。 刷新界面，看看booklist分类有没有demo3的文章。如果没有，hugo server重新启动，现在应该有了。Hugo在这方面不能实时刷新。 首页文章增加分类 回到首页，你会发现，文章只有categories和tags的分类：demo1和demo2。添加demo3需要在themes\\LoveIt\\layouts\\_default\\summary.html中加入新的分类。 {{- $booklist := slice -}} {{- range .Params.booklist -}} {{- $category := partialCached \"function/path.html\" . . | printf \"/booklist/%v\" | $.Site.GetPage -}} {{- $booklist = $booklist | append (printf `\u003ca href=\"%v\"\u003e\u003ci class=\"fas fa-file-alt fa-fw\"\u003e\u003c/i\u003e%v\u003c/a\u003e` $category.RelPermalink $category.Title) -}} {{- end -}} {{- with delimit $booklist \"\u0026nbsp;\" -}} \u0026nbsp;\u003cspan class=\"post-category\"\u003e {{- . | safeHTML -}} \u003c/span\u003e {{- end -}} 继续加其他分类，只需要再复制一段，用编辑器Ctrl+H替换代码中的booklist。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"笔记页面 博客最初的设计是Hugo写文章，VuePress记笔记。在写这篇教程的过程中发现，如果把OneNote记的笔记放到VuePress上，再写文章，这会消耗大量时间。 不过VuePress能给文章加上一个背景知识。权衡之后放弃了VuePress。 如果你需要搭建一个笔记网站，可以考虑VuePress和Hugo的learn主题。 VuePress搭建过程可以参考B站教程和VuePress 中文文档。 搭建时需要注意这两点： Auto Sidebar插件自动生成侧边导航栏，如果没有这个插件，VuePress会繁琐得不想再用。 内置搜索只为页面的标题、h2、h3以及tags构建搜索索引。docsearch只支持技术文档，不支持博客索引和商业内容。Algolia搜索的方法可行，但是配置Algolia步骤很麻烦。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"最后 博客搭建教程结束，如果你想要添加更多的功能，更灵活的开发自己的博客，那么学习Hugo框架吧！只是这需要投入一些成本，学习Hugo花了11个小时，开发又用了95个小时。或许你还需要了解下自媒体以及公众号，知乎等其他写作平台，这消耗了28个小时。（番茄工作法统计得出） 专心于博客的内容创作或许是更好的选择，希望这篇教程可以帮到你。 如果想学习Hugo，那么Hugo论坛是一个不错的地方。 我为什么要搭博客呢？把知识留下来！ ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:7:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"参考 Hugo官方文档 LoveIt-extend LoveIt Theme ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:8:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"alloc创建一个对象","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","series":null,"tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"​ alloc创建一个对象 dealloc销毁对象 retain增加对象的保留计数器值 release减少对象的保留计数器值 retainCount获得保留计数器的当前值 autorelease将来一个时间自动释放 NSAutoreleasePool自动释放池 ","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"NSArray","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/","series":null,"tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSArray 是一个Cocoa类，用来存储对象的有序列表 arrayWithObjects用来创建新的NSArray initWithObjects 初始化数组并赋值 objectAtIndex获取指定索引处的对象 componentsSeparatedByString切分NSArray componentsJoinedByString合并NSArray NSMutableArray可变数组 arrayWithCapacity创建可变数组 addObject在数组末尾添加对象 removeObjectAtIndex删除特定索引处的对象 ","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/:0:0","series":null,"tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSEnumerator","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/","series":null,"tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSEnumerator 用来描述集合运算的方式 objectEnumerator向数组请求枚举器 reverseObjectEnumerator从后向前浏览集合 nextObject下一个对象 NSDictionary字典，在给定的关键字下存储一个数值 dictionaryWithObjectsAndKeys创建字典 objectForKey获取字典中的值，向方法传递之前用来存储该值的关键字 NSMutableDictionary可变字典 dictionary可以向类NSMutableDictionary发送dictionary消息创建可变字典 dictionaryWithCapacity创建可变字典 setObject: forkey:给字典添加元素 removeObjectForKey删除可变字典中的关键字 ","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSNumber","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","series":null,"tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSNumber 用来包装基本数据类型 numberWithInt创建NSNumber intValue提取NSNumber NSValue可以包装任意值 valueWithBytes: objCType:创建新NSValue getValue提取NSValue @encode编译器指令可以接受数据类型的名称并为你生成合适的字符串 valueWithSize将struct型数据转换成NSValue NSNull代表无 NSFileManager对文件系统进行操作 defaultManager创建NSFileManager对象 stringByExpandingTildeInpath替换当前用户的主目录 NSDirectoryEnumerator 是NSEnumerator的子类，调用nextObject时返回该目录中一个文件的另一个路径，这个方法也可以搜索子目录。 pathExtension输出文件的扩展名(去掉了扩展名前面的点) ","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSPredicate类","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/","series":null,"tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"NSPredicate类 用于制定过滤器的条件 +predicateWithFormat创建谓词 -evaluateWithObject通知谓词根据指定的对象计算自身的值 -filteredArrayUsingPredicate循环过滤数组内容，根据谓词计算每个对象的值，并将值为Yes的对象累积到将被返回的新数组中 copy指针复制，浅拷贝，返回的是不能修改的对象 mutableCopy对象复制，深拷贝，返回的是可修改的对象 -filterUsingPredicate针对可变数组进行过滤及返回 predicateWithSubstitutionVariables构造新的专用谓词，创建一个键/值对字典，其中，键是变量名，值是插入谓词的内容 \u0026\u0026 AND 和 || OR 或 ! NOT 非 BETWEEN { }之间 BEGINSWITH检查某个字符串是否以另一个字符串开头 ENDSWITH检查某个字符串是否以另一个字符串结尾 CONTAINS检查某个字符串是否在另一个字符串内部 [c]不区分大小写 [d]不区分发音符号 [cd]不区分以上两项 LIKE 匹配运算符 ","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/:0:0","series":null,"tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"笔记1","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/","series":null,"tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"​ 笔记1 \\n换行符 new 是alloc和init的结合 double精度是float的两倍 char单个字符 %o 八进制整数 %x十六进制整数 %f浮点计数法 %e科学计数法 %g %a和%f一样 long扩展值域，输出时要在%后添加l long long 特定扩展%后加ll short缩小值域 %后加h unsigned正数(无符号) id NSLog字符%p ","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/:0:0","series":null,"tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"导航控制器和表视图(一)","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/","series":null,"tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"​ 导航控制器和表视图(一) UINavigationController 导航控制器 accessoryType 附件类型 navigationController 导航控制器属性 pushViewController: 入栈方法 viewWillAppear: 视图出现时加载 NSIndexPath 属性,索引路径 UITableViewCellAccessoryCheckmark 属性,检查标记(对勾) UITableViewCellAccessoryNone 属性,无标记 deselectRowAtIndexPath 取消选中某行 buttonWithType 按钮格式 setBackgroundImage 设置背景图片 addTarget 添加目标 forControlEvents 按钮事件 accessoryView 附加视图 buttonTapped: 轻击按钮 ","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/:0:0","series":null,"tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"多视图应用程序","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","series":null,"tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"多视图应用程序 UITabBarController标签栏界面 UINavigationController导航栏界面 addSubview添加视图，是将view加到所有层的最顶层 insertSubview在索引位置插入视图 initWithNibName: bundle:加载nib文件 removeFromSuperview从父视图删除 beginAnimation: context:声明动画块 setAnimationDuration:动画持续时间 setAnimationCurve:动画曲线 setAnimationTransition:动画转换类型 ","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:0","series":null,"tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"更丰富的用户界面(二)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/","series":null,"tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"更丰富的用户界面(二) showInView:在视图中显示 view视图 { UIAlertViewDelegate警报委托控件 UIActionSheetDelegate操作表委托控件(在例子中作为协议) actionSheet: didDismissWithButtonIndex:(在例子中作为协议的方法) } buttonIndex 按钮的索引 cancelButtonIndex 取消按钮的索引 { UIAlertView 警报控件 initWithTitle:初始化警报 message:警报内容 delegate:警报响应的委托 cancelButtonTitle:取消按钮 otherButtonTitles:其它按钮 } viewDidLoad视图加载方法 viewDidUnload视图卸载方法 UIImage图像控件 imageNamed: 加载图像文件 UIImageView 图像视图控件 initWithImage: 初始化图像视图 ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/:0:0","series":null,"tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"更丰富的用户界面(一)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/","series":null,"tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(一) resignFirstResponder取消第一响应者状态 UISlider滑块控件 UISegmentedControl分段开关控件 #define定义常量 UISwitch切换开关控件 UITxtField文本控件 { isOn 获取切换开关控件的状态 setOn设置切换开关控件的状态 animated移动方式 YES为缓慢 NO为瞬间 } selectedSegmentIndex分段控件索引 hidden隐藏 { UIActionSheet操作表控件 initWithTitle:初始化操作表 delegate:操作表响应的委托 cancelButtonTitle:取消按钮 destructiveButtonTitle:继续按钮 otherButtonTitles:其它按钮 } ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/:0:0","series":null,"tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"键/值编码","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/","series":null,"tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"​ 键/值编码 count计数 -valueForKey: 读取方法,以字符串的形式向对象发送消息 -setValue: forKey: 设置方法,以字符串的形式向对象发送消息(设置标量值需要封装数据) -valueForKeyPath: 路径读取方法 -setValue: forKeyPath: 路径设置方法 @运算符,它获取左侧指定的集合,对该集合中的每个对象使用右侧的键路径,然后将结果转换为一个集合 @count计数 @sum求和 @avg求平均值 @min取最小值 @max取最大值 @distinctUnionOfObjects取交集 lastObject方法,最后一个对象 dictionaryWithValuesForKeys它接受一个字符串数组,该数组中的数据成为键,对每个键使用读取方法,然后为键字符串和刚才获得的值构建一个字典. setValuesForKeysWithDictionary批量修改,用字典来修改键值 setNilValueForKey重设nil意义 valueForUndefinedKey:读取未知键 setValue: forUndefinedKey: 设置未知键 ","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/:0:0","series":null,"tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"特性","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/","series":null,"tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"​ 特性 @property表示声明了一个新对象的属性，自动声明属性的setter和getter方法 @synthesize 表示创建该属性的访问器 readwrite读写属性 readonly只读 ","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/:0:0","series":null,"tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"文件加载和保存","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/","series":null,"tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"​ 文件加载和保存 date获取当前的时间和日期 dateWithTimeIntervalSinceNow获取与当前时间相隔一定时差的日期 const它限定一个变量不允许被改变 writeToFile:atomically:将属性列表写入文件 arrayWithContentsOfFile读取文件 code编码 decode解码 encodeSomething: forKey:编码方法 decodeSomethingForKey解码方法 NSKeyedArchiver归档 archivedDataWithRootObject创建归档实例 NSKeyedUnarchiver重新创建档案,和归档相反 unarchiveObjectWithData重新创建档案实例 ","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/:0:0","series":null,"tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"协议","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/","series":null,"tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"​ 协议 @protocol创建协议 encodeWithCoder用于接受对象的实例变量并将其转换为NSCoder类的对象 initWithCoder从NSCoder类的对象中提取经过转换的冻结的实例变量并使用它们初始化一个新对象 copyWithZone复制到一块可供分配的内存区域 class所属的类 allocWithZone分配内存并创建一个该类的新对象 @optional协议中的可选方法 @required协议中的必选方法 ","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/:0:0","series":null,"tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"自动旋转和自动调整大小","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/","series":null,"tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"​ 自动旋转和自动调整大小 shouldAutorotateToInterfaceOrientation:旋转支持 willAnimateRotationToInterfaceOrientation: duration: 此方法将在旋转开始之后，最后的旋转动画发生之前自动调用 UIInterfaceOrientation界面方向控件 NSTimeInterval间隔时间 frame框架 CGRectMake大小和位置 transform变换 bounds边界 ","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/:0:0","series":null,"tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"2021 ","date":"2020-07-01","objectID":"/milestone/:0:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"5月 10日，开始学习《Shark恒零基础百集软件逆向教程》，暂时学完前两期。历时两周。 25日，开始学习《2020DNF》、《2020DOF》、《2021DNF不完整》系列教程。历时5天。 30日，开始学习《派大星–英雄联盟LOL》、《派大星–亿万僵尸》、《CE WALKer》，历时9天。 ","date":"2020-07-01","objectID":"/milestone/:1:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"6月 8日，开始学习《小冷过游戏检测技术》及相关过检测教程，历时4天。期间还看了WOW按键视频。 12日，开始学习《植物大战僵尸》，历时9天。 23日，开始学习《CS》。 27日，开始各种尝试，然后放弃，继续看其它教程。 ","date":"2020-07-01","objectID":"/milestone/:2:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"7月 3日，开始学习《郁金香2020 WOW》，教程未完待续。历时19天。 24日，开始学习《郁金香2019 VS2010》，教程不完整，历时16天。 26日，开始利用闲暇时间搭建博客，用于记录笔记及心路历程。尝试搭了5个不同的博客，第一款基于jekyll框架，效果不理想，之后不断摸索。 ","date":"2020-07-01","objectID":"/milestone/:3:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"8月 4日，博客最终锁定了Hugo框架LoveIt模板，也就是现在看到的样子。 10日，开始学习《任鸟飞2015天涯明月刀》，历时18天。 28日，开始学习《任鸟飞2019 C++之灵魂起源》，历时3天 ","date":"2020-07-01","objectID":"/milestone/:4:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"9月 1日，开始学习《任鸟飞2016 画江山》，历时18天 19日，开始学习《任鸟飞 封包的加密与解密、线程发包专题》，历时8天 27日，开始学习《任鸟飞逆向C++基础篇》,历时4天 ","date":"2020-07-01","objectID":"/milestone/:5:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"10月 1日，《任鸟飞逆向C++进阶篇》只学了前3节，其它需要付费。开始学习《飞郁网络培训 2018-2019》,历时12天 13日，粗看《3D游戏逆向试看》，历时6天 19日，粗看《任鸟飞2016 LOL 不完整》，历时6天 25日，开始折腾《幻想神域》 ","date":"2020-07-01","objectID":"/milestone/:6:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"11月 12日，开始学习《任鸟飞2022基础》，未完待更 14日，开始学习《飞郁C++反汇编》 17日，开始学习《任鸟飞2021公开课》，未完待更 26日，开始学习《梦三国》及《飞郁2019-10在线班》 ","date":"2020-07-01","objectID":"/milestone/:7:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"12月 14日，开始学习《用C++和人工智能做游戏脚本》,作者还在连载中 2022 ","date":"2020-07-01","objectID":"/milestone/:8:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"1月 9日,开始学习《C++手游脚本中控》 16日,开始学习小土堆的《yolov5调试与讲解》 20日,开始学习神秘的二进制‘s 《yolov4》,读完第3节, 4、5、6没有读 27日,开始学习无名氏的《yolov5》 ","date":"2020-07-01","objectID":"/milestone/:9:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"2月 8日,开始学习木酥的yolov5 9日,开始学习小土堆的PyTorch 入门实战 15日,开始学习郁金香伙伴的 ImGui ,其中前15节有视频,后面的部分只有文字版(郁金香论坛) 17日,开始学习 半个人的 ImGui 18日,开始学习ImGui的DX系列 21日,开始学习飞郁2019-10在线班 ,读完2019.11.19-跨进程注入调用多个参数的CALL 数组指针,以后继续 23日,开始学习红叶谷 yolov5和辞去归来兮了了 C++实现HOOK D3D绘图函数 24日,开始学习夜风_来袭 C++逆向(未完) ","date":"2020-07-01","objectID":"/milestone/:10:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"3月 26日,开始学习iOS逆向ML GitHub ","date":"2020-07-01","objectID":"/milestone/:11:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"4月 13日,开始学习菲佣教你写出优美的脚本 ","date":"2020-07-01","objectID":"/milestone/:12:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"6月 26日，开始学习ios底层原理 MJ精选 研究目录 Shark恒零基础百集软件逆向教程（23:28） 《2020DNF》（6:53） 《2020DOF》（3:08） 《2021DNF不完整》（12:46） 派大星–英雄联盟LOL（3:16） 派大星–亿万僵尸（2:13） CE WALKer（6:38） 小冷过游戏检测技术（3:38） 植物大战僵尸（19:19） CS（4:54） 郁金香2020 WOW（21:13） 郁金香2019 VS2010（21:08） 任鸟飞2015 天涯明月刀 （26:40） 任鸟飞2019 C++之灵魂起源 不完整（12:07） 任鸟飞2016 画江山 （14:00） 任鸟飞 封包的加密与解密、线程发包专题 （4:06） 任鸟飞逆向C++基础篇 （6:21） 任鸟飞逆向C++进阶篇 收费（19:26） 任鸟飞逆向C++高级篇 收费（7:08） 飞郁网络培训 2018-2019 (17:08) 3D游戏逆向试看（8:17） 任鸟飞2016 LOL 不完整（6:24）缺1,3,4,5,8,13 任鸟飞2022基础 未完待续 飞郁C++反汇编 (6:02) 任鸟飞2021公开课 (24:37) 梦三国 (1:15) 飞郁2019-10在线班 (38:06) 用C++和人工智能做游戏脚本(12:51) 易17中控入门(8:12) C++手游脚本中控(14:03) 小土堆的yolov5调试与讲解 (2:35) 神秘的二进制‘s yolov4 (2:30) 小土堆的PyTorch 入门实战 (2:35) 木酥的yolov5 (4:43) 无名氏 yolov5 (0:59) 郁金香伙伴的 ImGui (2:00) 半个人的 ImGui (2:12) ImGui的DX系列(04:47) 任鸟飞FPS(02:13) 逆风魔兽 (11:40) 逆风游戏逆向C++\u0026易语言编程特训班(05:10) 逆风游戏安全逆向编程暑期班 微尘系列教程 IOS逆向分析 iOS底层原理班-大神MJ精选 安卓逆向 AGP论坛驱动教程 逆向4_X64dbg_翠翠妹子 (03:48) 汇编-魔鬼作坊 (03:13) 重楼(12:32) 梦无极过游戏驱动保护教程（25:20） 唐三藏逆向（02:11） HaiVince CE插件（00:16）需加群 若水过驱动 浴血凤凰 2019 dnf 2019年过游戏TP驱动保护+绝地BE检测+工具 黑马程序员C++教程 吕鑫MFC教程 赶码人 安卓手游戏绘制(01:44) 辞去归来兮了了 C++实现HOOK D3D绘图函数(00:46) 像真画 过驱动 (07:27) 夜风_来袭 C++逆向(03:30) WDF驱动(05:30) 红叶谷 yolov5(00:53) DriverEntry C++ 大漠 全民奇迹(40:25) 柠檬有多萌 C++(22:32) 任鸟飞2015天涯明月刀 完整 (28:58) iOS逆向ML GitHub (99:00) 菲佣教你写出优美的脚本 (07:41) TS Remote API 对接开发 (01:58) ","date":"2020-07-01","objectID":"/milestone/:13:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"教育背景 **学校名称:**咸宁教育学院 **所学专业:**计算机及应用 学校名称:中北大学 所学专业: 工商管理 荣誉奖励 2010 年获“优秀员工”称号 2012 年获“岗位能手”称号 2014 年获“优秀班组长”称号 工作经历 个人信息 姓名:辛琪 性别:男 出生年月:1983.08 联系电话:18635533702 电子邮件:xinqinew@163.com 家庭住址:侯堡 11 区 35 号楼 就读时间: 2003.09-2006.06 **学历学位:专科 就读时间:**2007.03-2010.01 学历学位:函授本科 **公司名称:**煤基合成油 **职位名称:**电气运行班长 工作经历: 2007 年 6 月至 9 月在太原工贸参加培训。 2007 年 10 月至 2008 年 2 月在河南义马气化厂实习。 2008 年 3 月至今在煤基油电气车间从事总降运行工作。 工作描述: 在职期间，担任班长职务，主要负责总降运行和调度工作。每年全厂大 修期间，负责变电站内高低压配电室和电容器室的检修工作。多年来，先后 参加并组织了锅炉、净化、气化、空分、尿素、合成各开闭所的冲击送电、 无功补偿与电压整定等工作。 工作之余，不断从事计算机软件编程等方面的研究，曾独立制作手游 APP、个人网站及博客等。 个人技能 熟练操作 Word、Excel、PPT、Photoshop 等软件。 具有一定的软件编程能力，熟悉 c 语言、lua 脚本语言、objective-c 语言 及 swift 语言。 拥有机动车 C1 驾照及 10 年以上驾龄。 自我评价 性格乐观开朗，能迅速和同事融洽相处、乐于助人、富有爱心。 丰富的工作经验和较强的组织、沟通和协作能力。 工作主动积极，能吃苦耐劳，富有责任感和团队合作精神。 ","date":"0001-01-01","objectID":"/1/01/%E7%AE%80%E5%8E%86/:0:0","series":null,"tags":null,"title":"","uri":"/1/01/%E7%AE%80%E5%8E%86/"},{"categories":null,"content":"高压电工作业 1 ()KV以上的电气设备,在没有专用验电器的 特殊情况下,可以使用绝缘棒代替代替验电 器,根据绝缘棒端有无火花和放电来判断有 无电压。 A.20 B.25 C.35 C 2 ()是我国第一部规范安全生产的综合性基础 法律。 A.《刑法》 B.《劳动法》 C.《安全生产法 》 C 3 电量的单位是()。 A.A B.V C.C C 4 电流的单位是()。 A.A B.mV C.W A 5 在配电系统中下列()是不允许出现的。 A.TN-S-系统 B.TN-C系统 C.TT系统 A 6 《生产经营单位安全培训规定》规定,从业 人员在调整工作岗位或离岗()年以上重新上 岗时,应重新接受安全培训。 A.1 B.2 C.3 A 7 保护接地系统属于()。 A.TN-S系统 B.TN- C.系统 D.IT系统 C 8 保护接零不能减低漏电设备对地电压。() A.对 B.错 B 9 爆炸性气体、蒸气、薄雾的组别是按()划分 的。 A.爆炸极限 B.闪点 C.引燃温度 C 10 避雷器与变压器之间的电气距离越大越好。 () A.对 B.错 B 11 变配电所的电气设备操作,必须两人同时进 行。() A.对 B.错 A 12 变压器内的绝缘油在正常时有很好的电气绝 缘性和合适的粘度。() A.对 B.错 A 13 变压器停电检修时,应先对地进行放电。() A.对 B.错 A 14 测量任何接地电阻都不受天气的限制。() A.对 B.错 B 15 厂区、居民区内的低压架空线路导线应采用 绝缘导体。() A.对 B.错 A 16 处于污秽地区的变配电所,对室外电气设备 的巡视检查应根据天气情况及污秽程度来确 定。() A.对 B.错 A 17 串联电路中各元件上的电流不一定相等。() A.对 B.错 B 18 单位时间内通过导体横截面的电荷量定义为 电流。() A.对 B.错 A 19 导体在磁场中运动时,一定会产生感应电动 势。() A.对 B.错 B 20 电场中某点的电场强度即单位正电荷在该点 所受到的电场力。() A.对 B.错 A 21 电工作业是指对电气设备进行运行、维护、 安装、检修、改造、施工、调试等作业(不 含电力系统进网作业)。() A.对 B.错 A 22 电火花和电气设备的危险温度都可能引起电 气火灾。() A.对 B.错 A 23 电击是电流直接作用于人体的伤害。() A.对 B.错 A 24 电缆接头事故占电缆事故的(),其安全运行 十分重要。 A.60% B.70% C.80% B 25 电流互感器的二次回路中应该装熔断器。() A.对 B.错 B 26 电流互感器的一次电流决定于一次负荷的大 小,而与二次负荷无关。() A.对 B.错 A 27 电流互感器将一次回路的大电流变换为二次 回路的标准值,额定二次电流为5A。() A.对 B.错 A 28 电能表常数是每用电()。 A.1KW.h B.1KW C.1h A 29 电气设备存在有缺陷或过负荷时,至少每小 时巡视检查一次,直至设备正常。() A.对 B.错 B 30 电气设备发生重大事故又恢复运行以后,对 事故范围内的设备进行特殊巡视检查。() A.对 B.错 A 31 电压的单位是()。 A. B.V C.J B 32 电压互感器将一次回路的高电压变换为二次 回路的标准值,通常额定电压为100V。() A.对 B.错 A 33 电压互感器盘、柜内的二次回路接线不应有 接线头。() A.对 B.错 A 34 电压与电动势的方向是一致的。() A.对 B.错 B 35 电阻的单位是Ω,电感和电容的单位也是Ω 。() A.对 B.错 B 36 跌落式熔断器是分相操作的。() A.对 B.错 A 37 独立避雷针的接地体与其他临近接地体之间 的最小距离为()m。 A.10 B.5 C.3 C 38 短路保护的动作时间应符合电气线路稳定性 的要求。() A.对 B.错 A 39 对架空线路等高空设备进行灭火时,人体位 置与带电体之间的仰角不应超过45°。() A.对 B.错 A 40 发电机和电动机等旋转电机着火时,不可以 用1211灭火剂灭火。() A.对 B.错 B 41 辅助安全用具的绝缘强度不足以承受电气设 备的工作电压,只能加强基本安全用具的作 用。() A.对 B.错 A 42 高压负荷开关的分断能力与高压断路器的分 断能力基本相同。() A.对 B.错 B 43 高压隔离开关不能用来切断短路电流,但在 合闸状态能可靠地通过负荷电流和短路电流 。() A.对 B.错 A 44 隔离开关主要用来隔断电源,不能用来操作 电压互感器。() A.对 B.错 B 45 工艺过程中产生的静电除可能给人以电击 外,还可以引起爆炸。() A.对 B.错 A 46 工作许可人可以签发工作票。() A.对 B.错 B 47 供配电系统由一次部分和二次部分组成。() A.对 B.错 A 48 互感器二次回路不受一次回路的限制,可采 用不同的接线形式,因而接线灵活方便,适当 改变二次接线即可实现对二次设备的维护。 () A.对 B.错 A 49 互感器使测量仪表与高压电隔离,保证测量 仪表和人身安全。() A.对 B.错 A 50 架空线缆电杆埋设深度不得小于2m,并不得 小于杆高的()。 A.五分之一 B.六分之一 C.五分之一 B 51 架空线路指档距超过()m,利用杆塔敷设的高 、低压力线路。 A.15 B.20 C.25 C 52 简单的电路由电源、负载、导线和开关组成 。() A.对 B.错 A 53 建立劳动关系,应当订立劳动合同。() A.对 B.错 A 54 接班人员必须按规定时间到岗,交班人员应 办理交接手续后方可离去。() A.对 B.错 B 55 接地线应多股软裸铜线,其界面应符合短路 电流的要求,但不得小于()mm²。 A.20 B.25 C.30 B 56 接户线与树木之间的最小距离不得小于()m 。 A.0.1 B.0.2 C.0.3 C 57 绝缘鞋和绝缘靴都属于低压基本安全用具。 () A.对 B.错 B 58 可以从电压表的指示判断电压互感器熔丝熔 断的具体情况。() A.对 B.错 A 59 临时架空线的高度和其它间距原则上不得小 于正规线路所规定的限值,必要的部位应采 取屏护措施,长度一般不超过()m。 A.200 B.300 C.500 C 60 临时接地线必须是带透明护套的多股软裸铜 线。其截面积不得小于()mm²。 A.6 B.10 C.25 C 61 流过电阻的电流与加在电阻两端的电压成正 比,而与电阻成反比。() A.对 B.错 A 62 目前在工矿企业运行的变压器绕组一般都是 B级绝缘。() A.对 B.错 B 63 气体击穿后绝缘性能很快得到恢复。() A.对 B.错 A 64 强调安全会在一定程度上妨碍生产。() A.对 B.错 B 65 全部停电时,工作负责人不可以参加工作班 工作。() A.对 B.错 B 66 确定电流所产生磁场方向的定则是()。 A.欧姆定律 B.右手螺旋定律 C.基尔霍夫定 律 B 67 人体电阻与接触电压的高低有关,与触电时 间的长短无关。() A.对 B.错 B 68 熔断器是电压互感器唯一的保护装置,必须 正确选用和维护。() A.对 B.错 A 69 三相变压器的工作原理与单相变压器的工作 原理相同。() A.对 B.错 A 70 三相四线线路可采用四级式或三级式漏电保 护器。() A.对 B.错 B 71 生产经营单位使用未取得特种作业操作证的 特种作业人员上岗作业的,责令限期改正;逾 期未改正的,责令停产停业整顿,可以并处() A.2 B.3 C.4 A 72 使用兆欧表之前应当先调好机械零点。() A.对 B.错 B 73 事故发生后,事故现场有关人员应当立即向 本单位负责人报告;单位负责人接到报告后, 应当于()小时内向事故发生地县级以上人民 政府安全生产监督管理部门和负有安全生产 A.1 B.2 C.3 A 74 监督管理职责的有关部门报告。 数字式仪表的测量机构是()。 A.数字式电压基本表 B.电磁系机构 C.磁电 系机构 A 75 塑料绝缘线的最高温度一般不得超过()°C。 A.60 B.70 C.80 B 76 特种作业操作证有效期为()年,在全国范围 内有效。 A.3 B.4 C.6 C 77 通常将向商业供配电的系统称为商业供电系 统。() A.对 B.错 B 78 为了短路时速断保护装置能可靠动作,短路 时必须有足够大的短路电流。() A.对 B.错 A 79 下列()是在高压操作中使用的基本安全用具 。 A.绝缘杆、绝缘夹钳、绝缘垫 B.高压验电 器、绝缘杆、绝缘夹钳 C.绝缘杆、高压验 电器、绝缘站台 B 80 新参加电气工作的人员不得单独工作。() A.对 B.错 A 81 新入厂的工作人员要接受厂、车间、班组等 三级安全教育。() A.对 B.错 A 82 新投入或大修后投入运行的电气设备,在24 小时内应加强巡视,无异常情况时,可按正常 周期进行巡视。() A.对 B.错 B 83 验电时,在检修设备的进出线两侧分别验电 。() A.对 B.错 A 84 一个工作负责人可以发两张工作票。() A.对 B.错 B 85 移动式临时线采用有保护芯线的橡套软线, 长度一般不超过5m。() A.对 B.错 B 86 已结束的工作票,保存()个月。 A.1 B.2 C.3 C 87 用人单位应当按时缴纳工伤保险费。职工个 人不缴纳工伤保险费。() A.对 B.错 A 88 用兆","date":"0001-01-01","objectID":"/1/01/%E9%AB%98%E5%8E%8B%E7%94%B5%E5%B7%A5%E4%BD%9C%E4%B8%9A/:0:0","series":null,"tags":null,"title":"","uri":"/1/01/%E9%AB%98%E5%8E%8B%E7%94%B5%E5%B7%A5%E4%BD%9C%E4%B8%9A/"},{"categories":null,"content":"content ","date":"0001-01-01","objectID":"/websites/:0:0","series":null,"tags":null,"title":"网站收藏","uri":"/websites/"},{"categories":null,"content":"这个地方不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 ","date":"0001-01-01","objectID":"/links/:0:0","series":null,"tags":null,"title":"友情链接","uri":"/links/"}]