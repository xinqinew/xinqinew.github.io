[{"categories":null,"content":"随着游戏行业的发展，x32位的程序已经很难满足一些新兴游戏的需求了，因为32位内存的最大值为0xFFFFFFFF，这个值看似足够，但是当游戏对资源需求非常大，那么真正可以分配的内存就显得捉襟见肘了，于是很多公司尝试并成功的开发了64位的游戏。并且很多32位的游戏也在向64位转型。 很多初学者在刚刚接触64位程序时会觉得很陌生，想象着这是一个新的领域，会比32位的分析难度高很多。其实当你对32位的逆向有一定的基础和理解的时候，再来看64位就不那么难了。 64位与32位最直观的区别就是他可分配的内存最大值是0xFFFFFFFFFFFFFFFF。有人可能会说这也就比32位的多了一倍，其实不然，他的大小是32位的0x100000000倍。这个大小就足够我们去使用了，甚至当你在分析64位的游戏时会发现，很多地址也仅仅是1XXXXXXXX，因为目前来说这些也就足够了。 64位与32位逆向的第二个区别就是他的寄存器，他的寄存器为16个而不是8个（如图） 在这16个寄存器中，前面8个的名字与32位的很像，只是前面的E改为了R。后面的8个则以R8-R15命名。当然我们所说的这16个是通用寄存器，而后面还有16个浮点数使用的XMM寄存器（如图） 在初学者的学习中，我们主要来学习通用寄存器的使用。 RAX与EAX的作用是类似的，他主要用来存放函数的返回值，他的数值也是经常会变化的（如图） 图中是一个随意截取的一断64位函数代码，函数后面的RAX传递给RDI，其实就是将返回值进行传递，这里了解一下即可，后面还会详细讲解。 RCX，RDX，R8，R9则常常会做为第1-4个参数（如图） 图中是一个游戏调用send函数的代码，RCX-R9分别为函数的s，buf，len，flags，当然如果还有其他的参数的话则会存放在RSP+20中，这些在后面讲函数的时候会详细讲解。 RSP和32位中的ESP是类似的，同样作为堆栈指针（如图） RBP虽然偶尔会用来作为帧指针，也就是所谓的栈底，但是显然没有32位用的频繁，下图则是RBP在函数头部被赋值的情况（如图） 当然RBP也常常会被用作普通的寄存器去进行传址。 R10和R11在syscall/sysret 指令中会被使用，暂时只需要了解一下即可。 而这些寄存器中，除了RAX，RCX,RDX,R8,R9,RSP之外的寄存器，如果在函数过程中被调用，则必须在调用前对其数值进行保留（如图）（如图） 以上就是64为内存和通用寄存器的一些基础知识，深入的内容会在后面的文章和视频中进行讲解。 ","date":"2021-10-13","objectID":"/2021/10/64%E4%BD%8D%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/:0:0","series":null,"tags":["飞郁精品帖"],"title":"64位内存与通用寄存器","uri":"/2021/10/64%E4%BD%8D%E5%86%85%E5%AD%98%E4%B8%8E%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/"},{"categories":null,"content":"InHook.h #pragma once #ifdef _WIN64 typedef unsigned __int64 SELF_PTR; #else typedef unsigned int SELF_PTR; #endif #if _WIN64 constexpr int byte_length = 9; #else constexpr int byte_length = 5; #endif // 0 class InHook { public: void Initalize(SELF_PTR oldAddr, SELF_PTR myAddr); static InHook* GetInitalize(); // 修改地址 void motifyAddress(); // 恢复地址 void restoreAddress(); using uchar = unsigned char; uchar m_oldByte[byte_length]; uchar m_myByte[byte_length]; SELF_PTR m_oldFuncAddr; SELF_PTR m_myFuncAddr; private: static InHook* m_pInstance; }; InHook.cpp #include \"pch.h\"#include \"InHook.h\" InHook* InHook::m_pInstance = NULL; InHook* InHook::GetInitalize() { if (m_pInstance == NULL) { m_pInstance = new InHook; } return m_pInstance; } //修改地址页面属性，返回原地址属性 DWORD motifyMemoryAttributes(SELF_PTR myAddr, SELF_PTR attributes = PAGE_EXECUTE_READWRITE) { DWORD oldAttributes; VirtualProtect((void*)myAddr, byte_length, attributes, \u0026oldAttributes); return oldAttributes; } void InHook::Initalize(SELF_PTR oldAddr, SELF_PTR myAddr) { memcpy(\u0026oldAddr, \u0026m_oldFuncAddr, sizeof(oldAddr)); memcpy(\u0026myAddr, \u0026m_myFuncAddr, sizeof(myAddr)); m_myByte[0] = { 0xe9 }; int offset = m_myFuncAddr - m_oldFuncAddr - byte_length; memcpy(\u0026m_myByte[1], \u0026offset, byte_length - 1); DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy(m_oldByte, (void*)m_oldFuncAddr, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } // 修改地址 void InHook::motifyAddress() { DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy((void*)m_oldFuncAddr, m_myByte, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } // 恢复地址 void InHook::restoreAddress() { DWORD attributes = motifyMemoryAttributes(m_oldFuncAddr); memcpy((void*)m_oldFuncAddr, m_oldByte, byte_length); motifyMemoryAttributes(m_oldFuncAddr, attributes); } 调用示例： main.cpp #include \u003cWindows.h\u003e#include \"InHook.h\" InHook::GetInitalize()-\u003eInitalize(d3d9Device_table[42],(SELF_PTR)hkEndScene); InHook::GetInitalize()-\u003emotifyAddress(); InHook::GetInitalize()-\u003erestoreAddress(); ","date":"2021-10-13","objectID":"/2021/10/x86-%E5%92%8C-x64-%E5%85%B1%E7%94%A8hook%E7%B1%BB/:0:0","series":null,"tags":["飞郁精品帖"],"title":"x86 和 x64 共用HOOK类","uri":"/2021/10/x86-%E5%92%8C-x64-%E5%85%B1%E7%94%A8hook%E7%B1%BB/"},{"categories":null,"content":"上一篇帖子中我们对技能等级进行了分析，接下来我们对技能名字库进行分析，进而获得完整的技能遍历。既然分析名字库，自然要从名字入手了，我们任意选择一个技能，用对其名字进行扫描，可以得到若干ASCII型的结果 这里注意的是如果名字后面带有后缀的结果比较多的话，可以转化成字节集，并加上结束标志00再扫描。分别对这些名字进行修改，同时切换技能栏，找到一个可以改变技能名字本地显示的地址。在xdbg32中对这个地址下硬件访问断点。 向上分析esi的来源，经过多层参数的传递，得到来源于一个[ebp-68]的局部变量 继续分析局部变量的来源，发现在上面出现了2个[ebp-68]，第一个是传入0，第二个是作为ecx指针传入到了CALL中 而第二个位置F2不会断，说明这个位置代码没有经过，那么来源就只能在传入0下面的CALL中了。在024B4BD处call 0x5A0CB0上下F2断点，单独到内部分析来源。这里得到了一个+C偏移，继续分析在上面又得到了一个-C偏移，而这个两个位置都是lea指令，所以只得到了+0偏移。 执行到返回后继续分析第一个参数eax，得到+8偏移，以及来源局部变量[ ebp-14]。代码再次向上滚动很久，可以得出局部变量[ebp-14]来源于eaxeax来源一个数组，数组起始地址eax来源于[esi+8]。我们切换不同种类的技能栏并对esi+8处下F2断点，发现esi是随着技能种类变化的，也就是说这个数组只是某个种类技能的数组，在上面还有一个技能种类的结构。 我们先将这里得到的数据进行分析和整理，如下 [技能种类+8]-4 技能数组元素数量 [[技能种类+8]+n8+4]+4 技能ID [[[技能种类+8]+n*8+4]+8]+0 技能名字ASCII 上面这个分析的过程除了有一点绕，并没有很难的知识点，不过这里能不能观察到esi的变化规律是一个关键，因为技能名字库还有需要对技能进行分类的游戏的确很少。在下一篇文章里我们将去分析技能种类的加密算法，并获取到完整的技能库。玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-13","objectID":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E6%8A%80%E8%83%BD%E5%BA%93/:0:0","series":null,"tags":["飞郁精品帖"],"title":"《冒险岛》技能分析之技能库","uri":"/2021/10/%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90%E4%B9%8B%E6%8A%80%E8%83%BD%E5%BA%93/"},{"categories":null,"content":"随着游戏代码的发展，新游戏的技能越来越华丽，分类也越来越多，数据结构用的五花八门。而老游戏也不甘寂寞，技能数据也处理的有模有样，分析起来也颇有难度。以下面这款游戏为例，我们从逆向安全的角度来学习一下它的技能体系数据结构。 这款游戏的技能体系我们大致分为三个部分去分析，分别为技能等级结构，技能库结构，剩余级技能点数结构。下面先分析最简单的技能等级结构。 技能的分析可以从技能ID，技能等级，技能名字三个角度入手分析，而如果技能等级可以使用的话自然是最方便的一种，起码扫描起来很简单。而这款游戏恰好就可以通过技能加点来入手。 首先我们呢用CE来任意扫描一个高级魔法的等级，最终可以得到一个结果 在xdbg32中对这个地址下硬件访问断点，游戏直接断下，并得到一个+C偏移 向上分析可以看到一个跳转跳过ret，执行到+C偏移处，而上面可以得到一个循环+4的链表结构 图中可以看出这个链表最初的来源是上面的一个数组，当数组指向地址+8的位置与传入的esi相等时会跳出链表，或者当链表节点eax等于0时结束链表循环。 我们先到上面分析出数组的起始地址和范围，然后再获取下标的信息。 在上面不远处可以看到起始地址为[ecx+4]，而外面传入的第一个参数在循环右移5之后与[ecx+8]进行模运算，可以获取到下标edx 经观察可以得出这个这个[ecx+8]恰好是数组中总的元素数量。 由于数组中元素较少，而链表中的节点也不多，可以判断这个数组下标其实可以不去管他，只要我们得到技能库与之关联就可以得到所有的技能信息。 接下来我们继续去分析数组起始地址ecx的来源，在执行到返回后可以得到一个+0DCE偏移 向上分析得到来来源于[ebp+8]，执行到返回继续分析第一个参数，可以得到来源[eax+4] 然而这个+4并不是偏移，因为eax是一个堆栈地址，[eax+4]是一个局部变脸，并且在上面的CALL 0x2D50780中被赋值。我们到这个CALL中可以很快找到来源，并得到一个+22EC的偏移 退出这个CALL并再次下断执行到返回，可以很快得到基地址 这个数据结构总体来说是很简单的，只是中间的局部变量作为参数到CALL的赋值的操作对逆向新手有一些难度，如果对堆栈比较熟悉的话可以轻松搞定，从安全角度来讲，这里可以做的更加复杂一些。 公式就不整理了，我们接下来将要分析较为复杂的技能库结构。 玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-13","objectID":"/2021/10/%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90/:0:0","series":null,"tags":["飞郁精品帖"],"title":"技能点数结构（冒险岛技能分析）","uri":"/2021/10/%E6%8A%80%E8%83%BD%E7%82%B9%E6%95%B0%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E5%B2%9B%E6%8A%80%E8%83%BD%E5%88%86%E6%9E%90/"},{"categories":null,"content":"今天我们来分析一下\u003c传奇永恒\u003e的释放技能CALL, 调用技能CALL可以实现全自动循环打怪功能. 首先, 定位到明文包头部 在明文包头部下断, 再按快捷键, 释放技能打怪 按Ctrl+F9, 再按F8, 返回到第1层, 这个CALL看上去有点乱, 参数不明显, 再返回一层看看. 返回到第2层, 这个CALL看起来就明朗的多了, 参数明显, 就是它了! 在CALL上下断, 分析一下参数. 经过分析, 参数1, Rcx, 来源于上面的CALL, 直接是一个\u003c基地址\u003e. 参数2, Edx, 可能是\u003c怪物ID\u003e 参数3, r8d, 值并不是很大, 很有可能是\u003c技能ID\u003e 参数4, r9d, 是一个更小的值, 也许是\u003c技能等级\u003e 参数5, eax, 是一个结构体, DD之后发现是一个\u003c坐标结构体\u003e, 并且不是人物坐标, 那就一定是怪物的坐标了. 参数6, 经过多次下断尝试, 是个\u003c固定值, 1\u003e 参数7, 直接就是一个基地址, 并且每次释放技能, 都会+1, 所以这是一个\u003c计数器\u003e 现在释放技能CALL已经分析完毕, 参数明确, 下面是循环调用释放技能CALL的效果图. ","date":"2021-10-12","objectID":"/2021/10/x64%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E4%B9%8B%E9%87%8A%E6%94%BE%E6%8A%80%E8%83%BDcall/:0:0","series":null,"tags":["飞郁精品帖"],"title":"x64\u003c传奇永恒\u003e之释放技能CALL","uri":"/2021/10/x64%E4%BC%A0%E5%A5%87%E6%B0%B8%E6%81%92%E4%B9%8B%E9%87%8A%E6%94%BE%E6%8A%80%E8%83%BDcall/"},{"categories":null,"content":"明文发包CALL是分析一款游戏功能的主要突破口，但是很多游戏都是线程发包，需要跳出线程才能得到明文CALL的位置。以往的条线程方式都是在包内容或者内容来源上下写入断点，一次或者多次写入就可以跳出线程，但是韩服的剑灵2又有了一些不一样的地方，很多人也会在这里止步不前。下面我们就利用几种不同的方式跳出这个游戏的发包线程。 前面的方法都是固定不变的，首先我们用xdbg64找到其发包函数WSASend 由于这里每次断的包内容地址是变化的，所以我们要取追一下来源，执行到返回后来到函数调用处 这里的包内容来源于rax+[rdi+18]，而下断之后我们可以发现rax始终都0，所以我们继续向上追rdi，可以得到来源于CALL的返回值。在CALL上下断，并单步到内部，可以得到一个数组，这发包方式和传奇永恒的特别像 这里的RCX是不变的，所以我们可以直接配出包内容的公式为[rcx+18]+([rcx]\u0026FFFFFFFF)*8填入rcx的值,在数据窗口中跟随,并在下面不远处选择一个地址,提前下好写入断点,不断的走路发包,等待游戏断下 我们发现写入的这个位置还是在原来那个函数内部,也就是说我们还是没有跳出线程 那么我们要继续向上追rbp的来源，在执行到返回后得到了[r14+rax] 在这里下断后发现r14始终是0，而rax是不变的，于是我们在rax上下写入断点，走路后游戏断下 现在这个位置就是很多人都会遇到的难点，继续向上追可以得到一个数组，而这数组的下标是随机获取的，想从这个里入手很麻烦 既然这里不好下写入断，那我们只要整体函数的执行流程做一个分析。在上面我们发现了一个位置断的特备频繁，发包的执行流程中会掺杂大量的假包，并跳到函数尾部，不执行发包代码。而这个位置的上面会有一个判断，用来分辨当前执行的代码是否是真的发包代码。 所以我们分别取追一下r14d和eax的来源，并最终得到了两处赋值的位置 我们在下面的数组上下断，获取到真正发包时的rbp的值，并对+40和+88进行下断观察，可以发现+88是决定代码流程的关键，因为有的时候+40不变，而+88会改变，此时恰好会让二者不相等，实现真的发包。 于是我们在这个+88偏移上下写入断点，尝试跳出线程。在游戏内下断断的狠频繁，我们很难做出写入的动作。所以我们要来带创建角色界面下断，在这里可以很轻松的断下，并来到跳出线程的代码里 这是我们的第一种跳出方式，而第二种方式比较简单，我们可以用CE对这个地址下写入断点，然后挨个尝试，其中会有一个写入会在线程外 第三种方式有一些玄学，就是在模块内扫描比较函数中的基地址，虽然扫描到的基地址有很多，不过在前面的几个里面就会有一个在线程外，跳过去下断可以返回到功能CALL。当然这种方式虽然有一定的道理，但也是在我们走投无路的情况下才去尝试的。 以上就是跳出剑灵2线程的几种方法，如果大家有更多的方法，也可以联系我，大家一起学习交流下。玩游戏，学逆向，做安全，欢迎感兴趣的小伙伴关注我们。 ","date":"2021-10-12","objectID":"/2021/10/%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9F%A9%E6%9C%8D%E5%89%91%E7%81%B52/:0:0","series":null,"tags":["飞郁精品帖"],"title":"跳出线程发包的几种方式（韩服剑灵2）","uri":"/2021/10/%E8%B7%B3%E5%87%BA%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E9%9F%A9%E6%9C%8D%E5%89%91%E7%81%B52/"},{"categories":["辅助"],"content":"ASCII控制字符 二进制 十进制 十六进制 缩写 名称/意义 0000 0000 0 00 NUL 空字符（Null） 0000 0001 1 01 SOH 标题开始 0000 0010 2 02 STX 本文开始 0000 0011 3 03 ETX 本文结束 0000 0100 4 04 EOT 传输结束 0000 0101 5 05 ENQ 请求 0000 0110 6 06 ACK 确认回应 0000 0111 7 07 BEL 响铃 0000 1000 8 08 BS 退格 0000 1001 9 09 HT 水平定位符号 0000 1010 10 0A LF 换行键 0000 1011 11 0B VT 垂直定位符号 0000 1100 12 0C FF 换页键 0000 1101 13 0D CR 归位键 0000 1110 14 0E SO 取消变换（Shift out） 0000 1111 15 0F SI 启用变换（Shift in） 0001 0000 16 10 DLE 跳出数据通讯 0001 0001 17 11 DC1 设备控制一（XON 启用软件速度控制） 0001 0010 18 12 DC2 设备控制二 0001 0011 19 13 DC3 设备控制三（XOFF 停用软件速度控制） 0001 0100 20 14 DC4 设备控制四 0001 0101 21 15 NAK 确认失败回应 0001 0110 22 16 SYN 同步用暂停 0001 0111 23 17 ETB 区块传输结束 0001 1000 24 18 CAN 取消 0001 1001 25 19 EM 连接介质中断 0001 1010 26 1A SUB 替换 0001 1011 27 1B ESC 跳出 0001 1100 28 1C FS 文件分割符 0001 1101 29 1D GS 组群分隔符 0001 1110 30 1E RS 记录分隔符 0001 1111 31 1F US 单元分隔符 0111 1111 127 7F DEL 删除 ","date":"2021-10-07","objectID":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/:0:1","series":null,"tags":["辅助"],"title":"ASCII码对照表","uri":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"},{"categories":["辅助"],"content":"ASCII可显示字符 二进制 十进制 十六进制 字符/缩写 00100001 33 21 ! 00100010 34 22 \" 00100011 35 23 # 00100100 36 24 $ 00100101 37 25 % 00100110 38 26 \u0026 00100111 39 27 ' 00101000 40 28 ( 00101001 41 29 ) 00101010 42 2A * 00101011 43 2B + 00101100 44 2C , 00101101 45 2D - 00101110 46 2E . 00101111 47 2F / 00110000 48 30 0 00110001 49 31 1 00110010 50 32 2 00110011 51 33 3 00110100 52 34 4 00110101 53 35 5 00110110 54 36 6 00110111 55 37 7 00111000 56 38 8 00111001 57 39 9 00111010 58 3A : 00111011 59 3B ; 00111100 60 3C \u003c 00111101 61 3D = 00111110 62 3E \u003e 00111111 63 3F ? 01000000 64 40 @ 01000001 65 41 A 01000010 66 42 B 01000011 67 43 C 01000100 68 44 D 01000101 69 45 E 01000110 70 46 F 01000111 71 47 G 01001000 72 48 H 01001001 73 49 I 01001010 74 4A J 01001011 75 4B K 01001100 76 4C L 01001101 77 4D M 01001110 78 4E N 01001111 79 4F O 01010000 80 50 P 01010001 81 51 Q 01010010 82 52 R 01010011 83 53 S 01010100 84 54 T 01010101 85 55 U 01010110 86 56 V 01010111 87 57 W 01011000 88 58 X 01011001 89 59 Y 01011010 90 5A Z 01011011 91 5B [ 01011100 92 5C \\ 01011101 93 5D ] 01011110 94 5E ^ 01011111 95 5F _ 01100000 96 60 ` 01100001 97 61 a 01100010 98 62 b 01100011 99 63 c 01100100 100 64 d 01100101 101 65 e 01100110 102 66 f 01100111 103 67 g 01101000 104 68 h 01101001 105 69 i 01101010 106 6A j 01101011 107 6B k 01101100 108 6C l 01101101 109 6D m 01101110 110 6E n 01101111 111 6F o 01110000 112 70 p 01110001 113 71 q 01110010 114 72 r 01110011 115 73 s 01110100 116 74 t 01110101 117 75 u 01110110 118 76 v 01110111 119 77 w 01111000 120 78 x 01111001 121 79 y 01111010 122 7A z 01111011 123 7B { 01111100 124 7C | 01111101 125 7D } 01111110 126 7E ~ ","date":"2021-10-07","objectID":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/:0:2","series":null,"tags":["辅助"],"title":"ASCII码对照表","uri":"/2021/10/ascii%E7%A0%81%E5%AF%B9%E7%85%A7%E8%A1%A8/"},{"categories":["辅助"],"content":"菜单栏 E 模块 T 线程（挂起与激活）resume恢复线程 B 执行断点 HBP 硬件断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:1:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD指令 dd 查看dword db 查看字节集 hw 硬件写入断点 hr 硬件访问断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:2:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"快捷键 CTRL + A 分析代码 F2 下断和取消 Shift+F2 条件断点 F4 代码执行一次 F7 单步步入（进call） F8 单步步过（不进call） ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:3:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"条件断点 == 等于 != 不等于 \u0026\u0026 和 || 或 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:4:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"汇编指令 mov 赋值 lea 传址 push 入栈 pop 出栈 add 加 sub 减 mul 乘法 div 除法 call 函数 retn 返回 rep 主要用来重复执行指令 详见 REP指令前缀簇 ​ 指令：REP MOVS mem8/16/32, m8/16/32 ​ 描述：从DS:[(E)SI]中复制(E)CX个字节/字/双字到ES:[(E)DI] DS:[(E)SI]由于(E)SI寄存器中保存的是源操作数的地址，所以DS:[(E)SI]指的就是该地址保存的值 mov ecx,12 rep movs dword ptr es:[edi],dword ptr [esi] # 从[esi]中复制 ecx个四字节 到ES:[edi] # 每复制一次 esi 和 edi 的地址要加4，而ecx减1 # 源自 飞郁网络培训 2018-2019 52第二部分第八节结构体数组 55结构体数组实例1 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:5:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"断点 内存访问 断在执行之前 内存写入 断在执行之前 硬件访问（CE） 断在执行之后 硬件写入（CE） 断在执行之后 硬件执行 可添加条件断点 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD断点缺点 一次只能断在一个位置 CE则可以把所有相关断点列在一起 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"OD断点优点 高亮插件，易于追踪 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:6:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"堆栈 esp 栈顶指针 堆栈顶端的刻度 ebp 栈底指针 本层函数的栈底 ebp 不稳定，有时不是栈底，而是普通寄存器 判断方法，看ebp与esp的差距是否很大 如果差距大，则是普通寄存器 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:7:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"堆栈平衡 特性 esp 不能变化 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:8:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"寄存器 EAX call的返回值 ECX call的参数 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:9:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找call总结 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找call时，需要注意的地方： 找call在send上下断，尽量避免被心跳call干扰 在我们找call的时候，会有一些其它伴生函数干扰 例如： 打怪、打开npc对话框或者寻路call，可能会先触发走路call 打坐、释放技能可能会伴随快捷键函数 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"找到call后，我们还需要对函数的参数、寄存器进行分析。 外平栈，看清楚参数的数量，是否和平栈的数值对应。在调用call的时候一定要平栈，否则会崩溃。 内平栈，通过retn的数值，来判断参数的数量，并且分析ecx的来源。个别情况下，还需要分析edx和esi等参数的来源。 有些函数调用的是虚函数，比如 call eax或者call [edx+8],我们需要去分析call里寄存器的来源。 如果我们的参数中需要用到eax，但是eax无法很快的得到结果，这时可以通过调用eax来源的call来获得，前提是分析清楚来源函数的参数和寄存器。调用连call。 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"带有结构体的函数 申请一片内存（可以通过OD插件） 在内存中填写结构体里的内容 将我们申请的内存地址，push到call中 进行调用 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:3","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"无法通过发包函数获得的call 例如：寻路，控件，按键 graph LR 寻路--\u003e走路--\u003ez[\"通过目的地坐标，\u003cbr\u003e下写入断点\"] graph LR 控件--\u003ez[\"可以通过背包的打开状态，\u003cbr\u003e来对状态下写入断点\"] graph LR 按键 --\u003ez \u0026 z1 \u0026 z2 z[\"可以通过背包的打开状态，\u003cbr\u003e来对状态下写入断点\"] z1[\"鼠标点击\"] z2[\"键盘\"] ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:10:4","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"发包函数 bp send send sendto WSASend 重新实现的发包函数 WSPSend 线程发包 graph subgraph 普通发包 喊话call --\u003e 喊话_内层call --\u003e 组包的过程1 --\u003e 最内层喊话call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 --\u003e 加密 --\u003e 发包发送 走路call --\u003e 走路_内层call --\u003e 组包的过程2 --\u003e 最内层走路call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 其它call --\u003e 其它_内层call --\u003e 组包的过程3 --\u003e 最内层其它call--\u003e|进call后的头部\u003cbr\u003e就是\u003cbr\u003e最外层明文包头部\u003cbr\u003e往下走就是|明文封包 end ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:11:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件输入 寻找突破口: graph z1[\"方法一\"] z2[\"方法二\"] z3[\"字符串的长度\"] z4[\"直接搜索字符串\"] z5[\"下写入断点\"] z1--\u003ez3--\u003ez5 z2--\u003ez4--\u003ez5 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:1","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"控件点击 graph z[\"下写入断点\"] z1[\"方法一\"] z2[\"控件界面打开，搜1或0\"] z3[\"控件界面关闭，搜0或1\"] z4[\"方法二\"] z5[\"单选框选中，搜1或0\"] z6[\"单选框未选中，搜0或1\"] z1--\u003ez2--\u003ez3--\u003ez z4--\u003ez5--\u003ez6--\u003ez ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:12:2","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"按键call graph z[\"按一下对应按键来触发\"] z1[\"方法一\"] z2[\"通过按键触发发包函数\"] z3[\"在发包函数处下断\"] z4[\"方法二\"] z5[\"比如通过背包打开\u003cbr\u003e或者关闭的标志位\u003cbr\u003e来进行查找\"] z6[\"下写入断点\"] z7[\"之后返回，\u003cbr\u003e就有可能断在按键call\"] z8[\"有可能断在按键call\"] z9[\"proc断点\"] z10[\"方法三\"] z1--\u003ez2--\u003ez3--\u003ez7 z4--\u003ez5--\u003ez6--\u003ez--\u003ez8 z10--\u003ez9 proc断点 (源自 飞郁网络培训 2018-2019 2018.12.22 proc断点分析按键CALL) ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:13:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"插件 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:14:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":["辅助"],"content":"IDA 用于查看伪函数代码 对于复杂的结构体、数组、二叉树、链表，更直观。 ","date":"2021-10-03","objectID":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/:15:0","series":null,"tags":["OD","辅助"],"title":"OD常识及技巧","uri":"/2021/10/od%E5%B8%B8%E8%AF%86%E5%8F%8A%E6%8A%80%E5%B7%A7/"},{"categories":null,"content":"购普通课程或者核心课程，为保您购买与售后无忧，先咨询飞郁客服QQ:290330101，并享受不定额度优惠！ 逆向基本工具包 链接：https://pan.baidu.com/s/1CLTHQ3BXi4aA8iFbELZAJA 提取码：h45h 基础篇课件+课堂源码+课堂用到的一些工具等 链接：https://pan.baidu.com/s/1B8ozmsy4qsDiFJk_Dnn_bA 提取码：9scm ","date":"2021-09-30","objectID":"/2021/09/%E9%A3%9E%E9%83%81%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":null,"title":"飞郁逆向课程详解","uri":"/2021/09/%E9%A3%9E%E9%83%81%E9%80%86%E5%90%91%E8%AF%BE%E7%A8%8B%E8%AF%A6%E8%A7%A3/"},{"categories":null,"content":"内存中的浮点数 3开头 1.xxxx 0.xxxx 4开头 100.xxxx b开头 -0.xxxx c开头 -15.xxxx ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:1:0","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"CE扫四种编码 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:0","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"ASCI UNIDCOE（不勾选） ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:1","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"UNIDCOE UNIDCOE graph 勾选UNIDCOE--\u003e 扫描类型_字符串--\u003e 输入待扫描内容--\u003e a[\"搜索\"]--成功---\u003e 完毕 a--失败--\u003e 扫描类型_字节集---\u003e a 字符串转字节集的方法--\u003e 随便添加一个空白地址--\u003e 类型选择字符串或文本型--\u003e 输入待扫描的内容--\u003e 更改类型为字节集--\u003e b[\"完毕\"] ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:2","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"utf_8 graph 不勾选UNIDCOE--\u003e 扫描类型_字符串--\u003e 输入待扫描内容--\u003e 更改类型为字节集--\u003e 完毕 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:3","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"big5 用工具转换 GBK转BIG5 ","date":"2021-09-27","objectID":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/:2:4","series":null,"tags":null,"title":"内存中的浮点数与CE扫四种编码","uri":"/2021/09/%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%8Ece%E6%89%AB%E5%9B%9B%E7%A7%8D%E7%BC%96%E7%A0%81/"},{"categories":["C++"],"content":"C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求： 实例 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { // 创建一个向量存储 int vector\u003cint\u003e vec; int i; // 显示 vec 的原始大小 cout \u003c\u003c \"vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 推入 5 个值到向量中 for(i = 0; i \u003c 5; i++){ vec.push_back(i); } // 显示 vec 扩展后的大小 cout \u003c\u003c \"extended vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 访问向量中的 5 个值 for(i = 0; i \u003c 5; i++){ cout \u003c\u003c \"value of vec [\" \u003c\u003c i \u003c\u003c \"] = \" \u003c\u003c vec[i] \u003c\u003c endl; } // 使用迭代器 iterator 访问值 vector\u003cint\u003e::iterator v = vec.begin(); while( v != vec.end()) { cout \u003c\u003c \"value of v = \" \u003c\u003c *v \u003c\u003c endl; v++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： vector size = 0 extended vector size = 5 value of vec [0] = 0 value of vec [1] = 1 value of vec [2] = 2 value of vec [3] = 3 value of vec [4] = 4 value of v = 0 value of v = 1 value of v = 2 value of v = 3 value of v = 4 关于上面实例中所使用的各种函数，有几点要注意： push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。 size( ) 函数显示向量的大小。 begin( ) 函数返回一个指向向量开头的迭代器。 end( ) 函数返回一个指向向量末尾的迭代器。 菜鸟官方笔记 C++ STL 之 vector 的 capacity 和 size 属性区别 size 是当前 vector 容器真实占用的大小，也就是容器当前拥有多少个容器。 capacity 是指在发生 realloc 前能允许的最大元素数，即预分配的内存空间。 当然，这两个属性分别对应两个方法：resize() 和 reserve()。 使用 resize() 容器内的对象内存空间是真正存在的。 使用 reserve() 仅仅只是修改了 capacity 的值，容器内的对象并没有真实的内存空间(空间是\"野\"的)。 此时切记使用[ ]操作符访问容器内的对象，很可能出现数组越界的问题。 下面用例子进行说明： #include \u003ciostream\u003e#include \u003cvector\u003e using std::vector; int main(void) { vector\u003cint\u003e v; std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; v.reserve(10); std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; v.resize(10); v.push_back(0); std::cout\u003c\u003c\"v.size() == \" \u003c\u003c v.size() \u003c\u003c \" v.capacity() = \" \u003c\u003c v.capacity() \u003c\u003c std::endl; return 0; } 运行结果为：(win 10 + VS2010) 注： 对于 reserve(10) 后接着直接使用 [] 访问越界报错(内存是野的)，大家可以加一行代码试一下，我这里没有贴出来。 这里直接用[]访问，vector 退化为数组，不会进行越界的判断。此时推荐使用 at()，会先进行越界检查。 相关引申： 针对 capacity 这个属性，STL 中的其他容器，如 list map set deque，由于这些容器的内存是散列分布的，因此不会发生类似 realloc() 的调用情况，因此我们可以认为 capacity 属性针对这些容器是没有意义的，因此设计时这些容器没有该属性。 在 STL 中，拥有 capacity 属性的容器只有 vector 和 string。 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B040stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记40STL 教程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B040stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 标准库 C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"标准函数库 标准函数库分为以下几类： 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"面向对象类库 标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 ","date":"2021-09-26","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记41标准库","uri":"/2021/09/c-%E7%AC%94%E8%AE%B041%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":null,"content":"报名QQ: 3534373359 ================================ 本期在线班, 实战游戏列表: 口袋西游 传奇永恒 幻想神域单机版 猎天 QQ自由幻想 天涯明月刀 魔兽单机版 神途 QQ三国 新寻仙 魔兽怀旧服 自由足球 成吉思汗2 QQ仙侠传 轩辕传奇 NBA2KOL 最终幻想14 创世战车 第九大陆 武林外传 神魔大陆 完美世界 极光世界 新风云 神鬼世界 诛仙3 鹿鼎记 斗战神 彩虹岛Online 待添加… ================================ ♦ 课程目录： ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:0:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第一章：创建第一个程序编写进制转换器 进制 13:10 进制进阶 12:08 高级语言和低级语言 15:36 创建第一个程序 18:52 printf和scanf编写进制转换器 19:30 变量和常量 10:09 内存 23:56 数据类型 22:22 数据在内存中的储存方式_字符，整数类 10:54 数据在内存中的储存方式_浮点类 26:03 有符号和无符号区别，强制转换类型 25:10 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:1:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第二章: CE基础和实现游戏瞬移 CE入门整数扫描 20:05 CE浮点数扫描实现瞬移 14:17 CE扫描进入游戏标志位 16:30 基地址，动态地址和偏移 16:52 CE的一些技巧 13:32 CE扫描字符串_Ascii Unicode 18:45 CE扫描字符串_UTF_8 Big5 13:22 CE找偏移表达式 23:41 代码编写MFC DLL显示窗口 16:47 内存读写，输出人物血量和实现瞬移 24:46 Writeprocessmemory和指针读写 04:53 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:2:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第三章: OD基础，逆向游戏基地址和偏移表达式 OD基础 22:04 动态加载模块，静态加载模块和游戏领空 18:57 GetModuleHandle 10:18 数据段和代码段18:01 寄存器20:57 堆栈18:33 汇编基础指令 mov lea push pop pushad popad24:14 基础汇编指令 add sub mul div jmp call retn25:12 浮点数指令fld fild fldl fldpi19:10 浮点数指令fstp fistp fst fist19:31 逆向思维看汽车质量问题14:43 浮点数指令fadd fmul fsub fdiv08:55 OD和CE的对应关系22:34 OD追整数类型偏移表达式其一22:36 OD追整数类型偏移表达式其二26:30 OD追浮点数类型偏移表达式15:52 OD中的七种断点18:08 OD中追哪个寄存器的技巧 10:29 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:3:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第四章 call，变态功能和编写自动吃药脚本 什么是函数[视频未上传] 编写第一个函数17:53 逆向函数，call和子程序的对应关系13:41 函数的调用关系22:29 通过send调用关系找功能call例子18:16 发包函数及晒除心跳包18:11 外层call和内层call的关系以及变态功能11:03 执行到返回，K和堆栈中跳转的关系12:51 分析call，代码注入器调call实现功能19:19 堆栈平衡和函数约定，防止崩溃代码注入器22:58 _asm内联汇编12:10 内联汇编需要注意的事项12:52 吃药call，真正的项目使用什么样的call15:44 结构体参数call，malloc和free22:14 call详解12:48 内存的访问找万能按键call12:07 编写万能按键call和学习sleep20:10 补充万能按键call为什么不能走路26:22 参数找寻路call12:42 锻炼堆栈构建结构体及寻路call10:13 寻路状态找寻路call12:21 控件输入call12:21 控件点击call12:05 EFLAGS寄存器，篡改变态功能的原理18:51 JCC09:51 流程控制语句14:09 if else和逆向16:29 switch和逆向11:26 for和逆向16:19 break和continue12:47 while和逆向10:32 什么是线程13:42 编写自动吃药15:05 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:4:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第五章: 检测多开入门 call的检测，变量检测05:53 处理call检测17:36 最简单的处理API解除游戏限制多开14:23 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:5:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第六章 堆栈及 检测进阶 全局变量和局部变量13:36 逆向全局变量和局部变量08:09 堆栈知识09:22 堆栈详解EBP26:57 堆栈详解ESP12:45 堆栈详解ESP追局部变量20:32 堆栈补充10:18 堆栈锻炼名称字符串18:40 进call逆向数据来源09:08 本层call内部追局部变量16:29 内联汇编需要注意的事项其二10:47 堆栈隐藏调用痕迹10:42 堆栈检测的两种方式11:11 堆栈检测07:21 处理一层堆栈检测防封15:27 处理多层堆栈检测防封11:23 处理多层堆栈检测防封补充[视频未上传] CRC检测09:23 过CRC检测防封23:13 直接nop引起网络波动的问题09:10 数据检测05:58 过数据检测防封11:35 过数据间接检测防封20:27 行为检测 09:31 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:6:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第七章: 明文收发包，脱机和漏洞bug 三大发包函数send,sendto,WSASend[视频未上传] 系统发包函数WSPSend 重新实现的发包函数15:12 线程发包的形态和特点11:35 WSASend条件断点晒出心跳包10:35 跳出线程发包的思路18:15 线程发包跳出线程找到功能函数18:15 确定加密封包位置14:56 明文发包函数12:04 加密call19:29 分析加密call调用方法18:08 自己调用加密call加密12:00 发送喊话函数封包26:55 偷功能119:18 偷功能207:39 不走游戏代码测试吃药封包07:17 收包函数recv，WSARecv和沾包18:57 找明文收包函数的方法12:24 解密call和找明文收包函数的更巧妙办法07:19 脱机和漏洞bug09:10 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:7:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第八章: HOOK HOOK的原理15:03 手动修改实现HOOK14:21 代码HOOK明文发包16:21 VirtualProtect修改页面属性13:45 dbgview输出信息13:00 拦截所有封包内容24:02 实例测试排除bug10:50 HOOK明文收包31:14 bug对半排除法16:09 发送封包实现任意功能 14:20 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:8:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第九章: 数据结构和自动打怪 数据结构[视频未上传] 数组[视频未上传] 二维数组 [视频未上传] 逆向数组[视频未上传] 逆向数组套数组及call内修改参数值[视频未上传] 逆向数组实战调call取对象[视频未上传] 逆向数组实战内层call追局部变量[视频未上传] 逆向数组实战加密数组下标[视频未上传] 分析人物所有属性[视频未上传] 字符串和字符数组[视频未上传] 结构体[视频未上传] 结构体的大小[视频未上传] 结构体数组[视频未上传] 代码整理[视频未上传] 结构体成员函数和输出人物信息[视频未上传] __try()[视频未上传] 代码编写输出数组信息[视频未上传] 链表[视频未上传] 有头链表，无头链表和链表的插入方式[视频未上传] 链表在内存中的形态[视频未上传] 实战周围对象链表[视频未上传] JMP隐藏返回和堆栈[视频未上传] 代码编写输出链表信息[视频未上传] 名称字符串找法和字符串内存存放规则[视频未上传] big5转码输出怪物名字[视频未上传] 冒泡算法取最近怪物[视频未上传] 二叉树[视频未上传] 背包数据嵌套结构[视频未上传] 背包二叉树[视频未上传] 二叉树分析[视频未上传] 嵌套结构分析[视频未上传] 遍历背包二叉树信息[视频未上传] 物品名称分析[视频未上传] 物品库[视频未上传] 数据结构关联[视频未上传] 分析调用吃药封包[视频未上传] 编写保护线程[视频未上传] 技能冷却二叉树牵扯出游戏全部冷却数据[视频未上传] 编程输出冷却技能数据[视频未上传] 获取技能名称[视频未上传] 获取技能名称编程[视频未上传] 技能遍历1[视频未上传] 技能遍历2[视频未上传] 已学技能遍历和BUG调试[视频未上传] 分析编写技能封包[视频未上传] 简陋版自动打怪[视频未上传] ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:9:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十章: Al智能 主线脚本 寻路call[视频未上传] 改进自动打怪[视频未上传] 程序调call或运行久了产生崩溃[视频未上传] 修改主线程调用[视频未上传] 完善自动打怪[视频未上传] 完善自动打怪-技能循环[视频未上传] 判断障碍点[视频未上传] 分析判断障碍点1[视频未上传] 分析判断障碍点2[视频未上传] 绕过卡点怪物继续攻击错误版[视频未上传] 绕过卡点怪物继续攻击正确版[视频未上传] 异常bug修复[视频未上传] 任务分析[视频未上传] 任务遍历[视频未上传] 任务要求分析[视频未上传] 任务遍历编写[视频未上传] 交接任务封包[视频未上传] 编写交接任务封包[视频未上传] 任务逻辑编写[视频未上传] 自动任务[视频未上传] 自动主线任务1[视频未上传] 自动主线任务2[视频未上传] 自动主线任务3[视频未上传] 自动主线任务4[视频未上传] ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:10:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十一章 x64游戏逆向 198.x64寄存器 199.x64堆栈与函数 200.x64写汇编 201.x64写汇编调call 202.x64工具 203.×64逆向分析加密 204.x64数组套链表 嵌套结构 205.x64逆向浮点数运算及XMM寄存器 206.x64逆向浮点数运算及XMM寄存器2 207.x64注入 208.x64找游残call 209.x64汇编用调用call 210.x64遍万代码写法 211.x64实战W某某游残1 212.x64实战W某某游戏2 213.x64实战W某某游戏3 214.x64实战W某某游戏4 215.×64实战W某某游戏5 216.x64实战W某某游戏6 217.x64实战W某某游戏7 218.x64实战W某某游戏8 219.x64实战W某某游戏9 220.x64实战W某某游戏10 221.x64实战W某某游戏11 222.x64实战W某某游戏12 223.×64实战W某某游戏13 224.x64实战W某某游戏14 225.x64实战W某某游戏15 226.x64实战W某某游戏16 227.x64实战W某某游戏17 228.x64实战W某某游戏18 229.x64实战W某某游戏19 230.x64实战W某某游戏20 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:11:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十二章 FPS游戏实战 231.FPS游戏自瞄效果实战 232.FPS游戏实战之模块动态加载 233.FPS游戏之玩转堆栈 234.FPS游戏获取敌我所有目标 235.FPS游戏攻击敌人目标属性总结 236.FPS游戏自瞄爆头准星数据查找 237.FPS游残炮头准星变化规律 238.FPS游戏自瞄准星算法 239.FPS游戏自瞄透视之C++代码实现自瞄1 240.FPS游戏自瞄透视之C++代码实现自瞄2 241.FPS游戏自瞄透视之C++代码实现自瞄3 242.FPS游戏封装必要函数 243.FPS游戏用类遍历输出人物属性 244.FPS游戏热键瞄准和计算最近距离 245.FPS游残实现自瞄 246.某F加密准星分析 247.某F人物坐标分析 248.某F遍历周边玩家 249.某F分析坐标规律实现自瞄 250.某F分析绘制和所需数据及视角查找 251.某F取窗口矩形位置和大小 252.某F建立透明口 跟随游戏 253.某F分析水平可视敌人 254.某F分析垂直可视敌人 255.某F转换2D坐标画出基础方框 256.某F透 视之如何调整方框比例1 257.某F透 视之如何调整方框比例2 258.某F计算并瞄准准案最近的敌人 259.某Fcf变态功能之飞天蹲地 260.某Fcf变态功能之无限子弹 26l.某F实战内存人物透视CRC 262.某F实战内存人物透视CRC 263.某F理解检测和对抗原理 264.某F封包处理检测 265.某F实战明文发包及木马加载 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:12:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十三章 RPG大型3D游残实战 266.RPG大型3D游残过TP驱动保护 267.RPG大型3D游残换属性绕过VM 268.RPG大 型3D游戏call内跳转隐藏偏移 269.RPG大型3D游戏人物属性整理 270.RPG大型3D游残编程输出人物信息 271.RPG大型3D游戏人物对象特性分析玩家链表 272.RPG大型3D游戏模仿结构搞定NPC怪物链表 273.RPG大型3D游戏其他找NPC怪物思路 274.RPG大型3D游戏属性对比分析以及编程输出链表 275.RPG大型3D游戏WSPSend以及重新实现的发包函数 276.RPG大型3D游戏线程发包 277.RPG大型3D游戏明文发 包call 278.RPG大型3D游戏Hook原理 279.RPG大型3D游戏Hook明文包分析封包协议 280.RPG大型3D游戏HOOK代码实现 281.RPG大型3D游戏巧妙方法找重新实现的收包函数 282.RPG大型3D游残特殊巧妙方法找明文包 283.RPG大型3D游残内联汇编 284.RPG大型3D游戏过QTE封包协议 285.RPG大型3D游戏无敌倍功功能 286.RPG大型3D游戏动画宝藏BUG 287.RPG大型3D游残动画宝藏效果 288.RPG大型3D游戏封包之外需要找的call整理 289.RPG大型3D游戏通用快捷键Call 290.RPG大型3D游戏快捷键CALL编写 291.RPG大型3D游戏控件点击call 292.RPG大型3D游残控件选择cal 293.RPG大型3D游戏控件callI编写以及动态模块编写 294.RPG大型3D游残变异二叉树 295.RPG大型3D游戏变异二叉树编写 296.RPG大型3D游戏寻路call 297.RPG大型3D游戏寻路call的编写 298.RPG大型3D游戏寻路隐藏检测点 299.RPG大型3D游戏带价值计算跨图寻路 300.RPG大型3D游戏小退call 301.RPG大型3D游戏攻击角度分析 302.RPG大型3D游戏攻击封包构建 302.RPG大型3D游攻击封包构建 303.RPG大型3D游戏朝向算法 304.RPG大型3D游戏冒泡算法计算最近怪物 305.RPG大 型3D游戏多 种技能封包结构 306.RPG大型3D游戏快速射击 307.RPG大型3D游戏技能库遍历 308.RPG大型3D游戏技能库二叉树编写 309.RPG大型3D游残已学技能遍历 310.RPG大型3D游戏技能冷却的巧妙思路 311.RPG大型3D游戏自动打怪代码遭辑实现 312.RPG大型3D游戏自动打怪效果视频及要求 313.RPG大型3D游戏接任务封包以及防封跟包 314.RPG大型3D游戏交任务封包 315.RPG大型3D游戏交中间小任务封包 316.RPG大型3D游戏任务库遍历 317.RPG大型3D游戏已接任务二叉树及数据关联 318.RPG大型3D游戏小任务数据跟踪原因及思路 319.RPG大型3D游戏自动任务脚本逻辑 320.RPG大型3D游戏多 线程控制辅助 321.RPG大型3D游戏自动主线自动副本效果 322.RPG大型3D游戏背包物品遍历 323.RPG大型3D游戏属性暴力对比分析及智能换装 324.RPG大型3D游戏地面物品遍历 325.RPG大型3D游戏躲避子弹 326.RPG大型3D游戏物品库及数据关联 327.RPG大型3D游残吸物 328.RPG大型3D游戏宝藏遍厅 329.RPG大型3D游戏变态获取自己想要的宝藏 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:13:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十四章 回合制游戏实战 330.回合制游戏人物对象 331.回合制游残加密坐标 332.回合制游戏升级经验数组 333.回合制游残等级加密解密 334.回合制游戏战斗标志位 335.回合制游戏战斗顺序标志位 336.回合制游戏怪物数 组遍历 337.回合制游戏序号提取表 338.回合制游戏编写DLL显示窗口 339.回合制游戏调试输出人物信息 340.回合制游残寻路call 341.回合制游戏内敛汇编编写寻路call 342.回合制游戏数据定位 343.回合制游戏封装周围数 组 344.回合制游戏封装升级标志战斗标志 345.回合制游戏HOOK原理 346.回合制游戏HOOK明文 包 347.回合制游戏封包和HOOK明文包的优点发包变态功能理解 348.回合制游戏send发送封包 349.回合制游戏分析攻击封包 350.回合制游戏封装人 物攻击宝宝攻击 351.回合制游戏通过参数找选角色call验征主线程调用效果 352.回合制游戏封装主线程调用 353.回合制游戏自动打怪逻辑 354.回合制游戏自 动打怪循环寻路线程 355.回合制游戏自动打怪杀怪线程 356.回合制游戏任务遍历 357.回合制游戏二叉树递归算法 358.回合制游戏任务属性分析 359.回合制游残检测概 论 360.回合制游戏第一个任务的3连封包分析 361.回合制游戏分析加密封包 362.回合制游戏远线程注入DLL 363.回合制游戏劫持注入DLL 364.回合制游戏收 包概论 365.回合制游戏recv实例分析 366.回合制游残收 包实例 367.回合制游戏收 包一些技巧 368.回合制游戏窗口 句柄and账号 369.回合制游戏背包遍历 370.回合制游戏寻宝 坐标加密 371.回合制游戏物品丢弃封包 372.回合制游戏自动清包 373.回合制游戏控件输入call 374.回合制游残控件遍 历数 组递归 375.回合制游戏控件遍厅编写 376.回合制游戏角色遍厅 377.回合制游戏创建角色封包 378.回合制游戏画江山总结 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:14:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十五章 MOBA游戏实战 379.L某某创建 380.L某某人物血量 381.L某某编辑读取人物血量 382.L某某人物全部信息以及简单绕VM 383.L某某编程管理更新数据输出人物信息 384.L某某线程发 包 385.L某某发包函数 386.L某某明文包 387.L某某回城call 388.L某某技能call 389.L某某技能数组 390.L某某秒切黄牌 39l.L某某无限视距 392L某某过无限视距检测及补充 393.L某某主线程防 止游戏崩溃 394.L某某自动补兵题辑和分析 395.L某某攻击call 396.L某某周围遍历数组 397.L某某玩家热键功能 398.L某某编写周围遍历 399.L某某寻路 400.L某某call总结 401.L某某背包遍历 402.L某某使用物品及封包调用逻辑 403.L某某BUFF判断 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:15:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":null,"content":"第十六章 WOWx64怀J服LUA脚本编写 404.创建x64项目及×64汇编写法 405.x64项目 汇编编写 406-407.x64项目汇编编写及调试bug 408.WOW怀旧服明文封包分析 409-410.x64项目 Hook原理及实现 410.WOW怀旧服代码段保护前提下获取明文封包 411.明文结构解析处理获得完整明文包 412.新思路绕道hook明文封包 413.x64瞬间定位数据自动更新 414.×64项目通用call写法 415.WOW怀旧服分析最内层明文发包call 416.分析调用喊话封包 417.处理喊话封包长度崩溃的bug 418.函数指针方式调用×64Call 419.走路call，汇编传专递值 420.主线程调用防止崩溃和万能按键消息 421.x64项目配置lua中文版 422.lua堆栈 423.取lua脚本变量 424.lua基础知识 425.LUA脚本调用C++函数 426.使用中文lua指令 427.修改Lua支持×64 QWORD（正向程序员和逆向程序员的方法） 428.lua MLD脚本 429.lua MLD脚本2 430.x64 堆栈对齐 431.取角色对象方法1 432.取角色对象方法2 433.对象遍历结构及加密代码 434.角色ID和角色基地址 435.分析角色名字以及判断对象类型 436.角色对象下的坐标分析 437.角色对象下的主背包遍历 438.附加背包遍万 439.主背包及其他格子ID分析 440.物品名字分析 441.装备基础属性偏移分析 442.装备前名字 443.装备前缀属性分析 444.连续调CALL取绿字名字 445.物品对象下属性及金币数量 446.技能名字遍历分析 447.已学技能数组分析 448.技能等级和类型遍历 449.技能学习标志遍历 450.天赋遍万分析1 451.天赋遍历分析2 452.天赋遍厅分析3 453.专业技能分析1 454.专业技能分析2 455.飞行点遍厅 456.拍卖行遍历 457.邮箱主题遍历 458.邮件内部分析 459.BUFF遍历 460.找到明文包 461.怪物尸体是否可拾取 462.怪物尸体内部遍历 463.控件点击CALL 464.控件遍历 465.账号密码输入 466.目的坐 标找鼠标走路 467.物品发包拾取 468.自动拾取分析 469.鼠标走路方法2 470.NPC交互相关封包 471.飞厅相关封包 472.使用物品和装备 473.扔物品脱装备 474.存取物品和更换背包 475.天赋加点解BUFF及学习技能包 476.扫拍包分析 477.购买与上架 478.打开和提取邮件 479.发邮件包 480.喊话包 481.技能包及加密1 482.技能包及加密2 483.技能包及加密3 4 484.正在释放技能标志 ","date":"2021-09-25","objectID":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/:16:0","series":null,"tags":null,"title":"在线班课程目录（6788）","uri":"/2021/09/%E5%9C%A8%E7%BA%BF%E7%8F%AD%E8%AF%BE%E7%A8%8B%E7%9B%AE%E5%BD%956788/"},{"categories":["C++"],"content":"C++ 预处理器 C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： #include \u003ciostream\u003eusing namespace std; #define PI 3.14159 int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c PI \u003c\u003c endl; return 0; } 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下： $ gcc -E test.cpp \u003e test.p ... int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c 3.14159 \u003c\u003c endl; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"参数宏 您可以使用 #define 来定义一个带有参数的宏，如下所示： #include \u003ciostream\u003eusing namespace std; #define MIN(a,b) (a\u003cb ? a : b) int main () { int i, j; i = 100; j = 30; cout \u003c\u003c\"较小的值为：\" \u003c\u003c MIN(i, j) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 较小的值为：30 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码： #ifdef NULL #define NULL 0 #endif 您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： #ifdef DEBUG cerr \u003c\u003c\"Variable x = \" \u003c\u003c x \u003c\u003c endl; #endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示： #if 0不进行编译的代码 #endif 让我们尝试下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; #define DEBUG #define MIN(a,b) (((a)\u003c(b)) ? a : b) int main () { int i, j; i = 100; j = 30; #ifdef DEBUG cerr \u003c\u003c\"Trace: Inside main function\" \u003c\u003c endl; #endif #if 0/* 这是注释部分 */ cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; #endif cout \u003c\u003c\"The minimum is \" \u003c\u003c MIN(i, j) \u003c\u003c endl; #ifdef DEBUG cerr \u003c\u003c\"Trace: Coming out of main function\" \u003c\u003c endl; #endif return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Trace: Inside main function The minimum is 30 Trace: Coming out of main function ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 请看下面的宏定义： 实例 #include \u003ciostream\u003eusing namespace std; #define MKSTR( x ) #x int main () { cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： HELLO C++ 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; 转换成了： cout \u003c\u003c \"HELLO C++\" \u003c\u003c endl; ## 运算符用于连接两个令牌。下面是一个实例： #define CONCAT( x, y ) x ## y 当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++\"，如下面实例所示。 实例 #include \u003ciostream\u003eusing namespace std; #define concat(a, b) a ## b int main() { int xy = 100; cout \u003c\u003c concat(x, y); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 100 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c concat(x, y); 转换成了： cout \u003c\u003c xy; ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 中的预定义宏 C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 让我们看看上述这些宏的实例： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Value of __LINE__ : \" \u003c\u003c __LINE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __FILE__ : \" \u003c\u003c __FILE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __DATE__ : \" \u003c\u003c __DATE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __TIME__ : \" \u003c\u003c __TIME__ \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of __LINE__ : 6 Value of __FILE__ : test.cpp Value of __DATE__ : Feb 28 2011 Value of __TIME__ : 18:52:48 菜鸟官方笔记 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 字符串化的意思，出现在宏定义中的#是把跟在后面的参数转换成一个字符串。 当用作字符串化操作时，# 的主要作用是将宏参数不经扩展地转换成字符串常量。 宏定义参数的左右两边的空格会被忽略，参数的各个 Token 之间的多个空格会被转换成一个空格。 宏定义参数中含有需要特殊含义字符如\"或\\时，它们前面会自动被加上转义字符 \\。 ## 连接符号，把参数连在一起。 将多个 Token 连接成一个 Token。要点： 它不能是宏定义中的第一个或最后一个 Token。 前后的空格可有可无。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"预处理更多例子。 #if SOMETHING\u003e=100 //... #else //... #endif #ifndef SOMETHING_H #define SOMETHING_H //... #endif #if (defined DEBUG)\u0026\u0026(defined SOMETHING) //... #endif #ifdef SOMETHING int func1(){/*...*/} #else int func1(){/*...*/} #endif #ifdef SOMETHING namespace space1{ #endif //... #ifdef SOMETHING }//space1 #endif ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记36预处理器","uri":"/2021/09/c-%E7%AC%94%E8%AE%B036%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 程序终止(interrupt)信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"signal() 函数 C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： void (*signal (int sig, void (*func)(int)))(int); 这个看起来有点费劲，以下语法格式更容易理解： signal(registered signal, signal handler) 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。 让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例： 实例 #include \u003ciostream\u003e#include \u003ccsignal\u003e#include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(1){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Going to sleep.... Going to sleep.... Going to sleep.... 现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"raise() 函数 您可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下： int raise (signal sig); 在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例： 实例 #include \u003ciostream\u003e#include \u003ccsignal\u003e#include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; if( i == 3 ){ raise( SIGINT); } sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果，并会自动退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记37信号处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B037%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"创建线程 下面的程序，我们可以用它来创建一个 POSIX 线程： #include \u003cpthread.h\u003epthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"终止线程 使用下面的程序，我们可以用它来终止一个 POSIX 线程： #include \u003cpthread.h\u003epthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"实例 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\": 实例 #include \u003ciostream\u003e// 必须的头文件 #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 // 线程的运行函数 void* say_hello(void* args) { cout \u003c\u003c \"Hello Runoob！\" \u003c\u003c endl; return 0; } int main() { // 定义线程的 id 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for(int i = 0; i \u003c NUM_THREADS; ++i) { //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(\u0026tids[i], NULL, say_hello, NULL); if (ret != 0) { cout \u003c\u003c \"pthread_create error: error_code=\" \u003c\u003c ret \u003c\u003c endl; } } //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来； pthread_exit(NULL); } 使用 -lpthread 库编译下面的程序： $ g++ test.cpp -lpthread -o test.o 现在，执行程序，将产生下列结果： $ ./test.o Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。 实例 //文件名：test.cpp #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 void *PrintHello(void *threadid) { // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout \u003c\u003c \"Hello Runoob! 线程 ID, \" \u003c\u003c tid \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; int indexes[NUM_THREADS];// 用数组来保存i的值 int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : 创建线程, \" \u003c\u003c i \u003c\u003c endl; indexes[i] = i; //先保存i的值 // 传入的时候必须强制转换为void* 类型，即无类型指针 rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026(indexes[i])); if (rc){ cout \u003c\u003c \"Error:无法创建线程,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 现在编译并执行程序，将产生下列结果： $ g++ test.cpp -lpthread -o test.o $ ./test.o main() : 创建线程, 0 main() : 创建线程, 1 Hello Runoob! 线程 ID, 0 main() : 创建线程, Hello Runoob! 线程 ID, 21 main() : 创建线程, 3 Hello Runoob! 线程 ID, 2 main() : 创建线程, 4 Hello Runoob! 线程 ID, 3 Hello Runoob! 线程 ID, 4 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"向线程传递参数 这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示： 实例 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg) { struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout \u003c\u003c \"Thread ID : \" \u003c\u003c my_data-\u003ethread_id ; cout \u003c\u003c \" Message : \" \u003c\u003c my_data-\u003emessage \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c\"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; td[i].thread_id = i; td[i].message = (char*)\"This is message\"; rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026td[i]); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： $ g++ -Wno-write-strings test.cpp -lpthread -o test.o $ ./test.o main() : creating thread, 0 main() : creating thread, 1 Thread ID : 0 Message : This is message main() : creating thread, Thread ID : 21 Message : This is message main() : creating thread, 3 Thread ID : 2 Message : This is message main() : creating thread, 4 Thread ID : 3 Message : This is message Thread ID : 4 Message : This is message ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"连接和分离线程 我们可以使用以下两个函数来连接或分离线程： pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。 实例 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e using namespace std; #define NUM_THREADS 5 void *wait(void *t) { int i; long tid; tid = (long)t; sleep(1); cout \u003c\u003c \"Sleeping in thread \" \u003c\u003c endl; cout \u003c\u003c \"Thread with id : \" \u003c\u003c tid \u003c\u003c \" ...exiting \" \u003c\u003c endl; pthread_exit(NULL); } int main () { int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_JOINABLE); for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; rc = pthread_create(\u0026threads[i], NULL, wait, (void *)\u0026i ); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } // 删除属性，并等待其他线程 pthread_attr_destroy(\u0026attr); for( i=0; i \u003c NUM_THREADS; i++ ){ rc = pthread_join(threads[i], \u0026status); if (rc){ cout \u003c\u003c \"Error:unable to join,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } cout \u003c\u003c \"Main: completed thread id :\" \u003c\u003c i ; cout \u003c\u003c \" exiting with status :\" \u003c\u003c status \u003c\u003c endl; } cout \u003c\u003c \"Main: program exiting.\" \u003c\u003c endl; pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Sleeping in thread Thread with id : 4 ...exiting Sleeping in thread Thread with id : 3 ...exiting Sleeping in thread Thread with id : 2 ...exiting Sleeping in thread Thread with id : 1 ...exiting Sleeping in thread Thread with id : 0 ...exiting Main: completed thread id :0 exiting with status :0 Main: completed thread id :1 exiting with status :0 Main: completed thread id :2 exiting with status :0 Main: completed thread id :3 exiting with status :0 Main: completed thread id :4 exiting with status :0 Main: program exiting. 更多实例参考：http://www.runoob.com/w3cnote/cpp-multithread-demo.html 菜鸟官方笔记 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"c++ 11 之后有了标准的线程库： #include \u003ciostream\u003e #include \u003cthread\u003e std:🧵:id main_thread_id = std::this_thread::get_id(); void hello() { std::cout \u003c\u003c \"Hello Concurrent World\\n\"; if (main_thread_id == std::this_thread::get_id()) std::cout \u003c\u003c \"This is the main thread.\\n\"; else std::cout \u003c\u003c \"This is not the main thread.\\n\"; } void pause_thread(int n) { std::this_thread::sleep_for(std::chrono::seconds(n)); std::cout \u003c\u003c \"pause of \" \u003c\u003c n \u003c\u003c \" seconds ended\\n\"; } int main() { std::thread t(hello); std::cout \u003c\u003c t.hardware_concurrency() \u003c\u003c std::endl;//可以并发执行多少个(不准确) std::cout \u003c\u003c \"native_handle \" \u003c\u003c t.native_handle() \u003c\u003c std::endl;//可以并发执行多少个(不准确) t.join(); std::thread a(hello); a.detach(); std::thread threads[5]; // 默认构造线程 std::cout \u003c\u003c \"Spawning 5 threads...\\n\"; for (int i = 0; i \u003c 5; ++i) threads[i] = std::thread(pause_thread, i + 1); // move-assign threads std::cout \u003c\u003c \"Done spawning threads. Now waiting for them to join:\\n\"; for (auto \u0026thread : threads) thread.join(); std::cout \u003c\u003c \"All threads joined!\\n\"; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"要注意内存泄露问题 如果设置为 PTHREAD_CREATE_JOINABLE，就继续用 pthread_join() 来等待和释放资源，否则会内存泄露。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记38多线程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B038%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"C++ Web 编程 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。 公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 架构图 下图演示了 CGI 的架构： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi。 默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分： \u003cDirectory \"/var/www/cgi-bin\"\u003e AllowOverride None Options ExecCGI Order allow,deny Allow from all \u003c/Directory\u003e \u003cDirectory \"/var/www/cgi-bin\"\u003e Options All \u003c/Directory\u003e 在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"第一个 CGI 程序 请看下面的 C++ 程序： 实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eHello World - 第一个 CGI 程序\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ch2\u003eHello World! 这是我的第一个 CGI 程序\u003c/h2\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 chmod 755 cplusplus.cgi UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出： ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Hello World! 这是我的第一个 CGI 程序 上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 Content-type:text/html\\r\\n\\r\\n。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"HTTP 头信息 行 Content-type:text/html\\r\\n\\r\\n 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下： HTTP 字段名称: 字段内容 例如 Content-type: text/html\\r\\n\\r\\n 还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。 头信息 描述 Content-type: MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 Expires: Date 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 Location: URL 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 Last-modified: Date 资源的最后修改日期。 Content-length: N 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 Set-Cookie: String 通过 string 设置 cookie。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 环境变量 所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。 变量名 描述 CONTENT_TYPE 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 CONTENT_LENGTH 查询的信息长度。只对 POST 请求可用。 HTTP_COOKIE 以键 \u0026 值对的形式返回设置的 cookies。 HTTP_USER_AGENT 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 PATH_INFO CGI 脚本的路径。 QUERY_STRING 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 REMOTE_ADDR 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 REMOTE_HOST 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 REQUEST_METHOD 用于发出请求的方法。最常见的方法是 GET 和 POST。 SCRIPT_FILENAME CGI 脚本的完整路径。 SCRIPT_NAME CGI 脚本的名称。 SERVER_NAME 服务器的主机名或 IP 地址。 SERVER_SOFTWARE 服务器上运行的软件的名称和版本。 下面的 CGI 程序列出了所有的 CGI 变量。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cstdlib.h\u003e#include \u003cstring\u003eusing namespace std; const string ENV[ 24 ] = { \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\", \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\", \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\", \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\", \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\", \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\", \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\", \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\", \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" }; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 环境变量\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\"cellspacing = \\\"2\\\"\u003e\"; for ( int i = 0; i \u003c 24; i++ ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c ENV[ i ] \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; // 尝试检索环境变量的值 char *value = getenv( ENV[ i ].c_str() ); if ( value != 0 ){ cout \u003c\u003c value; }else{ cout \u003c\u003c \"环境变量不存在。\"; } cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:9:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ CGI 库 在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 ftp://ftp.gnu.org/gnu/cgicc/ 上下载这个 CGI 库，并按照下面的步骤安装库： $ tar xzf cgicc-X.X.X.tar.gz $ cd cgicc-X.X.X/ $ ./configure --prefix=/usr $ make $ make install **注意：**libcgicc.so 和 libcgicc.a 库会被安装到/usr/lib目录下，需执行拷贝命令： $ sudo cp /usr/lib/libcgicc.* /usr/lib64/ 才能使 CGI 程序自动找到 libcgicc.so 动态链接库。 您可以点击 C++ CGI Lib Documentation，查看相关的库文档。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:10:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"GET 和 POST 方法 您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:11:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 GET 方法传递信息 GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示： http://www.test.com/cgi-bin/cpp.cgi?key1=value1\u0026key2=value2 GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。 当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。 您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML 标签的 GET 方法来传信息。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:12:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的 URL 实例：Get 方法 下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。 /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 下面的实例生成 cpp_get.cgi CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息： 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e使用 GET 和 POST 方法\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"first_name\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"名：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for first name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; fi = formData.getElement(\"last_name\"); if( !fi-\u003eisEmpty() \u0026\u0026fi != (*formData).end()) { cout \u003c\u003c \"姓：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for last name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，如下所示： $g++ -o cpp_get.cgi cpp_get.cpp -lcgicc 生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问： /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 这会产生以下结果： 名：ZARA 姓：ALI ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:13:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的表单实例：GET 方法 下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。 \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"get\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e \u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:14:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 POST 方法传递信息 一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。 我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示： \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"post\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e\u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:15:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递复选框数据 当需要选择多个选项时，我们使用复选框。 下面的 HTML 代码实例是一个带有两个复选框的表单： \u003cform action=\"/cgi-bin/cpp_checkbox.cgi\" method=\"POST\" target=\"_blank\"\u003e \u003cinput type=\"checkbox\" name=\"maths\" value=\"on\" /\u003e 数学 \u003cinput type=\"checkbox\" name=\"physics\" value=\"on\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; bool maths_flag, physics_flag; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递复选框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; maths_flag = formData.queryCheckbox(\"maths\"); if( maths_flag ) { cout \u003c\u003c \"Maths Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Maths Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; physics_flag = formData.queryCheckbox(\"physics\"); if( physics_flag ) { cout \u003c\u003c \"Physics Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Physics Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:16:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递单选按钮数据 当只需要选择一个选项时，我们使用单选按钮。 下面的 HTML 代码实例是一个带有两个单选按钮的表单： \u003cform action=\"/cgi-bin/cpp_radiobutton.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cinput type=\"radio\" name=\"subject\" value=\"maths\" checked=\"checked\"/\u003e 数学 \u003cinput type=\"radio\" name=\"subject\" value=\"physics\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递单选按钮数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"subject\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Radio box selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:17:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递文本区域数据 当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。 下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单： \u003cform action=\"/cgi-bin/cpp_textarea.cgi\" method=\"post\" target=\"_blank\"\u003e \u003ctextarea name=\"textcontent\" cols=\"40\" rows=\"4\"\u003e 请在这里输入文本... \u003c/textarea\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递文本区域数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"textcontent\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Text Content: \" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:18:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递下拉框数据 当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。 下面的 HTML 代码实例是一个带有下拉框的表单： \u003cform action=\"/cgi-bin/cpp_dropdown.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cselect name=\"dropdown\"\u003e \u003coption value=\"Maths\" selected\u003e数学\u003c/option\u003e \u003coption value=\"Physics\"\u003e物理\u003c/option\u003e \u003c/select\u003e \u003cinput type=\"submit\" value=\"提交\"/\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递下拉框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"dropdown\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Value Selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:19:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"在 CGI 中使用 Cookies HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。 在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"它是如何工作的 服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。 cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段： Expires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。 Domain : 网站的域名。 Path : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。 Secure : 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。 Name=Value : cookie 以键值对的形式被设置和获取。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"设置 Cookies 向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示： 实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Set-Cookie:UserID=XYZ;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Password=XYZ123;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Path=/perl;\\n\"; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"设置 cookies\" \u003c\u003c endl; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 从这个实例中，我们了解了如何设置 cookies。我们使用 Set-Cookie HTTP 头来设置 cookies。 在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 “Content-type:text/html\\r\\n\\r\\n 之前被设置的。 编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies： /cgi-bin/setcookies.cgi ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"获取 Cookies 检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下： key1=value1;key2=value2;key3=value3.... 下面的实例演示了如何获取 cookies。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; const_cookie_iterator cci; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\"cellspacing = \\\"2\\\"\u003e\"; // 获取环境变量 const CgiEnvironment\u0026 env = cgi.getEnvironment(); for( cci = env.getCookieList().begin(); cci != env.getCookieList().end(); ++cci ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c cci-\u003egetName() \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; cout \u003c\u003c cci-\u003egetValue(); cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies： /cgi-bin/getcookies.cgi 这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies： UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:20:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"文件上传实例 为了上传一个文件，HTML 表单必须把 enctype 属性设置为 multipart/form-data。带有文件类型的 input 标签会创建一个 “Browse” 按钮。 \u003chtml\u003e \u003cbody\u003e \u003cform enctype=\"multipart/form-data\" action=\"/cgi-bin/cpp_uploadfile.cgi\" method=\"post\"\u003e \u003cp\u003e文件：\u003cinput type=\"file\" name=\"userfile\" /\u003e\u003c/p\u003e \u003cp\u003e\u003cinput type=\"submit\" value=\"上传\" /\u003e\u003c/p\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 这段代码的结果是下面的表单： **注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。 下面是用于处理文件上传的脚本 cpp_uploadfile.cpp： 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的文件上传\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; // 获取要被上传的文件列表 const_file_iterator file = cgi.getFile(\"userfile\"); if(file != cgi.getFiles().end()) { // 在 cout 中发送数据类型 cout \u003c\u003c HTTPContentHeader(file-\u003egetDataType()); // 在 cout 中写入内容 file-\u003ewriteToStream(cout); } cout \u003c\u003c \"\u003c文件上传成功\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 上面的实例是在 cout 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。 ","date":"2021-09-23","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/:21:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记39Web 编程","uri":"/2021/09/c-%E7%AC%94%E8%AE%B039web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 动态内存 C++ 程序中的内存分为两个部分： **栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"malloc 和 free 成对出现 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： new data-type; double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; if( !(pvalue = new double )) { cout \u003c\u003c \"Error: out of memory.\" \u003c\u003cendl; exit(1); } malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 delete pvalue; // 释放 pvalue 所指向的内存 实例 #include \u003ciostream\u003eusing namespace std; int main () { double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout \u003c\u003c \"Value of pvalue : \" \u003c\u003c *pvalue \u003c\u003c endl; delete pvalue; // 释放内存 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of pvalue : 29495 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"数组的动态内存分配 假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示： char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 要删除我们刚才创建的数组，语句如下： delete [] pvalue; // 删除 pvalue 所指向的数组 下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示： 一维数组 // 动态分配,数组长度为 m int *array=new int [m]; //释放内存 delete [] array; 二维数组 int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int [n] ; } //释放 for( int i=0; i\u003cm; i++ ) { delete [] array[i]; } delete [] array; 二维数组实例测试： 实例 #include \u003ciostream\u003eusing namespace std; int main() { int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i\u003c4;i++){ p[i]=new int [8]; } for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++){ p[i][j] = j*i; } } //打印数据 for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++) { if(j==0) cout\u003c\u003cendl; cout\u003c\u003cp[i][j]\u003c\u003c\"\\t\"; } } //开始释放申请的堆 for(i=0; i\u003c4; i++){ delete [] p[i]; } delete [] p; return 0; } 三维数组 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int *[n]; for( int j=0; j\u003cn; j++ ) { array[i][j] = new int [h]; } } //释放 for( int i=0; i\u003cm; i++ ) { for( int j=0; j\u003cn; j++ ) { delete[] array[i][j]; } delete[] array[i]; } delete[] array; 三维数组测试实例： 实例 #include \u003ciostream\u003eusing namespace std; int main() { int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i\u003c2; i++) { p[i]=new int *[3]; for(j=0; j\u003c3; j++) p[i][j]=new int[4]; } //输出 p[i][j][k] 三维数据 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { for(k=0;k\u003c4;k++) { p[i][j][k]=i+j+k; cout\u003c\u003cp[i][j][k]\u003c\u003c\" \"; } cout\u003c\u003cendl; } cout\u003c\u003cendl; } // 释放内存 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { delete [] p[i][j]; } } for(i=0; i\u003c2; i++) { delete [] p[i]; } delete [] p; return 0; } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"对象的动态内存分配 对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念： 实例 #include \u003ciostream\u003eusing namespace std; class Box { public: Box() { cout \u003c\u003c \"调用构造函数！\" \u003c\u003cendl; } ~Box() { cout \u003c\u003c \"调用析构函数！\" \u003c\u003cendl; } }; int main( ) { Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 菜鸟官方笔记 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"delete 与 delete[] 区别： 针对简单类型 使用 new 分配后的不管是数组还是非数组形式内存空间用两种方式均可 如： int *a = new int[10]; delete a; delete [] a; 针对类Class 两种方式体现出具体差异 当你通过下列方式分配一个类对象数组： class A { private: char *m_cBuffer; int m_nLen; public: A(){ m_cBuffer = new char[m_nLen]; } ~A() { delete [] m_cBuffer; } }; A *a = new A[10]; // 仅释放了a指针指向的全部内存空间 但是只调用了a[0]对象的析构函数 剩下的从a[1]到a[9]这9个用户自行分配的m_cBuffer对应内存空间将不能释放 从而造成内存泄漏 delete a; // 调用使用类对象的析构函数释放用户自己分配内存空间并且 释放了a指针指向的全部内存空间 delete [] a; 所以总结下就是，如果ptr代表一个用new申请的内存返回的内存空间地址，即所谓的指针，那么： delete ptr – 代表用来释放内存，且只用来释放ptr指向的内存。 delete[] rg – 用来释放rg指向的内存，！！还逐一调用数组中每个对象的 destructor！！ 对于像 int/char/long/int*/struct 等等简单数据类型，由于对象没有 destructor，所以用 delete 和 delete [] 是一样的！但是如果是C++ 对象数组就不同了！ ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记33动态内存","uri":"/2021/09/c-%E7%AC%94%E8%AE%B033%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++ 命名空间 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： namespace namespace_name { // 代码声明 } 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围： 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int main () { // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space Inside second_space ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"using 指令 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } using namespace first_space; int main () { // 调用第一个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： using std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示： 实例 #include \u003ciostream\u003eusing std::cout; int main () { cout \u003c\u003c \"std::endl is used with std!\" \u003c\u003c std::endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： std::endl is used with std! using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： namespace namespace_name { // 代码声明 } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示： namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } 您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员： // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示： 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } } using namespace first_space::second_space; int main () { // 调用第二个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside second_space 菜鸟官方笔记 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"关于命名空间内变量和函数及全局变量的使用和作用域: #include \u003ciostream\u003eusing namespace std; namespace A { int a = 100; namespace B //嵌套一个命名空间B { int a =20; } } int a = 200;//定义一个全局变量 int main(int argc, char *argv[]) { cout \u003c\u003c\"A::a =\"\u003c\u003c A::a \u003c\u003c endl; cout \u003c\u003c\"A::B::a =\"\u003c\u003cA::B::a \u003c\u003c endl; cout \u003c\u003c\"a =\"\u003c\u003ca \u003c\u003c endl; cout \u003c\u003c\"::a =\"\u003c\u003c::a \u003c\u003c endl; int a = 30; cout \u003c\u003c\"a =\"\u003c\u003ca \u003c\u003c endl; cout \u003c\u003c\"::a =\"\u003c\u003c::a \u003c\u003c endl; return 0; } 结果： A::a =100 A::B::a =20 a =200 //全局变量a ::a =200 a =30 //局部变量a ::a =200 即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 补充关于 using 的错误事例： #include \u003ciostream\u003eusing namespace std; namespace A { int a = 100; int fun() { cout\u003c\u003c\"a = \"\u003c\u003ca\u003c\u003cendl; } namespace B //嵌套一个命名空间B { int a =20; int fun() { cout\u003c\u003c\"a = \"\u003c\u003ca\u003c\u003cendl; } } } int main(int argc, char *argv[]) { cout\u003c\u003ca\u003c\u003cendl; fun(); return 0; } 这样会出错：会显示 a 变量和 fun 函数 “was not declared in this scope”，即找不到这个 a 和 fun 函数。 解决办法： 用 using 来告诉编译器用到的是哪个命名空间内的内容。在 main() 上面加 using namespace A; 或者 using namespace A::B; 。这样就可以使用其中的 a 和 fun()。但是不能同时使用，因为这样也会导致编译出错，编译器器不知道要去使用哪个 a 和 fun()。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"补充一个命名空间冲突的情况： #include \u003ciostream\u003e using namespace std; namespace A { int a = 100; namespace B //嵌套一个命名空间B { int a = 20; } } int a = 200;//定义一个全局变量 int main(int argc, char *argv[]) { cout \u003c\u003c \"A::a =\" \u003c\u003c A::a \u003c\u003c endl; //A::a =100 cout \u003c\u003c \"A::B::a =\" \u003c\u003c A::B::a \u003c\u003c endl; //A::B::a =20 cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; //a =200 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 using namespace A; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; // Reference to 'a' is ambiguous // 命名空间冲突，编译期错误 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 int a = 30; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; //a =30 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 //即：全局变量 a 表达为 ::a，用于当有同名的局部变量时来区别两者。 using namespace A; cout \u003c\u003c \"a =\" \u003c\u003c a \u003c\u003c endl; // a =30 // 当有本地同名变量后，优先使用本地，冲突解除 cout \u003c\u003c \"::a =\" \u003c\u003c ::a \u003c\u003c endl; //::a =200 return 0; } ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记34命名空间","uri":"/2021/09/c-%E7%AC%94%E8%AE%B034%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。 您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。 ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"函数模板 模板函数定义的一般形式如下所示： template \u003ctypename type\u003e ret-type func-name(parameter list) { // 函数的主体 } 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 下面是函数模板的实例，返回两个数中的最大值： 实例 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max (T const\u0026 a, T const\u0026 b) { return a \u003c b ? b:a; } int main () { int i = 39; int j = 20; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： template \u003cclass type\u003e class class-name { . . . } 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack\u003c\u003e，并实现了泛型方法来对元素进行入栈出栈操作： ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccstdlib\u003e#include \u003cstring\u003e#include \u003cstdexcept\u003e using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; // 元素 public: void push(T const\u0026); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push (T const\u0026 elem) { // 追加传入元素的副本 elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop () { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top () const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; // int 类型的栈 Stack\u003cstring\u003e stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout \u003c\u003c intStack.top() \u003c\u003cendl; // 操作 string 类型的栈 stringStack.push(\"hello\"); cout \u003c\u003c stringStack.top() \u003c\u003c std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003cendl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果： 7 hello Exception: Stack\u003c\u003e::pop(): empty stack ","date":"2021-09-20","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记35模板","uri":"/2021/09/c-%E7%AC%94%E8%AE%B035%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"封包的加密与解密、线程发包专题 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:0:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"三大发包函数 send WSASend sendto 模块前缀为ws2_32 WSPSend （在同一个电脑上位置是固定的） DXF单机版 私服 找到WSPSend 附加上口袋西游(或者任何的send发包的软件都可以)，跳到send位置 send 第三个call下断（win7是第三个，win10是第四个），断下后F7进入，这就是WSPSend的位置。 附加到目标进程，跳转到这个地址，下断。 有时WSASend胡乱断，不是真正的发包 ，根据它的特征码，去搜索。查找–\u003e所有命令 ,输入特征码，然后右键–\u003e在每个命令上下设置断点。然后在所有被断下的位置做标记（注释），并取消断点。然后去执行喊话等发包操作，看在哪断下。如果不断，说明在刚才被标记的里面。之后逐一下断测试。 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:1:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"线程发包 线程发包的特点： 断得非常频繁 任何功能堆栈返回都是一样的 正常流程 找到发包函数 判断是不是线程发包 判断包内容(非包长)的地址是否变化 跳出线程发包的步骤： graph z([找到发包函数]) --\u003ez1{判断是不是\u003cbr\u003e线程发包} --是--\u003e 想办法跳出线程发包 --\u003ez2{\"判断包内容\u003cbr\u003e(非包长)的地址\u003cbr\u003e是否变化\"} z1 --否--\u003e z3[正常发包] z2 --是--\u003e z4[唯一突破口,找到包的内容来源]--\u003e z5[\"向上追,直到追到不变的地址\"]--\u003e z7[\"在不变的地址上，\u003cbr\u003e下硬件写入断点，\u003cbr\u003e返回，看是否跳出线程外\"] z2 --否--\u003e z6[在包内容处下硬件写入dword断点] --\u003e 就能跳出线程发包 --\u003e z8 z7 --否--\u003e z5 z7 --是--\u003e z8([yeah]) ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:2:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"条件断 实例 [[esp+8]]!=11\u0026\u0026[[esp+8]]!=4 # esp 是堆顶 # == 等于 # != 不等于 # \u0026\u0026 和 word ptr[[[ebp+8]+4]] != 11 #word ptr 代表一个字节 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:3:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"找出加密封包 找出加密封包的步骤： graph z[\"跳出线程发包后\"] z1[\"配好表达式\"] z2[\"验证是不是加密封包\"] z3[\"在此处(跳出线程封包的位置)下断\"] z3a[\"喊话或者其它动作，令其断下\"] z4[\"dd 表达式\"] z5[\"在send处下断\"] z5a[\"喊话或者其它动作，令其断下\"] z6[\"找到封包内容\"] z7[\"此处应该就是封包内容\"] z8{\"对比\"} z9[\"确定是加密封包\"] z10[\"失败，寻找错误或者换其他方法\"] z--\u003ez1--\u003ez2 z2--\u003ez5--\u003ez5a--\u003ez6--\u003ez8 z2--\u003ez3--\u003ez3a--\u003ez4--\u003ez7--\u003ez8 z8--相同--\u003ez9 z8--不相同--\u003ez10 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:4:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"明文包 graph LR 功能call --\u003e 明文封包 --\u003e 加密CALL --\u003e 加密封包 到加密封包的外层找明文包。 找出明文封包的步骤： graph LR 加密封包 --\u003e Ctrl+F9到外层找明文包 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:5:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"找出加密CALL 找出加密CALL的步骤： graph z1[\"找出已加密的最外层\"]--\u003e z2[\"找出明文封包\"]--\u003e z3[\"进入明文包\"]--\u003e z4[\"先走一圈，并标注跳转\"] z5[\"回到明文封包外部\"]--\u003e z6[\"下断\"]--\u003e z7[\"喊话\"]--\u003e z8[\"dd 明文封包内容\"]--\u003e z9[\"F7进入明文封包\"]--\u003e z10[\"F8逐步走，并观察内存窗口中明文封包何时变化\"]--\u003e z11[\"如果经过某个call之后，内存窗口内容变化\"]--\u003e z12[\"找到加密CALL\"] ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:6:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"分析加密CALL 需要分析的元素： CALL的参数 包长 包地址 加密地址 加密长度 密钥（找到就行） CALL内的寄存器 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:7:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"调用加密CALL加密 实例 push 12345678 push 12345678 push 11 mov ecx,[00f84ba4] mov ecx,[ecx] mov ecx.[ecx+4] mov ecx,[ecx+14] mov ecx, [ecx] lea ecx,[ecx+54] push ecx call 00B94700 add esp, 10 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:8:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"发送喊话函数封包 void HXSYDialog::OnBnClickedEutton15() { byte a[100] = {0x11,0x00,0x7E,0x00,0x00,0x00,0x00,0x02,0x00,0x31,0x31, OFF, OxFF,OxFF,OxFF,0x00,0x00,0x00,0x00,0x60,0xA8,0x6C}: DWORD 包长 = 0x13; DWORD 包地址=(DWORD)a; DWORD 加密地址 = 包地址+2; DWORD 加密长度 = 包长-2; __asm { push 加密地址 push 加密地址 push 加密长度 mov ecx, 0x00f84ba4 mov ecx, [ecx] mov ecx, [ecx] mov ecx, [ecx+0x4] mov ecx, [ecx+0x14] mov ecx, [ecx] lea ecx, [ecx+0x54] push ecx mov eax, 0x00B94700 call eax add esp, 0x10 } HWND 窗口句柄=FindWindowA(\"Lapis Network C1ass\",0); DWORD A=GetWindowLongW(窗口句柄，-21); DWORD S=*(DWORD*)(A+0x38); send(S,(const char*)包地址,包长,0); //TODO：在此添加控件通知处理程序代码 } ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:9:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"C++写 加密CALL __declspec(naked) void 加密Ca11(DWORD秘钥,DWORD 加密长度,DWOED 加密地址,DWORD 加密地址2) { __asm { ... } } //__declspec(naked) 裸体函数 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:10:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"结合加密call，写加密封包，完全不走游戏代码 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:11:0","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":null,"content":"不走游戏代码，写吃药封包 ","date":"2021-09-19","objectID":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/:11:1","series":null,"tags":null,"title":"封包的加密与解密、线程发包专题","uri":"/2021/09/%E5%B0%81%E5%8C%85%E7%9A%84%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E7%BA%BF%E7%A8%8B%E5%8F%91%E5%8C%85%E4%B8%93%E9%A2%98/"},{"categories":["C++"],"content":"C++ 异常处理 C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。 double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"捕获异常 catch 块跟在 try 块后面，用于捕获异常。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示： try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 实例 #include \u003ciostream\u003eusing namespace std; double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout \u003c\u003c z \u003c\u003c endl; }catch (const char* msg) { cerr \u003c\u003c msg \u003c\u003c endl; } return 0; } 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： Division by zero condition! ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 标准的异常 C++ 提供了一系列标准的异常，定义在 \u003cexception\u003e 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset\u003c\u003e::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"定义新的异常 您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 实例 #include \u003ciostream\u003e#include \u003cexception\u003eusing namespace std; struct MyException : public exception { const char * what () const throw () { return \"C++ Exception\"; } }; int main() { try { throw MyException(); } catch(MyException\u0026 e) { std::cout \u003c\u003c \"MyException caught\" \u003c\u003c std::endl; std::cout \u003c\u003c e.what() \u003c\u003c std::endl; } catch(std::exception\u0026 e) { //其他的错误 } } 这将产生以下结果： MyException caught C++ Exception 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。 菜鸟官方笔记 在 C++11 中，声明一个函数不可以抛出任何异常使用关键字 noexcept。 void mightThrow(); // could throw any exceptions. void doesNotThrow() noexcept; // does not throw any exceptions. 下面两个函数声明的异常规格在语义上是相同的，都表示函数不抛出任何异常。 void old_stytle() throw(); void new_style() noexcept; 对于: const char * what () const throw () { //函数体 } 做几点说明，从左到右看： const char * 表示返回值类型 what 是函数名称 () 是参数列表 const 表示该成员函数不能修改成员变量 throw() 是异常规格说明符。括号内写该函数可抛出的异常类型 上述 5 点均为函数的声明部分。 ","date":"2021-09-17","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记32异常处理","uri":"/2021/09/c-%E7%AC%94%E8%AE%B032%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 文件和流 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 本教程介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： ofstream outfile; outfile.open(\"file.dat\", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： ifstream afile; afile.open(\"file.dat\", ios::out | ios::in ); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"关闭文件 当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"写入文件 在 C++ 编程中，我们使用流插入运算符（ « ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取文件 在 C++ 编程中，我们使用流提取运算符（ » ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取 \u0026 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"实例 #include \u003cfstream\u003e#include \u003ciostream\u003eusing namespace std; int main () { char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cout \u003c\u003c \"Writing to the file\" \u003c\u003c endl; cout \u003c\u003c \"Enter your name: \"; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; cout \u003c\u003c \"Enter your age: \"; cin \u003e\u003e data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); cout \u003c\u003c \"Reading from the file\" \u003c\u003c endl; infile \u003e\u003e data; // 在屏幕上写入数据 cout \u003c\u003c data \u003c\u003c endl; // 再次从文件读取数据，并显示它 infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 infile.close(); return 0; } 当上面的代码被编译和执行时，它会产生下列输入和输出： $./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"文件位置指针 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（“seek get”）和关于 ostream 的 seekp（“seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); ","date":"2021-09-13","objectID":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 31文件和流","uri":"/2021/09/c-31%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"C++ 异常处理 异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：try、catch、throw。 throw: 当问题出现时，程序会抛出一个异常。这是通过使用 throw 关键字来完成的。 catch: 在您想要处理问题的地方，通过异常处理程序捕获异常。catch 关键字用于捕获异常。 try: try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 如果有一个块抛出一个异常，捕获异常的方法会使用 try 和 catch 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示： try { // 保护代码 }catch( ExceptionName e1 ) { // catch 块 }catch( ExceptionName e2 ) { // catch 块 }catch( ExceptionName eN ) { // catch 块 } 如果 try 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 catch 语句，用于捕获不同类型的异常。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"抛出异常 您可以使用 throw 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。 以下是尝试除以零时抛出异常的实例： double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"捕获异常 catch 块跟在 try 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。 try { // 保护代码 }catch( ExceptionName e ) { // 处理 ExceptionName 异常的代码 } 上面的代码会捕获一个类型为 ExceptionName 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示： try { // 保护代码 }catch(...) { // 能处理任何异常的代码 } 下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。 实例 #include \u003ciostream\u003eusing namespace std; double division(int a, int b) { if( b == 0 ) { throw \"Division by zero condition!\"; } return (a/b); } int main () { int x = 50; int y = 0; double z = 0; try { z = division(x, y); cout \u003c\u003c z \u003c\u003c endl; }catch (const char* msg) { cerr \u003c\u003c msg \u003c\u003c endl; } return 0; } 由于我们抛出了一个类型为 const char* 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果： Division by zero condition! ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 标准的异常 C++ 提供了一系列标准的异常，定义在 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示： 下表是对上面层次结构中出现的每个异常的说明： 异常 描述 std::exception 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 new 抛出。 std::bad_cast 该异常可以通过 dynamic_cast 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 std::bad_typeid 该异常可以通过 typeid 抛出。 std::logic_error 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset\u003c\u003e::operator。 std::runtime_error 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"定义新的异常 您可以通过继承和重载 exception 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常： 实例 #include \u003ciostream\u003e#include \u003cexception\u003eusing namespace std; struct MyException : public exception { const char * what () const throw () { return \"C++ Exception\"; } }; int main() { try { throw MyException(); } catch(MyException\u0026 e) { std::cout \u003c\u003c \"MyException caught\" \u003c\u003c std::endl; std::cout \u003c\u003c e.what() \u003c\u003c std::endl; } catch(std::exception\u0026 e) { //其他的错误 } } 这将产生以下结果： MyException caught C++ Exception 在这里，what() 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。 ","date":"2021-09-13","objectID":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 32异常处理","uri":"/2021/09/c-32%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 动态内存 了解动态内存在 C++ 中是如何工作的是成为一名合格的 C++ 程序员必不可少的。C++ 程序中的内存分为两个部分： **栈：**在函数内部声明的所有变量都将占用栈内存。 **堆：**这是程序中未使用的内存，在程序运行时可用于动态分配内存。 很多时候，您无法提前预知需要多少内存来存储某个定义变量中的特定信息，所需内存的大小需要在运行时才能确定。 在 C++ 中，您可以使用特殊的运算符为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址。这种运算符即 new 运算符。 如果您不再需要动态分配的内存空间，可以使用 delete 运算符，删除之前由 new 运算符分配的内存。 ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"new 和 delete 运算符 下面是使用 new 运算符来为任意的数据类型动态分配内存的通用语法： new data-type; 在这里，data-type 可以是包括数组在内的任意内置的数据类型，也可以是包括类或结构在内的用户自定义的任何数据类型。让我们先来看下内置的数据类型。例如，我们可以定义一个指向 double 类型的指针，然后请求内存，该内存在执行时被分配。我们可以按照下面的语句使用 new 运算符来完成这点： double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 如果自由存储区已被用完，可能无法成功分配内存。所以建议检查 new 运算符是否返回 NULL 指针，并采取以下适当的操作： double* pvalue = NULL; if( !(pvalue = new double )) { cout \u003c\u003c \"Error: out of memory.\" \u003c\u003cendl; exit(1); } malloc() 函数在 C 语言中就出现了，在 C++ 中仍然存在，但建议尽量不要使用 malloc() 函数。new 与 malloc() 函数相比，其主要的优点是，new 不只是分配了内存，它还创建了对象。 在任何时候，当您觉得某个已经动态分配内存的变量不再需要使用时，您可以使用 delete 操作符释放它所占用的内存，如下所示： delete pvalue; // 释放 pvalue 所指向的内存 下面的实例中使用了上面的概念，演示了如何使用 new 和 delete 运算符： 实例 #include \u003ciostream\u003eusing namespace std; int main () { double* pvalue = NULL; // 初始化为 null 的指针 pvalue = new double; // 为变量请求内存 *pvalue = 29494.99; // 在分配的地址存储值 cout \u003c\u003c \"Value of pvalue : \" \u003c\u003c *pvalue \u003c\u003c endl; delete pvalue; // 释放内存 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of pvalue : 29495 ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"数组的动态内存分配 假设我们要为一个字符数组（一个有 20 个字符的字符串）分配内存，我们可以使用上面实例中的语法来为数组动态地分配内存，如下所示： char* pvalue = NULL; // 初始化为 null 的指针 pvalue = new char[20]; // 为变量请求内存 要删除我们刚才创建的数组，语句如下： delete [] pvalue; // 删除 pvalue 所指向的数组 下面是 new 操作符的通用语法，可以为多维数组分配内存，如下所示： 一维数组 // 动态分配,数组长度为 m int *array=new int [m]; //释放内存 delete [] array; 二维数组 int **array // 假定数组第一维长度为 m， 第二维长度为 n // 动态分配空间 array = new int *[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int [n] ; } //释放 for( int i=0; i\u003cm; i++ ) { delete [] array[i]; } delete [] array; 二维数组实例测试： 实例 #include \u003ciostream\u003eusing namespace std; int main() { int **p; int i,j; //p[4][8] //开始分配4行8列的二维数据 p = new int *[4]; for(i=0;i\u003c4;i++){ p[i]=new int [8]; } for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++){ p[i][j] = j*i; } } //打印数据 for(i=0; i\u003c4; i++){ for(j=0; j\u003c8; j++) { if(j==0) cout\u003c\u003cendl; cout\u003c\u003cp[i][j]\u003c\u003c\"\\t\"; } } //开始释放申请的堆 for(i=0; i\u003c4; i++){ delete [] p[i]; } delete [] p; return 0; } 三维数组 int ***array; // 假定数组第一维为 m， 第二维为 n， 第三维为h // 动态分配空间 array = new int **[m]; for( int i=0; i\u003cm; i++ ) { array[i] = new int *[n]; for( int j=0; j\u003cn; j++ ) { array[i][j] = new int [h]; } } //释放 for( int i=0; i\u003cm; i++ ) { for( int j=0; j\u003cn; j++ ) { delete[] array[i][j]; } delete[] array[i]; } delete[] array; 三维数组测试实例： 实例 #include \u003ciostream\u003eusing namespace std; int main() { int i,j,k; // p[2][3][4] int ***p; p = new int **[2]; for(i=0; i\u003c2; i++) { p[i]=new int *[3]; for(j=0; j\u003c3; j++) p[i][j]=new int[4]; } //输出 p[i][j][k] 三维数据 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { for(k=0;k\u003c4;k++) { p[i][j][k]=i+j+k; cout\u003c\u003cp[i][j][k]\u003c\u003c\" \"; } cout\u003c\u003cendl; } cout\u003c\u003cendl; } // 释放内存 for(i=0; i\u003c2; i++) { for(j=0; j\u003c3; j++) { delete [] p[i][j]; } } for(i=0; i\u003c2; i++) { delete [] p[i]; } delete [] p; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"对象的动态内存分配 对象与简单的数据类型没有什么不同。例如，请看下面的代码，我们将使用一个对象数组来理清这一概念： 实例 #include \u003ciostream\u003eusing namespace std; class Box { public: Box() { cout \u003c\u003c \"调用构造函数！\" \u003c\u003cendl; } ~Box() { cout \u003c\u003c \"调用析构函数！\" \u003c\u003cendl; } }; int main( ) { Box* myBoxArray = new Box[4]; delete [] myBoxArray; // 删除数组 return 0; } 如果要为一个包含四个 Box 对象的数组分配内存，构造函数将被调用 4 次，同样地，当删除这些对象时，析构函数也将被调用相同的次数（4次）。 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用构造函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ 调用析构函数！ ","date":"2021-09-13","objectID":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 33动态内存","uri":"/2021/09/c-33%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++ 命名空间 假设这样一种情况，当一个班上有两个名叫 Zara 的学生时，为了明确区分它们，我们在使用名字之外，不得不使用一些额外的信息，比如他们的家庭住址，或者他们父母的名字等等。 同样的情况也出现在 C++ 应用程序中。例如，您可能会写一个名为 xyz() 的函数，在另一个可用的库中也存在一个相同的函数 xyz()。这样，编译器就无法判断您所使用的是哪一个 xyz() 函数。 因此，引入了命名空间这个概念，专门用于解决上面的问题，它可作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。 我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。 ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"定义命名空间 命名空间的定义使用关键字 namespace，后跟命名空间的名称，如下所示： namespace namespace_name { // 代码声明 } 为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称，如下所示： name::code; // code 可以是变量或函数 让我们来看看命名空间如何为变量或函数等实体定义范围： 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } int main () { // 调用第一个命名空间中的函数 first_space::func(); // 调用第二个命名空间中的函数 second_space::func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space Inside second_space ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"using 指令 您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称。 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } using namespace first_space; int main () { // 调用第一个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside first_space using 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句： using std::cout; 随后的代码中，在使用 cout 时就可以不用加上命名空间名称作为前缀，但是 std 命名空间中的其他项目仍然需要加上命名空间名称作为前缀，如下所示： 实例 #include \u003ciostream\u003eusing std::cout; int main () { cout \u003c\u003c \"std::endl is used with std!\" \u003c\u003c std::endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： std::endl is used with std! using 指令引入的名称遵循正常的范围规则。名称从使用 using 指令开始是可见的，直到该范围结束。此时，在范围以外定义的同名实体是隐藏的。 ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"不连续的命名空间 命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。 所以，如果命名空间中的某个组成部分需要请求定义在另一个文件中的名称，则仍然需要声明该名称。下面的命名空间定义可以是定义一个新的命名空间，也可以是为已有的命名空间增加新的元素： namespace namespace_name { // 代码声明 } ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"嵌套的命名空间 命名空间可以嵌套，您可以在一个命名空间中定义另一个命名空间，如下所示： namespace namespace_name1 { // 代码声明 namespace namespace_name2 { // 代码声明 } } 您可以通过使用 :: 运算符来访问嵌套的命名空间中的成员： // 访问 namespace_name2 中的成员 using namespace namespace_name1::namespace_name2; // 访问 namespace:name1 中的成员 using namespace namespace_name1; 在上面的语句中，如果使用的是 namespace_name1，那么在该范围内 namespace_name2 中的元素也是可用的，如下所示： 实例 #include \u003ciostream\u003eusing namespace std; // 第一个命名空间 namespace first_space{ void func(){ cout \u003c\u003c \"Inside first_space\" \u003c\u003c endl; } // 第二个命名空间 namespace second_space{ void func(){ cout \u003c\u003c \"Inside second_space\" \u003c\u003c endl; } } } using namespace first_space::second_space; int main () { // 调用第二个命名空间中的函数 func(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inside second_space ","date":"2021-09-13","objectID":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 34命名空间","uri":"/2021/09/c-34%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"C++ 模板 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。 模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。 每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。 您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。 ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"函数模板 模板函数定义的一般形式如下所示： template \u003ctypename type\u003e ret-type func-name(parameter list) { // 函数的主体 } 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 下面是函数模板的实例，返回两个数中的最大值： 实例 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; template \u003ctypename T\u003e inline T const\u0026 Max (T const\u0026 a, T const\u0026 b) { return a \u003c b ? b:a; } int main () { int i = 39; int j = 20; cout \u003c\u003c \"Max(i, j): \" \u003c\u003c Max(i, j) \u003c\u003c endl; double f1 = 13.5; double f2 = 20.7; cout \u003c\u003c \"Max(f1, f2): \" \u003c\u003c Max(f1, f2) \u003c\u003c endl; string s1 = \"Hello\"; string s2 = \"World\"; cout \u003c\u003c \"Max(s1, s2): \" \u003c\u003c Max(s1, s2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max(i, j): 39 Max(f1, f2): 20.7 Max(s1, s2): World ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： template \u003cclass type\u003e class class-name { . . . } 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack\u003c\u003e，并实现了泛型方法来对元素进行入栈出栈操作： ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003ccstdlib\u003e#include \u003cstring\u003e#include \u003cstdexcept\u003e using namespace std; template \u003cclass T\u003e class Stack { private: vector\u003cT\u003e elems; // 元素 public: void push(T const\u0026); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const{ // 如果为空则返回真。 return elems.empty(); } }; template \u003cclass T\u003e void Stack\u003cT\u003e::push (T const\u0026 elem) { // 追加传入元素的副本 elems.push_back(elem); } template \u003cclass T\u003e void Stack\u003cT\u003e::pop () { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::pop(): empty stack\"); } // 删除最后一个元素 elems.pop_back(); } template \u003cclass T\u003e T Stack\u003cT\u003e::top () const { if (elems.empty()) { throw out_of_range(\"Stack\u003c\u003e::top(): empty stack\"); } // 返回最后一个元素的副本 return elems.back(); } int main() { try { Stack\u003cint\u003e intStack; // int 类型的栈 Stack\u003cstring\u003e stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout \u003c\u003c intStack.top() \u003c\u003cendl; // 操作 string 类型的栈 stringStack.push(\"hello\"); cout \u003c\u003c stringStack.top() \u003c\u003c std::endl; stringStack.pop(); stringStack.pop(); } catch (exception const\u0026 ex) { cerr \u003c\u003c \"Exception: \" \u003c\u003c ex.what() \u003c\u003cendl; return -1; } } 当上面的代码被编译和执行时，它会产生下列结果： 7 hello Exception: Stack\u003c\u003e::pop(): empty stack ","date":"2021-09-13","objectID":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 35模板","uri":"/2021/09/c-35%E6%A8%A1%E6%9D%BF/"},{"categories":["C++"],"content":"C++ 预处理器 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。 所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。 我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。 C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"#define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： #define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： #include \u003ciostream\u003eusing namespace std; #define PI 3.14159 int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c PI \u003c\u003c endl; return 0; } 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下： $ gcc -E test.cpp \u003e test.p ... int main () { cout \u003c\u003c \"Value of PI :\" \u003c\u003c 3.14159 \u003c\u003c endl; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"参数宏 您可以使用 #define 来定义一个带有参数的宏，如下所示： #include \u003ciostream\u003eusing namespace std; #define MIN(a,b) (a\u003cb ? a : b) int main () { int i, j; i = 100; j = 30; cout \u003c\u003c\"较小的值为：\" \u003c\u003c MIN(i, j) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 较小的值为：30 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码： #ifdef NULL #define NULL 0 #endif 您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： #ifdef DEBUG cerr \u003c\u003c\"Variable x = \" \u003c\u003c x \u003c\u003c endl; #endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示： #if 0不进行编译的代码 #endif 让我们尝试下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; #define DEBUG #define MIN(a,b) (((a)\u003c(b)) ? a : b) int main () { int i, j; i = 100; j = 30; #ifdef DEBUG cerr \u003c\u003c\"Trace: Inside main function\" \u003c\u003c endl; #endif #if 0/* 这是注释部分 */ cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; #endif cout \u003c\u003c\"The minimum is \" \u003c\u003c MIN(i, j) \u003c\u003c endl; #ifdef DEBUG cerr \u003c\u003c\"Trace: Coming out of main function\" \u003c\u003c endl; #endif return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Trace: Inside main function The minimum is 30 Trace: Coming out of main function ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"# 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 请看下面的宏定义： 实例 #include \u003ciostream\u003eusing namespace std; #define MKSTR( x ) #x int main () { cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： HELLO C++ 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c MKSTR(HELLO C++) \u003c\u003c endl; 转换成了： cout \u003c\u003c \"HELLO C++\" \u003c\u003c endl; ## 运算符用于连接两个令牌。下面是一个实例： #define CONCAT( x, y ) x ## y 当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++\"，如下面实例所示。 实例 #include \u003ciostream\u003eusing namespace std; #define concat(a, b) a ## b int main() { int xy = 100; cout \u003c\u003c concat(x, y); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 100 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： cout \u003c\u003c concat(x, y); 转换成了： cout \u003c\u003c xy; ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 中的预定义宏 C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 让我们看看上述这些宏的实例： ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Value of __LINE__ : \" \u003c\u003c __LINE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __FILE__ : \" \u003c\u003c __FILE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __DATE__ : \" \u003c\u003c __DATE__ \u003c\u003c endl; cout \u003c\u003c \"Value of __TIME__ : \" \u003c\u003c __TIME__ \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of __LINE__ : 6 Value of __FILE__ : test.cpp Value of __DATE__ : Feb 28 2011 Value of __TIME__ : 18:52:48 ","date":"2021-09-13","objectID":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 36预处理器","uri":"/2021/09/c-36%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"categories":["C++"],"content":"C++ 信号处理 信号是由操作系统传给进程的中断，会提早终止一个程序。在 UNIX、LINUX、Mac OS X 或 Windows 系统上，可以通过按 Ctrl+C 产生中断。 有些信号不能被程序捕获，但是下表所列信号可以在程序中捕获，并可以基于信号采取适当的动作。这些信号是定义在 C++ 头文件 中。 信号 描述 SIGABRT 程序的异常终止，如调用 abort。 SIGFPE 错误的算术运算，比如除以零或导致溢出的操作。 SIGILL 检测非法指令。 SIGINT 程序终止(interrupt)信号。 SIGSEGV 非法访问内存。 SIGTERM 发送到程序的终止请求。 ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"signal() 函数 C++ 信号处理库提供了 signal 函数，用来捕获突发事件。以下是 signal() 函数的语法： void (*signal (int sig, void (*func)(int)))(int); 这个看起来有点费劲，以下语法格式更容易理解： signal(registered signal, signal handler) 这个函数接收两个参数：第一个参数是一个整数，代表了信号的编号；第二个参数是一个指向信号处理函数的指针。 让我们编写一个简单的 C++ 程序，使用 signal() 函数捕获 SIGINT 信号。不管您想在程序中捕获什么信号，您都必须使用 signal 函数来注册信号，并将其与信号处理程序相关联。看看下面的实例： 实例 #include \u003ciostream\u003e#include \u003ccsignal\u003e#include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(1){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Going to sleep.... Going to sleep.... Going to sleep.... 现在，按 Ctrl+C 来中断程序，您会看到程序捕获信号，程序打印如下内容并退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"raise() 函数 您可以使用函数 raise() 生成信号，该函数带有一个整数信号编号作为参数，语法如下： int raise (signal sig); 在这里，sig 是要发送的信号的编号，这些信号包括：SIGINT、SIGABRT、SIGFPE、SIGILL、SIGSEGV、SIGTERM、SIGHUP。以下是我们使用 raise() 函数内部生成信号的实例： 实例 #include \u003ciostream\u003e#include \u003ccsignal\u003e#include \u003cunistd.h\u003e using namespace std; void signalHandler( int signum ) { cout \u003c\u003c \"Interrupt signal (\" \u003c\u003c signum \u003c\u003c \") received.\\n\"; // 清理并关闭 // 终止程序 exit(signum); } int main () { int i = 0; // 注册信号 SIGINT 和信号处理程序 signal(SIGINT, signalHandler); while(++i){ cout \u003c\u003c \"Going to sleep....\" \u003c\u003c endl; if( i == 3 ){ raise( SIGINT); } sleep(1); } return 0; } 当上面的代码被编译和执行时，它会产生下列结果，并会自动退出： Going to sleep.... Going to sleep.... Going to sleep.... Interrupt signal (2) received. ","date":"2021-09-13","objectID":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 37信号处理","uri":"/2021/09/c-37%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/"},{"categories":["C++"],"content":"C++ 多线程 多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同时运行两个或两个以上的程序。一般情况下，两种类型的多任务处理：基于进程和基于线程。 基于进程的多任务处理是程序的并发执行。 基于线程的多任务处理是同一程序的片段的并发执行。 多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。 本教程假设您使用的是 Linux 操作系统，我们要使用 POSIX 编写多线程 C++ 程序。POSIX Threads 或 Pthreads 提供的 API 可在多种类 Unix POSIX 系统上可用，比如 FreeBSD、NetBSD、GNU/Linux、Mac OS X 和 Solaris。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"创建线程 下面的程序，我们可以用它来创建一个 POSIX 线程： #include \u003cpthread.h\u003epthread_create (thread, attr, start_routine, arg) 在这里，pthread_create 创建一个新的线程，并让它可执行。下面是关于参数的说明： 参数 描述 thread 指向线程标识符指针。 attr 一个不透明的属性对象，可以被用来设置线程属性。您可以指定线程属性对象，也可以使用默认值 NULL。 start_routine 线程运行函数起始地址，一旦线程被创建就会执行。 arg 运行函数的参数。它必须通过把引用作为指针强制转换为 void 类型进行传递。如果没有传递参数，则使用 NULL。 创建线程成功时，函数返回 0，若返回值不为 0 则说明创建线程失败。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"终止线程 使用下面的程序，我们可以用它来终止一个 POSIX 线程： #include \u003cpthread.h\u003epthread_exit (status) 在这里，pthread_exit 用于显式地退出一个线程。通常情况下，pthread_exit() 函数是在线程完成工作后无需继续存在时被调用。 如果 main() 是在它所创建的线程之前结束，并通过 pthread_exit() 退出，那么其他线程将继续执行。否则，它们将在 main() 结束时自动被终止。 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"实例 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，每个线程输出\"Hello Runoob！\": 实例 #include \u003ciostream\u003e// 必须的头文件 #include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 // 线程的运行函数 void* say_hello(void* args) { cout \u003c\u003c \"Hello Runoob！\" \u003c\u003c endl; return 0; } int main() { // 定义线程的 id 变量，多个变量使用数组 pthread_t tids[NUM_THREADS]; for(int i = 0; i \u003c NUM_THREADS; ++i) { //参数依次是：创建的线程id，线程参数，调用的函数，传入的函数参数 int ret = pthread_create(\u0026tids[i], NULL, say_hello, NULL); if (ret != 0) { cout \u003c\u003c \"pthread_create error: error_code=\" \u003c\u003c ret \u003c\u003c endl; } } //等各个线程退出后，进程才结束，否则进程强制结束了，线程可能还没反应过来； pthread_exit(NULL); } 使用 -lpthread 库编译下面的程序： $ g++ test.cpp -lpthread -o test.o 现在，执行程序，将产生下列结果： $ ./test.o Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ Hello Runoob！ 以下简单的实例代码使用 pthread_create() 函数创建了 5 个线程，并接收传入的参数。每个线程打印一个 “Hello Runoob!” 消息，并输出接收的参数，然后调用 pthread_exit() 终止线程。 实例 //文件名：test.cpp #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 void *PrintHello(void *threadid) { // 对传入的参数进行强制类型转换，由无类型指针变为整形数指针，然后再读取 int tid = *((int*)threadid); cout \u003c\u003c \"Hello Runoob! 线程 ID, \" \u003c\u003c tid \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; int indexes[NUM_THREADS];// 用数组来保存i的值 int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : 创建线程, \" \u003c\u003c i \u003c\u003c endl; indexes[i] = i; //先保存i的值 // 传入的时候必须强制转换为void* 类型，即无类型指针 rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026(indexes[i])); if (rc){ cout \u003c\u003c \"Error:无法创建线程,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 现在编译并执行程序，将产生下列结果： $ g++ test.cpp -lpthread -o test.o $ ./test.o main() : 创建线程, 0 main() : 创建线程, 1 Hello Runoob! 线程 ID, 0 main() : 创建线程, Hello Runoob! 线程 ID, 21 main() : 创建线程, 3 Hello Runoob! 线程 ID, 2 main() : 创建线程, 4 Hello Runoob! 线程 ID, 3 Hello Runoob! 线程 ID, 4 ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"向线程传递参数 这个实例演示了如何通过结构传递多个参数。您可以在线程回调中传递任意的数据类型，因为它指向 void，如下面的实例所示： 实例 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e using namespace std; #define NUM_THREADS 5 struct thread_data{ int thread_id; char *message; }; void *PrintHello(void *threadarg) { struct thread_data *my_data; my_data = (struct thread_data *) threadarg; cout \u003c\u003c \"Thread ID : \" \u003c\u003c my_data-\u003ethread_id ; cout \u003c\u003c \" Message : \" \u003c\u003c my_data-\u003emessage \u003c\u003c endl; pthread_exit(NULL); } int main () { pthread_t threads[NUM_THREADS]; struct thread_data td[NUM_THREADS]; int rc; int i; for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c\"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; td[i].thread_id = i; td[i].message = (char*)\"This is message\"; rc = pthread_create(\u0026threads[i], NULL, PrintHello, (void *)\u0026td[i]); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： $ g++ -Wno-write-strings test.cpp -lpthread -o test.o $ ./test.o main() : creating thread, 0 main() : creating thread, 1 Thread ID : 0 Message : This is message main() : creating thread, Thread ID : 21 Message : This is message main() : creating thread, 3 Thread ID : 2 Message : This is message main() : creating thread, 4 Thread ID : 3 Message : This is message Thread ID : 4 Message : This is message ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"连接和分离线程 我们可以使用以下两个函数来连接或分离线程： pthread_join (threadid, status) pthread_detach (threadid) pthread_join() 子程序阻碍调用程序，直到指定的 threadid 线程终止为止。当创建一个线程时，它的某个属性会定义它是否是可连接的（joinable）或可分离的（detached）。只有创建时定义为可连接的线程才可以被连接。如果线程创建时被定义为可分离的，则它永远也不能被连接。 这个实例演示了如何使用 pthread_join() 函数来等待线程的完成。 实例 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cpthread.h\u003e#include \u003cunistd.h\u003e using namespace std; #define NUM_THREADS 5 void *wait(void *t) { int i; long tid; tid = (long)t; sleep(1); cout \u003c\u003c \"Sleeping in thread \" \u003c\u003c endl; cout \u003c\u003c \"Thread with id : \" \u003c\u003c tid \u003c\u003c \" ...exiting \" \u003c\u003c endl; pthread_exit(NULL); } int main () { int rc; int i; pthread_t threads[NUM_THREADS]; pthread_attr_t attr; void *status; // 初始化并设置线程为可连接的（joinable） pthread_attr_init(\u0026attr); pthread_attr_setdetachstate(\u0026attr, PTHREAD_CREATE_JOINABLE); for( i=0; i \u003c NUM_THREADS; i++ ){ cout \u003c\u003c \"main() : creating thread, \" \u003c\u003c i \u003c\u003c endl; rc = pthread_create(\u0026threads[i], NULL, wait, (void *)\u0026i ); if (rc){ cout \u003c\u003c \"Error:unable to create thread,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } } // 删除属性，并等待其他线程 pthread_attr_destroy(\u0026attr); for( i=0; i \u003c NUM_THREADS; i++ ){ rc = pthread_join(threads[i], \u0026status); if (rc){ cout \u003c\u003c \"Error:unable to join,\" \u003c\u003c rc \u003c\u003c endl; exit(-1); } cout \u003c\u003c \"Main: completed thread id :\" \u003c\u003c i ; cout \u003c\u003c \" exiting with status :\" \u003c\u003c status \u003c\u003c endl; } cout \u003c\u003c \"Main: program exiting.\" \u003c\u003c endl; pthread_exit(NULL); } 当上面的代码被编译和执行时，它会产生下列结果： main() : creating thread, 0 main() : creating thread, 1 main() : creating thread, 2 main() : creating thread, 3 main() : creating thread, 4 Sleeping in thread Thread with id : 4 ...exiting Sleeping in thread Thread with id : 3 ...exiting Sleeping in thread Thread with id : 2 ...exiting Sleeping in thread Thread with id : 1 ...exiting Sleeping in thread Thread with id : 0 ...exiting Main: completed thread id :0 exiting with status :0 Main: completed thread id :1 exiting with status :0 Main: completed thread id :2 exiting with status :0 Main: completed thread id :3 exiting with status :0 Main: completed thread id :4 exiting with status :0 Main: program exiting. 更多实例参考：http://www.runoob.com/w3cnote/cpp-multithread-demo.html ","date":"2021-09-13","objectID":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 38多线程","uri":"/2021/09/c-38%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"categories":["C++"],"content":"C++ Web 编程 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"什么是 CGI？ 公共网关接口（CGI），是一套标准，定义了信息是如何在 Web 服务器和客户端脚本之间进行交换的。 CGI 规范目前是由 NCSA 维护的，NCSA 定义 CGI 如下： 公共网关接口（CGI），是一种用于外部网关程序与信息服务器（如 HTTP 服务器）对接的接口标准。 目前的版本是 CGI/1.1，CGI/1.2 版本正在推进中。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 浏览 为了更好地了解 CGI 的概念，让我们点击一个超链接，浏览一个特定的网页或 URL，看看会发生什么。 您的浏览器联系上 HTTP Web 服务器，并请求 URL，即文件名。 Web 服务器将解析 URL，并查找文件名。如果找到请求的文件，Web 服务器会把文件发送回浏览器，否则发送一条错误消息，表明您请求了一个错误的文件。 Web 浏览器从 Web 服务器获取响应，并根据接收到的响应来显示文件或错误消息。 然而，以这种方式搭建起来的 HTTP 服务器，不管何时请求目录中的某个文件，HTTP 服务器发送回来的不是该文件，而是以程序形式执行，并把执行产生的输出发送回浏览器显示出来。 公共网关接口（CGI），是使得应用程序（称为 CGI 程序或 CGI 脚本）能够与 Web 服务器以及客户端进行交互的标准协议。这些 CGI 程序可以用 Python、PERL、Shell、C 或 C++ 等进行编写。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 架构图 下图演示了 CGI 的架构： ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Web 服务器配置 在您进行 CGI 编程之前，请确保您的 Web 服务器支持 CGI，并已配置成可以处理 CGI 程序。所有由 HTTP 服务器执行的 CGI 程序，都必须在预配置的目录中。该目录称为 CGI 目录，按照惯例命名为 /var/www/cgi-bin。虽然 CGI 文件是 C++ 可执行文件，但是按照惯例它的扩展名是 .cgi。 默认情况下，Apache Web 服务器会配置在 /var/www/cgi-bin 中运行 CGI 程序。如果您想指定其他目录来运行 CGI 脚本，您可以在 httpd.conf 文件中修改以下部分： \u003cDirectory \"/var/www/cgi-bin\"\u003e AllowOverride None Options ExecCGI Order allow,deny Allow from all \u003c/Directory\u003e \u003cDirectory \"/var/www/cgi-bin\"\u003e Options All \u003c/Directory\u003e 在这里，我们假设已经配置好 Web 服务器并能成功运行，你可以运行任意的 CGI 程序，比如 Perl 或 Shell 等。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"第一个 CGI 程序 请看下面的 C++ 程序： 实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eHello World - 第一个 CGI 程序\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ch2\u003eHello World! 这是我的第一个 CGI 程序\u003c/h2\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 编译上面的代码，把可执行文件命名为 cplusplus.cgi，并把这个文件保存在 /var/www/cgi-bin 目录中。在运行 CGI 程序之前，请使用 chmod 755 cplusplus.cgi UNIX 命令来修改文件模式，确保文件可执行。访问可执行文件，您会看到下面的输出： ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"Hello World! 这是我的第一个 CGI 程序 上面的 C++ 程序是一个简单的程序，把它的输出写在 STDOUT 文件上，即显示在屏幕上。在这里，值得注意一点，第一行输出 Content-type:text/html\\r\\n\\r\\n。这一行发送回浏览器，并指定要显示在浏览器窗口上的内容类型。您必须理解 CGI 的基本概念，这样才能进一步使用 Python 编写更多复杂的 CGI 程序。C++ CGI 程序可以与任何其他外部的系统（如 RDBMS）进行交互。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"HTTP 头信息 行 Content-type:text/html\\r\\n\\r\\n 是 HTTP 头信息的组成部分，它被发送到浏览器，以便更好地理解页面内容。HTTP 头信息的形式如下： HTTP 字段名称: 字段内容 例如 Content-type: text/html\\r\\n\\r\\n 还有一些其他的重要的 HTTP 头信息，这些在您的 CGI 编程中都会经常被用到。 头信息 描述 Content-type: MIME 字符串，定义返回的文件格式。例如 Content-type:text/html。 Expires: Date 信息变成无效的日期。浏览器使用它来判断一个页面何时需要刷新。一个有效的日期字符串的格式应为 01 Jan 1998 12:00:00 GMT。 Location: URL 这个 URL 是指应该返回的 URL，而不是请求的 URL。你可以使用它来重定向一个请求到任意的文件。 Last-modified: Date 资源的最后修改日期。 Content-length: N 要返回的数据的长度，以字节为单位。浏览器使用这个值来表示一个文件的预计下载时间。 Set-Cookie: String 通过 string 设置 cookie。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"CGI 环境变量 所有的 CGI 程序都可以访问下列的环境变量。这些变量在编写 CGI 程序时扮演了非常重要的角色。 变量名 描述 CONTENT_TYPE 内容的数据类型。当客户端向服务器发送附加内容时使用。例如，文件上传等功能。 CONTENT_LENGTH 查询的信息长度。只对 POST 请求可用。 HTTP_COOKIE 以键 \u0026 值对的形式返回设置的 cookies。 HTTP_USER_AGENT 用户代理请求标头字段，递交用户发起请求的有关信息，包含了浏览器的名称、版本和其他平台性的附加信息。 PATH_INFO CGI 脚本的路径。 QUERY_STRING 通过 GET 方法发送请求时的 URL 编码信息，包含 URL 中问号后面的参数。 REMOTE_ADDR 发出请求的远程主机的 IP 地址。这在日志记录和认证时是非常有用的。 REMOTE_HOST 发出请求的主机的完全限定名称。如果此信息不可用，则可以用 REMOTE_ADDR 来获取 IP 地址。 REQUEST_METHOD 用于发出请求的方法。最常见的方法是 GET 和 POST。 SCRIPT_FILENAME CGI 脚本的完整路径。 SCRIPT_NAME CGI 脚本的名称。 SERVER_NAME 服务器的主机名或 IP 地址。 SERVER_SOFTWARE 服务器上运行的软件的名称和版本。 下面的 CGI 程序列出了所有的 CGI 变量。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cstdlib.h\u003e#include \u003cstring\u003eusing namespace std; const string ENV[ 24 ] = { \"COMSPEC\", \"DOCUMENT_ROOT\", \"GATEWAY_INTERFACE\", \"HTTP_ACCEPT\", \"HTTP_ACCEPT_ENCODING\", \"HTTP_ACCEPT_LANGUAGE\", \"HTTP_CONNECTION\", \"HTTP_HOST\", \"HTTP_USER_AGENT\", \"PATH\", \"QUERY_STRING\", \"REMOTE_ADDR\", \"REMOTE_PORT\", \"REQUEST_METHOD\", \"REQUEST_URI\", \"SCRIPT_FILENAME\", \"SCRIPT_NAME\", \"SERVER_ADDR\", \"SERVER_ADMIN\", \"SERVER_NAME\",\"SERVER_PORT\",\"SERVER_PROTOCOL\", \"SERVER_SIGNATURE\",\"SERVER_SOFTWARE\" }; int main () { cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 环境变量\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\"cellspacing = \\\"2\\\"\u003e\"; for ( int i = 0; i \u003c 24; i++ ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c ENV[ i ] \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; // 尝试检索环境变量的值 char *value = getenv( ENV[ i ].c_str() ); if ( value != 0 ){ cout \u003c\u003c value; }else{ cout \u003c\u003c \"环境变量不存在。\"; } cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:9:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ CGI 库 在真实的实例中，您需要通过 CGI 程序执行许多操作。这里有一个专为 C++ 程序而编写的 CGI 库，我们可以从 ftp://ftp.gnu.org/gnu/cgicc/ 上下载这个 CGI 库，并按照下面的步骤安装库： $ tar xzf cgicc-X.X.X.tar.gz $ cd cgicc-X.X.X/ $ ./configure --prefix=/usr $ make $ make install **注意：**libcgicc.so 和 libcgicc.a 库会被安装到/usr/lib目录下，需执行拷贝命令： $ sudo cp /usr/lib/libcgicc.* /usr/lib64/ 才能使 CGI 程序自动找到 libcgicc.so 动态链接库。 您可以点击 C++ CGI Lib Documentation，查看相关的库文档。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:10:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"GET 和 POST 方法 您可能有遇到过这样的情况，当您需要从浏览器传递一些信息到 Web 服务器，最后再传到 CGI 程序。通常浏览器会使用两种方法把这个信息传到 Web 服务器，分别是 GET 和 POST 方法。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:11:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 GET 方法传递信息 GET 方法发送已编码的用户信息追加到页面请求中。页面和已编码信息通过 ? 字符分隔开，如下所示： http://www.test.com/cgi-bin/cpp.cgi?key1=value1\u0026key2=value2 GET 方法是默认的从浏览器向 Web 服务器传信息的方法，它会在浏览器的地址栏中生成一串很长的字符串。当您向服务器传密码或其他一些敏感信息时，不要使用 GET 方法。GET 方法有大小限制，在一个请求字符串中最多可以传 1024 个字符。 当使用 GET 方法时，是使用 QUERY_STRING http 头来传递信息，在 CGI 程序中可使用 QUERY_STRING 环境变量来访问。 您可以通过在 URL 后跟上简单连接的键值对，也可以通过使用 HTML 标签的 GET 方法来传信息。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:12:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的 URL 实例：Get 方法 下面是一个简单的 URL，使用 GET 方法传递两个值给 hello_get.py 程序。 /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 下面的实例生成 cpp_get.cgi CGI 程序，用于处理 Web 浏览器给出的输入。通过使用 C++ CGI 库，可以很容易地访问传递的信息： 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e使用 GET 和 POST 方法\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"first_name\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"名：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for first name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; fi = formData.getElement(\"last_name\"); if( !fi-\u003eisEmpty() \u0026\u0026fi != (*formData).end()) { cout \u003c\u003c \"姓：\" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered for last name\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，如下所示： $g++ -o cpp_get.cgi cpp_get.cpp -lcgicc 生成 cpp_get.cgi，并把它放在 CGI 目录中，并尝试使用下面的链接进行访问： /cgi-bin/cpp_get.cgi?first_name=ZARA\u0026last_name=ALI 这会产生以下结果： 名：ZARA 姓：ALI ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:13:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"简单的表单实例：GET 方法 下面是一个简单的实例，使用 HTML 表单和提交按钮传递两个值。我们将使用相同的 CGI 脚本 cpp_get.cgi 来处理输入。 \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"get\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e \u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面是上述表单的实际输出，请输入名和姓，然后点击提交按钮查看结果。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:14:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"使用 POST 方法传递信息 一个更可靠的向 CGI 程序传递信息的方法是 POST 方法。这种方法打包信息的方式与 GET 方法相同，不同的是，它不是把信息以文本字符串形式放在 URL 中的 ? 之后进行传递，而是把它以单独的消息形式进行传递。该消息是以标准输入的形式传给 CGI 脚本的。 我们同样使用 cpp_get.cgi 程序来处理 POST 方法。让我们以同样的例子，通过使用 HTML 表单和提交按钮来传递两个值，只不过这次我们使用的不是 GET 方法，而是 POST 方法，如下所示： \u003cform action=\"/cgi-bin/cpp_get.cgi\" method=\"post\"\u003e 名：\u003cinput type=\"text\" name=\"first_name\"\u003e\u003cbr /\u003e 姓：\u003cinput type=\"text\" name=\"last_name\" /\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:15:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递复选框数据 当需要选择多个选项时，我们使用复选框。 下面的 HTML 代码实例是一个带有两个复选框的表单： \u003cform action=\"/cgi-bin/cpp_checkbox.cgi\" method=\"POST\" target=\"_blank\"\u003e \u003cinput type=\"checkbox\" name=\"maths\" value=\"on\" /\u003e 数学 \u003cinput type=\"checkbox\" name=\"physics\" value=\"on\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_checkbox.cgi 脚本，用于处理 Web 浏览器通过复选框给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; bool maths_flag, physics_flag; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递复选框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; maths_flag = formData.queryCheckbox(\"maths\"); if( maths_flag ) { cout \u003c\u003c \"Maths Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Maths Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; physics_flag = formData.queryCheckbox(\"physics\"); if( physics_flag ) { cout \u003c\u003c \"Physics Flag: ON \" \u003c\u003c endl; }else{ cout \u003c\u003c \"Physics Flag: OFF \" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:16:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递单选按钮数据 当只需要选择一个选项时，我们使用单选按钮。 下面的 HTML 代码实例是一个带有两个单选按钮的表单： \u003cform action=\"/cgi-bin/cpp_radiobutton.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cinput type=\"radio\" name=\"subject\" value=\"maths\" checked=\"checked\"/\u003e 数学 \u003cinput type=\"radio\" name=\"subject\" value=\"physics\" /\u003e 物理 \u003cinput type=\"submit\" value=\"选择学科\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_radiobutton.cgi 脚本，用于处理 Web 浏览器通过单选按钮给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递单选按钮数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"subject\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Radio box selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:17:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递文本区域数据 当需要向 CGI 程序传递多行文本时，我们使用 TEXTAREA 元素。 下面的 HTML 代码实例是一个带有 TEXTAREA 框的表单： \u003cform action=\"/cgi-bin/cpp_textarea.cgi\" method=\"post\" target=\"_blank\"\u003e \u003ctextarea name=\"textcontent\" cols=\"40\" rows=\"4\"\u003e 请在这里输入文本... \u003c/textarea\u003e \u003cinput type=\"submit\" value=\"提交\" /\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_textarea.cgi 脚本，用于处理 Web 浏览器通过文本区域给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递文本区域数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"textcontent\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Text Content: \" \u003c\u003c **fi \u003c\u003c endl; }else{ cout \u003c\u003c \"No text entered\" \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:18:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"向 CGI 程序传递下拉框数据 当有多个选项可用，但只能选择一个或两个选项时，我们使用下拉框。 下面的 HTML 代码实例是一个带有下拉框的表单： \u003cform action=\"/cgi-bin/cpp_dropdown.cgi\" method=\"post\" target=\"_blank\"\u003e \u003cselect name=\"dropdown\"\u003e \u003coption value=\"Maths\" selected\u003e数学\u003c/option\u003e \u003coption value=\"Physics\"\u003e物理\u003c/option\u003e \u003c/select\u003e \u003cinput type=\"submit\" value=\"提交\"/\u003e \u003c/form\u003e 下面的 C++ 程序会生成 cpp_dropdown.cgi 脚本，用于处理 Web 浏览器通过下拉框给出的输入。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc formData; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003e向 CGI 程序传递下拉框数据\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; form_iterator fi = formData.getElement(\"dropdown\"); if( !fi-\u003eisEmpty() \u0026\u0026 fi != (*formData).end()) { cout \u003c\u003c \"Value Selected: \" \u003c\u003c **fi \u003c\u003c endl; } cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:19:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"在 CGI 中使用 Cookies HTTP 协议是一种无状态的协议。但对于一个商业网站，它需要在不同页面间保持会话信息。例如，一个用户在完成多个页面的步骤之后结束注册。但是，如何在所有网页中保持用户的会话信息。 在许多情况下，使用 cookies 是记忆和跟踪有关用户喜好、购买、佣金以及其他为追求更好的游客体验或网站统计所需信息的最有效的方法。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"它是如何工作的 服务器以 cookie 的形式向访客的浏览器发送一些数据。如果浏览器接受了 cookie，则 cookie 会以纯文本记录的形式存储在访客的硬盘上。现在，当访客访问网站上的另一个页面时，会检索 cookie。一旦找到 cookie，服务器就知道存储了什么。 cookie 是一种纯文本的数据记录，带有 5 个可变长度的字段： Expires : cookie 的过期日期。如果此字段留空，cookie 会在访客退出浏览器时过期。 Domain : 网站的域名。 Path : 设置 cookie 的目录或网页的路径。如果您想从任意的目录或网页检索 cookie，此字段可以留空。 Secure : 如果此字段包含单词 “secure”，那么 cookie 只能通过安全服务器进行检索。如果此字段留空，则不存在该限制。 Name=Value : cookie 以键值对的形式被设置和获取。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"设置 Cookies 向浏览器发送 cookies 是非常简单的。这些 cookies 会在 Content-type 字段之前，与 HTTP 头一起被发送。假设您想设置 UserID 和 Password 为 cookies，设置 cookies 的步骤如下所示： 实例 #include \u003ciostream\u003eusing namespace std; int main () { cout \u003c\u003c \"Set-Cookie:UserID=XYZ;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Password=XYZ123;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Domain=www.w3cschool.cc;\\r\\n\"; cout \u003c\u003c \"Set-Cookie:Path=/perl;\\n\"; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"设置 cookies\" \u003c\u003c endl; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 从这个实例中，我们了解了如何设置 cookies。我们使用 Set-Cookie HTTP 头来设置 cookies。 在这里，有一些设置 cookies 的属性是可选的，比如 Expires、Domain 和 Path。值得注意的是，cookies 是在发送行 “Content-type:text/html\\r\\n\\r\\n 之前被设置的。 编译上面的程序，生成 setcookies.cgi，并尝试使用下面的链接设置 cookies。它会在您的计算机上设置四个 cookies： /cgi-bin/setcookies.cgi ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"获取 Cookies 检索所有设置的 cookies 是非常简单的。cookies 被存储在 CGI 环境变量 HTTP_COOKIE 中，且它们的形式如下： key1=value1;key2=value2;key3=value3.... 下面的实例演示了如何获取 cookies。 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; const_cookie_iterator cci; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的 Cookies\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; cout \u003c\u003c \"\u003ctable border = \\\"0\\\"cellspacing = \\\"2\\\"\u003e\"; // 获取环境变量 const CgiEnvironment\u0026 env = cgi.getEnvironment(); for( cci = env.getCookieList().begin(); cci != env.getCookieList().end(); ++cci ) { cout \u003c\u003c \"\u003ctr\u003e\u003ctd\u003e\" \u003c\u003c cci-\u003egetName() \u003c\u003c \"\u003c/td\u003e\u003ctd\u003e\"; cout \u003c\u003c cci-\u003egetValue(); cout \u003c\u003c \"\u003c/td\u003e\u003c/tr\u003e\\n\"; } cout \u003c\u003c \"\u003c/table\u003e\u003c\\n\"; cout \u003c\u003c \"\u003cbr/\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 现在，编译上面的程序，生成 getcookies.cgi，并尝试使用下面的链接获取您的计算机上所有可用的 cookies： /cgi-bin/getcookies.cgi 这会产生一个列表，显示了上一节中设置的四个 cookies 以及您的计算机上所有其他的 cookies： UserID XYZ Password XYZ123 Domain www.w3cschool.cc Path /perl ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:20:3","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"文件上传实例 为了上传一个文件，HTML 表单必须把 enctype 属性设置为 multipart/form-data。带有文件类型的 input 标签会创建一个 “Browse” 按钮。 \u003chtml\u003e \u003cbody\u003e \u003cform enctype=\"multipart/form-data\" action=\"/cgi-bin/cpp_uploadfile.cgi\" method=\"post\"\u003e \u003cp\u003e文件：\u003cinput type=\"file\" name=\"userfile\" /\u003e\u003c/p\u003e \u003cp\u003e\u003cinput type=\"submit\" value=\"上传\" /\u003e\u003c/p\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 这段代码的结果是下面的表单： **注意：**上面的实例已经故意禁用了保存上传的文件在我们的服务器上。您可以在自己的服务器上尝试上面的代码。 下面是用于处理文件上传的脚本 cpp_uploadfile.cpp： 实例 #include \u003ciostream\u003e#include \u003cvector\u003e #include \u003cstring\u003e #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003ccgicc/CgiDefs.h\u003e #include \u003ccgicc/Cgicc.h\u003e #include \u003ccgicc/HTTPHTMLHeader.h\u003e #include \u003ccgicc/HTMLClasses.h\u003e using namespace std; using namespace cgicc; int main () { Cgicc cgi; cout \u003c\u003c \"Content-type:text/html\\r\\n\\r\\n\"; cout \u003c\u003c \"\u003chtml\u003e\\n\"; cout \u003c\u003c \"\u003chead\u003e\\n\"; cout \u003c\u003c \"\u003ctitle\u003eCGI 中的文件上传\u003c/title\u003e\\n\"; cout \u003c\u003c \"\u003c/head\u003e\\n\"; cout \u003c\u003c \"\u003cbody\u003e\\n\"; // 获取要被上传的文件列表 const_file_iterator file = cgi.getFile(\"userfile\"); if(file != cgi.getFiles().end()) { // 在 cout 中发送数据类型 cout \u003c\u003c HTTPContentHeader(file-\u003egetDataType()); // 在 cout 中写入内容 file-\u003ewriteToStream(cout); } cout \u003c\u003c \"\u003c文件上传成功\u003e\\n\"; cout \u003c\u003c \"\u003c/body\u003e\\n\"; cout \u003c\u003c \"\u003c/html\u003e\\n\"; return 0; } 上面的实例是在 cout 流中写入内容，但您可以打开文件流，并把上传的文件内容保存在目标位置的某个文件中。 ","date":"2021-09-13","objectID":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/:21:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 39Web 编程","uri":"/2021/09/c-39web-%E7%BC%96%E7%A8%8B/"},{"categories":["C++"],"content":"C++ STL 教程 在前面的章节中，我们已经学习了 C++ 模板的概念。C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。 C++ 标准模板库的核心包括以下三个组件： 组件 描述 容器（Containers） 容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。 算法（Algorithms） 算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。 迭代器（iterators） 迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。 这三个组件都带有丰富的预定义函数，帮助我们通过简单的方式处理复杂的任务。 下面的程序演示了向量容器（一个 C++ 标准的模板），它与数组十分相似，唯一不同的是，向量在需要扩展大小的时候，会自动处理它自己的存储需求： 实例 #include \u003ciostream\u003e#include \u003cvector\u003eusing namespace std; int main() { // 创建一个向量存储 int vector\u003cint\u003e vec; int i; // 显示 vec 的原始大小 cout \u003c\u003c \"vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 推入 5 个值到向量中 for(i = 0; i \u003c 5; i++){ vec.push_back(i); } // 显示 vec 扩展后的大小 cout \u003c\u003c \"extended vector size = \" \u003c\u003c vec.size() \u003c\u003c endl; // 访问向量中的 5 个值 for(i = 0; i \u003c 5; i++){ cout \u003c\u003c \"value of vec [\" \u003c\u003c i \u003c\u003c \"] = \" \u003c\u003c vec[i] \u003c\u003c endl; } // 使用迭代器 iterator 访问值 vector\u003cint\u003e::iterator v = vec.begin(); while( v != vec.end()) { cout \u003c\u003c \"value of v = \" \u003c\u003c *v \u003c\u003c endl; v++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： vector size = 0 extended vector size = 5 value of vec [0] = 0 value of vec [1] = 1 value of vec [2] = 2 value of vec [3] = 3 value of vec [4] = 4 value of v = 0 value of v = 1 value of v = 2 value of v = 3 value of v = 4 关于上面实例中所使用的各种函数，有几点要注意： push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小。 size( ) 函数显示向量的大小。 begin( ) 函数返回一个指向向量开头的迭代器。 end( ) 函数返回一个指向向量末尾的迭代器。 ","date":"2021-09-13","objectID":"/2021/09/c-40stl-%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 40STL 教程","uri":"/2021/09/c-40stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"C++ 标准库 C++ 标准库可以分为两部分： 标准函数库： 这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自 C 语言。 面向对象类库： 这个库是类及其相关函数的集合。 C++ 标准库包含了所有的 C 标准库，为了支持类型安全，做了一定的添加和修改。 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"标准函数库 标准函数库分为以下几类： 输入/输出 I/O 字符串和字符处理 数学 时间、日期和本地化 动态分配 其他 宽字符函数 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"面向对象类库 标准的 C++ 面向对象类库定义了大量支持一些常见操作的类，比如输入/输出 I/O、字符串处理、数值处理。面向对象类库包含以下内容： 标准的 C++ I/O 类 String 类 数值类 STL 容器类 STL 算法 STL 函数对象 STL 迭代器 STL 分配器 本地化库 异常处理类 杂项支持库 ","date":"2021-09-13","objectID":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 41标准库","uri":"/2021/09/c-41%E6%A0%87%E5%87%86%E5%BA%93/"},{"categories":["C++"],"content":"C++ 有用的资源 以下资源包含了 C++ 有关的网站、书籍和文章。请使用它们来进一步学习 C++ 的知识。 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 有用的网站 C++ Standard Library headers − C++ 标准库。 C++ Programming − 这本书涵盖了 C++ 语言编程、软件交互设计、C++ 语言的现实生活应用。 C++ FAQ − C++ 常见问题 Free Country − Free Country 提供了免费的 C++ 源代码和 C++ 库，这些源代码和库涵盖了压缩、存档、游戏编程、标准模板库和 GUI 编程等 C++ 编程领域。 C and C++ Users Group − C 和 C++ 的用户团体提供了免费的涵盖各种编程领域 C++ 项目的源代码，包括 AI、动画、编译器、数据库、调试、加密、游戏、图形、GUI、语言工具、系统编程等。 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 有用的书籍 《Essential C++ 中文版》 《C++ Primer Plus 第6版中文版》 《C++ Primer中文版（第5版）》 ","date":"2021-09-13","objectID":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 42有用的资源","uri":"/2021/09/c-42%E6%9C%89%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90/"},{"categories":["C++"],"content":"C++ 实例 C++ 实例 - 输出 “Hello, World!\" C++ 实例 - 标准输入输出 C++ 实例 - 输出换行 C++ 实例 - 实现两个数相加 C++ 实例 - 创建不同类型的变量 C++ 实例 - 求商及余数 C++ 实例 - 查看 int, float, double 和 char 变量大小 C++ 实例 - 交换两个数 C++ 实例 - 判断一个数是奇数还是偶数 C++ 实例 - 判断元音/辅音 C++ 实例 - 判断三个数中的最大数 C++ 实例 - 求一元二次方程的根 C++ 实例 - 计算自然数之和 C++ 实例 - 判断闰年 C++ 实例 - 求一个数的阶乘 C++ 实例 - 创建各类三角形图案 C++ 实例 - 求两数的最大公约数 C++ 实例 - 求两数最小公倍数 C++ 实例 - 实现一个简单的计算器 猴子吃桃问题 ","date":"2021-09-13","objectID":"/2021/09/c-43%E5%AE%9E%E4%BE%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 43实例","uri":"/2021/09/c-43%E5%AE%9E%E4%BE%8B/"},{"categories":["C++"],"content":"C++ 文件和流 数据类型 描述 ofstream 该数据类型表示输出文件流，用于创建文件并向文件写入信息。 ifstream 该数据类型表示输入文件流，用于从文件读取信息。 fstream 该数据类型通常表示文件流，且同时具有 ofstream 和 ifstream 两种功能，这意味着它可以创建文件，向文件写入信息，从文件读取信息。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 \u003ciostream\u003e 和 \u003cfstream\u003e。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"打开文件 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： ofstream outfile; outfile.open(\"file.dat\", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： ifstream afile; afile.open(\"file.dat\", ios::out | ios::in ); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"关闭文件 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 void close(); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"写入文件 在 C++ 编程中，我们使用流插入运算符（ « ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取文件 在 C++ 编程中，我们使用流提取运算符（ » ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"读取 \u0026 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"实例 #include \u003cfstream\u003e#include \u003ciostream\u003eusing namespace std; int main () { char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open(\"afile.dat\"); cout \u003c\u003c \"Writing to the file\" \u003c\u003c endl; cout \u003c\u003c \"Enter your name: \"; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; cout \u003c\u003c \"Enter your age: \"; cin \u003e\u003e data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open(\"afile.dat\"); cout \u003c\u003c \"Reading from the file\" \u003c\u003c endl; infile \u003e\u003e data; // 在屏幕上写入数据 cout \u003c\u003c data \u003c\u003c endl; // 再次从文件读取数据，并显示它 infile \u003e\u003e data; cout \u003c\u003c data \u003c\u003c endl; // 关闭打开的文件 infile.close(); return 0; } 当上面的代码被编译和执行时，它会产生下列输入和输出： $./a.out Writing to the file Enter your name: Zara Enter your age: 9 Reading from the file Zara 9 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["C++"],"content":"文件位置指针 istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（“seek get”）和关于 ostream 的 seekp（“seek put”）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get” 文件位置指针的实例： // 定位到 fileObject 的第 n 个字节（假设是 ios::beg） fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节 fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节 fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾 fileObject.seekg( 0, ios::end ); ","date":"2021-09-13","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记31文件和流","uri":"/2021/09/c-%E7%AC%94%E8%AE%B031%E6%96%87%E4%BB%B6%E5%92%8C%E6%B5%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。 就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签： 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"数据抽象的好处 数据抽象有两个重要的优势： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"数据抽象的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是用户不需要了解的，但又是类能正常工作所必需的。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。 在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记28数据抽象","uri":"/2021/09/c-%E7%AC%94%E8%AE%B028%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据封装 所有的 C++ 程序都有以下两个基本要素： **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制。 数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"数据封装的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记29数据封装","uri":"/2021/09/c-%E7%AC%94%E8%AE%B029%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["菜鸟C++笔记"],"content":"C++ 接口（抽象类） C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示： class Box { public: // 纯虚函数 virtual double getVolume() = 0; private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。 可用于实例化对象的类被称为具体类。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()： 实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Rectangle area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Triangle area: \" \u003c\u003c Tri.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total Rectangle area: 35 Total Triangle area: 17 从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。 外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。 这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。 ","date":"2021-09-11","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记30接口（抽象类）","uri":"/2021/09/c-%E7%AC%94%E8%AE%B030%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 下面的实例中，基类 Shape 被派生为两个类，如下所示： 实例 #include \u003ciostream\u003e using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Rectangle class area :\" \u003c\u003cendl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Triangle class area :\" \u003c\u003cendl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = \u0026rec; // 调用矩形的求面积函数 area shape-\u003earea(); // 存储三角形的地址 shape = \u0026tri; // 调用三角形的求面积函数 area shape-\u003earea(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Parent class area Parent class area 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; 修改后，当编译和执行前面的实例代码时，它会产生以下结果： Rectangle class area Triangle class area 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"虚函数 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"纯虚函数 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 我们可以把基类中的虚函数 area() 改写如下： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; }; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 ","date":"2021-09-08","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记27多态","uri":"/2021/09/c-%E7%AC%94%E8%AE%B027%E5%A4%9A%E6%80%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 继承 // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"基类 \u0026 派生类 类派生列表以一个或多个基类命名，形式如下： class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 假设有一个基类 Shape，Rectangle 是它的派生类，如下所示： #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"访问控制和继承 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： class \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,… { \u003c派生类类体\u003e }; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; // 输出总花费 cout \u003c\u003c \"Total paint cost: $\" \u003c\u003c Rect.getCost(area) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 Total paint cost: $2450 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记25继承","uri":"/2021/09/c-%E7%AC%94%E8%AE%B025%E7%BB%A7%E6%89%BF/"},{"categories":["菜鸟C++笔记"],"content":"C++ 重载运算符和重载函数 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的函数重载 同名函数 print() 被用于输出不同的数据类型： #include \u003ciostream\u003eusing namespace std; class printData { public: void print(int i) { cout \u003c\u003c \"整数为: \" \u003c\u003c i \u003c\u003c endl; } void print(double f) { cout \u003c\u003c \"浮点数为: \" \u003c\u003c f \u003c\u003c endl; } void print(char c[]) { cout \u003c\u003c \"字符串为: \" \u003c\u003c c \u003c\u003c endl; } }; int main(void) { printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = \"Hello C++\"; pd.print(c); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 整数为: 5 浮点数为: 500.263 字符串为: Hello C++ ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的运算符重载 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box\u0026); 在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： #include \u003ciostream\u003eusing namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"可重载运算符/不可重载运算符 下面是可重载的运算符列表： 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，\u003c (小于)，\u003e (大于)，\u003c=(小于等于)，\u003e=(大于等于) 逻辑运算符 ||(逻辑或)，\u0026\u0026(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，\u0026(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，\u0026 (按位与)，~(按位取反)，^(按位异或),，« (左移)，»(右移) 赋值运算符 =, +=, -=, *=, /= , % = , \u0026=, |=, ^=, «=, »= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-\u003e(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -\u003e*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 ","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["菜鸟C++笔记"],"content":"运算符重载实例 下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。 序号 运算符和实例 1 一元运算符重载 2 二元运算符重载 3 关系运算符重载 4 输入/输出运算符重载 5 ++ 和 – 运算符重载 6 赋值运算符重载 7 函数调用运算符 () 重载 8 [下标运算符 ] 重载 9 类成员访问运算符 -\u003e 重载 C++ 一元运算符重载 递增运算符（ ++ ）和递减运算符（ – ） 一元减运算符，即负号（ - ） 逻辑非运算符（ ! ） #include \u003ciostream\u003eusing namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // 显示距离的方法 void displayDistance() { cout \u003c\u003c \"F: \" \u003c\u003c feet \u003c\u003c \" I:\" \u003c\u003c inches \u003c\u003cendl; } // 重载负运算符（ - ） Distance operator- () { feet = -feet; inches = -inches; return Distance(feet, inches); } }; int main() { Distance D1(11, 10), D2(-5, 11); -D1; // 取相反数 D1.displayDistance(); // 距离 D1 -D2; // 取相反数 D2.displayDistance(); // 距离 D2 return 0; } 当上面的代码被编译和执行时，它会产生下列结果： F: -11 I:-10 F: 5 I:-11 C++ 二元运算符重载 加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符。 #include \u003ciostream\u003eusing namespace std; class Box { double length; // 长度 double breadth; // 宽度 double height; // 高度 public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 C++ 关系运算符重载 C++ 语言支持各种关系运算符（ \u003c 、 \u003e 、 \u003c= 、 \u003e= 、 == 等等） #include \u003ciostream\u003eusing namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } // 显示距离的方法 void displayDistance() { cout \u003c\u003c \"F: \" \u003c\u003c feet \u003c\u003c \" I:\" \u003c\u003c inches \u003c\u003cendl; } // 重载负运算符（ - ） Distance operator- () { feet = -feet; inches = -inches; return Distance(feet, inches); } // 重载小于运算符（ \u003c ） bool operator \u003c(const Distance\u0026 d) { if(feet \u003c d.feet) { return true; } if(feet == d.feet \u0026\u0026 inches \u003c d.inches) { return true; } return false; } }; int main() { Distance D1(11, 10), D2(5, 11); if( D1 \u003c D2 ) { cout \u003c\u003c \"D1 is less than D2 \" \u003c\u003c endl; } else { cout \u003c\u003c \"D2 is less than D1 \" \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： D2 is less than D1 C++ 输入/输出运算符重载 C++ 能够使用流提取运算符 \u003e\u003e 和流插入运算符 « 来输入和输出内置的数据类型。 有一点很重要，我们需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数。 #include \u003ciostream\u003eusing namespace std; class Distance { private: int feet; // 0 到无穷 int inches; // 0 到 12 public: // 所需的构造函数 Distance(){ feet = 0; inches = 0; } Distance(int f, int i){ feet = f; inches = i; } friend ostream \u0026operator\u003c\u003c( ostream \u0026output, const Distance \u0026D ) { output \u003c\u003c \"F : \" \u003c\u003c D.feet \u003c\u003c \" I : \" \u003c\u003c D.inches; return output; } friend istream \u0026operator\u003e\u003e( istream \u0026input, Distance \u0026D ) { input \u003e\u003e D.feet \u003e\u003e D.inches; return input; } }; int main() { Distance D1(11, 10), D2(5, 11), D3; cout \u003c\u003c \"Enter the value of object : \" \u003c\u003c endl; cin \u003e\u003e D3; cout \u003c\u003c \"First Distance : \" \u003c\u003c D1 \u003c\u003c endl; cout \u003c\u003c \"Second Distance :\" \u003c\u003c D2 \u003c\u003c endl; cout \u003c\u003c \"Third Distance :\" \u003c\u003c D3 \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： $./a.out Enter the value of object : 70 10 First Distance : F : 11 I : 10 Second Distance :F : 5 I : 11 Third Distance :F : 70 I : 10 C++ ++ 和 – 运算符重载 #include \u003ciostream\u003eusing namespace std; class Time { private: int hours; // 0 到 23 i","date":"2021-09-02","objectID":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记26重载运算符和重载函数","uri":"/2021/09/c-%E7%AC%94%E8%AE%B026%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["任鸟飞","C++"],"content":"C++ 逆向 C++编程原理 软件安全 破解与防破解 外挂与反外挂 病毒分析 灵魂起源 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:0:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"创建DLL并且注入窗口中 实例 //唯一的一个 C我们的DLLApp 对象 C我们的DLLApp theApp; CMyDialog *PMainDialog; //窗口类 DWORD WINAPI ShowDialog(LPARAM lpData) { PMainDialog = new CMyDialog; //给指针分配空间 PMainDialog-\u003eDoModal(); //阻塞的方式 模态窗口 delete PMainDialog; //释放空间 FreeLibraryAndExitThread(theApp.m_hInstance,1); //释放DLL退出线程 return TRUE; } // C我们的DLLApp 初始化 BOOL C我们的DLLApp::InitInstance() { CWinApp::InitInstance(); ::CreateThread(NULL,NULL,(LPTHREAD_START_ROUTINE)ShowDialog,NULL,NULL,NULL); //创建线程 return TRUE; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"读写内存修改血量 实例 void CMyDialog::OnBnClickedButton1() { // [[[0x00D0DF1C]+1C]+28]+288 //读取内存数据 DWORD a = *(DWORD*)0x00D0DF1C; a = *(DWORD*)(a+0x1C); a = *(DWORD*)(a+0x28); a = *(DWORD*)(a+0x288); CString Stemp; Stemp.Format(_T(\"%d\"),a); MessageBox(Stemp); //写入内存数据 a = *(DWORD*)0x00D0DF1C; a = *(DWORD*)(a+0x1C); a = *(DWORD*)(a+0x28); *(DWORD*)(a+0x288) = 999； } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"函数和call的对应关系 画江山 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"人物属性结构 typedef struct TROLE_PROPERTY //人物属性结构 { char* szpName; DWORD ndHp; ... ... TROLE_PROPERTY* GetData(); //获得人物数据 void FindWay(int x,int y); DWORD GetMaxJy(); //获得人物当前升级最大经验 DWORD GetisCombat(); //获得战斗标志位 DWORD GetComebatNo(); //获得战斗顺序标志位 }_TROLE_PROPERTY; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物数据 TROLE_PROPERTY*TROLE_PROPERTY::GetData() //获得人物数据 { try { DWORD Base = GetBase(Offset_RoleProperty1); DWORD Offset2 = Offset_RoleProperty2; Base = Base+Offset_RoleProperty2; DWORD Temp = *(DWORD*)Base; ndLv = *(DWORD*)(Temp+0x12*8); } catch(...) { OutputDebugStringA(\"读取人物信息异常\\r\\n\"); return NULL; } return this; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物基地址+大偏移 DWORD GetBase(DWORD offset) //获得人物基地址+大偏移 { DWORD backeax; DWORD of = offset; __asm { mov ecx,Base_Role mov edx,[ecx] mov eax,of mov eax,[edx+eax] call eax mov backeax,eax } return backeax; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:6:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"寻路 void TROLE_PROPERTY::FindWay(int x,int y) //寻路 { try { DWORD ID = this-\u003eGetData()-\u003endMapId; DWORD X=x; DWORD Y=y; __asm { mov ecx,Base_Role mov eax,[ecx] mov edx,[eax+Offset_FindWay] call edx mov ecx,eax push 0 push Y push X push ID mov edx,[ecx] mov eax,[edx+4] call eax } } catch(...) { OutputDebugStringA(\"寻路异常\\r\\n\"); } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:7:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"NPC结构 typedef struct TNpc_PROPERTY //NPC结构 { char* szpName; DWORD ndID; DWORD ndX; DWORD ndY; DWORD ndOpenNpcID; DWORD ndAttackSign; }_TNpc_PROPERTY; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:8:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"NPC列表结构 typedef struct TNpc_List //NPC列表结构 { DWORD ndNum; TNpc_PROPERTY NpcList[1000]; DWORD ndNo; void GetData(); }_TNpc_List; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:9:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得npc列表数据 void TNpc_List::GetData //获得npc列表数据 { try { DWORD Base = Base_NPC; DWORD Offset = Offset_RoleProperty2; ndNum = *(DWORD*)(Base+0xC); //ID数组成员数 DWORD Base1 = *(DWORD*)(Base+0x4); //ID数组根 DWORD Id= 0; int j = 0; DbgPrint_Mint(\"NPCID数组大小:%x\\r\\n\",ndNum); for(int i=0;i\u003cndNum;i++) { Id = *(DWORD*)(Base1+i*0x4); if(Id\u003e0x100000) { Id = Id\u00260x0FFFFF; DWORD Temp=*(DWORD*)Base; Temp=*(DWORD*)(Temp+Id*0x8); Temp=*(DWORD*)(Temp+Offset); NpcList[j].ndId=*(DWORD*)(Temp+0x0*0x8); NpcList[j].ndX=*(DWORD*)(Temp+0x5*0x8); NpcList[j].ndY=*(DWORD*)(Temp+0x6*0x8); NpcList[j].ndOpenNpcID=*(DWORD*)(Temp+0x96*0x8); NpcList[j].ndAttackSign=*(DWORD*)(Temp+0x3*0x8); DWORD NameAddr=*(DWORD*)(Temp+Ox1*0x8); NpcList[j].szpName=(char*)(NameAddr+0x4); j=j+1; } } ndNo=j; } catch(...) { OutputDebugStringA(\"获得npc列表数据异常\\r\\n\"); } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:10:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得战斗标志位 DWORD TROLE_PROPERTY::GetisCombat() //获得战斗标志位 { DWORD Back=GetBase(Offset_isCombat1); Back=Back+Offset_isCombat2; DWORD n=*(DWORD*)Back; return n; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:11:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得战斗顺序标志位 DWORD TROLE_PROPERTY::GetComebatNo() //获得战斗顺序标志位 { DWORD Back = GetBase(Offset_CombatNo1) __asm { mov ecx ,Back mov eax ,[ecx] mov edx ,[eax+Offset_CombatNo2] call edx mov Back,eax } Back =*(DWORD*)(Back+4): return Back; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:12:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得人物当前升级最大经验 DWORD TROLE_PROPERTY::GetMaxJy() //获得人物当前升级最大经验 { DWORD Back1=GetBase (Offset_MaxJingYan); DWORD* pLv = new DWORD; DWORD* pBack = new DWORD; *pLv = this-\u003eGetData()-\u003endLv; __asm { push pLv push pBack mov ecx, Back1 add ecx, 4 mov eax, Call_LvtoJy call eax } DWORD Temp=*pBack; Temp=*(DWORD*)(Temp+Ox10); return Temp; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:13:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"Hook明文包 void HookGameClearE() //Hook明文包 { DWORD dwHookAddr = HookClearEAddr; //HOOK地址 DWORD dwTargetAddr = (DWORD)HookGameClearECall; //跳转到的子程序 DbgPrint_Mine(\"Hook明文包地址%x HookCall地址%x\\r\\n\",dwHookAddr ,dwTargetAddr); EnableDebugPrivilege(TRUE); //提升权限 DWORD pid =NULL; DWORD WriteSize =NULL; GetWindowThreadProcessId(GetGameWndHandle(), \u0026pid); //获得进程ID hProcess =OpenProcess(PROCESS_ALL_ACCESS,FALSE ,pid ); //打开进程 DbgPrint_Mine(\"pid:%x\\r\\n\",pid ); DbgPrint_Mine(\"hProcess:%x\\r\\n\",hProcess ); byte Temp =OxE9; //jmp WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x00),\u0026Temp,1 ,\u0026WriteSize); DWORD Temp1= dwTargetAddr - dwHookAddr - 5; //跳转的差值 WriteProcessMemory(hProcess,(LDDWORD)(dwHookAddr + 0x01),\u0026Temp1,4 ,\u0026WriteSize); byte Temp2=0x90; //用nop填充 WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x05),\u0026Temp2,1 ,\u0026WriteSize); } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:14:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"提升权限 BOOL EnableDebugPrivilege (BOOL bEnable) //提升权限OpenProcess { BOO fOK =FALSE; HANDLE hToken; if(OpenProcessToken(GetCurrentProcess()), TOKEN_ADTUSI_PRIVILEGES, \u0026hToken)) //打开进程访问令牌 { TOKEN_PRIVILEGES tp; tp.PrivilegeCount = 1; LookupPrivilegelalue(NULL, SE_DEBUG_NAME, \u0026tp.Privileges[0].Luid); tp.Privileges[0].Attributes = bEnable ? SE_PRIVILEGE_ENABLED:0; AdjustTokenPrivileges(hToken, FALSE, \u0026tp, sizeof (tp), NULL, NULL); fOK = (GetlastError() == ERROR_SUCCESS); CloseHandle(hToken); } return fOK; } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:15:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"HOOK明文包子程序 __declspec(naked) void HookGameCIearECa11()//裸体函数 HOOK明文包子程序 { __asm { //eax包长 ecx包内容 edx socket flags 0 pushad mov BaoChang, eax mov ecx, [esi+4] mov BaoNeiRongAddr, ecx } p =new byte[BaoChang]; ReadProcessMemory(hProcess, (LPCVOID)BaoNeiRongAddr, p, BaoChang, O); DbgPrint_Mine(\"包长:%x\",BaoChang); for (int i=0;i\u003c(int)BaoChang; i++) { sprintf(s, \"%02X\",p[i]); strcat_s(a, s); } DbgPrint_Mine(\"%s\", a); sprintf(a, \"%s\",\"包内容：\"); delete p; __asm { popd mov ecx,dword ptr [esi+4] mov edx,dword ptr [edi+0xC] jmp HookGameClearBackAdrr } } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:16:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"还原明文包 void UnHookGameClearE() //还原明文包 { //8B 4E 04 8B 57 0C 还原代码 DWORD dwHookAddr = HookClearEAddr; DWORD WriteSize = NULL; byte Temp[] = {0x8B,0x4E,0x04,0x8b,0x57,0x0C}; WriteProcessMemory(hProcess,(LPDWORD)(dwHookAddr + 0x00),\u0026Temp,6 ,\u0026WriteSize); } ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:17:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"发送封包 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"发送封包 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"HexChar转Byte ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:18:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"人物攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪相关 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"byte数组转string ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:19:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"宝宝攻击call ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:20:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"封装主线程调用 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"设置主线程和卸载主线程 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得窗口句柄 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"回调函数 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"主线程选角色消息 主线程HOOK明文包消息 主线程发包消息 寻路消息 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:21:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪参数结构体 typedef struct TAutomaticKill //自动打怪参数结构体 { int ndx1; int ndy1; int ndx2; int ndy2; }_TAutomaticKill; ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"结束自动打怪 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"StructGame.h声明 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪寻路线程 FindwayThread ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"循环寻路 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:22:5","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"自动打怪杀怪线程 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:23:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务遍历 void CMainDialogWnd::OnBnClickedButton14() ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务属性 Ttask_PROPERTY ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:1","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务列表结构 typedef struct Ttask_List ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:2","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"获得任务列表数据 void Ttask_List::GetData() ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:3","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"任务二叉树遍历 void Ttask_List::taskthree(int threeBase) ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:24:4","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"检测概论 exe dll 特征码 改写内存或者改写汇编代码 CRC检测 代码段 下访问断 数据检测 数据段 下访问断 CALL检测 堆栈检测 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:25:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"远程注入dll int _tmain(int argc,_TCHAR* argue[]) InJectDll ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:26:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"劫持注入 劫持工具 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:27:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"收包 发包可以达到功能 收包只能作为判断 收包效率高 recv WS2_32.recv ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:28:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"收包实例 hook明文包 另一处 还原明文包 另一处 裸体函数 另一处 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:29:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"窗口句柄和帐号 游戏账号 查找到游戏帐号的文本以后 下访问断 退出游戏得到访问代码 发现是一个常量（类似基地址）1670D31C 这个代码在主线程中 主线程入口地址是16670000 那个公式应该是 主线程入口+9C31C 我们用ce搜索主线程入中发现有基地址存放 得到公式 [27AC124]+9D31C ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:30:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["任鸟飞","C++"],"content":"控件遍历 获得控件列表数据 GetData 控件遍历递归 GetData2 ","date":"2021-08-28","objectID":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/:31:0","series":null,"tags":["任鸟飞","灵魂起源","C++","画江山"],"title":"灵魂起源及画江山部分代码","uri":"/2021/08/%E7%81%B5%E9%AD%82%E8%B5%B7%E6%BA%90%E5%8F%8A%E7%94%BB%E6%B1%9F%E5%B1%B1%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类 \u0026 对象 #include \u003ciostream\u003e using namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double get(void); void set( double len, double bre, double hei ); }; // 成员函数定义 double Box::get(void) { return length * breadth * height; } void Box::set( double len, double bre, double hei) { length = len; breadth = bre; height = hei; } int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 详述 Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // box 1 的体积 volume = Box1.height * Box1.length * Box1.breadth; cout \u003c\u003c \"Box1 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 2 的体积 volume = Box2.height * Box2.length * Box2.breadth; cout \u003c\u003c \"Box2 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 3 详述 Box3.set(16.0, 8.0, 12.0); volume = Box3.get(); cout \u003c\u003c \"Box3 的体积：\" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Box1 的体积：210 Box2 的体积：1560 Box3 的体积：1536 私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"类 \u0026 对象详解 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类成员函数 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类访问修饰符 class Base { public: // 公有成员 protected: // 受保护成员 private: // 私有成员 }; 公有（public）成员 公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值 私有（private）成员 私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。 默认情况下，类的所有成员都是私有的。 protected（受保护）成员 protected（受保护）成员变量或函数与私有成员十分相似，但有一点不同，protected（受保护）成员在派生类（即子类）中是可访问的。 继承中的特点 有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。 public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private 但无论哪种继承方式，上面两点都没有改变： private 成员只能被本类成员（类内）和友元访问，不能被派生类访问； protected 成员可以被派生类访问。 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"类构造函数 \u0026 析构函数 类的构造函数 构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created Length of line : 6 带参数的构造函数 默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。这样在创建对象时就会给对象赋初始值，如下面的例子所示： #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(double len); // 这是构造函数 private: double length; }; // 成员函数定义，包括构造函数 Line::Line( double len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; length = len; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line(10.0); // 获取默认设置的长度 cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; // 再次设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created, length = 10 Length of line : 10 Length of line : 6 使用初始化列表来初始化字段 Line::Line( double len): length(len) { cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 上面的语法等同于如下语法： Line::Line( double len) { length = len; cout \u003c\u003c \"Object is being created, length = \" \u003c\u003c len \u003c\u003c endl; } 假设有一个类 C，具有多个字段 X、Y、Z 等需要进行初始化，同理地，您可以使用上面的语法，只需要在不同的字段使用逗号进行分隔，如下所示： C::C( double a, double b, double c): X(a), Y(b), Z(c) { .... } 类的析构函数 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。 析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 下面的实例有助于更好地理解析构函数的概念： #include \u003ciostream\u003e using namespace std; class Line { public: void setLength( double len ); double getLength( void ); Line(); // 这是构造函数声明 ~Line(); // 这是析构函数声明 private: double length; }; // 成员函数定义，包括构造函数 Line::Line(void) { cout \u003c\u003c \"Object is being created\" \u003c\u003c endl; } Line::~Line(void) { cout \u003c\u003c \"Object is being deleted\" \u003c\u003c endl; } void Line::setLength( double len ) { length = len; } double Line::getLength( void ) { return length; } // 程序的主函数 int main( ) { Line line; // 设置长度 line.setLength(6.0); cout \u003c\u003c \"Length of line : \" \u003c\u003c line.getLength() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Object is being created Length of line : 6 Object is being deleted ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于： 通过使用另一个同类型的对象来初始化新创建的对象。 复制对象把它作为参数传递给函数。 复制对象，并从函数返回这个对象。 classname (const classname \u0026obj) { // 构造函数的主体 //obj 是一个对象引用，该对象是用于初始化另一个对象的。 } 实例 #include \u003ciostream\u003e using namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line \u0026obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout \u003c\u003c \"调用构造函数\" \u003c\u003c endl; // 为指针分配内存 ptr = new int; *ptr = len; } Line::Line(const Line \u0026obj) { cout \u003c\u003c \"调用拷贝构造函数并为指针 ptr 分配内存\" \u003c\u003c endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } Line::~Line(void) { cout \u003c\u003c \"释放内存\" \u003c\u003c endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout \u003c\u003c \"line 大小 : \" \u003c\u003c obj.getLength() \u003c\u003cendl; } // 程序的主函数 int main( ) { Line line(10); display(line); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 下面的实例对上面的实例稍作修改，通过使用已有的同类型的对象来初始化新创建的对象： #include \u003ciostream\u003e using namespace std; class Line { public: int getLength( void ); Line( int len ); // 简单的构造函数 Line( const Line \u0026obj); // 拷贝构造函数 ~Line(); // 析构函数 private: int *ptr; }; // 成员函数定义，包括构造函数 Line::Line(int len) { cout \u003c\u003c \"调用构造函数\" \u003c\u003c endl; // 为指针分配内存 ptr = new int; *ptr = len; } Line::Line(const Line \u0026obj) { cout \u003c\u003c \"调用拷贝构造函数并为指针 ptr 分配内存\" \u003c\u003c endl; ptr = new int; *ptr = *obj.ptr; // 拷贝值 } Line::~Line(void) { cout \u003c\u003c \"释放内存\" \u003c\u003c endl; delete ptr; } int Line::getLength( void ) { return *ptr; } void display(Line obj) { cout \u003c\u003c \"line 大小 : \" \u003c\u003c obj.getLength() \u003c\u003cendl; } // 程序的主函数 int main( ) { Line line1(10); Line line2 = line1; // 这里也调用了拷贝构造函数 display(line1); display(line2); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 调用构造函数 调用拷贝构造函数并为指针 ptr 分配内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 调用拷贝构造函数并为指针 ptr 分配内存 line 大小 : 10 释放内存 释放内存 释放内存 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:4","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 友元函数 如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示： class Box { double width; public: double length; friend void printWidth( Box box ); void setWidth( double wid ); }; 声明类 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明： friend class ClassTwo; #include \u003ciostream\u003e using namespace std; class Box { double width; public: friend void printWidth( Box box ); void setWidth( double wid ); }; // 成员函数定义 void Box::setWidth( double wid ) { width = wid; } // 请注意：printWidth() 不是任何类的成员函数 void printWidth( Box box ) { /* 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 */ cout \u003c\u003c \"Width of box : \" \u003c\u003c box.width \u003c\u003cendl; } // 程序的主函数 int main( ) { Box box; // 使用成员函数设置宽度 box.setWidth(10.0); // 使用友元函数输出宽度 printWidth( box ); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Width of box : 10 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:5","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 内联函数 如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。 在类定义中的定义的函数都是内联函数，即使没有使用 inline 说明符。 下面是一个实例，使用内联函数来返回两个数中的最大值： #include \u003ciostream\u003e using namespace std; inline int Max(int x, int y) { return (x \u003e y)? x : y; } // 程序的主函数 int main( ) { cout \u003c\u003c \"Max (20,10): \" \u003c\u003c Max(20,10) \u003c\u003c endl; cout \u003c\u003c \"Max (0,200): \" \u003c\u003c Max(0,200) \u003c\u003c endl; cout \u003c\u003c \"Max (100,1010): \" \u003c\u003c Max(100,1010) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Max (20,10): 20 Max (0,200): 200 Max (100,1010): 1010 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:6","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ this 指针 友元函数没有 this 指针，因为友元不是类的成员。只有成员函数才有 this 指针。 #include \u003ciostream\u003e using namespace std; class Box { public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; } double Volume() { return length * breadth * height; } int compare(Box box) { return this-\u003eVolume() \u003e box.Volume(); } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; int main(void) { Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 if(Box1.compare(Box2)) { cout \u003c\u003c \"Box2 is smaller than Box1\" \u003c\u003cendl; } else { cout \u003c\u003c \"Box2 is equal to or larger than Box1\" \u003c\u003cendl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Box2 is equal to or larger than Box1 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:7","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向类的指针 一个指向 C++ 类的指针与指向结构的指针类似，访问指向类的指针的成员，需要使用成员访问运算符 -\u003e，就像访问指向结构的指针一样。与所有的指针一样，您必须在使用指针之前，对指针进行初始化。 #include \u003ciostream\u003e using namespace std; class Box { public: // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; } double Volume() { return length * breadth * height; } private: double length; // Length of a box double breadth; // Breadth of a box double height; // Height of a box }; int main(void) { Box Box1(3.3, 1.2, 1.5); // Declare box1 Box Box2(8.5, 6.0, 2.0); // Declare box2 Box *ptrBox; // Declare pointer to a class. // 保存第一个对象的地址 ptrBox = \u0026Box1; // 现在尝试使用成员访问运算符来访问成员 cout \u003c\u003c \"Volume of Box1: \" \u003c\u003c ptrBox-\u003eVolume() \u003c\u003c endl; // 保存第二个对象的地址 ptrBox = \u0026Box2; // 现在尝试使用成员访问运算符来访问成员 cout \u003c\u003c \"Volume of Box2: \" \u003c\u003c ptrBox-\u003eVolume() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Volume of Box1: 5.94 Volume of Box2: 102 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:8","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["菜鸟C++笔记"],"content":"C++ 类的静态成员 不能把静态成员的初始化放置在类的定义中，但是可以在类的外部通过使用范围解析运算符 :: 来重新声明静态变量从而对它进行初始化 #include \u003ciostream\u003e using namespace std; class Box { public: static int objectCount; // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; // 每次创建对象时增加 1 objectCount++; } double Volume() { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 初始化类 Box 的静态成员 int Box::objectCount = 0; int main(void) { Box Box1(3.3, 1.2, 1.5); // 声明 box1 Box Box2(8.5, 6.0, 2.0); // 声明 box2 // 输出对象的总数 cout \u003c\u003c \"Total objects: \" \u003c\u003c Box::objectCount \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Constructor called. Constructor called. Total objects: 2 静态成员函数 静态函数只要使用类名加范围解析运算符 :: 就可以访问。 静态成员函数只能访问静态成员数据、其他静态成员函数和类外部的其他函数。 静态成员函数与普通成员函数的区别： 静态成员函数没有 this 指针，只能访问静态成员（包括静态成员变量和静态成员函数）。 普通成员函数有 this 指针，可以访问类中的任意成员；而静态成员函数没有 this 指针。 #include \u003ciostream\u003e using namespace std; class Box { public: static int objectCount; // 构造函数定义 Box(double l=2.0, double b=2.0, double h=2.0) { cout \u003c\u003c\"Constructor called.\" \u003c\u003c endl; length = l; breadth = b; height = h; // 每次创建对象时增加 1 objectCount++; } double Volume() { return length * breadth * height; } static int getCount() { return objectCount; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 初始化类 Box 的静态成员 int Box::objectCount = 0; int main(void) { // 在创建对象之前输出对象的总数 cout \u003c\u003c \"Inital Stage Count: \" \u003c\u003c Box::getCount() \u003c\u003c endl; Box Box1(3.3, 1.2, 1.5); // 声明 box1 Box Box2(8.5, 6.0, 2.0); // 声明 box2 // 在创建对象之后输出对象的总数 cout \u003c\u003c \"Final Stage Count: \" \u003c\u003c Box::getCount() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Inital Stage Count: 0 Constructor called. Constructor called. Final Stage Count: 2 ","date":"2021-08-27","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:9","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记24类 \u0026 对象","uri":"/2021/08/c-%E7%AC%94%E8%AE%B024%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 类 \u0026 对象 C++ 在 C 语言的基础上增加了面向对象编程，C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。 类用于指定对象的形式，它包含了数据表示法和用于处理数据的方法。类中的数据和方法称为类的成员。函数在一个类中被称为类的成员。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 类定义 定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。 类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中。类定义后必须跟着一个分号或一个声明列表。例如，我们使用关键字 class 定义 Box 数据类型，如下所示： class Box { public: double length; // 盒子的长度 double breadth; // 盒子的宽度 double height; // 盒子的高度 }; 关键字 public 确定了类成员的访问属性。在类对象作用域内，公共成员在类的外部是可访问的。您也可以指定类的成员为 private 或 protected，这个我们稍后会进行讲解。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"定义 C++ 对象 类提供了对象的蓝图，所以基本上，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象： Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box 对象 Box1 和 Box2 都有它们各自的数据成员。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"访问数据成员 类的对象的公共数据成员可以使用直接成员访问运算符 . 来访问。 为了更好地理解这些概念，让我们尝试一下下面的实例： 实例 #include \u003ciostream\u003e using namespace std; class Box { public: double length; // 长度 double breadth; // 宽度 double height; // 高度 // 成员函数声明 double get(void); void set( double len, double bre, double hei ); }; // 成员函数定义 double Box::get(void) { return length * breadth * height; } void Box::set( double len, double bre, double hei) { length = len; breadth = bre; height = hei; } int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 用于存储体积 // box 1 详述 Box1.height = 5.0; Box1.length = 6.0; Box1.breadth = 7.0; // box 2 详述 Box2.height = 10.0; Box2.length = 12.0; Box2.breadth = 13.0; // box 1 的体积 volume = Box1.height * Box1.length * Box1.breadth; cout \u003c\u003c \"Box1 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 2 的体积 volume = Box2.height * Box2.length * Box2.breadth; cout \u003c\u003c \"Box2 的体积：\" \u003c\u003c volume \u003c\u003cendl; // box 3 详述 Box3.set(16.0, 8.0, 12.0); volume = Box3.get(); cout \u003c\u003c \"Box3 的体积：\" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Box1 的体积：210 Box2 的体积：1560 Box3 的体积：1536 需要注意的是，私有的成员和受保护的成员不能使用直接成员访问运算符 (.) 来直接访问。我们将在后续的教程中学习如何访问私有成员和受保护的成员。 类 \u0026 对象详解 到目前为止，我们已经对 C++ 的类和对象有了基本的了解。下面的列表中还列出了其他一些 C++ 类和对象相关的概念，可以点击相应的链接进行学习。 概念 描述 类成员函数 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 类访问修饰符 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 构造函数 \u0026 析构函数 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 C++ 拷贝构造函数 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 C++ 友元函数 友元函数可以访问类的 private 和 protected 成员。 C++ 内联函数 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 C++ 中的 this 指针 每个对象都有一个特殊的指针 this，它指向对象本身。 C++ 中指向类的指针 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 C++ 类的静态成员 类的数据成员和函数成员都可以被声明为静态的。 ","date":"2021-08-25","objectID":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 24类 \u0026 对象","uri":"/2021/08/c-24%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 继承 面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。 当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。 继承代表了 is a 关系。例如，哺乳动物是动物，狗是哺乳动物，因此，狗是动物，等等。 代码如下： // 基类 class Animal { // eat() 函数 // sleep() 函数 }; //派生类 class Dog : public Animal { // bark() 函数 }; ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"基类 \u0026 派生类 一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下： class derived-class: access-specifier base-class 其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。 假设有一个基类 Shape，Rectangle 是它的派生类，如下所示： ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"访问控制和继承 派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 我们可以根据访问权限总结出不同的访问类型，如下所示： 访问 public protected private 同一个类 yes yes yes 派生类 yes yes no 外部的类 yes no no 一个派生类继承了所有的基类方法，但下列情况除外： 基类的构造函数、析构函数和拷贝构造函数。 基类的重载运算符。 基类的友元函数。 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"继承类型 当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。 我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则： 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"多继承 多继承即一个子类可以有多个父类，它继承了多个父类的特性。 C++ 类可以从多个类继承成员，语法如下： class \u003c派生类名\u003e:\u003c继承方式1\u003e\u003c基类名1\u003e,\u003c继承方式2\u003e\u003c基类名2\u003e,… { \u003c派生类类体\u003e }; 其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔，如上所示。现在让我们一起看看下面的实例： 实例 #include \u003ciostream\u003e using namespace std; // 基类 Shape class Shape { public: void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 基类 PaintCost class PaintCost { public: int getCost(int area) { return area * 70; } }; // 派生类 class Rectangle: public Shape, public PaintCost { public: int getArea() { return (width * height); } }; int main(void) { Rectangle Rect; int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 输出对象的面积 cout \u003c\u003c \"Total area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; // 输出总花费 cout \u003c\u003c \"Total paint cost: $\" \u003c\u003c Rect.getCost(area) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total area: 35 Total paint cost: $2450 ","date":"2021-08-25","objectID":"/2021/08/c-25%E7%BB%A7%E6%89%BF/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 25继承","uri":"/2021/08/c-25%E7%BB%A7%E6%89%BF/"},{"categories":["C++"],"content":"C++ 重载运算符和重载函数 C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。 重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。 当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 中的函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。 下面的实例中，同名函数 print() 被用于输出不同的数据类型： 实例 #include \u003ciostream\u003eusing namespace std; class printData { public: void print(int i) { cout \u003c\u003c \"整数为: \" \u003c\u003c i \u003c\u003c endl; } void print(double f) { cout \u003c\u003c \"浮点数为: \" \u003c\u003c f \u003c\u003c endl; } void print(char c[]) { cout \u003c\u003c \"字符串为: \" \u003c\u003c c \u003c\u003c endl; } }; int main(void) { printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = \"Hello C++\"; pd.print(c); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 整数为: 5 浮点数为: 500.263 字符串为: Hello C++ ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 中的运算符重载 您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 Box operator+(const Box\u0026); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示： Box operator+(const Box\u0026, const Box\u0026); 下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; class Box { public: double getVolume(void) { return length * breadth * height; } void setLength( double len ) { length = len; } void setBreadth( double bre ) { breadth = bre; } void setHeight( double hei ) { height = hei; } // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box\u0026 b) { Box box; box.length = this-\u003elength + b.length; box.breadth = this-\u003ebreadth + b.breadth; box.height = this-\u003eheight + b.height; return box; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; // 程序的主函数 int main( ) { Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout \u003c\u003c \"Volume of Box1 : \" \u003c\u003c volume \u003c\u003cendl; // Box2 的体积 volume = Box2.getVolume(); cout \u003c\u003c \"Volume of Box2 : \" \u003c\u003c volume \u003c\u003cendl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout \u003c\u003c \"Volume of Box3 : \" \u003c\u003c volume \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Volume of Box1 : 210 Volume of Box2 : 1560 Volume of Box3 : 5400 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"可重载运算符/不可重载运算符 下面是可重载的运算符列表： 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，\u003c (小于)，\u003e (大于)，\u003c=(小于等于)，\u003e=(大于等于) 逻辑运算符 ||(逻辑或)，\u0026\u0026(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，\u0026(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 | (按位或)，\u0026 (按位与)，~(按位取反)，^(按位异或),，« (左移)，»(右移) 赋值运算符 =, +=, -=, *=, /= , % = , \u0026=, |=, ^=, «=, »= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-\u003e(成员访问)，,(逗号)，[](下标) 下面是不可重载的运算符列表： .：成员访问运算符 .*, -\u003e*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"运算符重载实例 下面提供了各种运算符重载的实例，帮助您更好地理解重载的概念。 序号 运算符和实例 1 一元运算符重载 2 二元运算符重载 3 关系运算符重载 4 输入/输出运算符重载 5 ++ 和 – 运算符重载 6 赋值运算符重载 7 函数调用运算符 () 重载 8 [下标运算符 ] 重载 9 类成员访问运算符 -\u003e 重载 ","date":"2021-08-25","objectID":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 26重载运算符和重载函数","uri":"/2021/08/c-26%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 多态 多态按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。 C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。 下面的实例中，基类 Shape 被派生为两个类，如下所示： 实例 #include \u003ciostream\u003e using namespace std; class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; class Rectangle: public Shape{ public: Rectangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Rectangle class area :\" \u003c\u003cendl; return (width * height); } }; class Triangle: public Shape{ public: Triangle( int a=0, int b=0):Shape(a, b) { } int area () { cout \u003c\u003c \"Triangle class area :\" \u003c\u003cendl; return (width * height / 2); } }; // 程序的主函数 int main( ) { Shape *shape; Rectangle rec(10,7); Triangle tri(10,5); // 存储矩形的地址 shape = \u0026rec; // 调用矩形的求面积函数 area shape-\u003earea(); // 存储三角形的地址 shape = \u0026tri; // 调用三角形的求面积函数 area shape-\u003earea(); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Parent class area Parent class area 导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。 但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } virtual int area() { cout \u003c\u003c \"Parent class area :\" \u003c\u003cendl; return 0; } }; 修改后，当编译和执行前面的实例代码时，它会产生以下结果： Rectangle class area Triangle class area 此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。 正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"虚函数 虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。 我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"纯虚函数 您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。 我们可以把基类中的虚函数 area() 改写如下： class Shape { protected: int width, height; public: Shape( int a=0, int b=0) { width = a; height = b; } // pure virtual function virtual int area() = 0; }; = 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。 ","date":"2021-08-25","objectID":"/2021/08/c-27%E5%A4%9A%E6%80%81/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 27多态","uri":"/2021/08/c-27%E5%A4%9A%E6%80%81/"},{"categories":["C++"],"content":"C++ 数据抽象 数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。 数据抽象是一种依赖于接口和实现分离的编程（设计）技术。 让我们举一个现实生活中的真实例子，比如一台电视机，您可以打开和关闭、切换频道、调整音量、添加外部组件（如喇叭、录像机、DVD 播放器），但是您不知道它的内部实现细节，也就是说，您并不知道它是如何通过缆线接收信号，如何转换信号，并最终显示在屏幕上。 因此，我们可以说电视把它的内部实现和外部接口分离开了，您无需知道它的内部实现原理，直接通过它的外部接口（比如电源按钮、遥控器、声量控制器）就可以操控电视。 现在，让我们言归正传，就 C++ 编程而言，C++ 类为数据抽象提供了可能。它们向外界提供了大量用于操作对象数据的公共方法，也就是说，外界实际上并不清楚类的内部实现。 例如，您的程序可以调用 sort() 函数，而不需要知道函数中排序数据所用到的算法。实际上，函数排序的底层实现会因库的版本不同而有所差异，只要接口不变，函数调用就可以照常工作。 在 C++ 中，我们使用类来定义我们自己的抽象数据类型（ADT）。您可以使用类 iostream 的 cout 对象来输出数据到标准输出，如下所示： 实例 #include \u003ciostream\u003eusing namespace std; int main( ) { cout \u003c\u003c \"Hello C++\" \u003c\u003cendl; return 0; } 在这里，您不需要理解 cout 是如何在用户的屏幕上显示文本。您只需要知道公共接口即可，cout 的底层实现可以自由改变。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"访问标签强制抽象 在 C++ 中，我们使用访问标签来定义类的抽象接口。一个类可以包含零个或多个访问标签： 使用公共标签定义的成员都可以访问该程序的所有部分。一个类型的数据抽象视图是由它的公共成员来定义的。 使用私有标签定义的成员无法访问到使用类的代码。私有部分对使用类型的代码隐藏了实现细节。 访问标签出现的频率没有限制。每个访问标签指定了紧随其后的成员定义的访问级别。指定的访问级别会一直有效，直到遇到下一个访问标签或者遇到类主体的关闭右括号为止。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"数据抽象的好处 数据抽象有两个重要的优势： 类的内部受到保护，不会因无意的用户级错误导致对象状态受损。 类实现可能随着时间的推移而发生变化，以便应对不断变化的需求，或者应对那些要求不改变用户级代码的错误报告。 如果只在类的私有部分定义数据成员，编写该类的作者就可以随意更改数据。如果实现发生改变，则只需要检查类的代码，看看这个改变会导致哪些影响。如果数据是公有的，则任何直接访问旧表示形式的数据成员的函数都可能受到影响。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"数据抽象的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是用户不需要了解的，但又是类能正常工作所必需的。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"设计策略 抽象把代码分离为接口和实现。所以在设计组件时，必须保持接口独立于实现，这样，如果改变底层实现，接口也将保持不变。 在这种情况下，不管任何程序使用接口，接口都不会受到影响，只需要将最新的实现重新编译即可。 ","date":"2021-08-25","objectID":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 28数据抽象","uri":"/2021/08/c-28%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"},{"categories":["C++"],"content":"C++ 数据封装 所有的 C++ 程序都有以下两个基本要素： **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。 **程序数据：**数据是程序的信息，会受到程序函数的影响。 封装是面向对象编程中的把数据和操作数据的函数绑定在一起的一个概念，这样能避免受到外界的干扰和误用，从而确保了安全。数据封装引申出了另一个重要的 OOP 概念，即数据隐藏。 数据封装是一种把数据和操作数据的函数捆绑在一起的机制，数据抽象是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。 C++ 通过创建类来支持封装和数据隐藏（public、protected、private）。我们已经知道，类包含私有成员（private）、保护成员（protected）和公有成员（public）成员。默认情况下，在类中定义的所有项目都是私有的。例如： class Box { public: double getVolume(void) { return length * breadth * height; } private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 变量 length、breadth 和 height 都是私有的（private）。这意味着它们只能被 Box 类中的其他成员访问，而不能被程序中其他部分访问。这是实现封装的一种方式。 为了使类中的成员变成公有的（即，程序中的其他部分也能访问），必须在这些成员前使用 public 关键字进行声明。所有定义在 public 标识符后边的变量或函数可以被程序中所有其他的函数访问。 把一个类定义为另一个类的友元类，会暴露实现细节，从而降低了封装性。理想的做法是尽可能地对外隐藏每个类的实现细节。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"数据封装的实例 C++ 程序中，任何带有公有和私有成员的类都可以作为数据封装和数据抽象的实例。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; class Adder{ public: // 构造函数 Adder(int i = 0) { total = i; } // 对外的接口 void addNum(int number) { total += number; } // 对外的接口 int getTotal() { return total; }; private: // 对外隐藏的数据 int total; }; int main( ) { Adder a; a.addNum(10); a.addNum(20); a.addNum(30); cout \u003c\u003c \"Total \" \u003c\u003c a.getTotal() \u003c\u003cendl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total 60 上面的类把数字相加，并返回总和。公有成员 addNum 和 getTotal 是对外的接口，用户需要知道它们以便使用类。私有成员 total 是对外隐藏的，用户不需要了解它，但它又是类能正常工作所必需的。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"设计策略 通常情况下，我们都会设置类成员状态为私有（private），除非我们真的需要将其暴露，这样才能保证良好的封装性。 这通常应用于数据成员，但它同样适用于所有成员，包括虚函数。 ","date":"2021-08-25","objectID":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 29数据封装","uri":"/2021/08/c-29%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"},{"categories":["C++"],"content":"C++ 接口（抽象类） 接口描述了类的行为和功能，而不需要完成类的特定实现。 C++ 接口是使用抽象类来实现的，抽象类与数据抽象互不混淆，数据抽象是一个把实现细节与相关的数据分离开的概念。 如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “= 0” 来指定的，如下所示： class Box { public: // 纯虚函数 virtual double getVolume() = 0; private: double length; // 长度 double breadth; // 宽度 double height; // 高度 }; 设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。 因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。 可用于实例化对象的类被称为具体类。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["C++"],"content":"抽象类的实例 请看下面的实例，基类 Shape 提供了一个接口 getArea()，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea()： 实例 #include \u003ciostream\u003e using namespace std; // 基类 class Shape { public: // 提供接口框架的纯虚函数 virtual int getArea() = 0; void setWidth(int w) { width = w; } void setHeight(int h) { height = h; } protected: int width; int height; }; // 派生类 class Rectangle: public Shape { public: int getArea() { return (width * height); } }; class Triangle: public Shape { public: int getArea() { return (width * height)/2; } }; int main(void) { Rectangle Rect; Triangle Tri; Rect.setWidth(5); Rect.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Rectangle area: \" \u003c\u003c Rect.getArea() \u003c\u003c endl; Tri.setWidth(5); Tri.setHeight(7); // 输出对象的面积 cout \u003c\u003c \"Total Triangle area: \" \u003c\u003c Tri.getArea() \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total Rectangle area: 35 Total Triangle area: 17 从上面的实例中，我们可以看到一个抽象类是如何定义一个接口 getArea()，两个派生类是如何通过不同的计算面积的算法来实现这个相同的函数。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["C++"],"content":"设计策略 面向对象的系统可能会使用一个抽象基类为所有的外部应用程序提供一个适当的、通用的、标准化的接口。然后，派生类通过继承抽象基类，就把所有类似的操作都继承下来。 外部应用程序提供的功能（即公有函数）在抽象基类中是以纯虚函数的形式存在的。这些纯虚函数在相应的派生类中被实现。 这个架构也使得新的应用程序可以很容易地被添加到系统中，即使是在系统被定义之后依然可以如此。 ","date":"2021-08-25","objectID":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 30接口（抽象类）","uri":"/2021/08/c-30%E6%8E%A5%E5%8F%A3%E6%8A%BD%E8%B1%A1%E7%B1%BB/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针的算术运算 下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 \u0026var[MAX - 1]，则把变量指针进行递增： #include \u003ciostream\u003e using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr; // 指针中第一个元素的地址 ptr = var; int i = 0; while ( ptr \u003c= \u0026var[MAX - 1] ) { cout \u003c\u003c \"Address of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c *ptr \u003c\u003c endl; // 指向上一个位置 ptr++; i++; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Address of var[0] = 0xbfce42d0 Value of var[0] = 10 Address of var[1] = 0xbfce42d4 Value of var[1] = 100 Address of var[2] = 0xbfce42d8 Value of var[2] = 200 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指针数组 #include \u003ciostream\u003e using namespace std; const int MAX = 3; int main () { int var[MAX] = {10, 100, 200}; int *ptr[MAX]; for (int i = 0; i \u003c MAX; i++) { ptr[i] = \u0026var[i]; // 赋值为整数的地址 } for (int i = 0; i \u003c MAX; i++) { cout \u003c\u003c \"Value of var[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c *ptr[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var[0] = 10 Value of var[1] = 100 Value of var[2] = 200 您也可以用一个指向字符的指针数组来存储一个字符串列表，如下： #include \u003ciostream\u003e using namespace std; const int MAX = 4; int main () { const char *names[MAX] = { \"Zara Ali\", \"Hina Ali\", \"Nuha Ali\", \"Sara Ali\", }; for (int i = 0; i \u003c MAX; i++) { cout \u003c\u003c \"Value of names[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c names[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of names[0] = Zara Ali Value of names[1] = Hina Ali Value of names[2] = Nuha Ali Value of names[3] = Sara Ali ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向指针的指针（多级间接寻址） 一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针： int **var; #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int **pptr; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 使用运算符 \u0026 获取 ptr 的地址 pptr = \u0026ptr; // 使用 pptr 获取值 cout \u003c\u003c \"var 值为 :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"*ptr 值为:\" \u003c\u003c *ptr \u003c\u003c endl; cout \u003c\u003c \"**pptr 值为:\" \u003c\u003c **pptr \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var 值为 :3000 *ptr 值为:3000 **pptr 值为:3000 C++ 引用 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 #include \u003ciostream\u003e using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026 r = i; double\u0026 s = d; i = 5; cout \u003c\u003c \"Value of i : \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"Value of i reference : \" \u003c\u003c r \u003c\u003c endl; d = 11.7; cout \u003c\u003c \"Value of d : \" \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c \"Value of d reference : \" \u003c\u003c s \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中创建引用 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 把引用作为参数 #include \u003ciostream\u003eusing namespace std; // 函数声明 void swap(int\u0026 x, int\u0026 y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 */ swap(a, b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } // 函数定义 void swap(int\u0026 x, int\u0026 y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 把引用作为返回值 #include \u003ciostream\u003e using namespace std; double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0}; double\u0026 setValues(int i) { double\u0026 ref = vals[i]; return ref; // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]，最后再返回 shit。 } // 要调用上面定义函数的主函数 int main () { cout \u003c\u003c \"改变前的值\" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"vals[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c vals[i] \u003c\u003c endl; } setValues(1) = 20.23; // 改变第 2 个元素 setValues(3) = 70.8; // 改变第 4 个元素 cout \u003c\u003c \"改变后的值\" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"vals[\" \u003c\u003c i \u003c\u003c \"] = \"; cout \u003c\u003c vals[i] \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 改变前的值 vals[0] = 10.1 vals[1] = 12.6 vals[2] = 33.1 vals[3] = 24.1 vals[4] = 50 改变后的值 vals[0] = 10.1 vals[1] = 20.23 vals[2] = 33.1 vals[3] = 70.8 vals[4] = 50 当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。 int\u0026 func() { int q; //! return q; // 在编译时发生错误 static int x; return x; // 安全，x 在函数作用域外依然是有效的 } ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/:5:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记19-20指针 \u0026 引用","uri":"/2021/08/c-%E7%AC%94%E8%AE%B019-20%E6%8C%87%E9%92%88-%E5%BC%95%E7%94%A8/"},{"categories":["菜鸟C++笔记"],"content":"C++ 日期 \u0026 时间 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; 序号 函数 \u0026 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"当前日期和时间 #include \u003ciostream\u003e#include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026now); cout \u003c\u003c \"本地日期和时间：\" \u003c\u003c dt \u003c\u003c endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(\u0026now); dt = asctime(gmtm); cout \u003c\u003c \"UTC 日期和时间：\"\u003c\u003c dt \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 本地日期和时间：Sat Jan 8 20:07:41 2011 UTC 日期和时间：Sun Jan 9 03:07:41 2011 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"使用结构 tm 格式化时间 使用箭头 -\u003e 运算符来访问结构成员 #include \u003ciostream\u003e#include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); cout \u003c\u003c \"1970 到目前经过秒数:\" \u003c\u003c now \u003c\u003c endl; tm *ltm = localtime(\u0026now); // 输出 tm 结构的各个组成部分 cout \u003c\u003c \"年: \"\u003c\u003c 1900 + ltm-\u003etm_year \u003c\u003c endl; cout \u003c\u003c \"月: \"\u003c\u003c 1 + ltm-\u003etm_mon\u003c\u003c endl; cout \u003c\u003c \"日: \"\u003c\u003c ltm-\u003etm_mday \u003c\u003c endl; cout \u003c\u003c \"时间: \"\u003c\u003c ltm-\u003etm_hour \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_min \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_sec \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 1970 到目前时间:1503564157 年: 2017 月: 8 日: 24 时间: 16:42:37 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记21日期 \u0026 时间","uri":"/2021/08/c-%E7%AC%94%E8%AE%B021%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["菜鸟C++笔记"],"content":"C++ 基本的输入输出 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 \u003ciostream\u003e 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 \u003ciomanip\u003e 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 \u003cfstream\u003e 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准输入流（cin） cin \u003e\u003e name \u003e\u003e age; 这相当于下面两个语句： cin \u003e\u003e name; cin \u003e\u003e age; ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准错误流（cerr） 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记22基本的输入输出","uri":"/2021/08/c-%E7%AC%94%E8%AE%B022%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数据结构 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"定义结构 struct type_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3; . . } object_names; ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"访问结构成员 使用成员访问运算符（.） ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"结构作为函数参数 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0; } void printBook( struct Books book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book.title \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book.author \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book.subject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book.book_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"指向结构的指针 为了使用指向该结构的指针访问结构的成员，您必须使用 -\u003e 运算符 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; void printBook( struct Books *book ); struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( \u0026Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( \u0026Book2 ); return 0; } // 该函数以结构指针作为参数 void printBook( struct Books *book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book-\u003etitle \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book-\u003eauthor \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book-\u003esubject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book-\u003ebook_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["菜鸟C++笔记"],"content":"typedef 关键字 下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如： typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }Books; 现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 您可以使用 typedef 关键字来定义非结构类型，如下所示： typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。 ","date":"2021-08-24","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记23数据结构","uri":"/2021/08/c-%E7%AC%94%E8%AE%B023%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"C++ 指针 学习 C++ 的指针既简单又有趣。通过指针，可以简化一些 C++ 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优秀的 C++ 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（\u0026）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { int var1; char var2[10]; cout \u003c\u003c \"var1 变量的地址： \"; cout \u003c\u003c \u0026var1 \u003c\u003c endl; cout \u003c\u003c \"var2 变量的地址： \"; cout \u003c\u003c \u0026var2 \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： var1 变量的地址： 0xbfebd5c0 var2 变量的地址： 0xbfebd5b6 通过上面的实例，我们了解了什么是内存地址以及如何访问它。接下来让我们看看什么是指针。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"什么是指针？ 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C++ 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： int *ip; /* 一个整型的指针 */ double *dp; /* 一个 double 型的指针 */ float *fp; /* 一个浮点型的指针 */ char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 中使用指针 使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 ***** 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { int var = 20; // 实际变量的声明 int *ip; // 指针变量的声明 ip = \u0026var; // 在指针变量中存储 var 的地址 cout \u003c\u003c \"Value of var variable: \"; cout \u003c\u003c var \u003c\u003c endl; // 输出在指针变量中存储的地址 cout \u003c\u003c \"Address stored in ip variable: \"; cout \u003c\u003c ip \u003c\u003c endl; // 访问指针中地址的值 cout \u003c\u003c \"Value of *ip variable: \"; cout \u003c\u003c *ip \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var variable: 20 Address stored in ip variable: 0xbfc601ac Value of *ip variable: 20 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 指针详解 在 C++ 中，有很多指针相关的概念，这些概念都很简单，但是都很重要。下面列出了 C++ 程序员必须清楚的一些与指针相关的重要概念： 概念 描述 C++ Null 指针 C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 C++ 指针的算术运算 可以对指针进行四种算术运算：++、–、+、- C++ 指针 vs 数组 指针和数组之间有着密切的关系。 C++ 指针数组 可以定义用来存储指针的数组。 C++ 指向指针的指针 C++ 允许指向指针的指针。 C++ 传递指针给函数 通过引用或地址传递参数，使传递的参数在调用函数中被改变。 C++ 从函数返回指针 C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。 ","date":"2021-08-20","objectID":"/2021/08/c-19%E6%8C%87%E9%92%88/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 19指针","uri":"/2021/08/c-19%E6%8C%87%E9%92%88/"},{"categories":["C++"],"content":"C++ 引用 引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 引用 vs 指针 引用很容易与指针混淆，它们之间有三个主要的不同： 不存在空引用。引用必须连接到一块合法的内存。 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。 引用必须在创建时被初始化。指针可以在任何时间被初始化。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 中创建引用 试想变量名称是变量附属在内存位置中的标签，您可以把引用当成是变量附属在内存位置中的第二个标签。因此，您可以通过原始变量名称或引用来访问变量的内容。例如： int i = 17; 我们可以为 i 声明引用变量，如下所示： int\u0026 r = i; double\u0026 s = d; 在这些声明中，\u0026 读作引用。因此，第一个声明可以读作 “r 是一个初始化为 i 的整型引用”，第二个声明可以读作 “s 是一个初始化为 d 的 double 型引用”。下面的实例使用了 int 和 double 引用： ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main () { // 声明简单的变量 int i; double d; // 声明引用变量 int\u0026 r = i; double\u0026 s = d; i = 5; cout \u003c\u003c \"Value of i : \" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"Value of i reference : \" \u003c\u003c r \u003c\u003c endl; d = 11.7; cout \u003c\u003c \"Value of d : \" \u003c\u003c d \u003c\u003c endl; cout \u003c\u003c \"Value of d reference : \" \u003c\u003c s \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of i : 5 Value of i reference : 5 Value of d : 11.7 Value of d reference : 11.7 引用通常用于函数参数列表和函数返回值。下面列出了 C++ 程序员必须清楚的两个与 C++ 引用相关的重要概念： 概念 描述 把引用作为参数 C++ 支持把引用作为参数传给函数，这比传一般的参数更安全。 把引用作为返回值 可以从 C++ 函数中返回引用，就像返回其他数据类型一样。 ","date":"2021-08-20","objectID":"/2021/08/c-20%E5%BC%95%E7%94%A8/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 20引用","uri":"/2021/08/c-20%E5%BC%95%E7%94%A8/"},{"categories":["C++"],"content":"C++ 日期 \u0026 时间 C++ 标准库没有提供所谓的日期类型。C++ 继承了 C 语言用于日期和时间操作的结构和函数。为了使用日期和时间相关的函数和结构，需要在 C++ 程序中引用 头文件。 有四个与时间相关的类型：clock_t、time_t、size_t 和 tm。类型 clock_t、size_t 和 time_t 能够把系统时间和日期表示为某种整数。 结构类型 tm 把日期和时间以 C 结构的形式保存，tm 结构的定义如下： struct tm { int tm_sec; // 秒，正常范围从 0 到 59，但允许至 61 int tm_min; // 分，范围从 0 到 59 int tm_hour; // 小时，范围从 0 到 23 int tm_mday; // 一月中的第几天，范围从 1 到 31 int tm_mon; // 月，范围从 0 到 11 int tm_year; // 自 1900 年起的年数 int tm_wday; // 一周中的第几天，范围从 0 到 6，从星期日算起 int tm_yday; // 一年中的第几天，范围从 0 到 365，从 1 月 1 日算起 int tm_isdst; // 夏令时 }; 下面是 C/C++ 中关于日期和时间的重要函数。所有这些函数都是 C/C++ 标准库的组成部分，您可以在 C++ 标准库中查看一下各个函数的细节。 序号 函数 \u0026 描述 1 time_t time(time_t *time); 该函数返回系统的当前日历时间，自 1970 年 1 月 1 日以来经过的秒数。如果系统没有时间，则返回 -1。 2 char *ctime(const time_t *time); 该返回一个表示当地时间的字符串指针，字符串形式 day month year hours:minutes:seconds year\\n\\0。 3 struct tm *localtime(const time_t *time); 该函数返回一个指向表示本地时间的 tm 结构的指针。 4 clock_t clock(void); 该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。如果时间不可用，则返回 -1。 5 char * asctime ( const struct tm * time ); 该函数返回一个指向字符串的指针，字符串包含了 time 所指向结构中存储的信息，返回形式为：day month date hours:minutes:seconds year\\n\\0。 6 struct tm *gmtime(const time_t *time); 该函数返回一个指向 time 的指针，time 为 tm 结构，用协调世界时（UTC）也被称为格林尼治标准时间（GMT）表示。 7 time_t mktime(struct tm *time); 该函数返回日历时间，相当于 time 所指向结构中存储的时间。 8 double difftime ( time_t time2, time_t time1 ); 该函数返回 time1 和 time2 之间相差的秒数。 9 size_t strftime(); 该函数可用于格式化日期和时间为指定的格式。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"当前日期和时间 下面的实例获取当前系统的日期和时间，包括本地时间和协调世界时（UTC）。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); // 把 now 转换为字符串形式 char* dt = ctime(\u0026now); cout \u003c\u003c \"本地日期和时间：\" \u003c\u003c dt \u003c\u003c endl; // 把 now 转换为 tm 结构 tm *gmtm = gmtime(\u0026now); dt = asctime(gmtm); cout \u003c\u003c \"UTC 日期和时间：\"\u003c\u003c dt \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 本地日期和时间：Sat Jan 8 20:07:41 2011 UTC 日期和时间：Sun Jan 9 03:07:41 2011 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"使用结构 tm 格式化时间 tm 结构在 C/C++ 中处理日期和时间相关的操作时，显得尤为重要。tm 结构以 C 结构的形式保存日期和时间。大多数与时间相关的函数都使用了 tm 结构。下面的实例使用了 tm 结构和各种与日期和时间相关的函数。 在练习使用结构之前，需要对 C 结构有基本的了解，并懂得如何使用箭头 -\u003e 运算符来访问结构成员。 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003cctime\u003e using namespace std; int main( ) { // 基于当前系统的当前日期/时间 time_t now = time(0); cout \u003c\u003c \"1970 到目前经过秒数:\" \u003c\u003c now \u003c\u003c endl; tm *ltm = localtime(\u0026now); // 输出 tm 结构的各个组成部分 cout \u003c\u003c \"年: \"\u003c\u003c 1900 + ltm-\u003etm_year \u003c\u003c endl; cout \u003c\u003c \"月: \"\u003c\u003c 1 + ltm-\u003etm_mon\u003c\u003c endl; cout \u003c\u003c \"日: \"\u003c\u003c ltm-\u003etm_mday \u003c\u003c endl; cout \u003c\u003c \"时间: \"\u003c\u003c ltm-\u003etm_hour \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_min \u003c\u003c \":\"; cout \u003c\u003c ltm-\u003etm_sec \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： 1970 到目前时间:1503564157 年: 2017 月: 8 日: 24 时间: 16:42:37 ","date":"2021-08-20","objectID":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 21日期 \u0026 时间","uri":"/2021/08/c-21%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4/"},{"categories":["C++"],"content":"C++ 基本的输入输出 C++ 标准库提供了一组丰富的输入/输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I/O 操作。 C++ 的 I/O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"I/O 库头文件 下列的头文件在 C++ 编程中很重要。 头文件 函数和描述 \u003ciostream\u003e 该文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、非缓冲标准错误流和缓冲标准错误流。 \u003ciomanip\u003e 该文件通过所谓的参数化的流操纵器（比如 setw 和 setprecision），来声明对执行标准化 I/O 有用的服务。 \u003cfstream\u003e 该文件为用户控制的文件处理声明服务。我们将在文件和流的相关章节讨论它的细节。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准输出流（cout） 预定义的对象 cout 是 iostream 类的一个实例。cout 对象\"连接\"到标准输出设备，通常是显示屏。cout 是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Hello C++\"; cout \u003c\u003c \"Value of str is : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Value of str is : Hello C++ C++ 编译器根据要输出变量的数据类型，选择合适的流插入运算符来显示值。« 运算符被重载来输出内置类型（整型、浮点型、double 型、字符串和指针）的数据项。 流插入运算符 « 在一个语句中可以多次使用，如上面实例中所示，endl 用于在行末添加一个换行符。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准输入流（cin） 预定义的对象 cin 是 iostream 类的一个实例。cin 对象附属到标准输入设备，通常是键盘。cin 是与流提取运算符 » 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char name[50]; cout \u003c\u003c \"请输入您的名称： \"; cin \u003e\u003e name; cout \u003c\u003c \"您的名称是： \" \u003c\u003c name \u003c\u003c endl; } 当上面的代码被编译和执行时，它会提示用户输入名称。当用户输入一个值，并按回车键，就会看到下列结果： 请输入您的名称： cplusplus 您的名称是： cplusplus C++ 编译器根据要输入值的数据类型，选择合适的流提取运算符来提取值，并把它存储在给定的变量中。 流提取运算符 » 在一个语句中可以多次使用，如果要求输入多个数据，可以使用如下语句： cin \u003e\u003e name \u003e\u003e age; 这相当于下面两个语句： cin \u003e\u003e name; cin \u003e\u003e age; ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准错误流（cerr） 预定义的对象 cerr 是 iostream 类的一个实例。cerr 对象附属到标准错误设备，通常也是显示屏，但是 cerr 对象是非缓冲的，且每个流插入到 cerr 都会立即输出。 cerr 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; cerr \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"标准日志流（clog） 预定义的对象 clog 是 iostream 类的一个实例。clog 对象附属到标准错误设备，通常也是显示屏，但是 clog 对象是缓冲的。这意味着每个流插入到 clog 都会先存储在缓冲区，直到缓冲填满或者缓冲区刷新时才会输出。 clog 也是与流插入运算符 « 结合使用的，如下所示： ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e using namespace std; int main( ) { char str[] = \"Unable to read....\"; clog \u003c\u003c \"Error message : \" \u003c\u003c str \u003c\u003c endl; } 当上面的代码被编译和执行时，它会产生下列结果： Error message : Unable to read.... 通过这些小实例，我们无法区分 cout、cerr 和 clog 的差异，但在编写和执行大型程序时，它们之间的差异就变得非常明显。所以良好的编程实践告诉我们，使用 cerr 流来显示错误消息，而其他的日志消息则使用 clog 流来输出。 ","date":"2021-08-20","objectID":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:9:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 22基本的输入输出","uri":"/2021/08/c-22%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"C++ 数据结构 C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。 结构用于表示一条记录，假设您想要跟踪图书馆中书本的动态，您可能需要跟踪每本书的下列属性： Title ：标题 Author ：作者 Subject ：类目 Book ID ：书的 ID ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"定义结构 为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： struct type_name { member_type1 member_name1; member_type2 member_name2; member_type3 member_name3; . . } object_names; type_name 是结构体类型的名称，member_type1 member_name1 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的。下面是声明一个结构体类型 Books，变量为 book： struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } book; ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"访问结构成员 为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。 下面的实例演示了结构的用法： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 cout \u003c\u003c \"第一本书标题 : \" \u003c\u003c Book1.title \u003c\u003cendl; cout \u003c\u003c \"第一本书作者 : \" \u003c\u003c Book1.author \u003c\u003cendl; cout \u003c\u003c \"第一本书类目 : \" \u003c\u003c Book1.subject \u003c\u003cendl; cout \u003c\u003c \"第一本书 ID : \" \u003c\u003c Book1.book_id \u003c\u003cendl; // 输出 Book2 信息 cout \u003c\u003c \"第二本书标题 : \" \u003c\u003c Book2.title \u003c\u003cendl; cout \u003c\u003c \"第二本书作者 : \" \u003c\u003c Book2.author \u003c\u003cendl; cout \u003c\u003c \"第二本书类目 : \" \u003c\u003c Book2.subject \u003c\u003cendl; cout \u003c\u003c \"第二本书 ID : \" \u003c\u003c Book2.book_id \u003c\u003cendl; return 0; } 实例中定义了结构体类型 Books 及其两个变量 Book1 和 Book2。当上面的代码被编译和执行时，它会产生下列结果： 第一本书标题 : C++ 教程 第一本书作者 : Runoob 第一本书类目 : 编程语言 第一本书 ID : 12345 第二本书标题 : CSS 教程 第二本书作者 : Runoob 第二本书类目 : 前端技术 第二本书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"结构作为函数参数 您可以把结构作为函数参数，传参方式与其他类型的变量或指针类似。您可以使用上面实例中的方式来访问结构变量： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; void printBook( struct Books book ); // 声明一个结构体类型 Books struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 输出 Book1 信息 printBook( Book1 ); // 输出 Book2 信息 printBook( Book2 ); return 0; } void printBook( struct Books book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book.title \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book.author \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book.subject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book.book_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"指向结构的指针 您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： struct Books *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 \u0026 运算符放在结构名称的前面，如下所示： struct_pointer = \u0026Book1; 为了使用指向该结构的指针访问结构的成员，您必须使用 -\u003e 运算符，如下所示： struct_pointer-\u003etitle; 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; void printBook( struct Books *book ); struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }; int main( ) { Books Book1; // 定义结构体类型 Books 的变量 Book1 Books Book2; // 定义结构体类型 Books 的变量 Book2 // Book1 详述 strcpy( Book1.title, \"C++ 教程\"); strcpy( Book1.author, \"Runoob\"); strcpy( Book1.subject, \"编程语言\"); Book1.book_id = 12345; // Book2 详述 strcpy( Book2.title, \"CSS 教程\"); strcpy( Book2.author, \"Runoob\"); strcpy( Book2.subject, \"前端技术\"); Book2.book_id = 12346; // 通过传 Book1 的地址来输出 Book1 信息 printBook( \u0026Book1 ); // 通过传 Book2 的地址来输出 Book2 信息 printBook( \u0026Book2 ); return 0; } // 该函数以结构指针作为参数 void printBook( struct Books *book ) { cout \u003c\u003c \"书标题 : \" \u003c\u003c book-\u003etitle \u003c\u003cendl; cout \u003c\u003c \"书作者 : \" \u003c\u003c book-\u003eauthor \u003c\u003cendl; cout \u003c\u003c \"书类目 : \" \u003c\u003c book-\u003esubject \u003c\u003cendl; cout \u003c\u003c \"书 ID : \" \u003c\u003c book-\u003ebook_id \u003c\u003cendl; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C++ 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 书标题 : CSS 教程 书作者 : Runoob 书类目 : 前端技术 书 ID : 12346 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":["C++"],"content":"typedef 关键字 下面是一种更简单的定义结构的方式，您可以为创建的类型取一个\"别名\"。例如： typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; }Books; 现在，您可以直接使用 Books 来定义 Books 类型的变量，而不需要使用 struct 关键字。下面是实例： Books Book1, Book2; 您可以使用 typedef 关键字来定义非结构类型，如下所示： typedef long int *pint32; pint32 x, y, z; x, y 和 z 都是指向长整型 long int 的指针。 ","date":"2021-08-20","objectID":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 23数据结构","uri":"/2021/08/c-23%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"categories":null,"content":"任鸟飞逆向分析基础教程 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞天涯明月刀辅助实战教程 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:1","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"2020飞郁任鸟飞C++之灵魂起源 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:2","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"代号1124-任鸟飞2019之易语言FPS游戏自瞄爆头飞天透视画框 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:3","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2016百尺竿头 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:0:4","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞天涯明月刀 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:1:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"2020飞郁任鸟飞C++之灵魂起源系列教程 课程目录： 001.灵魂起源_进制 002.灵魂起源_进制_进阶 003.灵魂起源_高级语言和低级语言 004.灵魂起源_创建第一个程序 005.灵魂起源_printf和scanf编写进制转换器 006.灵魂起源_变量与常量 007.灵魂起源_内存 008.灵魂起源_数据类型 009.灵魂起源_数据类型在内存中的储存方式1 010.灵魂起源_数据类型在内存中的储存方式2 011.灵魂起源_有符号和无符号区别，强制转换类型 012.灵魂起源_CE入门整数扫描 013.灵魂起源_CE浮点数扫描实现瞬移 014.灵魂起源_CE扫描进入游戏标志位 015.灵魂起源_基地址，动态地址和偏移 016.灵魂起源_CE的一些技巧 017.灵魂起源_CE扫描字符串1 018.灵魂起源_CE扫描字符串2 019.灵魂起源_CE找偏移表达式 020.灵魂起源_代码编写MFCDLL显示窗口 021.内存读写，输出人物血量和实现瞬移 089.堆栈检测 090.处理一层堆栈检测防封 095.数据检测 096.过数据检测防封 106.明文发包函数 114.收包函数recv，WSARecv和沾包 115.找明文收包函数的方法 165.技能冷却二叉树牵扯出游戏全部冷却数据 169.技能遍历1 ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:2:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2019之易语言FPS游戏自瞄爆头飞天透视画框 教程目录: 0.FPS游戏自瞄展示 1.FPS游戏自瞄透视之模块动态加载; 2.FPS游戏自瞄透视之玩转堆栈 3.FPS游戏自瞄透视之遍历周围所有目标 4.FPS游戏自瞄透视之目标需要的属性总结 5.FPS游戏自瞄透视之准星数据查找\" 6.FPS游戏自瞄透视之准星变化规律 7.FPS游戏自瞄透视之准星算法 8.FPS游戏自瞄透视之C++代码实现自瞄1 9.FPS游戏自瞄透视之C++代码实现自瞄2 10.FPS游戏自瞄透视之C++代码实现自瞄3 11.C++源码FPSyouxi——————-不是视频 12.创世最新数据——————不是视频 13.FPS游戏易语言之封装必要函数 14.FPS游戏易语言之用类遍历人物属性4 15.FPS游戏易语言之热键瞄准和计算最近距离 16.FPS游戏易语言之实现自瞄 17.易语言创世战车源码! 18.cf加密准星分析 19.cf人物坐标分析 20.cf遍历周边玩家 21.cf分析坐标规律实现自瞄, 22.分析绘制和所需数据（视角查找） 23.取窗口矩形位置和大小 24.建立透明窗口跟随游戏! 25..分析水平可视敌人 26..分析垂直可视敌人 27.转换2D坐标画出基础方框 28.如何调整方框比例（1） 29.如何调整方框比例（2） 30.计算并瞄准准星最近的敌人 31.cf变态功能之飞天蹲地 32.cf变态功能之无限子弹 33.实战内存人物透视CRC(1) 34.实战内存人物透视CRC(2) 35.理解检测和对抗原理1 36.封包处理检测（理论） 37.实战明文发包（木马加载 ） 38.分享实战笔记(不是视频 ) ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:3:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":null,"content":"任鸟飞2016百尺竿头 任鸟飞2016百尺竿头课程00介绍00.rar 任鸟飞2016百尺竿头课程第1课人物对象.rar 任鸟飞2016百尺竿头课程第2课加密坐标.rar 任鸟飞2016百尺竿头课程第3课升级经验数组.rar 任鸟飞2016百尺竿头课程第4课等级加密解密.rar 任鸟飞2016百尺竿头课程第5课战斗标志位.rar 任鸟飞2016百尺竿头课程第6课战斗顺序标志位.rar 任鸟飞2016百尺竿头课程第7课怪物数组遍历.rar 任鸟飞2016百尺竿头课程第8课序号提取表.rar 任鸟飞2016百尺竿头课程第9课(C++)编写DLL显示窗口.rar 任鸟飞2016百尺竿头课程第10课(C++)调试输出人物信息.rar 任鸟飞2016百尺竿头课程第11课寻路CALL.rar 任鸟飞2016百尺竿头课程第12课(C++)内联汇编编写寻路CALL.rar 任鸟飞2016百尺竿头课程第13课数据定位.rar 任鸟飞2016百尺竿头课程第14课(C++)封装周围数组.rar 任鸟飞2016百尺竿头课程第15课(C++)封装升级标志战斗标志.rar 任鸟飞2016百尺竿头课程第16课HOOK原理.rar 任鸟飞2016百尺竿头课程第17课(C++)HOOK明文包.rar 任鸟飞2016百尺竿头课程第18课封包和HOOK明文包的优点发包变态功能理解.rar 任鸟飞2016百尺竿头课程第19课(C++)send发送封包.rar 任鸟飞2016百尺竿头课程第20课分析攻击封包.rar 任鸟飞2016百尺竿头课程第21课(C++)封装人物攻击宝宝攻击.rar 任鸟飞2016百尺竿头课程第22课通过参数找选角色Call并且验证主线程调用的作用.rar 任鸟飞2016百尺竿头课程第23课(C++)封装主线程调用.rar 任鸟飞2016百尺竿头课程第24课自动打怪逻辑.rar 任鸟飞2016百尺竿头课程第25课(C++)自动打怪循环寻路线程.rar 任鸟飞2016百尺竿头课程第26课(C++)自动打怪杀怪线程.rar 任鸟飞2016百尺竿头课程第27课任务遍历.rar 任鸟飞2016百尺竿头课程第28课(C++)二叉树递归算法.rar 任鸟飞2016百尺竿头课程第29课任务属性分析.rar 任鸟飞2016百尺竿头课程第30课检测概论.rar 任鸟飞2016百尺竿头课程第31课第一个任务的3连封包分析.rar 任鸟飞2016百尺竿头课程第32课分析加密封包.rar 任鸟飞2016百尺竿头课程第33课远线程注入DLL.rar 任鸟飞2016百尺竿头课程第34课劫持注入.rar 任鸟飞2016百尺竿头课程第35课收包概论.rar 任鸟飞2016百尺竿头课程第36课recv实例分析.rar 任鸟飞2016百尺竿头课程第37-38课收包实例及一些技巧.rar 任鸟飞2016百尺竿头课程第39课窗口句柄and账号.rar 任鸟飞2016百尺竿头课程第40课背包遍历.rar 任鸟飞2016百尺竿头课程第41课寻宝坐标加密.rar 任鸟飞2016百尺竿头课程第42课物品丢弃封包.rar 任鸟飞2016百尺竿头课程第43课自动清包.rar 任鸟飞2016百尺竿头课程第44课控件输入CALL.rar 任鸟飞2016百尺竿头课程第45课控件遍历数组递归.rar 任鸟飞2016百尺竿头课程第46课控件遍历编写.rar 任鸟飞2016百尺竿头课程第47课角色遍历.rar 任鸟飞2016百尺竿头课程第48课创建角色封包.rar 任鸟飞2016百尺竿头课程第49课画江山总结.rar graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ","date":"2021-08-19","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/:4:0","series":null,"tags":["任鸟飞"],"title":"任鸟飞系列","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%B3%BB%E5%88%97/"},{"categories":["C++"],"content":"C++ 自增自减运算符 C++ 运算符 自增运算符 ++ 会把操作数加 1，自减运算符 – 会把操作数减 1。因此： x = x+1; 等同于 x++; 同样的： x = x-1; 等同于 x--; 无论是自增运算符还是自减运算符，都可以放在操作数的前面（前缀）或后面（后缀）。例如： x = x+1; 可以写成： ++x; // 前缀形式 或者： x++; // 后缀形式 前缀形式与后缀形式之间有一点不同。如果使用前缀形式，则会在表达式计算之前完成自增或自减，如果使用后缀形式，则会在表达式计算之后完成自增或自减。 实例 请看下面的实例，理解二者之间的区别： #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int c ; // a 的值在赋值之前不会自增 c = a++; cout \u003c\u003c \"Line 1 - Value of a++ is :\" \u003c\u003c c \u003c\u003c endl ; // 表达式计算之后，a 的值增加 1 cout \u003c\u003c \"Line 2 - Value of a is :\" \u003c\u003c a \u003c\u003c endl ; // a 的值在赋值之前自增 c = ++a; cout \u003c\u003c \"Line 3 - Value of ++a is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of a++ is :21 Line 2 - Value of a is :22 Line 3 - Value of ++a is :23 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12a自增自减运算符","uri":"/2021/08/c-12a%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 杂项运算符 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ sizeof 运算符 sizeof 是一个关键字，它是一个编译时运算符，用于判断变量或数据类型的字节大小。 sizeof 运算符可用于获取类、结构、共用体和其他用户自定义数据类型的大小。 使用 sizeof 的语法如下： sizeof (data type) 其中，data type 是要计算大小的数据类型，包括类、结构、共用体和其他用户自定义数据类型。 请尝试下面的实例，理解 C++ 中 sizeof 的用法。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Size of char : \" \u003c\u003c sizeof(char) \u003c\u003c endl; cout \u003c\u003c \"Size of int : \" \u003c\u003c sizeof(int) \u003c\u003c endl; cout \u003c\u003c \"Size of short int : \" \u003c\u003c sizeof(short int) \u003c\u003c endl; cout \u003c\u003c \"Size of long int : \" \u003c\u003c sizeof(long int) \u003c\u003c endl; cout \u003c\u003c \"Size of float : \" \u003c\u003c sizeof(float) \u003c\u003c endl; cout \u003c\u003c \"Size of double : \" \u003c\u003c sizeof(double) \u003c\u003c endl; cout \u003c\u003c \"Size of wchar_t : \" \u003c\u003c sizeof(wchar_t) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果，结果会根据使用的机器而不同： Size of char : 1 Size of int : 4 Size of short int : 2 Size of long int : 4 Size of float : 4 Size of double : 8 Size of wchar_t : 4 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 条件运算符 ? : Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意冒号的使用和位置。? : 表达式的值取决于 Exp1 的计算结果。如果 Exp1 为真，则计算 Exp2 的值，且 Exp2 的计算结果则为整个 ? : 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，且 Exp3 的计算结果则为整个 ? : 表达式的值。 ? 被称为三元运算符，因为它需要三个操作数，可以用来代替如下所示的 if-else 语句： if(condition){ var = X; }else{ var = Y; } 例如，请看下面这段代码： if(y \u003c 10){ var = 30; }else{ var = 40; } 上面的代码可以写成以下语句： var = (y \u003c 10) ? 30 : 40; 在这里，如果 y 小于 10，则 var 被赋值为 30，如果 y 不小于 10，则 var 被赋值为 40。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int main () { // 局部变量声明 int x, y = 10; x = (y \u003c 10) ? 30 : 40; cout \u003c\u003c \"value of x: \" \u003c\u003c x \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： value of x: 40 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 逗号运算符 使用逗号运算符是为了把几个表达式放在一起。 整个逗号表达式的值为系列中最后一个表达式的值。 从本质上讲，逗号的作用是将一系列运算按顺序执行。 表达式1, 表达式2 求解过程是：先求解表达式 1，再求解表达式 2。整个逗号表达式的值是表达式 2 的值。 最右边的那个表达式的值将作为整个逗号表达式的值，其他表达式的值会被丢弃。 例如： var = (count=19, incr=10, count+1); 在这里，首先把 count 赋值为 19，把 incr 赋值为 10，然后把 count 加 1，最后，把最右边表达式 count+1 的计算结果 20 赋给 var。上面表达式中的括号是必需的，因为逗号运算符的优先级低于赋值操作符。 尝试运行下面的实例，理解逗号运算符的用法。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int i, j; j = 10; i = (j++, j+100, 999+j); cout \u003c\u003c i; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 1010 上面的程序中，j 最初的值为 10，然后自增到 11，这时 j 的值就为 11，然后再计算第二个表达式 j+100，最后 j（j 为 11） 再加上 999，最后 i 为 最后一个表达式的值 999+j，及 999+ 11=1010。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。箭头运算符与一个指向对象的指针一起使用。例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"（-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:4:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 强制转换运算符 强制转换运算符是一种特殊的运算符，它把一种数据类型转换为另一种数据类型。强制转换运算符是一元运算符，它的优先级与其他一元运算符相同。 大多数的 C++ 编译器都支持大部分通用的强制转换运算符： (type) expression 其中，type 是转换后的数据类型。下面列出了 C++ 支持的其他几种强制转换运算符： const_cast (expr): const_cast 运算符用于修改类型的 const / volatile 属性。除了 const 或 volatile 属性之外，目标类型必须与源类型相同。这种类型的转换主要是用来操作所传对象的 const 属性，可以加上 const 属性，也可以去掉 const 属性。 dynamic_cast (expr): dynamic_cast 在运行时执行转换，验证转换的有效性。如果转换未执行，则转换失败，表达式 expr 被判定为 null。dynamic_cast 执行动态转换时，type 必须是类的指针、类的引用或者 void*，如果 type 是类指针类型，那么 expr 也必须是一个指针，如果 type 是一个引用，那么 expr 也必须是一个引用。 reinterpret_cast (expr): reinterpret_cast 运算符把某种指针改为其他类型的指针。它可以把一个指针转换为一个整数，也可以把一个整数转换为一个指针。 static_cast (expr): static_cast 运算符执行非动态转换，没有运行时类检查来保证转换的安全性。例如，它可以用来把一个基类指针转换为派生类指针。 上述所有的强制转换运算符在使用类和对象时会用到。现在，请看下面的实例，理解 C++ 中如何使用一个简单的强制转换运算符。复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 #include \u003ciostream\u003eusing namespace std; int main() { double a = 21.09399; float b = 10.20; int c ; c = (int) a; cout \u003c\u003c \"Line 1 - Value of (int)a is :\" \u003c\u003c c \u003c\u003c endl ; c = (int) b; cout \u003c\u003c \"Line 2 - Value of (int)b is :\" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Line 1 - Value of (int)a is :21 Line 2 - Value of (int)b is :10 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 指针运算符（\u0026 和 *） C++ 提供了两种指针运算符，一种是取地址运算符 \u0026，一种是间接寻址运算符 *。 指针是一个包含了另一个变量地址的变量，您可以把一个包含了另一个变量地址的变量说成是\"指向\"另一个变量。变量可以是任意的数据类型，包括对象、结构或者指针。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作**“取地址运算符”**，这意味着，**\u0026var** 读作\"var 的地址\"。 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 C++ 运算符 ","date":"2021-08-18","objectID":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/:6:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12b杂项运算符","uri":"/2021/08/c-12b%E6%9D%82%E9%A1%B9%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 字符串 C++ 提供了以下两种类型的字符串表示形式： C 风格字符串 C++ 引入的 string 类类型 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C 风格字符串 C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 null 字符 \\0 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 下面的声明和初始化创建了一个 RUNOOB 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 RUNOOB 的字符数多一个。 char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char site[] = \"RUNOOB\"; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C++ 编译器会在初始化数组时，自动把 \\0 放在字符串的末尾。让我们尝试输出上面的字符串： 实例 #include \u003ciostream\u003e using namespace std; int main () { char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; cout \u003c\u003c \"菜鸟教程: \"; cout \u003c\u003c site \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 菜鸟教程: RUNOOB C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 \u0026 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = “runoob”;string str2 = “google”; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 下面的实例使用了上述的一些函数： 实例 #include \u003ciostream\u003e#include \u003ccstring\u003e using namespace std; int main () { char str1[13] = \"runoob\"; char str2[13] = \"google\"; char str3[13]; int len ; // 复制 str1 到 str3 strcpy( str3, str1); cout \u003c\u003c \"strcpy( str3, str1) : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 strcat( str1, str2); cout \u003c\u003c \"strcat( str1, str2): \" \u003c\u003c str1 \u003c\u003c endl; // 连接后，str1 的总长度 len = strlen(str1); cout \u003c\u003c \"strlen(str1) : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： strcpy( str3, str1) : runoob strcat( str1, str2): runoobgoogle strlen(str1) : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 中的 String 类 C++ 标准库提供了 string 类类型，支持上述所有的操作，另外还增加了其他更多的功能。我们将学习 C++ 标准库中的这个类，现在让我们先来看看下面这个实例： 现在您可能还无法透彻地理解这个实例，因为到目前为止我们还没有讨论类和对象。所以现在您可以只是粗略地看下这个实例，等理解了面向对象的概念之后再回头来理解这个实例。 实例 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; int main () { string str1 = \"runoob\"; string str2 = \"google\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： str3 : runoob str1 + str2 : runoobgoogle str3.size() : 12 ","date":"2021-08-18","objectID":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 18字符串","uri":"/2021/08/c-18%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 函数 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"定义函数 C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"函数参数 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"指针调用 // 函数定义 void swap(int *x, int *y) { int temp; temp = *x; /* 保存地址 x 的值 */ *x = *y; /* 把 y 赋值给 x */ *y = temp; /* 把 x 赋值给 y */ return; } #include \u003ciostream\u003eusing namespace std; // 函数声明 void swap(int *x, int *y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 * \u0026a 表示指向 a 的指针，即变量 a 的地址 * \u0026b 表示指向 b 的指针，即变量 b 的地址 */ swap(\u0026a, \u0026b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"引用调用 // 函数定义 void swap(int \u0026x, int \u0026y) { int temp; temp = x; /* 保存地址 x 的值 */ x = y; /* 把 y 赋值给 x */ y = temp; /* 把 x 赋值给 y */ return; } #include \u003ciostream\u003eusing namespace std; // 函数声明 void swap(int \u0026x, int \u0026y); int main () { // 局部变量声明 int a = 100; int b = 200; cout \u003c\u003c \"交换前，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换前，b 的值：\" \u003c\u003c b \u003c\u003c endl; /* 调用函数来交换值 */ swap(a, b); cout \u003c\u003c \"交换后，a 的值：\" \u003c\u003c a \u003c\u003c endl; cout \u003c\u003c \"交换后，b 的值：\" \u003c\u003c b \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 交换前，a 的值： 100 交换前，b 的值： 200 交换后，a 的值： 200 交换后，b 的值： 100 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: [capture](parameters)-\u003ereturn-type{body} 例如： [](int x, int y){ return x \u003c y ; } 如果没有返回值可以表示为： [capture](parameters){body} 例如： []{ ++global_x; } 在一个更为复杂的例子中，返回类型可以被明确的指定如下： [](int x, int y) -\u003e int { int z = x + y; return z + x; } 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： [this]() { this-\u003esomeFunc(); }(); C++ 数字 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数学运算 序号 函数 \u0026 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 随机数 rand()该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 time() 函数来获取系统时间的秒数 #include \u003ciostream\u003e#include \u003cctime\u003e#include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 随机数： 1748144778 随机数： 630873888 随机数： 2134540646 随机数： 219404170 随机数： 902129458 随机数： 920445370 随机数： 1319072661 随机数： 257938873 随机数： 1256201101 随机数： 580322989 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记15-16函数 \u0026 数字","uri":"/2021/08/c-%E7%AC%94%E8%AE%B015-16%E5%87%BD%E6%95%B0-%E6%95%B0%E5%AD%97/"},{"categories":["菜鸟C++笔记"],"content":"C++ 数组 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"多维数组 多维数组声明的一般形式如下： type name[size1][size2]...[sizeN]; 初始化二维数组 int a[3][4] = { {0, 1, 2, 3} , /* 初始化索引号为 0 的行 */ {4, 5, 6, 7} , /* 初始化索引号为 1 的行 */ {8, 9, 10, 11} /* 初始化索引号为 2 的行 */ }; ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 指向数组的指针 #include \u003ciostream\u003eusing namespace std; int main () { // 带有 5 个元素的双精度浮点型数组 double runoobAarray[5] = {1000.0, 2.0, 3.4, 17.0, 50.0}; double *p; p = runoobAarray; // 输出数组中每个元素的值 cout \u003c\u003c \"使用指针的数组值 \" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"*(p + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(p + i) \u003c\u003c endl; } cout \u003c\u003c \"使用 runoobAarray 作为地址的数组值 \" \u003c\u003c endl; for ( int i = 0; i \u003c 5; i++ ) { cout \u003c\u003c \"*(runoobAarray + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(runoobAarray + i) \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 使用指针的数组值 *(p + 0) : 1000 *(p + 1) : 2 *(p + 2) : 3.4 *(p + 3) : 17 *(p + 4) : 50 使用 runoobAarray 作为地址的数组值 *(runoobAarray + 0) : 1000 *(runoobAarray + 1) : 2 *(runoobAarray + 2) : 3.4 *(runoobAarray + 3) : 17 *(runoobAarray + 4) : 50 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 传递数组给函数 方式 1 形式参数是一个指针： void myFunction(int *param) { . . . } 方式 2 形式参数是一个已定义大小的数组： void myFunction(int param[10]) { . . . } 方式 3 形式参数是一个未定义大小的数组： void myFunction(int param[]) { . . . } 实例 现在，让我们来看下面这个函数，它把数组作为参数，同时还传递了另一个参数，根据所传的参数，会返回数组中各元素的平均值： double getAverage(int arr[], int size) { int i, sum = 0; double avg; for (i = 0; i \u003c size; ++i) { sum += arr[i]; } avg = double(sum) / size; return avg; } 现在，让我们调用上面的函数，如下所示： #include \u003ciostream\u003eusing namespace std; // 函数声明 double getAverage(int arr[], int size); int main () { // 带有 5 个元素的整型数组 int balance[5] = {1000, 2, 3, 17, 50}; double avg; // 传递一个指向数组的指针作为参数 avg = getAverage( balance, 5 ) ; // 输出返回值 cout \u003c\u003c \"平均值是：\" \u003c\u003c avg \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 平均值是： 214.4 您可以看到，就函数而言，数组的长度是无关紧要的，因为 C++ 不会对形式参数执行边界检查。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 从函数返回数组 C++ 不允许返回一个完整的数组作为函数的参数。但是，您可以通过指定不带索引的数组名来返回一个指向数组的指针。 如果您想要从函数返回一个一维数组，您必须声明一个返回指针的函数，如下： int * myFunction() { . . . } C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量。 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003cctime\u003e using namespace std; // 要生成和返回随机数的函数 int * getRandom( ) { static int r[10]; // 设置种子 srand( (unsigned)time( NULL ) ); for (int i = 0; i \u003c 10; ++i) { r[i] = rand(); cout \u003c\u003c r[i] \u003c\u003c endl; } return r; } // 要调用上面定义函数的主函数 int main () { // 一个指向整数的指针 int *p; p = getRandom(); for ( int i = 0; i \u003c 10; i++ ) { cout \u003c\u003c \"*(p + \" \u003c\u003c i \u003c\u003c \") : \"; cout \u003c\u003c *(p + i) \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 624723190 1468735695 807113585 976495677 613357504 1377296355 1530315259 1778906708 1820354158 667126415 *(p + 0) : 624723190 *(p + 1) : 1468735695 *(p + 2) : 807113585 *(p + 3) : 976495677 *(p + 4) : 613357504 *(p + 5) : 1377296355 *(p + 6) : 1530315259 *(p + 7) : 1778906708 *(p + 8) : 1820354158 *(p + 9) : 667126415 C++ 字符串 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C 风格字符串 char site[7] = {'R', 'U', 'N', 'O', 'O', 'B', '\\0'}; 依据数组初始化规则，您可以把上面的语句写成以下语句： char site[] = \"RUNOOB\"; 以下是 C/C++ 中定义的字符串的内存表示： C/C++ 中的字符串表示 C++ 中有大量的函数用来操作以 null 结尾的字符串: 序号 函数 \u0026 目的 1 strcpy(s1, s2); 复制字符串 s2 到字符串 s1。 2 strcat(s1, s2); 连接字符串 s2 到字符串 s1 的末尾。连接字符串也可以用 + 号，例如: string str1 = “runoob”;string str2 = “google”; string str = str1 + str2; 3 strlen(s1); 返回字符串 s1 的长度。 4 strcmp(s1, s2); 如果 s1 和 s2 是相同的，则返回 0；如果 s1\u003cs2 则返回值小于 0；如果 s1\u003es2 则返回值大于 0。 5 strchr(s1, ch); 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 6 strstr(s1, s2); 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的 String 类 实例 #include \u003ciostream\u003e#include \u003cstring\u003e using namespace std; int main () { string str1 = \"runoob\"; string str2 = \"google\"; string str3; int len ; // 复制 str1 到 str3 str3 = str1; cout \u003c\u003c \"str3 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接 str1 和 str2 str3 = str1 + str2; cout \u003c\u003c \"str1 + str2 : \" \u003c\u003c str3 \u003c\u003c endl; // 连接后，str3 的总长度 len = str3.size(); cout \u003c\u003c \"str3.size() : \" \u003c\u003c len \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： str3 : runoob str1 + str2 : runoobgoogle str3.size() : 12 ","date":"2021-08-18","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记17-18数组 \u0026 字符串","uri":"/2021/08/c-%E7%AC%94%E8%AE%B017-18%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["C++"],"content":"C++ 变量作用域 作用域是程序的一个区域，一般来说有三个地方可以定义变量： 在函数或一个代码块内部声明的变量，称为局部变量。 在函数参数的定义中声明的变量，称为形式参数。 在所有函数外部声明的变量，称为全局变量。 我们将在后续的章节中学习什么是函数和参数。本章我们先来讲解什么是局部变量和全局变量。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"局部变量 在函数或一个代码块内部声明的变量，称为局部变量。它们只能被函数内部或者代码块内部的语句使用。下面的实例使用了局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main () { // 局部变量声明 int a, b; int c; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c; return 0; } ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"全局变量 在所有函数外部定义的变量（通常是在程序的头部），称为全局变量。全局变量的值在程序的整个生命周期内都是有效的。 全局变量可以被任何函数访问。也就是说，全局变量一旦声明，在整个程序中都是可用的。下面的实例使用了全局变量和局部变量： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; // 全局变量声明 int g; int main () { // 局部变量声明 int a, b; // 实际初始化 a = 10; b = 20; g = a + b; cout \u003c\u003c g; return 0; } 在程序中，局部变量和全局变量的名称可以相同，但是在函数内，局部变量的值会覆盖全局变量的值。下面是一个实例： ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; // 全局变量声明 int g = 20; int main () { // 局部变量声明 int g = 10; cout \u003c\u003c g; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 10 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:2:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"初始化局部变量和全局变量 当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值： 数据类型 初始化默认值 int 0 char ‘\\0’ float 0 double 0 pointer NULL 正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。 ","date":"2021-08-17","objectID":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 08变量作用域","uri":"/2021/08/c-08%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"},{"categories":["C++"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"auto 存储类 自 C++ 11 以来，auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。 C++98标准中auto关键字用于自动变量的声明，但由于使用极少且多余，在C++11中已删除这一用法。 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } 寄存器只用于需要快速访问的变量，比如计数器。还应注意的是，定义 ‘register’ 并不意味着变量将被存储在寄存器中，它意味着变量可能存储在寄存器中，这取决于硬件和实现的限制。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"static 存储类 static 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。 static 修饰符也可以应用于全局变量。当 static 修饰全局变量时，会使变量的作用域限制在声明它的文件内。 在 C++ 中，当 static 用在类数据成员上时，会导致仅有一个该成员的副本被类的所有对象共享。 实例 #include \u003ciostream\u003e // 函数声明 void func(void); static int count = 10; /* 全局变量 */ int main() { while(count--) { func(); } return 0; } // 函数定义 void func( void ) { static int i = 5; // 局部静态变量 i++; std::cout \u003c\u003c \"变量 i 为 \" \u003c\u003c i ; std::cout \u003c\u003c \" , 变量 count 为 \" \u003c\u003c count \u003c\u003c std::endl; } 当上面的代码被编译和执行时，它会产生下列结果： 变量 i 为 6 , 变量 count 为 9 变量 i 为 7 , 变量 count 为 8 变量 i 为 8 , 变量 count 为 7 变量 i 为 9 , 变量 count 为 6 变量 i 为 10 , 变量 count 为 5 变量 i 为 11 , 变量 count 为 4 变量 i 为 12 , 变量 count 为 3 变量 i 为 13 , 变量 count 为 2 变量 i 为 14 , 变量 count 为 1 变量 i 为 15 , 变量 count 为 0 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"extern 存储类 extern 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。当您使用 ‘extern’ 时，对于无法初始化的变量，会把变量名指向一个之前定义过的存储位置。 当您有多个文件且定义了一个可以在其他文件中使用的全局变量或函数时，可以在其他文件中使用 extern 来得到已定义的变量或函数的引用。可以这么理解，extern 是用来在另一个文件中声明一个全局变量或函数。 extern 修饰符通常用于当有两个或多个文件共享相同的全局变量或函数的时候，如下所示： 第一个文件：main.cpp 实例 #include \u003ciostream\u003e int count ; extern void write_extern(); int main() { count = 5; write_extern(); } 第二个文件：support.cpp 实例 #include \u003ciostream\u003e extern int count; void write_extern(void) { std::cout \u003c\u003c \"Count is \" \u003c\u003c count \u003c\u003c std::endl; } 在这里，第二个文件中的 extern 关键字用于声明已经在第一个文件 main.cpp 中定义的 count。现在 ，编译这两个文件，如下所示： $ g++ main.cpp support.cpp -o write 这会产生 write 可执行程序，尝试执行 write，它会产生下列结果： $ ./write Count is 5 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"thread_local 存储类 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。 thread_local 说明符可以与 static 或 extern 合并。 可以将 thread_local 仅应用于数据声明和定义，thread_local 不能用于函数声明或定义。 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } ","date":"2021-08-17","objectID":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 11存储类","uri":"/2021/08/c-11%E5%AD%98%E5%82%A8%E7%B1%BB/"},{"categories":["C++"],"content":"C++ 运算符 运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C++ 内置了丰富的运算符，并提供了以下类型的运算符： 算术运算符 关系运算符 逻辑运算符 位运算符 赋值运算符 杂项运算符 本章将逐一介绍算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"算术运算符 下表显示了 C++ 支持的算术运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 – 自减运算符，整数值减少 1 A– 将得到 9 实例 请看下面的实例，了解 C++ 中可用的算术运算符。 复制并粘贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int b = 10; int c; c = a + b; cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a - b; cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a * b; cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a / b; cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a % b; cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; int d = 10; // 测试自增、自减 c = d++; cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; d = 10; // 重新赋值 c = d--; cout \u003c\u003c \"Line 7 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 31 Line 2 - c 的值是 11 Line 3 - c 的值是 210 Line 4 - c 的值是 2 Line 5 - c 的值是 1 Line 6 - c 的值是 10 Line 7 - c 的值是 10 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"关系运算符 下表显示了 C++ 支持的关系运算符。 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 #实例 请看下面的实例，了解 C++ 中可用的关系运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int b = 10; int c ; if( a == b ) { cout \u003c\u003c \"Line 1 - a 等于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 1 - a 不等于 b\" \u003c\u003c endl ; } if ( a \u003c b ) { cout \u003c\u003c \"Line 2 - a 小于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 2 - a 不小于 b\" \u003c\u003c endl ; } if ( a \u003e b ) { cout \u003c\u003c \"Line 3 - a 大于 b\" \u003c\u003c endl ; } else { cout \u003c\u003c \"Line 3 - a 不大于 b\" \u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 5; b = 20; if ( a \u003c= b ) { cout \u003c\u003c \"Line 4 - a 小于或等于 b\" \u003c\u003c endl ; } if ( b \u003e= a ) { cout \u003c\u003c \"Line 5 - b 大于或等于 a\" \u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - a 不等于 b Line 2 - a 不小于 b Line 3 - a 大于 b Line 4 - a 小于或等于 b Line 5 - b 大于或等于 a ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"逻辑运算符 下表显示了 C++ 支持的关系逻辑运算符。 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A || B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 #实例 请看下面的实例，了解 C++ 中可用的逻辑运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 5; int b = 20; int c ; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 1 - 条件为真\"\u003c\u003c endl ; } if ( a || b ) { cout \u003c\u003c \"Line 2 - 条件为真\"\u003c\u003c endl ; } /* 改变 a 和 b 的值 */ a = 0; b = 10; if ( a \u0026\u0026 b ) { cout \u003c\u003c \"Line 3 - 条件为真\"\u003c\u003c endl ; } else { cout \u003c\u003c \"Line 4 - 条件不为真\"\u003c\u003c endl ; } if ( !(a \u0026\u0026 b) ) { cout \u003c\u003c \"Line 5 - 条件为真\"\u003c\u003c endl ; } return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - 条件为真 Line 2 - 条件为真 Line 4 - 条件不为真 Line 5 - 条件为真 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"位运算符 位运算符作用于位，并逐位执行操作。\u0026、 | 和 ^ 的真值表如下所示： p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 -—————- A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则：0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：`0 0=0; 0 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则：~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 » 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 #实例 请看下面的实例，了解 C++ 中可用的位运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { unsigned int a = 60; // 60 = 0011 1100 unsigned int b = 13; // 13 = 0000 1101 int c = 0; c = a \u0026 b; // 12 = 0000 1100 cout \u003c\u003c \"Line 1 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a | b; // 61 = 0011 1101 cout \u003c\u003c \"Line 2 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a ^ b; // 49 = 0011 0001 cout \u003c\u003c \"Line 3 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = ~a; // -61 = 1100 0011 cout \u003c\u003c \"Line 4 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003c\u003c 2; // 240 = 1111 0000 cout \u003c\u003c \"Line 5 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; c = a \u003e\u003e 2; // 15 = 0000 1111 cout \u003c\u003c \"Line 6 - c 的值是 \" \u003c\u003c c \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - c 的值是 12 Line 2 - c 的值是 61 Line 3 - c 的值是 49 Line 4 - c 的值是 -61 Line 5 - c 的值是 240 Line 6 - c 的值是 15 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"赋值运算符 下表列出了 C++ 支持的赋值运算符： 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 »= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C | 2 #实例 请看下面的实例，了解 C++ 中可用的赋值运算符。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 21; int c ; c = a; cout \u003c\u003c \"Line 1 - = 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c += a; cout \u003c\u003c \"Line 2 - += 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c -= a; cout \u003c\u003c \"Line 3 - -= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c *= a; cout \u003c\u003c \"Line 4 - *= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c /= a; cout \u003c\u003c \"Line 5 - /= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c = 200; c %= a; cout \u003c\u003c \"Line 6 - %= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003c\u003c= 2; cout \u003c\u003c \"Line 7 - \u003c\u003c= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u003e\u003e= 2; cout \u003c\u003c \"Line 8 - \u003e\u003e= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c \u0026= 2; cout \u003c\u003c \"Line 9 - \u0026= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c ^= 2; cout \u003c\u003c \"Line 10 - ^= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; c |= 2; cout \u003c\u003c \"Line 11 - |= 运算符实例，c 的值 = : \" \u003c\u003cc\u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： Line 1 - = 运算符实例，c 的值 = 21 Line 2 - += 运算符实例，c 的值 = 42 Line 3 - -= 运算符实例，c 的值 = 21 Line 4 - *= 运算符实例，c 的值 = 441 Line 5 - /= 运算符实例，c 的值 = 21 Line 6 - %= 运算符实例，c 的值 = 11 Line 7 - \u003c\u003c= 运算符实例，c 的值 = 44 Line 8 - \u003e\u003e= 运算符实例，c 的值 = 11 Line 9 - \u0026= 运算符实例，c 的值 = 2 Line 10 - ^= 运算符实例，c 的值 = 0 Line 11 - |= 运算符实例，c 的值 = 2 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"杂项运算符 下表列出了 C++ 支持的其他一些重要的运算符。 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 中的运算符优先级 运算符的优先级确定表达式中项的组合。这会影响到一个表达式如何计算。某些运算符比其他运算符有更高的优先级，例如，乘除运算符具有比加减运算符更高的优先级。 例如 x = 7 + 3 * 2，在这里，x 被赋值为 13，而不是 20，因为运算符 * 具有比 + 更高的优先级，所以首先计算乘法 3*2，然后再加上 7。 下表将按运算符优先级从高到低列出各个运算符，具有较高优先级的运算符出现在表格的上面，具有较低优先级的运算符出现在表格的下面。在表达式中，较高优先级的运算符会优先被计算。 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 #实例 请看下面的实例，了解 C++ 中运算符的优先级。 复制并黏贴下面的 C++ 程序到 test.cpp 文件中，编译并运行程序。 对比有括号和没有括号时的区别，这将产生不同的结果。因为 ()、 /、 * 和 + 有不同的优先级，高优先级的操作符将优先计算。 实例 #include \u003ciostream\u003eusing namespace std; int main() { int a = 20; int b = 10; int c = 15; int d = 5; int e; e = (a + b) * c / d; // ( 30 * 15 ) / 5 cout \u003c\u003c \"(a + b) * c / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = ((a + b) * c) / d; // (30 * 15 ) / 5 cout \u003c\u003c \"((a + b) * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = (a + b) * (c / d); // (30) * (15/5) cout \u003c\u003c \"(a + b) * (c / d) 的值是 \" \u003c\u003c e \u003c\u003c endl ; e = a + (b * c) / d; // 20 + (150/5) cout \u003c\u003c \"a + (b * c) / d 的值是 \" \u003c\u003c e \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生以下结果： (a + b) * c / d 的值是 90 ((a + b) * c) / d 的值是 90 (a + b) * (c / d) 的值是 90 a + (b * c) / d 的值是 50 ","date":"2021-08-17","objectID":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 12运算符","uri":"/2021/08/c-12%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["C++"],"content":"C++ 循环 有的时候，可能需要多次执行同一块代码。一般情况下，语句是顺序执行的：函数中的第一个语句先执行，接着是第二个语句，依此类推。 编程语言提供了允许更为复杂的执行路径的多种控制结构。 循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环类型 C++ 编程语言提供了以下几种循环类型。点击链接查看每个类型的细节。 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"循环控制语句 循环控制语句更改执行的正常序列。当执行离开一个范围时，所有在该范围中创建的自动对象都会被销毁。 C++ 提供了下列的控制语句。点击链接查看每个语句的细节。 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"无限循环 如果条件永远不为假，则循环将变成无限循环。for 循环在传统意义上可用于实现无限循环。由于构成循环的三个表达式中任何一个都不是必需的，您可以将某些条件表达式留空来构成一个无限循环。 实例 #include \u003ciostream\u003eusing namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } 当条件表达式不存在时，它被假设为真。您也可以设置一个初始值和增量表达式，但是一般情况下，C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 **注意：**您可以按 Ctrl + C 键终止一个无限循环。 ","date":"2021-08-17","objectID":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 13循环","uri":"/2021/08/c-13%E5%BE%AA%E7%8E%AF/"},{"categories":["C++"],"content":"C++ 判断 判断结构要求程序员指定一个或多个要评估或测试的条件，以及条件为真时要执行的语句（必需的）和条件为假时要执行的语句（可选的）。 下面是大多数编程语言中典型的判断结构的一般形式： ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"判断语句 C++ 编程语言提供了以下类型的判断语句。点击链接查看每个语句的细节。 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"? : 运算符 我们已经在前面的章节中讲解了 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; 其中，Exp1、Exp2 和 Exp3 是表达式。请注意，冒号的使用和位置。 ? 表达式的值是由 Exp1 决定的。如果 Exp1 为真，则计算 Exp2 的值，结果即为整个 ? 表达式的值。如果 Exp1 为假，则计算 Exp3 的值，结果即为整个 ? 表达式的值。 ","date":"2021-08-17","objectID":"/2021/08/c-14%E5%88%A4%E6%96%AD/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 14判断","uri":"/2021/08/c-14%E5%88%A4%E6%96%AD/"},{"categories":["C++"],"content":"C++ 函数 函数是一组一起执行一个任务的语句。每个 C++ 程序都至少有一个函数，即主函数 main() ，所有简单的程序都可以定义其他额外的函数。 您可以把代码划分到不同的函数中。如何划分代码到不同的函数中是由您来决定的，但在逻辑上，划分通常是根据每个函数执行一个特定的任务来进行的。 函数声明告诉编译器函数的名称、返回类型和参数。函数定义提供了函数的实际主体。 C++ 标准库提供了大量的程序可以调用的内置函数。例如，函数 strcat() 用来连接两个字符串，函数 memcpy() 用来复制内存到另一个位置。 函数还有很多叫法，比如方法、子例程或程序，等等。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"定义函数 C++ 中的函数定义的一般形式如下： return_type function_name( parameter list ) { body of the function } 在 C++ 中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分： **返回类型：**一个函数可以返回一个值。return_type 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 void。 **函数名称：**这是函数的实际名称。函数名和参数列表一起构成了函数签名。 **参数：**参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。 **函数主体：**函数主体包含一组定义函数执行任务的语句。 实例 以下是 max() 函数的源代码。该函数有两个参数 num1 和 num2，会返回这两个数中较大的那个数： // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数声明 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。 函数声明包括以下几个部分： return_type function_name( parameter list ); 针对上面定义的函数 max()，以下是函数声明： int max(int num1, int num2); 在函数声明中，参数的名称并不重要，只有参数的类型是必需的，因此下面也是有效的声明： int max(int, int); 当您在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。在这种情况下，您应该在调用函数的文件顶部声明函数。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"调用函数 创建 C++ 函数时，会定义函数做什么，然后通过调用函数来完成已定义的任务。 当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。 调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。例如： 实例 #include \u003ciostream\u003eusing namespace std; // 函数声明 int max(int num1, int num2); int main () { // 局部变量声明 int a = 100; int b = 200; int ret; // 调用函数来获取最大值 ret = max(a, b); cout \u003c\u003c \"Max value is : \" \u003c\u003c ret \u003c\u003c endl; return 0; } // 函数返回两个数中较大的那个数 int max(int num1, int num2) { // 局部变量声明 int result; if (num1 \u003e num2) result = num1; else result = num2; return result; } 把 max() 函数和 main() 函数放一块，编译源代码。当运行最后的可执行文件时，会产生下列结果： Max value is : 200 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"函数参数 如果函数要使用参数，则必须声明接受参数值的变量。这些变量称为函数的形式参数。 形式参数就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。 当调用函数时，有三种向函数传递参数的方式： 调用类型 描述 传值调用 该方法把参数的实际值赋值给函数的形式参数。在这种情况下，修改函数内的形式参数对实际参数没有影响。 指针调用 该方法把参数的地址赋值给形式参数。在函数内，该地址用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 引用调用 该方法把参数的引用赋值给形式参数。在函数内，该引用用于访问调用中要用到的实际参数。这意味着，修改形式参数会影响实际参数。 默认情况下，C++ 使用传值调用来传递参数。一般来说，这意味着函数内的代码不能改变用于调用函数的参数。之前提到的实例，调用 max() 函数时，使用了相同的方法。 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"参数的默认值 当您定义一个函数，您可以为参数列表中后边的每一个参数指定默认值。当调用函数时，如果实际参数的值留空，则使用这个默认值。 这是通过在函数定义中使用赋值运算符来为参数赋值的。调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int sum(int a, int b=20) { int result; result = a + b; return (result); } int main () { // 局部变量声明 int a = 100; int b = 200; int result; // 调用函数来添加值 result = sum(a, b); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; // 再次调用函数 result = sum(a); cout \u003c\u003c \"Total value is :\" \u003c\u003c result \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Total value is :300 Total value is :120 ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"Lambda 函数与表达式 C++11 提供了对匿名函数的支持,称为 Lambda 函数(也叫 Lambda 表达式)。 Lambda 表达式把函数看作对象。Lambda 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。 Lambda 表达式本质上与函数声明非常类似。Lambda 表达式具体形式如下: [capture](parameters)-\u003ereturn-type{body} 例如： [](int x, int y){ return x \u003c y ; } 如果没有返回值可以表示为： [capture](parameters){body} 例如： []{ ++global_x; } 在一个更为复杂的例子中，返回类型可以被明确的指定如下： [](int x, int y) -\u003e int { int z = x + y; return z + x; } 本例中，一个临时的参数 z 被创建用来存储中间结果。如同一般的函数，z 的值不会保留到下一次该不具名函数再次被调用时。 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。 在Lambda表达式内可以访问当前作用域的变量，这是Lambda表达式的闭包（Closure）行为。 与JavaScript闭包不同，C++变量传递有传值和传引用的区别。可以通过前面的[]来指定： [] // 沒有定义任何变量。使用未定义变量会引发错误。 [x, \u0026y] // x以传值方式传入（默认），y以引用方式传入。 [\u0026] // 任何被使用到的外部变量都隐式地以引用方式加以引用。 [=] // 任何被使用到的外部变量都隐式地以传值方式加以引用。 [\u0026, x] // x显式地以传值方式加以引用。其余变量以引用方式加以引用。 [=, \u0026z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。 另外有一点需要注意。对于[=]或[\u0026]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入： [this]() { this-\u003esomeFunc(); }(); ","date":"2021-08-17","objectID":"/2021/08/c-15%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 15函数","uri":"/2021/08/c-15%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"C++ 数字 通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 C++ 数据类型一章中讨论过。 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 定义数字 我们已经在之前章节的各种实例中定义过数字。下面是一个 C++ 中定义各种类型数字的综合实例： 实例 #include \u003ciostream\u003eusing namespace std; int main () { // 数字定义 short s; int i; long l; float f; double d; // 数字赋值 s = 10; i = 1000; l = 1000000; f = 230.47; d = 30949.374; // 数字输出 cout \u003c\u003c \"short s :\" \u003c\u003c s \u003c\u003c endl; cout \u003c\u003c \"int i :\" \u003c\u003c i \u003c\u003c endl; cout \u003c\u003c \"long l :\" \u003c\u003c l \u003c\u003c endl; cout \u003c\u003c \"float f :\" \u003c\u003c f \u003c\u003c endl; cout \u003c\u003c \"double d :\" \u003c\u003c d \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： short s :10 int i :1000 long l :1000000 float f :230.47 double d :30949.4 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数学运算 在 C++ 中，除了可以创建各种函数，还包含了各种有用的函数供您使用。这些函数写在标准 C 和 C++ 库中，叫做内置函数。您可以在程序中引用这些函数。 C++ 内置了丰富的数学函数，可对各种数字进行运算。下表列出了 C++ 中一些有用的内置的数学函数。 为了利用这些函数，您需要引用数学头文件 。 序号 函数 \u0026 描述 1 double cos(double); 该函数返回弧度角（double 型）的余弦。 2 double sin(double); 该函数返回弧度角（double 型）的正弦。 3 double tan(double); 该函数返回弧度角（double 型）的正切。 4 double log(double); 该函数返回参数的自然对数。 5 double pow(double, double); 假设第一个参数为 x，第二个参数为 y，则该函数返回 x 的 y 次方。 6 double hypot(double, double); 该函数返回两个参数的平方总和的平方根，也就是说，参数为一个直角三角形的两个直角边，函数会返回斜边的长度。 7 double sqrt(double); 该函数返回参数的平方根。 8 int abs(int); 该函数返回整数的绝对值。 9 double fabs(double); 该函数返回任意一个浮点数的绝对值。 10 double floor(double); 该函数返回一个小于或等于传入参数的最大整数。 下面是一个关于数学运算的简单实例： 实例 #include \u003ciostream\u003e#include \u003ccmath\u003eusing namespace std; int main () { // 数字定义 short s = 10; int i = -1000; long l = 100000; float f = 230.47; double d = 200.374; // 数学运算 cout \u003c\u003c \"sin(d) :\" \u003c\u003c sin(d) \u003c\u003c endl; cout \u003c\u003c \"abs(i) :\" \u003c\u003c abs(i) \u003c\u003c endl; cout \u003c\u003c \"floor(d) :\" \u003c\u003c floor(d) \u003c\u003c endl; cout \u003c\u003c \"sqrt(f) :\" \u003c\u003c sqrt(f) \u003c\u003c endl; cout \u003c\u003c \"pow( d, 2) :\" \u003c\u003c pow(d, 2) \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： sin(d) :-0.634939 abs(i) :1000 floor(d) :200 sqrt(f) :15.1812 pow( d, 2 ) :40149.7 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 随机数 在许多情况下，需要生成随机数。关于随机数生成器，有两个相关的函数。一个是 rand()，该函数只返回一个伪随机数。生成随机数之前必须先调用 srand() 函数。 下面是一个关于生成随机数的简单实例。实例中使用了 time() 函数来获取系统时间的秒数，通过调用 rand() 函数来生成随机数： 实例 #include \u003ciostream\u003e#include \u003cctime\u003e#include \u003ccstdlib\u003e using namespace std; int main () { int i,j; // 设置种子 srand( (unsigned)time( NULL ) ); /* 生成 10 个随机数 */ for( i = 0; i \u003c 10; i++ ) { // 生成实际的随机数 j= rand(); cout \u003c\u003c\"随机数： \" \u003c\u003c j \u003c\u003c endl; } return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 随机数： 1748144778 随机数： 630873888 随机数： 2134540646 随机数： 219404170 随机数： 902129458 随机数： 920445370 随机数： 1319072661 随机数： 257938873 随机数： 1256201101 随机数： 580322989 ","date":"2021-08-17","objectID":"/2021/08/c-16%E6%95%B0%E5%AD%97/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 16数字","uri":"/2021/08/c-16%E6%95%B0%E5%AD%97/"},{"categories":["C++"],"content":"C++ 数组 C++ 支持数组数据结构，它可以存储一个固定大小的相同类型元素的顺序集合。数组是用来存储一系列数据，但它往往被认为是一系列相同类型的变量。 数组的声明并不是声明一个个单独的变量，比如 number0、number1、…、number99，而是声明一个数组变量，比如 numbers，然后使用 numbers[0]、numbers[1]、…、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。 所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"声明数组 在 C++ 中要声明一个数组，需要指定元素的类型和元素的数量，如下所示： type arrayName [ arraySize ]; 这叫做一维数组。arraySize 必须是一个大于零的整数常量，type 可以是任意有效的 C++ 数据类型。例如，要声明一个类型为 double 的包含 10 个元素的数组 balance，声明语句如下： double balance[10]; 现在 balance 是一个可用的数组，可以容纳 10 个类型为 double 的数字。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"初始化数组 在 C++ 中，您可以逐个初始化数组，也可以使用一个初始化语句，如下所示： double balance[5] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。 如果您省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果： double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0}; 您将创建一个数组，它与前一个实例中所创建的数组是完全相同的。下面是一个为数组中某个元素赋值的实例： balance[4] = 50.0; 上述的语句把数组中第五个元素的值赋为 50.0。所有的数组都是以 0 作为它们第一个元素的索引，也被称为基索引，数组的最后一个索引是数组的总大小减去 1。以下是上面所讨论的数组的的图形表示： ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"访问数组元素 数组元素可以通过数组名称加索引进行访问。元素的索引是放在方括号内，跟在数组名称的后边。例如： double salary = balance[9]; 上面的语句将把数组中第 10 个元素的值赋给 salary 变量。下面的实例使用了上述的三个概念，即，声明数组、数组赋值、访问数组： 实例 #include \u003ciostream\u003eusing namespace std; #include \u003ciomanip\u003eusing std::setw; int main () { int n[ 10 ]; // n 是一个包含 10 个整数的数组 // 初始化数组元素 for ( int i = 0; i \u003c 10; i++ ) { n[ i ] = i + 100; // 设置元素 i 为 i + 100 } cout \u003c\u003c \"Element\" \u003c\u003c setw( 13 ) \u003c\u003c \"Value\" \u003c\u003c endl; // 输出数组中每个元素的值 for ( int j = 0; j \u003c 10; j++ ) { cout \u003c\u003c setw( 7 )\u003c\u003c j \u003c\u003c setw( 13 ) \u003c\u003c n[ j ] \u003c\u003c endl; } return 0; } 上面的程序使用了 setw() 函数 来格式化输出。当上面的代码被编译和执行时，它会产生下列结果： Element Value 0 100 1 101 2 102 3 103 4 104 5 105 6 106 7 107 8 108 9 109 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 中数组详解 在 C++ 中，数组是非常重要的，我们需要了解更多有关数组的细节。下面列出了 C++ 程序员必须清楚的一些与数组相关的重要概念： 概念 描述 多维数组 C++ 支持多维数组。多维数组最简单的形式是二维数组。 指向数组的指针 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 传递数组给函数 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 从函数返回数组 C++ 允许从函数返回数组。 ","date":"2021-08-17","objectID":"/2021/08/c-17%E6%95%B0%E7%BB%84/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 17数组","uri":"/2021/08/c-17%E6%95%B0%E7%BB%84/"},{"categories":["C++"],"content":"C++ 变量类型 变量其实只不过是程序可操作的存储区的名称。C++ 中每个变量都有指定的类型，类型决定了变量存储的大小和布局，该范围内的值都可以存储在内存中，运算符可应用于变量上。 变量的名称可以由字母、数字和下划线字符组成。它必须以字母或下划线开头。大写字母和小写字母是不同的，因为 C++ 是大小写敏感的。 基于前一章讲解的基本类型，有以下几种基本的变量类型，将在下一章中进行讲解： 类型 描述 bool 存储值 true 或 false。 char 通常是一个字符（八位）。这是一个整数类型。 int 对机器而言，整数的最自然的大小。 float 单精度浮点值。单精度是这样的格式，1位符号，8位指数，23位小数。 double 双精度浮点值。双精度是1位符号，11位指数，52位小数。 void 表示类型的缺失。 wchar_t 宽字符类型。 C++ 也允许定义各种其他类型的变量，比如枚举、指针、数组、引用、数据结构、类等等，这将会在后续的章节中进行讲解。 下面我们将讲解如何定义、声明和使用各种类型的变量。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量定义 变量定义就是告诉编译器在何处创建变量的存储，以及如何创建变量的存储。 变量定义指定一个数据类型，并包含了该类型的一个或多个变量的列表，如下所示： type variable_list; 在这里，type 必须是一个有效的 C++ 数据类型，可以是 char、wchar_t、int、float、double、bool 或任何用户自定义的对象，variable_list 可以由一个或多个标识符名称组成，多个标识符之间用逗号分隔。下面列出几个有效的声明： int i, j, k; char c, ch; float f, salary; double d; 行 int i, j, k; 声明并定义了变量 i、j 和 k，这指示编译器创建类型为 int 的名为 i、j、k 的变量。 变量可以在声明的时候被初始化（指定一个初始值）。初始化器由一个等号，后跟一个常量表达式组成，如下所示： type variable_name = value; 下面列举几个实例： extern int d = 3, f = 5; // d 和 f 的声明 int d = 3, f = 5; // 定义并初始化 d 和 f byte z = 22; // 定义并初始化 z char x = 'x'; // 变量 x 的值为 'x' 不带初始化的定义：带有静态存储持续时间的变量会被隐式初始化为 NULL（所有字节的值都是 0），其他所有变量的初始值是未定义的。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的变量声明 变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。 当您使用多个文件且只在其中一个文件中定义变量时（定义变量的文件在程序连接时是可用的），变量声明就显得非常有用。您可以使用 extern 关键字在任何地方声明一个变量。虽然您可以在 C++ 程序中多次声明一个变量，但变量只能在某个文件、函数或代码块中被定义一次。 ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 尝试下面的实例，其中，变量在头部就已经被声明，但它们是在主函数内被定义和初始化的： #include \u003ciostream\u003eusing namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 30 23.3333 同样的，在函数声明时，提供一个函数名，而函数的实际定义则可以在任何地方进行。例如： // 函数声明 int func(); int main() { // 函数调用 int i = func(); } // 函数定义 int func() { return 0; } ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:2:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的左值（Lvalues）和右值（Rvalues） C++ 中有两种类型的表达式： **左值（lvalue）：**指向内存位置的表达式被称为左值（lvalue）表达式。左值可以出现在赋值号的左边或右边。 **右值（rvalue）：**术语右值（rvalue）指的是存储在内存中某些地址的数值。右值是不能对其进行赋值的表达式，也就是说，右值可以出现在赋值号的右边，但不能出现在赋值号的左边。 变量是左值，因此可以出现在赋值号的左边。数值型的字面值是右值，因此不能被赋值，不能出现在赋值号的左边。下面是一个有效的语句： int g = 20; 但是下面这个就不是一个有效的语句，会生成编译时错误： 10 = 20; ","date":"2021-08-16","objectID":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 07变量类型","uri":"/2021/08/c-07%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++教程","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 数据类型 使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当您创建一个变量时，就会在内存中保留一些空间。 您可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"基本的内置类型 C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型： 类型 关键字 布尔型 bool 字符型 char 整型 int 浮点型 float 双浮点型 double 无类型 void 宽字符型 wchar_t 其实 wchar_t 是这样来的： typedef short int wchar_t; 所以 wchar_t 实际上的空间是和 short int 一样。 一些基本类型可以使用一个或多个类型修饰符进行修饰： signed unsigned short long 下表显示了各种变量类型在内存中存储值时需要占用的内存，以及该类型的变量所能存储的最大值和最小值。 **注意：**不同系统会有所差异，一字节为 8 位。 **注意：**long int 8 个字节，int 都是 4 个字节，早期的 C 编译器定义了 long int 占用 4 个字节，int 占用 2 个字节，新版的 C/C++ 标准兼容了早期的这一设定。 类型 位 范围 char 1 个字节 -128 到 127 或者 0 到 255 unsigned char 1 个字节 0 到 255 signed char 1 个字节 -128 到 127 int 4 个字节 -2147483648 到 2147483647 unsigned int 4 个字节 0 到 4294967295 signed int 4 个字节 -2147483648 到 2147483647 short int 2 个字节 -32768 到 32767 unsigned short int 2 个字节 0 到 65,535 signed short int 2 个字节 -32768 到 32767 long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 signed long int 8 个字节 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 unsigned long int 8 个字节 0 到 18,446,744,073,709,551,615 float 4 个字节 精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字) double 8 个字节 双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字) long double 16 个字节 长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。 wchar_t 2 或 4 个字节 1 个宽字符 从上表可得知，变量的大小会根据编译器和所使用的电脑而有所不同。 下面实例会输出您电脑上各种数据类型的大小。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"实例 #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } 实例使用了 endl，这将在每一行后插入一个换行符，« 运算符用于向屏幕传多个值，sizeof() 函数用来获取各种数据类型的大小。 当上面的代码被编译和执行时，它会产生以下的结果，结果会根据所使用的计算机而有所不同： type: ************size************** bool: 所占字节数：1 最大值：1 最小值：0 char: 所占字节数：1 最大值： 最小值：? signed char: 所占字节数：1 最大值： 最小值：? unsigned char: 所占字节数：1 最大值：? 最小值： wchar_t: 所占字节数：4 最大值：2147483647 最小值：-2147483648 short: 所占字节数：2 最大值：32767 最小值：-32768 int: 所占字节数：4 最大值：2147483647 最小值：-2147483648 unsigned: 所占字节数：4 最大值：4294967295 最小值：0 long: 所占字节数：8 最大值：9223372036854775807 最小值：-9223372036854775808 unsigned long: 所占字节数：8 最大值：18446744073709551615 最小值：0 double: 所占字节数：8 最大值：1.79769e+308 最小值：2.22507e-308 long double: 所占字节数：16 最大值：1.18973e+4932 最小值：3.3621e-4932 float: 所占字节数：4 最大值：3.40282e+38 最小值：1.17549e-38 size_t: 所占字节数：8 最大值：18446744073709551615 最小值：0 string: 所占字节数：24 type: ************size************** ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"typedef 声明 您可以使用 typedef 为一个已有的类型取一个新的名字。下面是使用 typedef 定义一个新类型的语法： typedef type newname; 例如，下面的语句会告诉编译器，feet 是 int 的另一个名称： typedef int feet; 现在，下面的声明是完全合法的，它创建了一个整型变量 distance： feet distance; ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"枚举类型 枚举类型(enumeration)是C++中的一种派生数据类型，它是由用户定义的若干枚举常量的集合。 如果一个变量只有几种可能的值，可以定义为枚举(enumeration)类型。所谓\"枚举\"是指将变量的值一一列举出来，变量的值只能在列举出来的值的范围内。 创建枚举，需要使用关键字 enum。枚举类型的一般形式为： enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; 如果枚举没有初始化, 即省掉\"=整型常数\"时, 则从第一个标识符开始。 例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 “blue”。 enum color { red, green, blue } c; c = blue; 默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，green 的值为 5。 enum color { red, green=5, blue }; 在这里，blue 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1，但 red 的值依然为 0。 ","date":"2021-08-10","objectID":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 06数据类型","uri":"/2021/08/c-06%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 常量 常量是固定值，在程序执行期间不会改变。这些固定的值，又叫做字面量。 常量可以是任何的基本数据类型，可分为整型数字、浮点数字、字符、字符串和布尔值。 常量就像是常规的变量，只不过常量的值在定义后不能进行修改。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"整数常量 整数常量可以是十进制、八进制或十六进制的常量。前缀指定基数：0x 或 0X 表示十六进制，0 表示八进制，不带前缀则默认表示十进制。 整数常量也可以带一个后缀，后缀是 U 和 L 的组合，U 表示无符号整数（unsigned），L 表示长整数（long）。后缀可以是大写，也可以是小写，U 和 L 的顺序任意。 下面列举几个整数常量的实例： 212 // 合法的 215u // 合法的 0xFeeL // 合法的 078 // 非法的：8 不是八进制的数字 032UU // 非法的：不能重复后缀 以下是各种类型的整数常量的实例： 85 // 十进制 0213 // 八进制 0x4b // 十六进制 30 // 整数 30u // 无符号整数 30l // 长整数 30ul // 无符号长整数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"浮点常量 浮点常量由整数部分、小数点、小数部分和指数部分组成。您可以使用小数形式或者指数形式来表示浮点常量。 当使用小数形式表示时，必须包含整数部分、小数部分，或同时包含两者。当使用指数形式表示时， 必须包含小数点、指数，或同时包含两者。带符号的指数是用 e 或 E 引入的。 下面列举几个浮点常量的实例： 3.14159 // 合法的 314159E-5L // 合法的 510E // 非法的：不完整的指数 210f // 非法的：没有小数或指数 .e55 // 非法的：缺少整数或分数 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"布尔常量 布尔常量共有两个，它们都是标准的 C++ 关键字： true 值代表真。 false 值代表假。 我们不应把 true 的值看成 1，把 false 的值看成 0。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符常量 字符常量是括在单引号中。如果常量以 L（仅当大写时）开头，则表示它是一个宽字符常量（例如 L’x'），此时它必须存储在 wchar_t 类型的变量中。否则，它就是一个窄字符常量（例如 ‘x’），此时它可以存储在 char 类型的简单变量中。 字符常量可以是一个普通的字符（例如 ‘x’）、一个转义序列（例如 ‘\\t’），或一个通用的字符（例如 ‘\\u02C0’）。 在 C++ 中，有一些特定的字符，当它们前面有反斜杠时，它们就具有特殊的含义，被用来表示如换行符（\\n）或制表符（\\t）等。下表列出了一些这样的转义序列码： 转义序列 含义 \\ \\ 字符 ' ' 字符 \" \" 字符 ? ? 字符 \\a 警报铃声 \\b 退格键 \\f 换页符 \\n 换行符 \\r 回车 \\t 水平制表符 \\v 垂直制表符 \\ooo 一到三位的八进制数 \\xhh . . . 一个或多个数字的十六进制数 下面的实例显示了一些转义序列字符： 实例 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello\\tWorld\\n\\n\"; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Hello World ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"字符串常量 字符串字面值或常量是括在双引号 \"\" 中的。一个字符串包含类似于字符常量的字符：普通的字符、转义序列和通用的字符。 您可以使用 ** 做分隔符，把一个很长的字符串常量进行分行。 下面的实例显示了一些字符串常量： 实例 #include \u003ciostream\u003e#include \u003cstring\u003eusing namespace std; int main() { string greeting = \"hello, runoob\"; cout \u003c\u003c greeting; cout \u003c\u003c \"\\n\"; // 换行符 string greeting2 = \"hello, \\ runoob\"; cout \u003c\u003c greeting; return 0; } hello, runoob hello, runoob ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"定义常量 在 C++ 中，有两种简单的定义常量的方式： 使用 #define 预处理器。 使用 const 关键字。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"#define 预处理器 下面是使用 #define 预处理器定义常量的形式： #define identifier value 具体请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; #define LENGTH 10 #define WIDTH 5 #define NEWLINE '\\n' int main() { int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"const 关键字 您可以使用 const 前缀声明指定类型的常量，如下所示： const type variable = value; 具体请看下面的实例： 实例 #include \u003ciostream\u003eusing namespace std; int main() { const int LENGTH = 10; const int WIDTH = 5; const char NEWLINE = '\\n'; int area; area = LENGTH * WIDTH; cout \u003c\u003c area; cout \u003c\u003c NEWLINE; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 50 请注意，把常量定义为大写字母形式，是一个很好的编程实践。 ","date":"2021-08-10","objectID":"/2021/08/c-09%E5%B8%B8%E9%87%8F/:8:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 09常量","uri":"/2021/08/c-09%E5%B8%B8%E9%87%8F/"},{"categories":["C++"],"content":"C++ 修饰符类型 C++ 允许在 char、int 和 double 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。 下面列出了数据类型修饰符： signed unsigned long short 修饰符 signed、unsigned、long 和 short 可应用于整型，signed 和 unsigned 可应用于字符型，long 可应用于双精度型。 修饰符 signed 和 unsigned 也可以作为 long 或 short 修饰符的前缀。例如：unsigned long int。 C++ 允许使用速记符号来声明无符号短整数或无符号长整数。您可以不写 int，只写单词 unsigned、short 或 unsigned、long，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。 unsigned x; unsigned int y; 为了理解 C++ 解释有符号整数和无符号整数修饰符之间的差别，我们来运行一下下面这个短程序： 实例 #include \u003ciostream\u003eusing namespace std; /* * 这个程序演示了有符号整数和无符号整数之间的差别 */ int main() { short int i; // 有符号短整数 short unsigned int j; // 无符号短整数 j = 50000; i = j; cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c j; return 0; } 当上面的程序运行时，会输出下列结果： -15536 50000 上述结果中，无符号短整数 50,000 的位模式被解释为有符号短整数 -15,536。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-10","objectID":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 10修饰符类型","uri":"/2021/08/c-10%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"},{"categories":["C++"],"content":"C++ 教程 C++ 是一种中级语言，它是由 Bjarne Stroustrup 于 1979 年在贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，是一种面向对象的程序设计语言。C++ 可运行于多种平台上，如 Windows、MAC 操作系统以及 UNIX 的各种版本。 本教程通过通俗易懂的语言来讲解 C++ 编程语言。 现在开始学习 C++ 编程！ C++ 在线工具 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"谁适合阅读本教程？ 本教程是专门为初学者打造的，帮助他们理解与 C++ 编程语言相关的基础到高级的概念。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"阅读本教程前，您需要了解的知识： 在您开始练习本教程中所给出的各种实例之前，您需要对计算机程序和计算机程序设计语言有基本的了解。 ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"编译/执行 C++ 程序 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 运行实例 » 你可以用 \"\\n\" 代替以上代码里的 endl。 实例 #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c \"\\n\"; return 0; } ","date":"2021-08-08","objectID":"/2021/08/c-01%E6%95%99%E7%A8%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 01教程","uri":"/2021/08/c-01%E6%95%99%E7%A8%8B/"},{"categories":["Mermaid"],"content":"GitHub","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":["Mermaid"],"content":"Mermaid之流程图语法 ","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":["Mermaid"],"content":"可能的形状有: ([])体育场形 表示开始/结束 []矩形/()圆角矩形 表示流程(一些特定的操作) [[]]表示子流程 [()]圆柱体 表示数据库 (())圆形 表示页面内引用(指示流程在同一页面上其他位置包含相同字母的匹配符号上继续进行) \u003e]不规则形状 {}菱形 表示判断 {{}}六角形 表示预备流程/初始化 ///\\平行四边形 表示数据(输入数据(参数)/输出数据(结果)) ///梯形 表示人工操作(只能人为进行的操作) graph LR A([开始])--\u003eA1([结束]) B[流程]--- C(流程)--- D[[子流程]]--- E[(数据库)] F((页面引用))--- G\u003e不规则形状]--- H{条件判断}--- I{{初始化}} J[/输入/出/]--- K[\\输入/出\\]--- L[/人为操作\\]--- M[\\人为操作/] ","date":"2021-10-03","objectID":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Mermaid"],"title":"Mermaid之流程图语法","uri":"/2021/10/mermaid%E4%B9%8B%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"Quick setup — if you’ve done this kind of thing before Set up in Desktop or HTTPS https://github.com/xinqinew/NewCode.git SSH git@github.com:xinqinew/NewCode.git Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore. ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:1","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"在命令行上创建新的存储库 echo \"# NewCode\" \u003e\u003e README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin git@github.com:xinqinew/NewCode.git git push -u origin main ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:2","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"从命令行推出现有存储库 git remote add origin git@github.com:xinqinew/NewCode.git git branch -M main git push -u origin main ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:3","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"从另一个存储库中导入代码 You can initialize this repository with code from a Subversion, Mercurial, or TFS project. Import code ","date":"2021-09-07","objectID":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/:0:4","series":null,"tags":null,"title":"GitHub官方git代码","uri":"/2021/09/github%E5%AE%98%E6%96%B9git%E4%BB%A3%E7%A0%81/"},{"categories":null,"content":"GitHub不再支持密码验证解决方案：SSH免密与Token登录配置 今天提交代码，push到GitHub上，突然出现这个问题。 remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: unable to access ‘https://github.com/zhoulujun/algorithm.git/': The requested URL returned error: 403 官方的解释：https://github.blog/changelog/2021-08-12-git-password-authentication-is-shutting-down/ As previously announced, starting on August 13, 2021, at 09:00 PST, we will no longer accept account passwords when authenticating Git operations on GitHub.com. Instead, token-based authentication (for example, personal access, OAuth, SSH Key, or GitHub App installation token) will be required for all authenticated Git operations. Please refer to this blog post for instructions on what you need to do to continue using git operations securely. Removal August 13, 2021, at 09:00 PST 大致意思是，密码验证于2021年8月13日不再支持，也就是今天intellij不能再用密码方式去提交代码。请用使用 personal access token 替代。 这个去年年底就说了，https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ In July 2020, we announced our intent to require the use of token-based authentication (for example, a personal access, OAuth, or GitHub App installation token) for all authenticated Git operations. Beginning August 13, 2021, we will no longer accept account passwords when authenticating Git operations on GitHub.com. 自己鼓捣了一遍 Token，烦人的很。还是觉得直接ssh 的方式操作git就好(之前是ssh的源，也没有这个问题)。 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:0:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"github配置SSH免密登录 这里讲的是Mac OS 操作。windows可以借鉴 查看ssh目录 ls -al ~/.ssh Mac OS目录~/.ssh，windows目录是： Users/uestc/.ssh/id_rsa -如果有配过，会列出： id_rsa (私钥)——这个不能泄露 id_rsa.pub（公钥） -如果没有配过，那么就进入第二步 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"新建一个新的SSH KEY ssh-keygen -t rsa -b 4096 -C \"uestchan@sina.com\" 接着会提示这个公钥私钥的保存路径-建议直接回车就好（默认目录里) 接着提示输入私钥密码passphrase - 如果不想使用私钥登录的话，私钥密码为空，直接回车 生成成功后，把 id_rsa.pub 拷贝到 github 新建的 SSH keys 中 配置好好，记住，你项目得使用 SSH clone 如果本地是https 源，那么就修改git 仓库地址 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:1","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"git修改远程仓库地址 方法有三种： 1.修改命令 git remote origin set-url [url] 先删后加 git remote rm origin git remote add origin [url] 直接修改config文件 git文件夹，找到config，编辑，把就的项目地址替换成新的。 顺手安利下 《git宝典—应付日常工作使用足够的指北手册》 关于github 建议让换 Token的形势，操作如下 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:2","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"GitHub token 打开自己的GitHub主页，点击自己的头像找到Settings并进入，在左边目录栏找到Personal access tokens，点击Generate new token，按照步骤申请即可，过程简单。Scopes（范围）那里建议全选。 Token申请成功后，将Token复制到Token一栏中 操作路径： 生成新的token就好。权限我是全部勾选上的。 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:1:3","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"Intellij IDEA 上Github账号校验 ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:0","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"配置Git路径 打开Settings（File–\u003eSettings） –\u003e 在搜索栏内输入git，回车跳转到Git配置页面 –\u003e 将git的运行路径填入Path to Git executable一栏（一般IDEA会自动定位） ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:1","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"配置GitHub账户密码 第一种方法可以选择使用帐号密码认证（Password） 之前的老板是这样的 在Login一栏填入你GitHub的用户名 –\u003e Password那栏填入你GitHub的登录密码 现在新版本的，点击密码登录，会自动跳转到登录验证页面，在验证页面点击确定（我的密码是chrome记住的）。就自动登录 选择log width token，填入token就好 参考文章： github配置SSH免密登录 https://blog.csdn.net/qq_38163309/article/details/105335097 GIT免密登录神器 SSH KEY配置详解 https://blog.csdn.net/w15321271041/article/details/80535135 Intellij IDEA 使用GitHub+Git https://www.cnblogs.com/yysbolg/p/8566389.html Intellij IDEA 协同 Git 与 GitHub 进行开发使用 https://www.jianshu.com/p/ea1703adf5cc Github 生成token的方法 — IDEA 拉代码或push失败需要从新校验Token https://blog.csdn.net/SR02020/article/details/106882205 Intellij IDEA 协同 Git 与 GitHub 进行开发使用 https://www.jianshu.com/p/ea1703adf5cc ","date":"2021-08-25","objectID":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/:2:2","series":null,"tags":null,"title":"GitHub SSH免密与Token登录","uri":"/2021/08/github-ssh%E5%85%8D%E5%AF%86%E4%B8%8Etoken%E7%99%BB%E5%BD%95/"},{"categories":null,"content":"俺如何为 hugo-theme-even 提供 mermaid 支持 如上是一个利用 mermaid 绘制的 SVG 图形 ，相比于直接在某些软件绘制好再截图，显然利用 mermaid 绘图具备诸多优点： 网站保存的是带 mermaid 的 markdown 文件，不涉及到图片存储。存储占用小。 渲染出图是 SVG 格式，上面的文字可以直接拷贝。 网站数据传输时是使用 mermaid 源码，而不是图片，可以有效减少网站加载过程产生的流量耗费。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:0:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"如何为你的 Hugo 博客引入 mermaid 支持？ 贴士 虽然由于 even theme 更新过慢，似乎久已无更多维护，因此本站已经开始使用 LoveIt 作为主题。 但是对于 even theme 而言，本方法应当依旧适用。 对于这一点，俺可以说前人之述备矣。反手就是一堆参考资料： Diagrams in hugo with mermaid 拓展 Hugo 的 MarkDown 流程图 这些解决方案引入 mermaid 的方法简单素雅，这一套流程可以总结为： 在博客中加载 mermaidJS。具体方法有： 直接在一定会加载的 HTML 文件中引入 \u003cscript\u003e 标签，加载 mermaid。 在部分支持自定义 JavaScript 的主题中，引入 JavaScript 文件。 自定义 ShortCodes，依靠 ShortCodes 实现标签替换。 但是习惯了通过 typora 之类的 MarkDown 拓展编辑器，他们无一例外都支持按照如下风格进行渲染： ```mermaid ... 图表内容 ... ``` 能不能实现它，从而实现更加一颗赛艇的编辑体验呢？ 能的。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:1:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"实现原理 通过阅读 mermaid 的 API 咱们可以得知 mermaidAPI 渲染 mermaid 图形的大致流程： 上述的特定标签是指\u003cdiv class=\"mermaid\"\u003e的 HTML 标签。通过检查页面元素，咱们会发现如今的大部分博客将代码块渲染成如下式样： \u003cpre\u003e\u003ccode class=\"language-语言种类\"\u003e \u003c!-- code --\u003e \u003c/code\u003e\u003c/pre\u003e 也就是说咱们只需要找到形如： \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e \u003c!-- mermaid code --\u003e \u003c/code\u003e\u003c/pre\u003e 的代码块，并将其替换成\u003cdiv class=\"mermaid\"\u003e即可。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:2:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"在 even theme 中的实现 注意 注意： 下文中的 “/” 目录代表 even theme 项目的根目录而不是 *nix 文件系统的 root. 本博客使用的是 even theme. 但是俺相信参照本文在其他博客中进行实现也会大差不差。 俺在自己实现了此种风格之后即向 hugo-theme-even 提出了 PR，even theme 的用户应该可以在不久以后在新版本中得到 mermaid 支持。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:0","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"导入 mermaid.min.js 实现应当遵循原理的指示精神，首先咱们需要拥有 mermaid 库。通过观察源码猜测 even 主题在 /static/layouts/partials/scripts.html 中进行 JS 的载入。于是咱们向其中插入能够引入 mermaid 模块的 script 标签。（实际上只要是会被加载的 HTML 文件都可以插） 这个标签在 HTML 文件里随便找个地方插就完事了，如果完全不懂，建议怼到 HTML 文件末尾。 通过 CDN 导入 为了保持文章的时效性，俺不会直接提供该 script 标签，但是你可以在 jsdelivr.com 中找到你中意版本的 mermaid.min.js 并按下右边的 Copy HTML + SRI 按钮即可获得对应的标签。 通过本地文件导入 由于房间里的大象太大挡住了境外CDN的信号，所以你也可以选择本地文件。在网上找到你中意版本的 mermaid.min.js, 下载下来并放在 /static/lib/mermaid/ 目录下（没有就新建一个），这时可以得到对应的 script 标签如下： \u003cscript src=\"{{ \"lib/mermaid/mermaid.min.js\" | relURL }}\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e 本人对境外 CDN 在内地的稳定性持悲观态度，建议中国大陆用户使用此方法。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:1","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"替换 HTML 标签 观察 even 主题的源码，咱们可以在 /assets/js/ 目录下发现 main.js 和 even.js。在 even.js 中插入如下代码段： // 插到文件末尾完事了 Even.mermaid = function () { if (!window.mermaid) return; const blocks = document.querySelectorAll(\"pre code.language-mermaid\"); // change all \u003cpre\u003e\u003ccode mamaid\u003e tags to \u003cdiv class=\"mermaid\"\u003e // mermaid will handle the rest! for (let i = 0; i \u003c blocks.length; i++) { if (!window.hljs \u0026\u0026 i % 2 === 0) continue; const block = blocks[i]; const rootElement = window.hljs ? block.parentElement : block.parentElement.parentElement.parentElement.parentElement .parentElement.parentElement.parentElement; var container = document.createElement(\"div\"); const id = `js-mermaid-diagrams-${i}`; container.id = id; container.className = \"align-center mermaid\"; container.textContent = block.childNodes[0].textContent; rootElement.parentElement.replaceChild(container, rootElement); } window.mermaid.mermaidAPI.initialize( window.mermaidOptions ? window.mermaidOptions : { securityLevel: \"loose\", theme: \"base\" } // 替换它可以修改 mermaid 的样式=======↑ ); }; 在 main.js 中插入： // 个人比较喜欢插在 Even.sequence(); 的后面 Even.mermaid(); 现在你应该可以在自己的博客中写 mermaid 了。 ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:2","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"工具推荐 Typora 写 MarkDown 咋能少得了 「Typora」？ Visual Studio Code 俺写这篇文章用的无所不能的编辑器，建议添加插件： Markdown All in One Markdown Preview Enhanced Mermaid Markdown Syntax Highlighting 之所以用 Visual Studio Code，很大程度上是因为它的 Vim 拓展。 “2021年了不会还有人不会用 Vim 吧？” vim ","date":"2021-08-19","objectID":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/:3:3","series":null,"tags":null,"title":"even 提供 mermaid","uri":"/2021/08/even-%E6%8F%90%E4%BE%9B-mermaid/"},{"categories":null,"content":"GitHub","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"好好配置了一下Hugo ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:0:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":" 换了个新的主题，原来的主题有Bug。 重新配置了MathJax和mermaid，原本随便弄的那个用不了了。 给旧文章换了标题 给文章打了tags 中文文章要设置isCJKLanguage=true不然字数是错的 重新写了部署脚本 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:1:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"换主题 之前用的主题叫hugo_theme_pickles，研究了下发现bug非常严重。它对主页的渲染就存在很大的问题，文章不会显示在主页上。遂尝试更新。更新之后问题更大了，除了Posts菜单下的文章都显示不出来了。而且看了一眼那个项目的提交历史也是非常混乱…… 去Hugo主题页找主题咯，最后发现自己还是喜欢Hermit这种简约的风格。 有些主题会让你把它加到你Git储存库的submodules，说是方便你升级。其实这个东西加上去很容易，要删就麻烦了 添加只要一个命令： git submodule add \u003curl\u003e \u003cpath\u003e Copy 删要手动删： # https://blog.csdn.net/guotianqing/article/details/82391665 rm -rf #子模块目录 删除子模块目录及源码 vi .gitmodules #删除项目目录下.gitmodules文件中子模块相关条目 vi .git/config #删除配置项中子模块相关条目 rm .git/module/* #删除模块下的子模块目录，注意只删除对应的子模块目录即可 Copy ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:2:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"重新配置MathJax和mermaid MathJax是用来渲染数学公式的，mermaid是用来渲染图表的。Hugo升级之后不给我直接在Markdown里嵌HTML了，然后就探索了一下到底应该怎么弄 配置这两个东西主要要把\u003cscript\u003e标签加到页面里，所以要在/layouts/partials目录下创建一个自定义的页面头模版。 {{ if .Params.usemermaid}} \u003cscript src=\"/mermaid.min.js\"\u003e\u003c/script\u003e \u003cscript\u003e window.onload = function () { mermaid.initialize({ theme: \"dark\" }) mermaid.init(undefined, \".language-mermaid\"); }; \u003c/script\u003e {{ end }} {{ if .Params.usemathjax }} \u003cscript src='/MathJax.js' async\u003e\u003c/script\u003e {{ end }} 用模版的语法判断当前页面是否启用了MathJax或者mermaid支持，只有当在文章开头的Front Matter里面显式地注明usemathjax: true和usemermaid: true，才为当前页面引入相应的.js。 网上有种配置mermaid的方法要用到shortcodes，但是那种用起来麻烦。我这种的话直接在Markdown里定义一个语言类型为mermaid的代码块就能渲染出图表了 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用mermaid ```mermaid graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ``` graph LR A[Hard edge] --\u003e|Link text| B(Round edge) B --\u003e C{Decision} C --\u003e|One| D[Result one] C --\u003e|Two| E[Result two] ps: 在代码块里嵌入要用到零宽字符\\u200b` ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:1","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用MathJax 在文章里写\\\\( \\\\LaTeX \\\\) 会被Markdown转义为\\( \\LaTeX \\) 经过MathJax处理输出LATEXLATEX ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:3:2","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"给文章换标题 要有一个好标题才能吸引读者吧哈哈哈 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:4:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"打标签tags 直接在Front Matter里面写tags: [\"tag1\", \"tag2\"]就好了，Hugo会自动分类 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:5:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"重新写了部署脚本 我之前自己写的用的是笨办法，是先tar打包，然后scp传上服务器，再在服务端解压，所以每次都要传输全部的数据。 直到我今天看的Hugo介绍的部署方法，用rsync可以实现增量同步 ","date":"2021-08-19","objectID":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/:6:0","series":null,"tags":null,"title":"Hugo mermaid替换","uri":"/2021/08/hugo-mermaid%E6%9B%BF%E6%8D%A2/"},{"categories":null,"content":"使用Mermaid在hugo的Markdown中绘制UML ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:0:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"简介 ¶ Mermaid是一个提供绘图功能的JavaScript项目。 它目前（8.6.4）支持： 流程图——Flowchat 顺序图——Sequence Diagram 类图——Class Diagram 状态图——State Diagram 甘特图——Gantt 饼图——Pie 实体关系图——Entity Relationship Diagram 用户行程图——User Journey Diagram ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:1:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"使用 ¶ 在Markdown中，使用Mermaid十分简单。 ```mermaid graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; ``` 写出以上代码块，就可以在网页渲染时，自动变成以下的svg图。 graph TD; A--\u003eB; A--\u003eC; B--\u003eD; C--\u003eD; 本文不对如何用它表达思想，做过多描述，详见官网文档。 此外，还可在其在线编辑器直接试用：mermaid-live-editor 以下介绍如何配置使用。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:2:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"配置 ¶ 在GitLab等平台中，内置了Mermaid，只是版本不是最新。 想要使用，直接写就好。 在自己的hugo网站中，则需要在head.html这类的模板中，配置一番。 确保在最后的网页中，在恰当的位置包含以下要素。 \u003chead\u003e ... \u003cscript async src=\"https://cdn.staticfile.org/mermaid/8.6.4/mermaid.min.js\"\u003e\u003c/script\u003e \u003c/head\u003e \u003cbody\u003e ... \u003cscript\u003e // Replace mermaid pre.code to div Array.from(document.getElementsByClassName('language-mermaid')).forEach(el =\u003e { el.parentElement.outerHTML = `\u003cdiv class=\"mermaid\"\u003e${el.innerText}\u003c/div\u003e` }) \u003c/script\u003e \u003cstyle\u003e /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u003c/style\u003e \u003c/body\u003e 其中，\u003chead\u003e部分是引入mermaid.js。 这里使用的是staticfile.org作为CDN，可按需替换。 在\u003cbody\u003e的最后，需要加上\u003cscript\u003e这段，用处是替换mermaid代码块为\u003cdiv\u003e，确保mermaid.js开始工作。 如果没有这段\u003cscript\u003e，把````mermaid写成`也是能用的，但不够优雅。 最后的\u003cstyle\u003e则是让svg居中显示。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:3:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"另一种配置 ¶ 以下是本站一次更新后的配置。 除了CDN使用jsdelivr、版本更新为8.8.2以外，主要改动是在Hugo模板中添加了if。 {{ if .Params.mermaid }}\u003cscript src=\"https://cdn.jsdelivr.net/npm/mermaid@8.8.2/dist/mermaid.min.js\" integrity=\"sha256-KqisLh8jVMBRjpNkOhH5W9VWs+F6x6vQksLqxs7+x9A=\" crossorigin=\"anonymous\" \u003e\u003c/script\u003e \u003cscript\u003e // Replace mermaid pre.code to div Array.from(document.getElementsByClassName(\"language-mermaid\")).forEach( (el) =\u003e { el.parentElement.outerHTML = `\u003cdiv class=\"mermaid\"\u003e${el.innerText}\u003c/div\u003e`; } ); \u003c/script\u003e \u003cstyle\u003e /* Set svg to center */ .mermaid svg { display: block; margin: auto; } \u003c/style\u003e {{ end }} 额外加上了.Params.mermaid的检查，避免所有页面都需要加载它。 在需要使用的Hugo页面，可以在Front Matter中添加一个配置，显式指定使用Mermaid。 以下为TOML形式的示例： +++ ... mermaid = true +++ ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:4:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":null,"content":"结语 ¶ 用好Mermaid，可以让Markdown的表现力增色不少。 以后，本站也会更多地使用它来做更好的表达。 ","date":"2021-08-19","objectID":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/:5:0","series":null,"tags":null,"title":"使用Mermaid在hugo的Markdown中绘制UML","uri":"/2021/08/%E4%BD%BF%E7%94%A8mermaid%E5%9C%A8hugo%E7%9A%84markdown%E4%B8%AD%E7%BB%98%E5%88%B6uml/"},{"categories":["C++"],"content":"C++ 简介 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 **注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"面向对象程序设计 C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性： 封装 抽象 继承 多态 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准库 标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"ANSI 标准 ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。 由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"学习 C++ 学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。 学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。 C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"C++ 的使用 基本上每个应用程序领域的程序员都有使用 C++。 C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。 C++ 广泛用于教学和研究。 任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"标准化 发布时间 通称 备注 2017 C++17 第五个C++标准 2017 coroutines TS 协程库扩展 2017 ranges TS 提供范围机制 2017 library fundamentals TS 标准库扩展 2016 concurrency TS 用于并发计算的扩展 2015 concepts TS 概念库，用于优化编译期信息 2015 TM TS 事务性内存操作 2015 parallelism TS 用于并行计算的扩展 2015 filesystem TS 文件系统 2014 C++14 第四个C++标准 2011 - 十进制浮点数扩展 2011 C++11 第三个C++标准 2010 - 数学函数扩展 2007 C++TR1 C++技术报告：库扩展 2006 - C++性能技术报告 2003 C++03 第二个C++标准 1998 C++98 第一个C++标准 ","date":"2021-08-08","objectID":"/2021/08/c-02%E7%AE%80%E4%BB%8B/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 02简介","uri":"/2021/08/c-02%E7%AE%80%E4%BB%8B/"},{"categories":["C++"],"content":"C++ 环境设置 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"本地环境设置 如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"文本编辑器 这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。 文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。 通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。 在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 编译器 写在源文件中的源代码是人类可读的源。它需要\"编译\"，转为机器语言，这样 CPU 可以按给定指令执行程序。 C++ 编译器用于把源代码编译成最终的可执行程序。 大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。 最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。 以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"安装 GNU 的 C/C++ 编译器 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"UNIX/Linux 上的安装 如果您使用的是 Linux 或 UNIX，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC： $ g++ -v 如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息： Using built-in specs. Target: i386-redhat-linux Configured with: ../configure --prefix=/usr ....... Thread model: posix gcc version 4.1.2 20080704 (Red Hat 4.1.2-46) 如果未安装 GCC，那么请按照 http://gcc.gnu.org/install/ 上的详细说明安装 GCC。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Mac OS X 上的安装 如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。 Xcode 目前可从 https://developer.apple.com/download 上下载，需要使用 apple ID 登录 。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:2","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"Windows 上的安装 为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 mingw-w64.org，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-.exe。 当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。 添加您安装的 MinGW 的 bin 子目录到您的 PATH 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。 当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:4:3","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"使用 Visual Studio (Graphical Interface) 编译 1、下载及安装 Visual Studio Community 2015。 2、打开 Visual Studio Community 3、点击 File -\u003e New -\u003e Project 4、左侧列表选择 Templates -\u003e Visual C++ -\u003e Win32 Console Application，并设置项目名为 MyFirstProgram。 5、点击 OK。 6、在以下窗口中点击 Next 7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮： 8、右击文件夹 Source File 并点击 Add –\u003e New Item… : 9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add： 10、拷贝以下代码到 main.cpp 中： #include \u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\\n\"; return 0; } 界面如下所示： 11、点击菜单上的 Debug -\u003e Start Without Debugging (或按下 ctrl + F5) : 12、完成以上操作后，你可以看到以下输出： ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 应用说明 程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示： $ gcc main.cpp -lstdc++ -o main 下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码： #include \u003ciostream\u003e using namespace std; int main() { cout \u003c\u003c \"Hello, world!\" \u003c\u003c endl; return 0; } 最简单的编译方式： $ g++ helloworld.cpp 由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行： $ ./a.out Hello, world! 通常我们使用 -o 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件： $ g++ helloworld.cpp -o helloworld 执行 helloworld: $ ./helloworld Hello, world! 如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下： $ g++ runoob1.cpp runoob2.cpp -o runoob 生成一个 runoob 可执行文件。 g++ 有些系统默认是使用 C++98，我们可以指定使用 C++11 来编译 main.cpp 文件： g++ -g -Wall -std=c++11 main.cpp ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"g++ 常用命令选项 选项 解释 -ansi 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 -c 只编译并生成目标文件。 -DMACRO 以字符串\"1\"定义 MACRO 宏。 -DMACRO=DEFN 以字符串\"DEFN\"定义 MACRO 宏。 -E 只运行 C 预编译器。 -g 生成调试信息。GNU 调试器可利用该信息。 -IDIRECTORY 指定额外的头文件搜索路径DIRECTORY。 -LDIRECTORY 指定额外的函数库搜索路径DIRECTORY。 -lLIBRARY 连接时搜索指定的函数库LIBRARY。 -m486 针对 486 进行代码优化。 -o FILE 生成指定的输出文件。用在生成可执行文件时。 -O0 不进行优化处理。 -O 或 -O1 优化生成代码。 -O2 进一步优化。 -O3 比 -O2 更进一步优化，包括 inline 函数。 -shared 生成共享目标文件。通常用在建立共享库时。 -static 禁止使用共享连接。 -UMACRO 取消对 MACRO 宏的定义。 -w 不生成任何警告信息。 -Wall 生成所有警告信息。 ","date":"2021-08-08","objectID":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/:6:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 03环境设置","uri":"/2021/08/c-03%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE/"},{"categories":["C++"],"content":"C++ 基本语法 C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。 对象 - 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。 类 - 类可以定义为描述对象行为/状态的模板/蓝图。 方法 - 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。 即时变量 - 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 程序结构 让我们看一段简单的代码，可以输出单词 Hello World。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"实例 #include using namespace std; // main() 是程序开始执行的地方 int main() { cout « “Hello World”; // 输出 Hello World return 0; } 接下来我们讲解一下上面这段程序： C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout « “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:1","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"编译 \u0026 执行 C++ 程序 接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤： 打开一个文本编辑器，添加上述代码。 保存文件为 hello.cpp。 打开命令提示符，进入到保存文件所在的目录。 键入 ‘g++ hello.cpp ‘，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。 现在，键入 ' a.out’ 来运行程序。 您可以看到屏幕上显示 ' Hello World ‘。 $ g++ hello.cpp $ ./a.out Hello World 请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。 您也可以使用 makefile 来编译 C/C++ 程序。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的分号 \u0026 语句块 在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。 例如，下面是三个不同的语句： x = y; y = y+1; add(x, y); 语句块是一组使用大括号括起来的按逻辑连接的语句。例如： { cout « “Hello World”; // 输出 Hello World return 0; } C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如： x = y; y = y+1; add(x, y); 等同于 x = y; y = y+1; add(x, y); ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 标识符 C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。 C++ 标识符内不允许出现标点字符，比如 @、\u0026 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，Manpower 和 manpower 是两个不同的标识符。 下面列出几个有效的标识符： mohd zara abc move_name a_123 myname50 _temp j a23b9 retVal ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 关键字 下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。 asm else new this auto enum operator throw bool explicit private true break export protected try case extern public typedef catch false register typeid char float reinterpret_cast typename class for return union const friend short unsigned const_cast goto signed using continue if sizeof virtual default inline static void delete int static_cast volatile do long struct wchar_t double mutable switch while dynamic_cast namespace template 完整关键字介绍可查阅：C++ 的关键字（保留字）完整介绍 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"三字符组 三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。 三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。 三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。 下面列出了最常用的三字符序列： 三字符组 替换 ??= # ??/ \\ ??’ ^ ??( [ ??) ] ??! | ??\u003c { ??\u003e } ??- ~ 如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：\"…?\"\"?…“或者转义序列：”…??…\"。 从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs g++仍默认支持三字符组，但会给出编译警告。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 中的空格 只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。 在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中： int age; 在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中： fruit = apples + oranges; // 获取水果的总数 fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。 ","date":"2021-08-08","objectID":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 04基本语法","uri":"/2021/08/c-04%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"C++ 注释 程序的注释是解释性语句，您可以在 C++ 代码中包含注释，这将提高源代码的可读性。所有的编程语言都允许某种形式的注释。 C++ 支持单行注释和多行注释。注释中的所有字符会被 C++ 编译器忽略。 C++ 注释一般有两种： // - 一般用于单行注释。 /*** … */** - 一般用于多行注释。 注释以 // 开始，直到行末为止。例如： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:0:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main() { // 这是一个注释 cout \u003c\u003c \"Hello World!\"; return 0; } 也可以放在语句后面： ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:1:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":["C++"],"content":"实例 #include \u003ciostream\u003eusing namespace std; int main() { cout \u003c\u003c \"Hello World!\"; // 输出 Hello World! return 0; } 当上面的代码被编译时，编译器会忽略 // 这是一个注释 和 // 输出 Hello World!，最后会产生以下结果： Hello World! C++ 注释以 /* 开始，以 */ 终止。例如： #include \u003ciostream\u003eusing namespace std; int main() { /* 这是注释 */ /* C++ 注释也可以 * 跨行 */ cout \u003c\u003c \"Hello World!\"; return 0; } 在 /* 和 / 注释内部，//* 字符没有特殊的含义。在 **//** 注释内，**/*** 和 ***/** 字符也没有特殊的含义。因此，您可以在一种注释内嵌套另一种注释。例如： /* 用于输出 Hello World 的注释 cout \u003c\u003c \"Hello World\"; // 输出 Hello World */ ","date":"2021-08-08","objectID":"/2021/08/c-05%E6%B3%A8%E9%87%8A/:2:0","series":null,"tags":["C++","菜鸟C++"],"title":"C++ 05注释","uri":"/2021/08/c-05%E6%B3%A8%E9%87%8A/"},{"categories":null,"content":"图解DbgView使用 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:0:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"一 DbgView简介 Sysinternals公司的系列调试工具。 debugview 可以捕获程序中由TRACE(debug版本)和OutputDebugString输出的信息。 Debug信息捕获软件 可以很方便的捕获系统实时输出的Debug信息，并保存为日志文件。可以远程捕获服务器上的Debug信息。 比较方便开发人员在系统发布前监控一些系统流程和异常，甚至在系统不大的情况下，更能在部署后进行远程监控功能。 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:1:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"二 实际操作 Computer菜单下可选择连接的计算机，默认连接本机； 输入IP或名字可连远程计算机； 下面四个按钮，第一个放大镜的，控制捕获的打开或关闭；第二个控制是否捕获系统内核的Debug信息；第三个控制是否捕获Win32应用的Debug信息； 这是本机捕获的情况； 点击漏斗型按钮，打开过滤器设置，在Include中输入TRACE，在Exclude中输入WAIT_TIMEOUT；这样就只显示带字符串“TRACE”的debug信息，不显示带“WAIT_TIMEOUT”的调试信息； 过滤以后的结果； 漏斗型按钮旁边的按钮控制显示记录的条数；下图显示16条； 捕获菜单中，默认捕获的是Win32，Pass-Through，Events；全局Win32，内核等，默认没有捕获； 选项菜单，可以选择是否显示Win32进程ID，是否滚动显示等； ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:2:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"三 TRACE宏和Dbgview http://blog.163.com/gou_ya/blog/static/102080580200810274839532/ debugview 1、用debugview，打开debugview，运行你的debug版本程序，可以定位到源文件的某一行。 2、包含stdlib.h crtdbg.h 两个头文件 在程序开始处添加 #define _CRTDBG_MAP_ALLOC 在程序结束处添加 _CrtDumpMemoryLeaks(); 比如 #define _CRTDBG_MAP_ALLOC int main(void) { char *p = new char; return 0; _CrtDumpMemoryLeaks(); } 运行debug版本的程序。在输出信息栏里会有内存泄露信息，可以定位到某一行 以上两种方法不是没种泄露都能定位，如果不能，会输出内存泄露信息和发生泄漏的模块，那就要自己想想，什么地方出现了泄露 TRACE宏对于VC下程序调试来说是很有用的东西，有着类似printf的功能；该宏仅仅在程序的DEBUG版本中出现，当RELEASE的时候该宏就完全消失了，从而帮助你调试也在RELEASE的时候减少代码量。 使用非常简单，格式如下： TRACE(“DDDDDDDDDDD”); TRACE(“wewe%d”,333); 同样还存在TRACE0，TRACE1，TRACE2。。。分别对应0，1，2。。个参数 TRACE信息输出到VC IDE环境的输出窗口（该窗口是你编译项目出错提示的那个窗口），但仅限于你在VC中运行你的DEBUG版本的程序。 TRACE信息还可以使用DEBUGVIEW来捕获到。这种情况下，你不能在VC的IDE环境中运行你的程序，而将BUILD好的DEBUG版本的程序单独运行，这个时候可以在DEBUGVIEW的窗口看到DEBUGVIE格式的输出了。 VC中TRACE的用法有以下四种： 1: TRACE ，就是不带动态参数输出字符串, 类似C的printf(“输出字符串”); 2: TRACE 中的字符串可以带一个参数输出 , 类似C的printf(\"…%d\",变量); 3: TRACE 可以带两个参数输出，类似C的printf(\"…%d…%f\",变量1,变量2); 4: TRACE 可以带三个参数输出，类似C的printf(\"…%d，%d,%d\",变量1,变量2，变量3); TRACE 宏有点象我们以前在C语言中用的Printf函数，使程序在运行过程中输出一些调试信息，使我们能了解程序的一些状态。但有一点不同的是： TRACE 宏只有在调试状态下才有所输出，而以前用的Printf 函数在任何情况下都有输出。和Printf 函数一样，TRACE函数可以接受多个参数如： int x = 1; int y = 16; float z = 32.0; TRACE( “This is a TRACE statement\\n” ); TRACE( “The value of x is %d\\n”, x ); TRACE( “x = %d and y = %d\\n”, x, y ); TRACE( “x = %d and y = %x and z = %f\\n”, x, y, z ); 要注意的是TRACE宏只对Debug 版本的工程产生作用，在Release 版本的工程中，TRACE宏将被忽略。 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:3:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"四 C#中使用 在C#中的使用方法： 将WinDebug.cs加入到项目中，也可以编译成.dll文件引入。然后在程序中需要输出调试信息调用即可。 另外，如果要在运行时应用不输出debug信息，可以将web.config或app.config中的 \u003csystem.web\u003e 设置为false，然后在调用WinDebug的地方就不会再输出Debug信息了 ","date":"2021-09-28","objectID":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/:4:0","series":null,"tags":null,"title":"图解DbgView使用","uri":"/2021/09/%E5%9B%BE%E8%A7%A3dbgview%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"Visual C++免注册调用大漠插件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:0:0","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"1、 注册调用 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"一、下载大漠插件，并注册到系统 下载地址：https://pan.baidu.com/s/1nCc5jB4izcp_I2J6JLqEKA 提取码：tf1f ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:1","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"二、创建一个空项目 添加main.cpp和main.h，导入插件中的obj.cpp和obj.h文件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:2","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"三、修改obj.cpp中引入的头文件 #include \"stdafx.h\"去除 #include \"main.h要放前面\" ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:3","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"四、更改运行库为“多线程(/MT)” ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:4","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"五、main.h #ifndef MAIN_H #define MAIN_H #include \u003cafx.h\u003e#include \u003cafxwin.h\u003e#include \u003cafxext.h\u003e#include \u003catlbase.h\u003e#include \u003catlstr.h\u003e#include \u003cafxdtctl.h\u003e#include \u003cafxcmn.h\u003e#include \u003cafxdisp.h\u003e#include \"obj.h\" #endif ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:5","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"六、main.cpp #include \"main.h\"#include \"obj.h\"#include \u003ciostream\u003e using namespace std; int main() { CoInitializeEx(NULL, 0);//初始化 AfxWinInit(GetModuleHandle(NULL), NULL, GetCommandLine(), 0); dmsoft* pDm = new dmsoft; pDm-\u003eMoveTo(0, 0); pDm-\u003eRunApp(L\"notepad\", 1); pDm-\u003edelay(3000); pDm-\u003eKeyPressStr(L\"123456789011\", 20); wcout \u003c\u003c (LPCTSTR)(pDm-\u003eVer())\u003c\u003c endl; return 0; } ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:1:6","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"2、免注册调用 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:0","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"一、创建一个空项目 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:1","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"二、添加main.cpp #include \u003ciostream\u003e#import \"dm.dll\" no_namespace int main() { return 0; } ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:2","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"三、添加dm.dll ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:3","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"四、生成解决方案 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:4","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"五、编译成功后会生成dm.tlh和dm.tli文件 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:5","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"六、修改dm.tlh 修改前 修改后 七、main.cpp #include \u003ciostream\u003e//#import \"dm.dll\" no_namespace #include \"Debug\\dm.tlh\"using namespace std; Idmsoft* GetDmObject() { Idmsoft* m_dm = NULL; bool m_bInit = false; //直接加载dll创建对象，避免进行注册文件 typedef HRESULT(_stdcall* pfnGCO)(REFCLSID, REFIID, void**); pfnGCO fnGCO = NULL; HINSTANCE hdllInst = LoadLibrary(L\"dm.dll\"); fnGCO = (pfnGCO)GetProcAddress(hdllInst, \"DllGetClassObject\"); if (fnGCO != 0) { IClassFactory* pcf = NULL; HRESULT hr = (fnGCO)(__uuidof(dmsoft), IID_IClassFactory, (void**)\u0026pcf); if (SUCCEEDED(hr) \u0026\u0026 (pcf != NULL)) { hr = pcf-\u003eCreateInstance(NULL, __uuidof(Idmsoft), (void**)\u0026m_dm); if ((SUCCEEDED(hr) \u0026\u0026 (m_dm != NULL)) == FALSE) return NULL; } pcf-\u003eRelease(); m_bInit = true; } else m_bInit = false; return m_dm; } int main() { Idmsoft* pDm = GetDmObject(); cout \u003c\u003c pDm-\u003eVer() \u003c\u003c endl; //dm-\u003eReg(L\"注册码\", L\"dass\");//收费版本需要注册后才能使用 /*6.1538版本修改内存可直接调用*/ DWORD pid = GetCurrentProcessId(); int handle = (int)GetModuleHandle(L\"dm.dll\"); cout \u003c\u003c \"进程ID:\" \u003c\u003c pid \u003c\u003c \"模块句柄：\" \u003c\u003c handle \u003c\u003c endl; HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid); int value = 1; bool is = WriteProcessMemory(hProcess, LPVOID(handle + 1078240), \u0026value, 1, NULL); /*调用大漠插件内函数*/ pDm-\u003eMoveTo(0, 0); pDm-\u003edelay(3000); pDm-\u003eKeyPressStr(\"1234567890\", 10); return 0; } 注册码 注册码：3093030f54fe75b8478f7c56fec81fc903841a9 附加码：Z3Ipwoyq5 注朋码：yiging123c12aba5b0179907a750692b023298f12\"ww168168” 注册码: qq760471367f21b0879268408e5096b92cb022804da附加码vvv0000 注册码：zhangxuhvi2d3b98fcd75ac8ee163feadabc6191b85附加码7b666777 ","date":"2021-09-16","objectID":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/:2:6","series":null,"tags":null,"title":"Visual C++免注册调用大漠插件","uri":"/2021/09/visual-c-%E5%85%8D%E6%B3%A8%E5%86%8C%E8%B0%83%E7%94%A8%E5%A4%A7%E6%BC%A0%E6%8F%92%E4%BB%B6/"},{"categories":null,"content":"第一步：JDK下载 打开Oracle官网，点击 资源–软件下载按钮： 进入下载页面：点击Java选项，跳转到Java相关下载的选项： 选择Java(JDK) for Developers选项，跳转到JDK下载页面。 也可以直接点击JDK下载，进入该页面，在该页面中有多个版本可以供开发者下载，目前我用的是JDK 16，所以，我以JDK 16为例，讲解它的下载，滑到Java SE 16，可以看到下图： ​ 点击红框中的按钮，下载，会跳转到JDK选择的页面： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:1:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第二步：JDK安装 双击JDK安装包，然后按照提示流程一步步操作，直到安装完成。我们可以根据下图标识的路径找到已经安装好的JDK： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:2:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第三步：Java配置环境变量 这是最关键的一步。不只是Java开发需要配置环境，在Android、Flutter等开发中如果配置相关的环境变量，也是根据下述的方法进行的。废话不多说，看下面的描述： 打开终端Terminal 如果是第一次配置环境变量，使用命令 touch .bash_profile 创建一个名为**.bash_profile** 隐藏配置文件; 如果不是第一次配置环境变量，使用命令 open .bash_profile 打开配置文件； 在配置文件中输入下面的内容： JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-16.0.2.jdk/Contents/Home PATH=$JAVA_HOME/bin:$PATH:. CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:. export JAVA_HOME export PATH export CLASSPATH 保存关闭配置文件。 注意：JAVA_HOME的值是JDK安装目录下Home的路径。 继续使用命令 source .bash_profile 使配置文件生效。 ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:3:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第四步：检测环境是否安装成功 输入命令 java -version ，查看JDK的版本，如果输出JDK的版本号，说明JDK环境变量配置成功。 如下图： ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:4:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"第五步：开发工具安装 JDK安装好后，我们就可以下载安装自己常用的开发工具，然后配置JDK的安装路径，这样就可以开发了。由于开发工具之多，每个开发人员的开发工具又不一样，这里就不再介绍了。 ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:5:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"扩展 Contents目录下的Home文件夹是JDK的根目录； bin目录下存放的是用于开发的一些终端命令工具，例如：javac、java等命令； db目录下是Java开发的一个开源的关系型数据库； include目录下是一些C语言的头文件； jre目录下是JDK所依赖的Java运行时； lib目录下存放JDK开发工具所依赖的一些库文件； man目录下存放JDK开发工具的说明文档。 以上就是关于Java开发的环境搭建！ ","date":"2021-08-22","objectID":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/:6:0","series":null,"tags":null,"title":"Java-环境搭建Mac版","uri":"/2021/08/java-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAmac%E7%89%88/"},{"categories":null,"content":"获取阿里云盘 refresh_token 登陆阿里云盘网页版 https://www.aliyundrive.com/sign/in 登陆以后F12 复制 refresh_token 留用 ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:1:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"配置 两种配置方式 Jar包运行 点击下载Jar包 java -jar webdav.jar --aliyundrive.refresh-token=\"your refreshToken\" docker运行 docker run -d --name=webdav-aliyundriver --restart=always -p 8080:8080 -v /etc/localtime:/etc/localtime -v /etc/aliyun-driver/:/etc/aliyun-driver/ -e TZ=\"Asia/Shanghai\" -e ALIYUNDRIVE_REFRESH_TOKEN=\"your refreshToken\" -e ALIYUNDRIVE_AUTH_PASSWORD=\"admin\" -e JAVA_OPTS=\"-Xmx1g\" zx5253/webdav-aliyundriver # /etc/aliyun-driver/ 挂载卷自动维护了最新的refreshToken，建议挂载 # ALIYUNDRIVE_AUTH_PASSWORD 是admin账户的密码，建议修改 # JAVA_OPTS 可修改最大内存占用，比如 -e JAVA_OPTS=\"-Xmx512m\" 表示最大内存限制为512m ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:2:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"参数说明 --aliyundrive.refresh-token 阿里云盘的refreshToken，获取方式见下文 --server.port 非必填，服务器端口号，默认为8080 --aliyundrive.auth.enable=true 是否开启WebDav账户验证，默认开启 --aliyundrive.auth.user-name=admin WebDav账户，默认admin --aliyundrive.auth.password=admin WebDav密码，默认admin ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:2:1","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"启动 docker或者jar运行成功后 在浏览器输入： http://127.0.0.1:8080/ 先登陆 输入账号密码 账号默认是admin 密码admin 登陆成功以后 这儿就显示的是你阿里云网盘的所有内容 然后command+k 前面记得一定要加http:// 点击连接 连接 ​ 这样就全部结束了 直接可以用 mac可以通过这种方式实现无感自启 ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:3:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":null,"content":"注意： 如果要用Jar包运行 必须要有java环境 如果要用docker配置 需提前在电脑上安装docker 安装brew：https://brew.sh/index_zh-cn 通过brew安装docker，执行：brew install –cask –appdir=/Applications docker 通过docker允许webdav：https://gitee.com/mirrors/webdav-aliyundriver 中容器允许，注意修改your refreshToken 访问http://127.0.0.1:8080/ 验证下，用户名密码：admin 连接到 WebDAV 服务器：https://support.apple.com/zh-cn/guide/mac-help/mchlp1546/10.13/mac/10.13 本文参考自： https://gitee.com/mirrors/webdav-aliyundriver 感谢大佬们的代码！！！ ","date":"2021-08-22","objectID":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/:4:0","series":null,"tags":null,"title":"阿里云盘变本地硬盘-MAC版","uri":"/2021/08/%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E5%8F%98%E6%9C%AC%E5%9C%B0%E7%A1%AC%E7%9B%98-mac%E7%89%88/"},{"categories":["任鸟飞"],"content":"天涯明月刀 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:0:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"npc等级 npc等级偏移的常见找法： 根据角色的等级偏移到npc对象里查找 通过当前选中怪物的等级来找 普通的方式，到怪物对象中进行偏移遍历 双开账号，通过另一个角色的等级提升进行查找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"npc坐标 遍历npc坐标的几种方式 通过当前怪物血，名字等找到npc遍历，然后在对象周围进行遍历找到坐标。 通过搜索未知初始值来得到当前选中怪，有可能得到的是ID，也有可能得到的是对象，然后追写入的来源，并在周围遍历到坐标。 通过追角色的坐标对象，并在得到对象偏移的代码段下f2断点，f9运行得到一个不同于角色基地址的返回地址，返回后得到npc的遍历。 直接双开角色，查找其中一个的坐标。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"角色速度 如何查找角色的速度，以及变态加速功能的实现： 通过改变角色的速度，比如上马下马，或者跑步走路，有速度值，比如走路100，跑步150，更常见。 通过角色的行走状态，比如走路1，跑步2，上马3 有可能是整数型，也可能是浮点（常见）。 1-10000 （常见） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"角色朝向 角色朝向的几种常见数值： 从-1到1 从-π到π 或者从0到π 从0到360 其他程序员自定义朝向值 朝向在数据中的表现形式： 以一个值会变动的地址同时表现xy朝向，以单独的内存地址表现z朝向 以单独内存地址分别表现xyz朝向 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"遍历背包 遍历背包的几种方式： 遍历背包格子 数组较多 遍历背包物品 二叉数较多 遍历背包格子，通过数量来找，或者通过是否有物品来找 遍历背包物品，通过数量，背包位置，物品名称来找比较方便 另外有些游戏通过发包返回功能call，分析参数也可以物到物品的遍历 站长工具 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"支线任务遍历 通过打怪数量 通过任务标志（接取和放弃任务）常见 通过任务名字或者任务描述 通过接任务或放弃任务call追参数 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"明文发包 首先确定是否为线程发包 然后确定明文包是否可以返回到功能call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:7:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能冷却 技能冷却的查找 通过技能冷却标志位查找，常见的有搜索0和1，0和-1，-1就是FFFFFFFF或者字节型就是FF 通过技能冷却时间查找，常见的有从冷却开始时间增加和从冷却开始时间减少。 通过找到技能call并到附近观察跳转，找到判断技能是否冷却的方式。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:8:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能名称及相关信息 大部分的游戏，技能的冷却与名字都不在同一个遍历下，为了得到全面的技能信息，需要通过搜索技能名称字符串找到技能的名字遍历，并通过技能ID与技能的其他信息进行关联。 天刀是utf-8的编码方式，需要通过工具将文本型转换成字节集进行搜索。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:9:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能封包 发包找技能call。常见 使用技能，在蓝量上下写入断点。 在技能id上，或者在技能的冷却上下访问或者写入断点。 在技能栏上下访问断点。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:10:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"选中npc和打开npc 封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:11:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"使用物品封包 使用明文包返回到功能call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:12:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"穿装备封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:13:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"游戏小退封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:14:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"喊话call 在喊话内容上下访问断 喊话类型上下访问断 直接通过发包来找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:15:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"喊话坐标的调用 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:16:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"自动复活 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:17:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"寻路 发包返回到寻路 通过目的地坐标，下写入断点直接找到寻路 通过目的地坐标，找到走路call，然后在走路call上下断，返回到寻路 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:18:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"地图遍历 通过当前地图id，下写入断点 通过地图名字，下访问断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:19:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"传送点遍历 通过传送call，跟踪返回参数，找到基地址。 通过传送点的名字来找 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:20:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"NPC对话（选项） 通过最后一句话进行一个发包，返回到点击npc选项的call上 选项的内容，下访问断点 通过对话的顺序，下访问或者写入断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:21:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"技能封包 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:22:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"剧情标志位 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:23:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"任务细节分析 第一种 怪物名字 或者 打怪数量的文本型 第二种 就是打怪的数量 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:24:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"分解及复刻装备 分解装备 复刻装备 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:25:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之搜索 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:26:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之遍历及购买 通过物品的数量 通过物品名字 通过拍卖页 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:27:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"万能按键call 通过明文包 （通过按键来触发的发包） 通过打开背包或者角色栏，找到标志位，下访问或者写入断点 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:28:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"日常任务之打坐 通过打坐获得的经验 通过打坐次数（已打坐次数或剩余次数） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:29:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"日常任务之荡寇 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:30:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"动画标志 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:31:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之词缀搜索 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:32:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之词缀遍历 ce内搜索词缀ID，然后分别下断，看哪个会被断下。 直接通过词缀名字进行搜索。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:33:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"拍卖之上架 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:34:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"控件call 设置按钮，对选项的标志位进行写入 直接通过功能call返回 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:35:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"控件遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:36:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"buff遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:37:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"对象buff和技能预判 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:38:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"摆摊和收摊 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:39:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"代工遍历 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:40:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"摆摊移动call ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:41:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"狩猎100%命中 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:42:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"狩猎堆栈检测及关键点 3个重点 找到3个包 条件断点 朝向计算 堆栈检测（结构体内部） x差==x2-x1 y差==y2-y1 z差==(z2-z1)/2 距离==（x差^2^+y差^2^+z差^2^)^0.5^ x朝向==x差/距离 y朝向==y差/距离 z朝向==z差/距离 画江山 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:43:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"加密坐标 搜索加密坐标的解决办法：（注意45度坐标） 搜索类型 换成字符串 （找突破口容易，逆向时困难） 在人物对象下寻找 搜索未知初始值（搜索过程复杂） ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:44:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"经验 当前经验 升级经验来搜索 最大经验值 搜索出一堆数据之后，数据一堆一堆得改。 ","date":"2021-08-20","objectID":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/:45:0","series":null,"tags":["任鸟飞","骷髅","天涯明月刀","画江山"],"title":"骷髅笔记 - 天涯明月刀","uri":"/2021/08/%E9%AA%B7%E9%AB%85%E7%AC%94%E8%AE%B0/"},{"categories":["菜鸟C++笔记"],"content":"C++ 循环 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"循环类型 循环类型 描述 while 循环 当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。 for 循环 多次执行一个语句序列，简化管理循环变量的代码。 do…while 循环 除了它是在循环主体结尾测试条件外，其他与 while 语句类似。 嵌套循环 您可以在 while、for 或 do..while 循环内使用一个或多个循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"基于范围的for循环(C++11) 拷贝range的元素时，使用for(auto x : range). 修改range的元素时，使用for(auto \u0026\u0026 x : range). 只读range的元素时，使用for(const auto \u0026 x : range). vector\u003cbool\u003e时使用auto会有问题，对于其他包含代理类的类也会有问题，直接使用for(bool x : vector\u003cbool\u003e) ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"do…while 循环 do { statement(s); }while( condition ); ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"循环控制语句 控制语句 描述 break 语句 终止 loop 或 switch 语句，程序流将继续执行紧接着 loop 或 switch 的下一条语句。 continue 语句 引起循环跳过主体的剩余部分，立即重新开始测试条件。 goto 语句 将控制转移到被标记的语句。但是不建议在程序中使用 goto 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"break 语句 C++ 中 break 语句有以下两种用法： 当 break 语句出现在一个循环内时，循环会立即终止，且程序流将继续执行紧接着循环的下一条语句。 它可用于终止 switch 语句中的一个 case。 如果您使用的是嵌套循环（即一个循环内嵌套另一个循环），break 语句会停止执行最内层的循环，然后开始执行该块之后的下一行代码。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"continue 语句 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"goto 语句 goto 语句一个很好的作用是退出深嵌套例程。例如，请看下面的代码片段： for(...) { for(...) { while(...) { if(...) goto stop; . . . } } } stop: cout \u003c\u003c \"Error in program.\\n\"; 消除 goto 会导致一些额外的测试被执行。一个简单的 break 语句在这里不会起到作用，因为它只会使程序退出最内层循环。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:2:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"无限循环 #include \u003ciostream\u003eusing namespace std; int main () { for( ; ; ) { printf(\"This loop will run forever.\\n\"); } return 0; } C++ 程序员偏向于使用 for(;;) 结构来表示一个无限循环。 注意：您可以按 Ctrl + C 键终止一个无限循环。 判断 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"判断语句 语句 描述 if 语句 一个 if 语句 由一个布尔表达式后跟一个或多个语句组成。 if…else 语句 一个 if 语句 后可跟一个可选的 else 语句，else 语句在布尔表达式为假时执行。 嵌套 if 语句 您可以在一个 if 或 else if 语句内使用另一个 if 或 else if 语句。 switch 语句 一个 switch 语句允许测试一个变量等于多个值时的情况。 嵌套 switch 语句 您可以在一个 switch 语句内使用另一个 switch 语句。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"switch 语句 switch(expression){ case constant-expression : statement(s); break; // 可选的 case constant-expression : statement(s); break; // 可选的 // 您可以有任意数量的 case 语句 default : // 可选的 statement(s); } switch 语句必须遵循下面的规则： switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。 case 的 constant-expression 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 break 语句为止。 当遇到 break 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。 不是每一个 case 都需要包含 break。如果 case 语句不包含 break，控制流将会 继续 后续的 case，直到遇到 break 为止。 一个 switch 语句可以有一个可选的 default case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 break 语句不是必需的。 ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"嵌套 switch 语句 switch(ch1) { case 'A': cout \u003c\u003c \"这个 A 是外部 switch 的一部分\"; switch(ch2) { case 'A': cout \u003c\u003c \"这个 A 是内部 switch 的一部分\"; break; case 'B': // 内部 B case 代码 } break; case 'B': // 外部 B case 代码 } ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:4:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["菜鸟C++笔记"],"content":"? : 运算符 条件运算符 ? :，可以用来替代 if…else 语句。它的一般形式如下： Exp1 ? Exp2 : Exp3; ","date":"2021-08-15","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记13-14循环 \u0026 判断","uri":"/2021/08/c-%E7%AC%94%E8%AE%B013-14%E5%BE%AA%E7%8E%AF-%E5%88%A4%E6%96%AD/"},{"categories":["博客"],"content":"俺如何为 hugo-theme-even 提供 mermaid 支持 如上是一个利用 mermaid 绘制的 SVG 图形 ，相比于直接在某些软件绘制好再截图，显然利用 mermaid 绘图具备诸多优点： 网站保存的是带 mermaid 的 markdown 文件，不涉及到图片存储。存储占用小。 渲染出图是 SVG 格式，上面的文字可以直接拷贝。 网站数据传输时是使用 mermaid 源码，而不是图片，可以有效减少网站加载过程产生的流量耗费。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:0:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"如何为你的 Hugo 博客引入 mermaid 支持？ 贴士 虽然由于 even theme 更新过慢，似乎久已无更多维护，因此本站已经开始使用 LoveIt 作为主题。 但是对于 even theme 而言，本方法应当依旧适用。 对于这一点，俺可以说前人之述备矣。反手就是一堆参考资料： Diagrams in hugo with mermaid 拓展 Hugo 的 MarkDown 流程图 这些解决方案引入 mermaid 的方法简单素雅，这一套流程可以总结为： 在博客中加载 mermaidJS。具体方法有： 直接在一定会加载的 HTML 文件中引入 \u003cscript\u003e 标签，加载 mermaid。 在部分支持自定义 JavaScript 的主题中，引入 JavaScript 文件。 自定义 ShortCodes，依靠 ShortCodes 实现标签替换。 但是习惯了通过 typora 之类的 MarkDown 拓展编辑器，他们无一例外都支持按照如下风格进行渲染： ```mermaid ... 图表内容 ... ``` 能不能实现它，从而实现更加一颗赛艇的编辑体验呢？ 能的。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:1:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"实现原理 通过阅读 mermaid 的 API 咱们可以得知 mermaidAPI 渲染 mermaid 图形的大致流程： 上述的特定标签是指\u003cdiv class=\"mermaid\"\u003e的 HTML 标签。通过检查页面元素，咱们会发现如今的大部分博客将代码块渲染成如下式样： \u003cpre\u003e\u003ccode class=\"language-语言种类\"\u003e \u003c!-- code --\u003e \u003c/code\u003e\u003c/pre\u003e 也就是说咱们只需要找到形如： \u003cpre\u003e\u003ccode class=\"language-mermaid\"\u003e \u003c!-- mermaid code --\u003e \u003c/code\u003e\u003c/pre\u003e 的代码块，并将其替换成\u003cdiv class=\"mermaid\"\u003e即可。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:2:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"在 even theme 中的实现 注意 注意： 下文中的 “/” 目录代表 even theme 项目的根目录而不是 *nix 文件系统的 root. 本博客使用的是 even theme. 但是俺相信参照本文在其他博客中进行实现也会大差不差。 俺在自己实现了此种风格之后即向 hugo-theme-even 提出了 PR，even theme 的用户应该可以在不久以后在新版本中得到 mermaid 支持。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"导入 mermaid.min.js 实现应当遵循原理的指示精神，首先咱们需要拥有 mermaid 库。通过观察源码猜测 even 主题在 /static/layouts/partials/scripts.html 中进行 JS 的载入。于是咱们向其中插入能够引入 mermaid 模块的 script 标签。（实际上只要是会被加载的 HTML 文件都可以插） 这个标签在 HTML 文件里随便找个地方插就完事了，如果完全不懂，建议怼到 HTML 文件末尾。 通过 CDN 导入 为了保持文章的时效性，俺不会直接提供该 script 标签，但是你可以在 jsdelivr.com 中找到你中意版本的 mermaid.min.js 并按下右边的 Copy HTML + SRI 按钮即可获得对应的标签。 通过本地文件导入 由于房间里的大象太大挡住了境外CDN的信号，所以你也可以选择本地文件。在网上找到你中意版本的 mermaid.min.js, 下载下来并放在 /static/lib/mermaid/ 目录下（没有就新建一个），这时可以得到对应的 script 标签如下： \u003cscript src=\"{{ \"lib/mermaid/mermaid.min.js\" | relURL }}\" crossorigin=\"anonymous\"\u003e\u003c/script\u003e 本人对境外 CDN 在内地的稳定性持悲观态度，建议中国大陆用户使用此方法。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"替换 HTML 标签 观察 even 主题的源码，咱们可以在 /assets/js/ 目录下发现 main.js 和 even.js。在 even.js 中插入如下代码段： // 插到文件末尾完事了 Even.mermaid = function () { if (!window.mermaid) return; const blocks = document.querySelectorAll(\"pre code.language-mermaid\"); // change all \u003cpre\u003e\u003ccode mamaid\u003e tags to \u003cdiv class=\"mermaid\"\u003e // mermaid will handle the rest! for (let i = 0; i \u003c blocks.length; i++) { if (!window.hljs \u0026\u0026 i % 2 === 0) continue; const block = blocks[i]; const rootElement = window.hljs ? block.parentElement : block.parentElement.parentElement.parentElement.parentElement .parentElement.parentElement.parentElement; var container = document.createElement(\"div\"); const id = `js-mermaid-diagrams-${i}`; container.id = id; container.className = \"align-center mermaid\"; container.textContent = block.childNodes[0].textContent; rootElement.parentElement.replaceChild(container, rootElement); } window.mermaid.mermaidAPI.initialize( window.mermaidOptions ? window.mermaidOptions : { securityLevel: \"loose\", theme: \"base\" } // 替换它可以修改 mermaid 的样式=======↑ ); }; 在 main.js 中插入： // 个人比较喜欢插在 Even.sequence(); 的后面 Even.mermaid(); 现在你应该可以在自己的博客中写 mermaid 了。 ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["博客"],"content":"工具推荐 Typora 写 MarkDown 咋能少得了 「Typora」？ Visual Studio Code 俺写这篇文章用的无所不能的编辑器，建议添加插件： Markdown All in One Markdown Preview Enhanced Mermaid Markdown Syntax Highlighting 之所以用 Visual Studio Code，很大程度上是因为它的 Vim 拓展。 “2021年了不会还有人不会用 Vim 吧？” vim ","date":"2021-08-14","objectID":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/:3:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"为 hugo-theme-even 提供 mermaid 支持.md","uri":"/2021/08/%E4%B8%BA-hugo-theme-even-%E6%8F%90%E4%BE%9B-mermaid-%E6%94%AF%E6%8C%81/"},{"categories":["菜鸟C++笔记"],"content":"C++ 存储类 存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类： auto register static extern mutable thread_local (C++11) 从 C++ 17 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:0:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"auto 存储类 根据初始化表达式自动推断被声明的变量的类型，如： auto f=3.14; //double auto s(\"hello\"); //const char* auto z = new auto(9); // int* auto x1 = 5, x2 = 5.0, x3='r';//错误，必须是初始化为同一类型 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"register 存储类 register 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。这意味着变量的最大尺寸等于寄存器的大小（通常是一个词），且不能对它应用一元的 ‘\u0026’ 运算符（因为它没有内存位置）。 { register int miles; } ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"static 存储类 静态变量 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"extern 存储类 extern 是用来在另一个文件中声明一个全局变量或函数。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"mutable 存储类 mutable 说明符仅适用于类的对象，这将在本教程的最后进行讲解。它允许对象的成员替代常量。也就是说，mutable 成员可以通过 const 成员函数修改。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"thread_local 存储类 以下演示了可以被声明为 thread_local 的变量： thread_local int x; // 命名空间下的全局变量 class X { static thread_local std::string s; // 类的static成员变量 }; static thread_local std::string X::s; // X::s 是需要定义的 void foo() { thread_local std::vector\u003cint\u003e v; // 本地变量 } C++运算符 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"算术运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 + 把两个操作数相加 A + B 将得到 30 - 从第一个操作数中减去第二个操作数 A - B 将得到 -10 * 把两个操作数相乘 A * B 将得到 200 / 分子除以分母 B / A 将得到 2 % 取模运算符，整除后的余数 B % A 将得到 0 ++ 自增运算符，整数值增加 1 A++ 将得到 11 -- 自减运算符，整数值减少 1 A– 将得到 9 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:7:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"关系运算符 假设变量 A 的值为 10，变量 B 的值为 20，则： 运算符 描述 实例 == 检查两个操作数的值是否相等，如果相等则条件为真。 (A == B) 不为真。 != 检查两个操作数的值是否相等，如果不相等则条件为真。 (A != B) 为真。 \u003e 检查左操作数的值是否大于右操作数的值，如果是则条件为真。 (A \u003e B) 不为真。 \u003c 检查左操作数的值是否小于右操作数的值，如果是则条件为真。 (A \u003c B) 为真。 \u003e= 检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。 (A \u003e= B) 不为真。 \u003c= 检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。 (A \u003c= B) 为真。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:8:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"逻辑运算符 假设变量 A 的值为 1，变量 B 的值为 0，则： 运算符 描述 实例 \u0026\u0026 称为逻辑与运算符。如果两个操作数都 true，则条件为 true。 (A \u0026\u0026 B) 为 false。 || 称为逻辑或运算符。如果两个操作数中有任意一个 true，则条件为 true。 (A|| B) 为 true。 ! 称为逻辑非运算符。用来逆转操作数的逻辑状态，如果条件为 true 则逻辑非运算符将使其为 false。 !(A \u0026\u0026 B) 为 true。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:9:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"位运算符 p q p \u0026 q p | q p ^ q 0 0 0 0 0 0 1 0 1 1 1 1 1 1 0 1 0 0 1 1 假设如果 A = 60，且 B = 13，现在以二进制格式表示，它们如下所示： A = 0011 1100 B = 0000 1101 A\u0026B = 0000 1100 A|B = 0011 1101 A^B = 0011 0001 ~A = 1100 0011 下表显示了 C++ 支持的位运算符。假设变量 A 的值为 60，变量 B 的值为 13，则： 运算符 描述 实例 \u0026 按位与操作，按二进制位进行\"与\"运算。运算规则： 0\u00260=0; 0\u00261=0; 1\u00260=0; 1\u00261=1; (A \u0026 B) 将得到 12，即为 0000 1100 | 按位或运算符，按二进制位进行\"或\"运算。运算规则：0|0=0; 0|1=1; 1|0=1; 1|1=1; (A | B) 将得到 61，即为 0011 1101 ^ 异或运算符，按二进制位进行\"异或\"运算。运算规则：0^0=0; 0^1=1; 1^0=1; 1^1=0; (A ^ B) 将得到 49，即为 0011 0001 ~ 取反运算符，按二进制位进行\"取反\"运算。运算规则： ~1=-2; ~0=-1; (~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。 « 二进制左移运算符。将一个运算对象的各二进制位全部左移若干位（左边的二进制位丢弃，右边补0）。 A « 2 将得到 240，即为 1111 0000 \u003e\u003e 二进制右移运算符。将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。 A » 2 将得到 15，即为 0000 1111 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:10:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"赋值运算符 运算符 描述 实例 = 简单的赋值运算符，把右边操作数的值赋给左边操作数 C = A + B 将把 A + B 的值赋给 C += 加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数 C += A 相当于 C = C + A -= 减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数 C -= A 相当于 C = C - A *= 乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数 C *= A 相当于 C = C * A /= 除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数 C /= A 相当于 C = C / A %= 求模且赋值运算符，求两个操作数的模赋值给左边操作数 C %= A 相当于 C = C % A «= 左移且赋值运算符 C «= 2 等同于 C = C « 2 \u003e\u003e= 右移且赋值运算符 C »= 2 等同于 C = C » 2 \u0026= 按位与且赋值运算符 C \u0026= 2 等同于 C = C \u0026 2 ^= 按位异或且赋值运算符 C ^= 2 等同于 C = C ^ 2 |= 按位或且赋值运算符 C |= 2 等同于 C = C ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:11:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"杂项运算符 运算符 描述 sizeof sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 Condition ? X : Y 条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。 , 逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 .（点）和 -\u003e（箭头） 成员运算符用于引用类、结构和共用体的成员。 Cast 强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 \u0026 指针运算符 \u0026 返回变量的地址。例如 \u0026a; 将给出变量的实际地址。 * 指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"逗号运算符 var = (count=19, incr=10, count+1); ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"成员运算符 .（点）运算符和 -\u003e（箭头）运算符用于引用类、结构和共用体的成员。 点运算符应用于实际的对象。 箭头运算符与一个指向对象的指针一起使用。 例如，假设有下面的结构： struct Employee { char first_name[16]; int age; } emp; （.）点运算符 下面的代码把值 “zara” 赋给对象 emp 的 first_name 成员： strcpy(emp.first_name, \"zara\"); （-\u003e）箭头运算符 如果 p_emp 是一个指针，指向类型为 Employee 的对象，则要把值 “zara” 赋给对象 emp 的 first_name 成员，需要编写如下代码： strcpy(p_emp-\u003efirst_name, \"zara\"); -\u003e 称为箭头运算符，它是由一个减号加上一个大于号组成。 简而言之，访问结构的成员时使用点运算符，而通过指针访问结构的成员时，则使用箭头运算符。 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"指针运算符（\u0026 和 *) 取地址运算符 \u0026 \u0026 是一元运算符，返回操作数的内存地址。例如，如果 var 是一个整型变量，则 \u0026var 是它的地址。该运算符与其他一元运算符具有相同的优先级，在运算时它是从右向左顺序进行的。 您可以把 \u0026 运算符读作\"取地址运算符\"，这意味着，\u0026var 读作\"var 的地址\"。 间接寻址运算符 * 第二个运算符是间接寻址运算符 ，它是 \u0026 运算符的补充。 是一元运算符，返回操作数所指定地址的变量的值。 请看下面的实例，理解这两种运算符的用法。 实例 #include \u003ciostream\u003e using namespace std; int main () { int var; int *ptr; int val; var = 3000; // 获取 var 的地址 ptr = \u0026var; // 获取 ptr 的值 val = *ptr; cout \u003c\u003c \"Value of var :\" \u003c\u003c var \u003c\u003c endl; cout \u003c\u003c \"Value of ptr :\" \u003c\u003c ptr \u003c\u003c endl; cout \u003c\u003c \"Value of val :\" \u003c\u003c val \u003c\u003c endl; return 0; } 当上面的代码被编译和执行时，它会产生下列结果： Value of var :3000 Value of ptr :0xbff64494 Value of val :3000 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:12:3","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的运算符优先级 类别 运算符 结合性 后缀 () [] -\u003e . ++ - - 从左到右 一元 + - ! ~ ++ - - (type)* \u0026 sizeof 从右到左 乘除 * / % 从左到右 加减 + - 从左到右 移位 « » 从左到右 关系 \u003c \u003c= \u003e \u003e= 从左到右 相等 == != 从左到右 位与 AND \u0026 从左到右 位异或 XOR ^ 从左到右 位或 OR | 从左到右 逻辑与 AND \u0026\u0026 从左到右 逻辑或 OR || 从左到右 条件 ?: 从右到左 赋值 = += -= *= /= %=»= «= \u0026= ^= |= 从右到左 逗号 , 从左到右 ","date":"2021-08-12","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/:13:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记11-12存储类 \u0026 运算符","uri":"/2021/08/c-%E7%AC%94%E8%AE%B011-12%E5%AD%98%E5%82%A8%E7%B1%BB-%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"categories":["任鸟飞"],"content":"小知识 16进制 4x xx xx xx一般是浮点数（正数） 16进制 Cx xx xx xx一般是浮点数（负数） st0 st1 st2 … 是浮点栈 sar 算术右移 每右移一位，相当于除以一次2 shl 算术左移 每左移一位，相当于乘以一次2 mov ecx,[edx+esi] #当出现两个寄存器的时候，99%其中一个是0 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"OD指令 dd 查看dword db 查看字节集 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:1","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"寄存器 EAX call的返回值 ECX call的参数 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:2","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编指令 AND 指令在两个操作数的对应位之间进行（按位）逻辑与（AND）操作，并将结果存放在目标操作数中。 XOR 指令在两个操作数的对应位之间进行（按位）逻辑异或（XOR）操作，并将结果存放在目标操作数中. xor eax,eax #eax清0 xor eax,A3F838C #简单的异或加密（可直接异或解密） TEST 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。 test eax,eax #判断eax是否为0 FLD类似于 PUSH指令 将浮点数据压入协处理器的堆栈中 fld dword ptr [eax+4] #将[eax+4]的值传入st0 FSTP类似于 POP指令 与FST相类似，FSTP执行完后，需要进行堆栈的弹出操作，堆栈将发生变化。 fstp dword ptr [ebp-28] #将st0中的值传入后面的地址[ebp-28],并出栈 FST 将协处理器堆栈栈顶的数据传送到目标操作数中。在进行数据传送时，系统自动根据控制寄存器中舍入控制位的设置把栈顶浮点数舍入成相应精度的数据。 fst dword ptr [ebp-28] #将st0中的值传入后面的地址[ebp-28]，不出栈 FADD类似于 ADD指令 源操作数与目的操作数相加 FDIV 指令执行目的操作数除以源操作数，被除数保存在目的操作数中。目的操作数总是一个寄存器，源操作数可以为寄存器或者内存操作数。其语法与 FADD 和 FSUB 相同。 FXCH 交换寄存器内容 FXCH ;ST0和ST1内容交换 FXCH ST(i) ;ST0和STi内容交换 MOVZX 指令（进行全零扩展并传送）将源操作数复制到目的操作数，并把目的操作数 0 扩展到 16 位或 32 位。这条指令只用于无符号整数. MOVSX 指令（进行符号扩展并传送）将源操作数内容复制到目的操作数，并把目的操作数符号扩展到 16 位或 32 位。这条指令只用于有符号整数. ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:3","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"发包函数 send WSASend sendto send在64位系统上是ws2_32.send WSPSend （在同一个电脑上位置是固定的） DXF单机版 私服 找到WSPSend 附加上口袋西游(或者任何的send发包的软件都可以)，跳到send位置 send 第三个call下断（win7是第三个，win10是第四个），断下后F7进入，这就是WSPSend的位置。 附加到目标进程，跳转到这个地址，下断。 有时WSASend胡乱断，不是真正的发包 ，根据它的特征码，去搜索。查找–\u003e所有命令 ,输入特征码，然后右键–\u003e在每个命令上下设置断点。然后在所有被断下的位置做标记（注释），并取消断点。然后去执行喊话等发包操作，看在哪断下。如果不断，说明在刚才被标记的里面。之后逐一下断测试。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:4","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"线程发包 graph RL d[ ]--\u003ee[\"检测是否真的需要发包(封包的加密解密)\"]--\u003ef[send] 线程发包的特点： 找到发包函数 下断会立刻断下，并且非常频繁 无论做任何动作断下的，我们的返回堆栈都是一样的 找到跳出线程的办法 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:5","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"确定堆栈平衡 方法： 在call的栈上双击 F8步过call 此时看栈上差值 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:6","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"应该熟悉的汇编指令 mov 赋值 和 lea 传址 push 入栈 和 pop 出栈 pushad 和 popad 调用call之前pushad，调用call之后popad，保证寄存器不受影响 add 加法 和 sub 减法 inc 自加1 和 dec 自减1 mul 乘法 div 除法 call 和 retn xor 异或 相同为0，不同为1 and 都是1为1 or 有一个是1为1 xor 是可逆运算，即 A xor B == C 那么 A xor C == B ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:7","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"堆栈详解 什么是堆栈 堆栈就是一种数据项按序排列的数据结构，只能在栈顶对数据项进行插入和删除，其它位置只能改变数值。 特点是先进后出，像个杯子。 堆栈指针寄存器 ESP 栈顶指针 EBP 栈底指针（本层CALL的栈底） ESI 堆栈地址 改变堆栈的操作 影响esp的操作 push eax == sub esp,4 + mov [esp],eax pop eax == mov eax,[esp] + add esp,4 call 1234 == push eip + jmp 1234 retn 8 == pop eip + add esp,8 add esp,xxx sub esp,xxx 堆栈中储存的都是 参数、局部变量、操作中间数 那么我们怎么去找他的来源 例如[ebp-4] [ebp+8] [esp+20] 实例来说明 通过ebp来传递参数和局部变量 头部有push ebp push ebp mov ebp,esp #头部 … … mov esp,ebp #尾部 pop ebp [ebp-8] 第二个局部变量 [ebp-4] 第一个局部变量 [ebp] 保存着上一层的ebp值 [ebp+4] call返回到xxxxxxxx == call xxxxxxxx 相当于 push eip [ebp+8] 第一个参数 [ebp+c] 第二个参数 同时知道了 ebp为什么是栈底指针 四种情况: ebp+10 如果ESP与EBP相差的远，说明ebp不是堆栈地址，而是普通寄存器，10就是偏移，追ebp就可以了 ebp+10 如果相差不远，ebp就是堆栈地址，返回上一层追参数 ebp+0或者ebp+4 需要注意一下，这可能是堆栈检测 ebp-x 说明是局部变量，来源必须是本条到函数头部，或者是这之前的call里面。 通过esp来传递参数和局部变量 头部没有push ebp mov ebp，esp #这样的代码，往往是用esp来表示 sub esp，xxxx #开辟局部变量 算到头部，如果是[esp+]，那么是参数 如果是[esp-]，那么是局部变量，是在本层找来源 更简单的方法是，直接断下看堆栈，看看这个堆栈指针，指向的位置是，上一层返回的上面还是下面。 但是不用全部计算，往往一个call都是自身堆栈平衡的。 我们只需要计算头部的一些堆栈处理。 [esp-8] 第二个局部变量 [esp-4] 第一个局部变量 [esp] 指向call返回到 [esp+4] 第一个参数 [esp+8] 第二个参数 首先要确定 我们要追的[esp+]是参数还是局部变量 两种方法可以确定 一条一条往上推，推到最上面，如果是esp+，那就是参数，如果是esp-那就是局部变量 直接下断，看堆栈，如果在第一个call返回到的下面是参数，在上面是局部变量 如果是局部变量，有两种追法 一条一条向上堆，并根据 影响esp的操作 来计算偏移 需要下两个断点，第一个断点为当前[esp+xx]处，第二个断点为：在头部位置找到 sub esp xxxx,在它的下一条下断。连断两次之后，看esp变化是多少，比如是n，那么在头部要追的就是[esp+xx-n]。 在堆栈内双击esp+xx-n，做个定位，然后在头部断点位置按F8，找哪句改变了堆栈内esp+xx-n的值即可。 如果是参数 看它在堆栈内,第一个call返回到的下面第几个位置，就代表它是上层第几个参数 graph z([\"首先要确定\u003cbr\u003e我们要追的[esp+]\u003cbr\u003e是参数\u003cbr\u003e还是局部变量\"]) --\u003e z1 \u0026 z4 z1{\"方法1\u003cbr\u003e一条一条往上推\u003cbr\u003e推到最上面\"} --\u003e z2 \u0026 z3 z2[\"如果是esp+\"]--\u003ez6 z3[\"如果是esp-\"]--\u003ez5 z4{\"方法2\u003cbr\u003e直接下断\u003cbr\u003e看堆栈\"} --\u003e z4a \u0026 z4b z4a[如果在第一个call\u003cbr\u003e返回到的上面]--\u003e z5 z4b[如果在第一个call\u003cbr\u003e返回到的下面]--\u003e z6 z5[\"局部变量\"]--\u003ez7 \u0026 z9 z6[\"参数\"]--\u003ez14 z7[\"方法1\u003cbr\u003e一条一条向上堆\"]--\u003e z8[\"并根据影响esp的\u003cbr\u003e操作来计算偏移\"] z9[\"方法2\u003cbr\u003e需要下两个断点\"]--\u003e z10[\"第一个断点为:\u003cbr\u003e当前[esp+xx]处\"]--\u003e z11[\"第二个断点为:\u003cbr\u003e在头部位置找到\u003cbr\u003esub esp xxxx\u003cbr\u003e在它的下一条下断\"]--\u003e z12[\"连断两次之后，\u003cbr\u003e看esp变化是多少，\u003cbr\u003e比如是n，\u003cbr\u003e那么在头部要追的就是\u003cbr\u003e[esp+xx-n]\"]--\u003e z13[\"在堆栈内双击esp+xx-n，\u003cbr\u003e做个定位，\u003cbr\u003e然后在头部断点位置按F8，\u003cbr\u003e找哪句改变了堆栈内\u003cbr\u003eesp+xx-n的值即可。\"] z14[\"看它在堆栈内\u003cbr\u003e第一个call返回到\u003cbr\u003e的下面第几个位置，\u003cbr\u003e就代表它是上层\u003cbr\u003e第几个参数\"] ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:8","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"数据结构 一般我们接触的数据结构有三种 数组、链表、二叉树，也就是数据不同的排列方式 二叉树 graph TD; a--\"[a+0]\"--\u003eb; a--\"[a+8]\"--\u003ec; b --\"[[a+0]+0]\"--\u003e d; b --\"[[a+0]+8]\"--\u003e e; c--\"[[a+8]+0]\"--\u003ef; e--\"[[[a+0]+8]+0]\"--\u003eg; 00433FA6 cmp dword ptr [eax+10],esi #可能是ID 00433FA9 jge short 00433FB0 00433FAB mov eax,dword ptr [eax+8] #右 00433FAE jmp short 00433FB4 00433FB0 mov edx,eax 00433FB2 mov eax,dword ptr [eax] #左 00433FB4 cmp byte ptr [eax+231],0 #判断 00433FBB je short 00433FA6 链表 graph LR a--\u003eb[\"[a+x]\"] --\u003ec[\"[[a+x]+x]\"]--\u003ed[\"[[[a+x]+x]+x]\"] 010A1BE0 cmp dword ptr [edx+C],esi #链表循环 010A1BE3 je short 010A1BF8 010A1BE5 mov edx,dword ptr [edx] #链表循环 010A1BE7 test edx,edx 010A1BE9 jnz short 010A1BE0 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:9","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"转移追踪代码 在call内部栈顶下条件断点 [esp]!=0A2BA8C 或者 [esp]!=0A2BA8C \u0026\u0026 [esp]!=0A12D1D 在call内部被追踪处下条件断点，断点内容和上面的相同也可以。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:10","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"跳出系统领空 在OD内存窗口对X地址下断，游戏暂停在系统领空后，跳出系统领空的方法： 在堆栈中查找X，找到后看是不是程序领空，如果不是的话，ctrl+L继续查找下一个。 如果找到程度领空的话，ctrl+f9返回。跳到第5步。 如果找不到的话，可以在堆栈中搜X省略后两位的数据，看能不能搜到。 实在找不到，就在堆栈里肉眼找相近的地址。（前提是程序领空） 找到后，前往“返回到”对应的地址。看“相近的地址”是第几个参数，加上相应的偏移。每有一个参数就加4 。之后就可以正常逆向了。 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:2:11","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"汇编实例 x,z,y [[[D0DF1C]+1C]+28]+3C,40,44 #运行时出错 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] fld [ecx+44] #y 入浮点栈 fld [ecx+40] #z fld [ecx+3C] #x fstp [esp] #x 出浮点栈 fstp [esp+4] #z fstp [esp+8] #y 手动建立一个堆栈的结构体 push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 mov edx,[00D0DF1C] mov eax,[edx+1C] mov ecx,[eax+28] push [ecx+44] #y push [ecx+40] #z push [ecx+3C] #x push 0 push 10 push 00D1F930 lea eax,[esp+0C] #结构体指针 push eax mov ecx,00D0DEC8 call 00445AB0 add esp,0C #堆栈平衡 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"防检测 调试检测 VM检测（虚拟机） EXE检测 DLL检测 行为检测 抓特征 CRC检测 数据检测 堆栈检测 Call的其它检测 内存检测 ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["任鸟飞"],"content":"2D 3D朝向算法 2D平面 传奇 只有8个方向（一个内存地址） 2D平面 剑灵 勇者 均匀的增加了更多角度 （一个内存地址） 2D平面 天刀 射雕 （两个内存地址） 3D球型 天刀狩猎 （三个内存地址） 1/z = 距离/z差 1/x = 距离/x差 距离的平方=z差平方+l的平方 l的平方=x差的平方+y差的平方 3D球型 CF 逆战 （三个内存地址） ","date":"2021-08-10","objectID":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["任鸟飞","汇编"],"title":"任鸟飞笔记","uri":"/2021/08/%E4%BB%BB%E9%B8%9F%E9%A3%9E%E7%AC%94%E8%AE%B0/"},{"categories":["C++"],"content":" #include\u003ciostream\u003e #include \u003climits\u003e using namespace std; int main() { cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; cout \u003c\u003c \"bool: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(bool); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cbool\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"char: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cchar\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"signed char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(signed char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003csigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned char: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned char); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned char\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"wchar_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(wchar_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cwchar_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"short: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(short); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::max)(); cout \u003c\u003c \"\\t\\t最小值：\" \u003c\u003c (numeric_limits\u003cshort\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"int: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(int); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cint\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cint\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"unsigned long: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(unsigned long); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cunsigned long\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cdouble\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"long double: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(long double); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003clong double\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"float: \\t\\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(float); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cfloat\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"size_t: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(size_t); cout \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::max)(); cout \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003csize_t\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"string: \\t\" \u003c\u003c \"所占字节数：\" \u003c\u003c sizeof(string) \u003c\u003c endl; // \u003c\u003c \"\\t最大值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::max)() \u003c\u003c \"\\t最小值：\" \u003c\u003c (numeric_limits\u003cstring\u003e::min)() \u003c\u003c endl; cout \u003c\u003c \"type: \\t\\t\" \u003c\u003c \"************size**************\"\u003c\u003c endl; return 0; } ","date":"2021-08-10","objectID":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/:0:0","series":null,"tags":["C++"],"title":"输出您电脑上各种数据类型的大小","uri":"/2021/08/%E8%BE%93%E5%87%BA%E6%82%A8%E7%94%B5%E8%84%91%E4%B8%8A%E5%90%84%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%A7%E5%B0%8F/"},{"categories":["C++"],"content":"runoob C++教程 语言中文网C++教程 ","date":"2021-08-08","objectID":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/:0:0","series":null,"tags":["C++","非官方教程"],"title":"C++非官方教程","uri":"/2021/08/c-%E9%9D%9E%E5%AE%98%E6%96%B9%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"一、L\"str\" 如 L\"我的字符串\" 表示将ANSI字符串转换成unicode的字符串，就是每个字符占用两个字节。 strlen(“asd”) = 3; strlen(L\"asd\") = 6; 二、 _T(“str”) _T(“str”)是一个宏，定义于tchar.h下,他的作用是让你的程序支持Unicode编码。 如果定义了UNICODE 那么_T(“ABCD”) 相当于 L\"ABCD\" ，这是宽字符串。 否则_T(“ABCD”) 就等价于 “ABCD” ","date":"2021-08-08","objectID":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/:0:0","series":null,"tags":["C++"],"title":"L和_T()的区别","uri":"/2021/08/l%E5%92%8C_t%E7%9A%84%E5%8C%BA%E5%88%AB/"},{"categories":["C++"],"content":"#pragma once 与 #ifndef 解析 为了避免同一个文件被include多次，C/C++中有两种方式，一种是#ifndef方式，一种是#pragma once方式。在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别。 方式一： #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 方式二： #pragma once … … // 声明、定义语句 #ifndef的方式受C/C++语言标准支持。它不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被不小心同时包含。 当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，编译器却硬说找不到声明的状况——这种情况有时非常让人抓狂。 由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始支持#pragma once的方式。 #pragma once一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的两个文件。你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件。 其好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。大型项目的编译速度也因此提高了一些。 对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，这种重复包含很容易被发现并修正。 #pragma once方式产生于#ifndef之后，因此很多人可能甚至没有听说过。目前看来#ifndef更受到推崇。因为#ifndef受C/C++语言标准的支持，不受编译器的任何限制；而#pragma once方式却不受一些较老版本的编译器支持，一些支持了的编译器又打算去掉它，所以它的兼容性可能不够好。一般而言，当程序员听到这样的话，都会选择#ifndef方式，为了努力使得自己的代码“存活”时间更久，通常宁愿降低一些编译性能，这是程序员的个性，当然这是题外话啦。 还看到一种用法是把两者放在一起的： #pragma once #ifndef SOMEFILE_H #define SOMEFILE_H … … // 声明、定义语句 #endif 看起来似乎是想兼有两者的优点。不过只要使用了#ifndef就会有宏名冲突的危险，也无法避免不支持#pragma once的编译器报错，所以混用两种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑。 选择哪种方式，应该在了解两种方式的情况下，视具体情况而定。只要有一个合理的约定来避开缺点，我认为哪种方式都是可以接受的。而这个已经不是标准或者编译器的责任了，应当由程序员自己或者小范围内的开发规范来搞定。 btw：我看到GNU的一些讨论似乎是打算在GCC 3.4（及其以后？）的版本取消对#pragma once的支持。不过事实上，我手上的GCC 3.4.2和GCC 4.1.1仍然支持#pragma once，甚至没有deprecation warning，倒是GCC2.95会对#pragma once提出warning。 VC6及其以后版本亦提供对#pragma once方式的支持，这一特性应该基本稳定下来了。 ","date":"2021-08-08","objectID":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/:0:0","series":null,"tags":["C++"],"title":"pragma once与ifndef 解析","uri":"/2021/08/pragma-once%E4%B8%8Eifndef%E8%A7%A3%E6%9E%90/"},{"categories":["菜鸟C++笔记"],"content":"C++类与对象 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"CEdit类 为Edit控件关联变量 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:1","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"CString类 CString 成员函数用法 // CStringA，CStringW CString::GetBuffer //获取字符串地址 char*或者wchar_t* CString::Format格式化函数 //类似printf CString::Empty() //清空 CString::GetLength() //返回字符串长度 字节数 CString::IsEmpty() //判断字符串是否为空 CString::LoadString(资源ID) //加载资源字符串 CDialogEx类 CButton类 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:1:2","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"C++类的构造函数与析构函数 类成员函数 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:2:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"枚举类型 enum 枚举名{ 标识符[=整型常数], 标识符[=整型常数], ... 标识符[=整型常数] } 枚举变量; ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:3:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"extern变量声明 #include \u003ciostream\u003eusing namespace std; // 变量声明 extern int a, b; extern int c; extern float f; int main () { // 变量定义 int a, b; int c; float f; // 实际初始化 a = 10; b = 20; c = a + b; cout \u003c\u003c c \u003c\u003c endl ; f = 70.0/3.0; cout \u003c\u003c f \u003c\u003c endl ; return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:4:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"全局变量和局部变量 全局变量和和局部变量同名时，可通过域名在函数中引用到全局变量，不加域名解析则引用局部变量。 #include\u003ciostream\u003eusing namespace std; int a = 10; int main() { int a = 20; cout \u003c\u003c ::a \u003c\u003c endl; // 10 cout \u003c\u003c a \u003c\u003c endl; // 20 return 0; } 在 VS2013 环境，对全局变量的引用以及重新赋值，直接用全局变量名会出现：count 变量不明确的问题。 在变量名前加上 :: 符号即可。 #include \u003ciostream\u003e using namespace std; int count = 10; //全局变量初始化 int main() { ::count = 1; //全局变量重新赋值 for (;::count \u003c= 10; ++::count) { cout \u003c\u003c\"全局变量count=\"\u003c\u003c ::count \u003c\u003c endl; } return 0; } ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:5:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["菜鸟C++笔记"],"content":"C++ 中的类型限定符 类型限定符提供了变量的额外信息。 限定符 含义 const const 类型的对象在程序执行期间不能被修改改变。 volatile 修饰符 volatile 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 restrict 由 restrict 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/:6:0","series":null,"tags":["C++","菜鸟C++笔记"],"title":"C++ 笔记01-10基础","uri":"/2021/08/c-%E7%AC%94%E8%AE%B001-10%E5%9F%BA%E7%A1%80/"},{"categories":["C++"],"content":"跨进程调用CALL ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CreateRemoteThread 创建远程进程 HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, //进程句柄. _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL _In_ SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M _In_ LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址 _In_ LPVOID lpParameter, //线程参数 _In_ DWORD dwCreationFlags, //线程的创建标志 _Out_ LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); ​ 线程的创建标志. 值 含义 0 线程创建后立即运行 CREATE_SUSPENDED 0x00000004 线程创建后先将线程挂起,直到 ResumeThread 被调用. STACK_SIZE_PARAM_IS_A_RESERVATION0x00010000 dwStackSize 参数指定为线程栈预订大小,如果STACK_SIZE_PARAM_IS_A_RESERVATION没有被指定,dwStackSize 参数指定为线程栈分配大小. ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:1:1","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"DLL注入调用CALL CWinApp::InitInstance 初始化函数（一般用于MFC初始化实例） ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:2:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"C++类与对象 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CEdit类 为Edit控件关联变量 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:1","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"CString类 CString 成员函数用法 // CStringA，CStringW CString::GetBuffer //获取字符串地址 char*或者wchar_t* CString::Format格式化函数 //类似printf CString::Empty() //清空 CString::GetLength() //返回字符串长度 字节数 CString::IsEmpty() //判断字符串是否为空 CString::LoadString(资源ID) //加载资源字符串 CDialogEx类 CButton类 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:3:2","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"结构体与联合体(联合类型) struct 结构类型 { int n; char s[1]; double d; }结构类型; union 联合类型1 { int n; char s[1]; //12 double d; }联合类型A; typedef union 联合类型2 { int n; char s[5]; double d; float a; }联合类型B; // 加typedef的话，联合类型B就是别名 // 不加typedef的话，联合类型B就是全局变量 // union 联合类型 所有成员共享一片内存，大小的话，以最大成员需求为准 ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:4:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["C++"],"content":"lstrcpy 与 _tcscpy 拷贝字符串 lstrcpy 既能作用于ASCII又能用于UNICODE， 兼容宏 #ifdef UNICODE #define lstrcpy IstrepyW #else #define lstrepy lstrepyA #endif // !UNICODE _tcscpy MessageBox MessageBoxA MessageBoxW Istropy IstrepyA IstrepyW ","date":"2021-08-07","objectID":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/:5:0","series":null,"tags":["C++"],"title":"C++知识点(二)","uri":"/2021/08/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%BA%8C/"},{"categories":["GitHub"],"content":"图标fontawesome 图标dashgame 留言板disqus 留言板valine 搜索algolia 自动发布travis google分析 sitemaps.xml检查 ghproxy加速站 ","date":"2021-08-07","objectID":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/:0:0","series":null,"tags":["GitHub","网址整理"],"title":"GitHub网址整理","uri":"/2021/08/github%E7%BD%91%E5%9D%80%E6%95%B4%E7%90%86/"},{"categories":["Git"],"content":"git使用总结 Git 分布式版本管理系统 Git 命令清单 workspace: 工作区 Index/Stage: 暂存区 Repository: 仓库区(或本地仓库) Remote: 远程仓库 ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:0:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"新建代码库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 细崽一个项目和它的整个代码历史 $ git clone [url] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:1:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"配置 Git 的配置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name \"[name]\" $ git config [--global] user.email \"[email address]\" ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:2:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每一个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并将这次删除放入暂存区 $ git rm [file1] [file2] # 停止追踪指定文件，但该文件会保留在工作区 $ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区 $ git mv [file-original] [file-renamed] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:3:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"代码提交 # 提交暂存区到仓库区 $ git commit -m [message] # 提交暂存区的指定文件到仓库区 $ git commit [file1] [file2] ... -m [message] # 提交工作区自上一次commit之后的变化，直接到仓库区 $ git commit -a # 提交时显示所有的diff信息 $ git commit -v # 使用一次新的commit，替代上一次提交 # 如果代码没有任何变化，则用来改写上一次commit的提交信息 $ git commit --amend -m [message] # 重做上一次commit,并包括指定文件的新变化 $ git commit --amend [file1] [file2] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:4:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"分支 # 列出所有本地分支 $ git branch # 列出所有远程分支 $ git branch -r # 列出所有本地分支和远程分支 $ git branch -a # 新建一个分支，单依然停留在当前分支 $ git branch [branch-name] # 新建一个分支，并切换到该分支 $ git cleckout -b [branch] # 新建一个分支，并指向指定commit $ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系 $ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区 $ git checkout [branch-name] # 切换到上一个分支 $ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间 $ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支 $ git merge [branch] # 选择一个commit，合并近当前分支 $ git cherry-pick [commit] # 删除分支 $ git branch -d [branch-name] # 删除远程分支 $ git push origin --delete [branch-name] $ git branch -dr [remote/branch] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:5:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"标签 # 列出所有tag $ git tag # 新建一个tag在当前commit $ git tag [tag] ＃新建一个tag在指定commit $ git tag [tag] [commit] # 删除本地tag $ git tag -d [tag] # 删除远程tag $ git push origin :refs/tags/[tagName] # 查看tag信息 $ git show [tag] ＃提交指定tag $ git push [remote] [tag] # 提交所有tag $ git push [remote] --tags # 新建一个分支，并指向某个tag $ git checkout -b [branch] [tag] ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:6:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"查看信息 # 显示有变更的文件 $ git status # 显示当前分支的历史版本 $ git log # 显示commit历史，以及每次commit发生变更的文件 $ git log --stat # 搜索提交历史，根据关键词 $ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行 $ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其”提交说明“必须符合搜索条件 $ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名 $ git log --follow [file] $ git whatchanged [file] # 显示指定文件相关的每一次diff $ git log -p [file] # 显示过去的5次提交 $ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序 $ git shortlog -sn # 显示指定文件是什么人在什么时间修改过 $ git blame [file] # 显示暂存区和工作区的差异 $ git diff # 显示暂存区和上一个commit的差异 $ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异 $ git diff HEAD # 显示两次提交之间的差异 $ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码 $ git diff --short --shortstat \"@{0 day ago}\" # 显示某次提交的元数据和内容变化 $ git show [commit] # 显示某次提交发生变化的文件 $ git show --name-only [commit] # 显示某次提交时，某个文件的内容 $ git show [commit]:[filename] # 显示当前分支的最近几次提交 $ git reflog ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:7:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"远程同步 # 下载远程仓库的所有变动 $ git fetch [remote] # 显示所有远程仓库 $ git remote -v # 显示某个远程仓库的信息 $ git remote show [remote] # 增加一个新的远程仓库，并命名 $ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并 $ git pull [remote] [branch] # 上传本地指定分支到远程仓库 $ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突 $ git push [remote] --force # 推送所有分支到远程仓库 $ git push [remote] --all ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:8:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"撤销 # 恢复暂存区的指定文件到工作区 $ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区 $ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区 $ git checkout . # 重置暂存区与工作区，与上一次commit保持一致,但工作区不变 $ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致 $ git reset --hard # 重置当前分支的指针未指定commit，同时重置暂存区，但工作区不变 $ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 $ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变 $ git reset --keep [commit] # 新建一个commit，用来撤销指定commit # 后者的所有变化都将被前者抵消，并且应用到当前分支 $ git revert [commit] # 暂时将未提交的变化移除，稍后再移入 $ git stash $ git stash pop ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:9:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"其他 # 生成一个可供发布的压缩包 $ git archive ","date":"2021-08-06","objectID":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/:10:0","series":null,"tags":["Git"],"title":"Git使用总结","uri":"/2021/08/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"},{"categories":["Git"],"content":"Git pwd 显示当前目录 git init 初始化仓库 ls -ah 查看隐藏文件及目录 git add \u003cfile\u003e 添加文件 git commit -m \u003cmessage\u003e 提交说明 git status 仓库状态 git diff \u003cfile\u003e 查看差别 git log 日志 git reflog 查看命令历史 git reset --hard commit_id 回退 用HEAD表示当前版本 上一个版本就是HEAD^ 上上一个版本就是HEAD^^ 往上100个版本HEAD~100 git rm \u003cfile\u003e 删除 git checkout -- test.txt 恢复 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:1:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"GitHub ssh-keygen -t rsa -C \"youremail@example.com\" 创建SSH Key 登陆GitHub，打开“Account settings”，“SSH Keys”页面。 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容 点“Add Key”，你就应该看到已经添加的Key： git remote add origin git@github.com:xinqinew/test.git 本地仓库关联到GitHub仓库 git push -u origin master 首次推送并关联 git push origin master 日常推送 git remote -v 查看远程库信息 git remote rm \u003cname\u003e 与远程库解除关系 git clone git@github.com:xinqinew/test.git 克隆远程库 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:2:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"分支 git branch dev 创建分支dev git switch dev git checkout dev 切换分支dev git switch -c dev git checkout -b dev 创建并切换分支dev git branch 查看当前分支 git merge dev 合并dev分支到当前分支 git branch -d dev 删除dev分支 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:3:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"标签 git tag \u003cname\u003e 创建标签 git tag 查看所有标签 git tag \u003ctagname\u003e f52c633 对历史打标签 git tag -a \u003ctagname\u003e -m \"message\" 创建带有说明的标签，用-a指定标签名，-m指定说明文字 git show \u003ctagname\u003e 查看标签信息 git tag -d \u003ctagname\u003e 删除标签 git push origin \u003ctagname\u003e 推送指定标签 git push origin --tags 推送所有标签 git push origin :refs/tags/\u003ctagname\u003e 删除远程标签 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:4:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"忽略特殊文件 在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class # 不排除.gitignore和App.class: !.gitignore !App.class GitHub官方提供的各种忽略文件配置 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:5:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["Git"],"content":"参考网站-廖雪峰 git-cheat-sheet.pdf ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:6:0","series":null,"tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["GitHub"],"content":"首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可)。 等几分钟，等到它显示 “好消息！Cloudflare 正在保护您的站点” 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/:0:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定Cloudflare及freenom","uri":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/"},{"categories":["GitHub"],"content":"freenom域名申请 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:0:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["GitHub"],"content":"freenom.com设置DNS freenom.com中选择Services-My Domains-\u003eManage Domain 然后选择选择下面的nameservers-\u003ecustom nameservers(enter below) 前面两行分别填入 BROAD.DNSPOD.NET PHONE.DNSPOD.NET 然后点击Change Nameservers 上述操作的意思是,不使用freenom.com的默认DNS,而是授权给DNSpod来处理域名解析 DNSpod设置 进入DNSPOD,实名认证后选择: DNS管理-\u003e我的域名-\u003e添加域名xinqi.cf https://console.dnspod.cn/dns/list 然后点击绿色小按钮右侧的域名xinqi.cf得到 下图: https://console.dnspod.cn/dns/yuchi.ml/record githubpage设置 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:1:0","series":null,"tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["博客"],"content":"GitHub Pages 不仅不花钱，而且还有免费的证书拿，可以说是相当划算的。但有个问题就是 GitHub 的服务器都部署在海外，也就是说在国内访问本博客的速度的速度会比较慢 (Ping 下来 100 到 200 多毫秒)。 解决这一问题的最优解就是使用 CDN。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:0:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"CDN 是什么？ 内容分发网络（英语：Content delivery network 或 Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。  —— 维基百科 简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。 世界上的 CDN 服务提供商有很多，七牛云、阿里云、腾讯云等等都提供了 CDN 服务，它们有的收费有的部分免费。我今天选择的 CDN 服务来自于 Cloudflare。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:1:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"Why Cloudflare？ Cloudflare 是全球最大的 DNS 服务提供商之一 (号称是全球最快的 DNS 1.1.1.1 就是它们搞的)。除此之外他们还提供 CDN、SSL 证书、DDos 保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。我今天要使用的就是免费版的 SSL 证书以及 CDN 服务。 除了 Cloudflare 比较 NB 以外选择他的另一个更重要的原因是国内的 CDN 无一例外都要要求域名在公安局备过案。作为一个遵纪守法的好市民，我肯定是不怕什么公安局备案的，我主要是觉得太麻烦了。并且在公安局备案后，放到网站上的那个小图标有点丑 ,,Ծ‸Ծ,, ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:2:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"配置 CDN 首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)，有钱也可以选择收费的，提供的服务更多。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可) 等几分钟，等到它显示 Great news! Cloudflare is now protecting your site 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:3:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"设置 SSL 证书 除了免费的 DNS 和 CDN 以外，Cloudflare 还提供了免费的 SSL 证书。 Cloudflare 的 SSL 证书默认是已经开启了的。不过最好还是在 Crypto 页面将 Always Use HTTPS 勾选上，这个选项可以自动在访问你的网站时将所有的 http 的链接重定向到相应的 https 链接上。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:4:0","series":null,"tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"使用Hugo+LoveIt主题搭建博客 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 Hugo 可参考Hugo 官方的 Quick Start ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装二进制（Mac） # 使用brew安装hugo brew install hugo # 创建新项目（网站） hugo new site my_website # 生成用于发布的静态文件（不包含草稿） hugo # 生成用于发布的静态文件（包括草稿） hugo -D # 本地运行网站 hugo server ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"直接使用 Docker # 创建新项目（网站） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo \\ new site my_website # 生成用于发布的静态文件（不包含草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo # 生成用于发布的静态文件（包括草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo -D # 本地运行网站 docker run --rm -it \\ -v $(pwd):/src \\ -p 1313:1313 \\ klakegg/hugo \\ server 可以在镜像后面增加版本号，指定使用的hugo版本 # 比如 docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo:0.82.0 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 LoveIt 主题 # 位于你的博客项目根目录 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 代码克隆成功后在./themes文件夹下应出现LoveIt文件夹。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"项目文件树结构 . ├── archetypes # markdown文章的模版 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，主要发布这个 ├── resources # 通过hugo命令一起生成的资源文件，暂时不知道什么用 ├── static # 静态文件，比如文章中的图片/视频文件、缩略图等 └── themes # 保存可用的hugo主题 通常，我们只会用到以下几个文件夹的东西 config.toml ：保存 hugo 的配置，包括主题的配置等。详细设置见下方 #网站配置 content：保存网站的各种内容，比如文章。 archetypes： 保存文章的 markdown 模版，通常包括文章的前缀注释，是一些在创建新文章时会被用到。 static ：保存文章中用到的静态文件，比如图片、网站缩略图等。 public ：通过hugo命令生成的静态 html 文件、css、js 等。在服务器上发布时主要发布这个文件夹。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置网站设置 配置文件位置：./config.toml 引用 具体的配置条目参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置缩略图 使用的网站：https://realfavicongenerator.net/ 获取缩略图的各种格式 下载到的全部内容\" 下载到的全部内容 将整个压缩包的文件（包括图片之外的文件）放到./static下 重启浏览器，应该可以看到标签上的缩略图出现了。 浏览器标签出现缩略图\" 浏览器标签出现缩略图 缩略图没生效？ 缩略图未生效的原因可能是浏览器使用了之前的缓存。尝试： 彻底关闭并重启浏览器。 通过这个步骤强制删除缓存。 强制 Chrome 禁用网页缓存。 打开 Chrome 开发者工具。（网页空白处右键-检查，或者按 F12） 在Network栏勾选Disable cache。 或者在设置里找到Preferences -\u003e Network -\u003e Disable cache ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:5:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"开始写第一篇文章 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"文章前缀参数 在每篇 markdown 文章最前面可以用一部分注释来告诉LoveIt主题，这篇文章的属性，譬如文章标签、分类、是否为草稿等。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"将文章前缀参数保存在 markdown 模版中 模版文件位置：./archetypes/default.md 我使用的md模版 --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} draft: true tags: [] categories: [] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: \"\" featuredImagePreview: \"\" license: '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' --- ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成新文章 生成新文章的命令： hugo new posts/文章标题.md 执行完成后，在./content/posts目录下应该可以看到新文件，同时里面已经有 markdown 模版中的文章前缀参数。 技巧 也可以手动复制旧文章来生成新文章，不通过命令。 也可以在content文件夹下建新的文件夹，方便管理。这种情况下生成的静态 Html 文件路由效果如下： . └── content └── about | └── index.md // \u003c- https://example.com/about/ ├── posts | ├── firstpost.md // \u003c- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // \u003c- https://example.com/posts/secondpost/ └── quote ├── first.md // \u003c- https://example.com/quote/first/ └── second.md // \u003c- https://example.com/quote/second/ ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:3","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"本地调试 本地调试命令： hugo server --disableFastRender 本地运行网站\" 本地运行网站 出现成功的提示后在浏览器打开http://localhost:1313即可看到网站。 Bug 如果你看到如图的编译错误，可能是因为你的文章除了前缀参数外没有任何内容。随便写几句话就可以解决这个问题。 有文章为空时的编译报错\" 有文章为空时的编译报错 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:4","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 Github 仓库 个人建议创建两个仓库： 一个用于托管博客项目源文件，包括配置文件等包含后续可能配置 API KEY 的东西。设置权限为 Private（不公开） 一个用于托管博客编译后生成的静态 Html 文件(即使用 hugo 命令编译生成的public文件夹)，并配置该仓库使用 Github Pages，然后 Github 就会自动检测到它其中的静态Html文件并搭建网站。设置权限为 Public（公开） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第一个仓库 按照常规方式创建仓库即可，反正设置为private权限等级，也没人看得见。 第一个仓库示例，保存博客源代码\" 第一个仓库示例，保存博客源代码 链接本地仓库与远端仓库 ## 位于博客源代码根目录 ## 初始化本地Git仓库 git init ## 设置名为Origin的远端Git仓库 git remote add origin {{这里替换成你的仓库在Github Clone用的地址}} ## 选择所有文件 git add -A ## Push到github git push -u origin master 创建.gitignore 在源代码项目中创建.gitignore文件，来防止把生成的静态文件上传。创建位置如下： . ├── .git ├── .github ├── .gitignore \u003c---- 在根目录下 ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes 在.gitignore中写入/public，来防止 Git 将其上传。 cat .gitignore ## 输出 /public ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第二个仓库 创建仓库，注意名称 第二个仓库名字比较重要，必须是{{你的github用户名}}.github.io。 比如我的 Github 名字为JellyZhang,那么我需要创建的仓库名称为JellyZhang.github.io，如图所示。 第二个仓库示例（注意仓库名称与自己用户名对应）\" 第二个仓库示例（注意仓库名称与自己用户名对应） 在仓库设置里设置启用Github Pages 找到仓库设置\" 找到仓库设置 找到Pages一栏\" 找到Pages一栏 设置Branch与静态文件位置\" 设置Branch与静态文件位置 这个地方设置Branch为master，静态文件位置为/(root)，原因是我们在下个步骤中会直接将生成的public文件夹中的内容push到master分支的/目录下。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"给源代码仓库添加 Github Action ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 CI 脚本 什么是Github Action? Github Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 在源代码项目根目录下新建.github/workflow/main.yml。(通过 Github Action 网页端操作也可以) . ├── .git ├── .github │ └── workflows │ └── main.yml \u003c---在这里创建 ├── .gitignore ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes main.yml脚本内容： # This is a basic workflow to help you get started with Actionsname:CI# Controls when the action will run.on:# Triggers the workflow on push or pull request events but only for the master branchpush:branches:[master]pull_request:branches:[master]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Hugo setup# You may pin to the exact commit or the version.# uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2euses:peaceiris/actions-hugo@v2.4.13with:# The Hugo version to download (if necessary) and use. Example: 0.58.2hugo-version:latest# optional, default is latest# Download (if necessary) and use Hugo extended version. Example: trueextended:true# optional, default is false- name:Buildrun:hugo- name:Pushes to another repositoryuses:cpina/github-action-push-to-another-repository@masterenv:API_TOKEN_GITHUB:${{ secrets.API_TOKEN_GITHUB }}with:source-directory:\"public\"destination-github-username:\"这里输入你的Github用户名\"destination-repository-name:\"这里输入你的Github用户名.github.io\"user-email:这里输入你的Github邮箱 需要自定义的部分 注意on里的 branch 是否和自己的相同，因为现在 Github 默认分支为 main。 同时最后三行内容需要自行替换。 脚本主要做了以下事情： 创建一个 Hugo 环境 使用 hugo 命令编译代码，产生 public 文件夹 将 public 文件 push 到你的Github用户名.github.io仓库。（也就是你之前创建的第二个仓库） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"设置 Push 用的密钥 为了让 Github Action 脚本有权限将代码 Push 到我们的xx.github.io仓库，我们需要申请一个密钥并告诉它。在 Github 设置中找到Developer settings/Personal access tokens 个人密钥设置界面\" 个人密钥设置界面 新建一个密钥，权限设置把Repo打勾。 新建密钥\" 新建密钥 回到第一个仓库的设置里，选择Secrets（密钥） 仓库密钥设置\" 仓库密钥设置 新建密钥，将刚才生成的个人密钥填进去，名字设为API_TOKEN_GITHUB(跟 CI 脚本里的名称对应即可) 新建仓库密钥\" 新建仓库密钥 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:2","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"观察效果 在 Push 新修改到第一个仓库后，在Action界面可以看到新的workflow开始运行了。 第一个仓库workflow界面（图中已经完成）\" 第一个仓库workflow界面（图中已经完成） 在workflow结束后，可以在第二个仓库看到新的Push 第二个仓库自动push了新的静态页面\" 第二个仓库自动push了新的静态页面 在等待 1-2 分钟后，即可在xx.github.io观察到变化。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:3","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置评论系统 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"GitTalk GitTalk是基于 github 的 repo issues 作为数据库来存储评论的。 Love-It主题集成了GitTalk ，需要使用的话只需要在config.toml里填写指定信息就可以了。 首先要去Github -\u003e Settings -\u003e Developer Settings -\u003e OAuth App 里注册一个新的 OAuth App 来给 Gitalk 使用。 两个 Url 填自己博客的地址就行。 注册OAuth App\" 注册OAuth App 修改config.toml: [params.page.comment] enable = true \u003c-- 启用评论系统 ... [params.page.comment.gitalk] enable = true owner = \"JellyZhang\" \u003c-- Github用户名 repo = \"blog-comment\" \u003c-- 用来存放评论的repo名称 clientId = \"\" \u003c-- 申请好的OAuth的ClientId clientSecret = \"\" \u003c-- 申请好的OAuth的ClientSecret 升级Gitalk来防止403问题 Gitalk 1.6.2版本 存在一个自身 Bug，它里面用到了一个链接来依赖某个下游，而事实上这个链接是 demo 演示用的，已经因为滥用被取消了，所以需要将 LoveIt 主题使用的 1.6.2 版本改成1.7.2 修改./themes/LoveIt/assets/data/cdn/jsdelivr.yml中的Gitalk的链接： ...metingJS:meting@2.0.1/dist/Meting.min.js# gitalk@1.6.2 https://github.com/gitalk/gitalkgitalkCSS:gitalk@1.7.2/dist/gitalk.min.css \u003c-- 改为1.7.2gitalkJS:gitalk@1.7.2/dist/gitalk.min.js \u003c-- 改为1.7.2# valine@1.4.14 https://valine.js.org/valineJS:valine@1.4.14/dist/Valine.min.js... 在本地环境看不到生效？ 评论系统在本地运行时不生效，需要 publish 后查看效果。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:1","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置搜索系统 LoveIt集成了两种搜索引擎，Lunr和algolia。 两种搜索引擎的区别 参考LoveIt 官方文档 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 我这里记录algolia的配置方法。 首先需要在配置文件中新增Outputs的JSON类型，用于产生index.json文件来提供给搜索引擎。 config.toml: [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] 设置后，在使用hugo命令编译后应该可以在public文件夹下找到index.json 之后在algolia注册账号并创建一个application与index: 创建application, freePlan一般够用\" 创建application, freePlan一般够用 然后在API Keys里找到appID和searchKey: 在API Keys里找到appId与searchKey\" 在API Keys里找到appId与searchKey config.toml: [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"\" \u003c--- 你创建的index的名字 appID = \"\" \u003c--- Application ID searchKey = \"\" \u003c--- Search-Only API Key 然后可以上传生成的index.json到 algolia 来生成索引，实现搜索功能。 手动上传index.json的方法\" 手动上传index.json的方法 当然，每次生成完上传index.json未免太过麻烦，况且我们还是用Github Action来自动编译的，因此接下来我们让Github Action来帮我们上传index.json到algolia。 首先生成一个 Admin API Key 用于调用 API 来上传 index.json: 生成Admin API Key\" 生成Admin API Key 然后修改我们的Github Action的脚本： 在`main.yml`末尾加上：- name:Algolia Index Uploader# You may pin to the exact commit or the version.# uses: rxrw/algolia-index-uploader@294d1d600c4a2197a64903b6161cc80acea1becbuses:rxrw/algolia-index-uploader@v1with:# Your Algolia IndexPathindex_path:public/index.json \u003c-- 生成的index.json位置，默认即可# Algolia Index Idalgolia_index_id:XXXXXXXXX \u003c-- 你的indexId, 即之前获得的`application ID`# Algolia Index Namealgolia_index_name:XXXX \u003c--- 你创建的index名字# Algolia Admin Keyalgolia_index_admin_key:XXXXXXXXXXXX \u003c--- 上图中获取的admin Key 之后运行脚本即可在algolia在 dashboard 里看到新增的记录。 algolia新增了record\" algolia新增了record 删除文章后需要删除旧Record 每次上传的记录是增量的，意味着不会清除旧的记录。 因此如果删除了发布过的旧文章，需要手动去algolia网站上清理相关的 Object。（也可以使用 Clear 功能全部清除） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:10:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Analytics 网站分析 Google analytics是将用户的动作行为收集后发送到 Google，交由 Google 进行统计与分析，形成看板。 在Google analytics创建媒体资源 –\u003e 添加数据流 –\u003e 网站，之后在数据流详情里获取到衡量ID: 获取衡量ID\" 获取衡量ID 之后可以在Dashboard里查看网站的用户行为，有很多内容可以慢慢探索。 Google analytics Dashboard\" Google analytics Dashboard ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:11:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Search Console 首先确定自己的站点地图有正常生成。打开/sitemap.xml链接： sitemap\" sitemap 之后在Google Search Console里填写自己站点地图的链接，可以帮助谷歌爬虫了解网站结构。 上传sitemap\" 上传sitemap 显示`无法获取`? 事实上是没有问题的，谷歌可能有点延迟。可以在bing webmaster tool 导入 Google 的设置，可以看到 bing 是可以立即获取的。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:12:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"参考文献 LoveIt 官方文档 Hugo 官方文档 刷新 Chrome 缓存 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:13:0","series":null,"tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"欢迎留言！😄 ","date":"2021-08-04","objectID":"/message-board/:0:0","series":null,"tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["博客"],"content":"Hugo使用algolia搜索 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"背景 在将hexo迁移到hugo后我就开始折腾博客搜索了，下面的配置正对loveit主题配置 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"开启algolia搜索 在config.toml中添加下面字段，xxxxx是必填，你可以参考loveit主题中的config.toml # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] # algolia注册的索引名称 index = \"xxxxx\" # 在你注册完成后，点击API Keys就能看见下面的参数 appID = \"xxxxx\" searchKey = \"xxxxx\" ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"自动提交索引到algolia 又又用到了npm,好在集成到travis中眼不见为净。 在config.toml同级目录下运行npm init，一路回车即可。 修改npm int生成的package.json添加下面字段 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在config.toml同级目录添加.env文件并添加下面字段 ❯ cat .env ALGOLIA_APP_ID=U9QMQ70DKL ALGOLIA_INDEX_NAME=gaojila.github.io ALGOLIA_INDEX_FILE=public/index.json 修改.travis.yml文件如下 language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装搜索插件- npm install atomic-algolia --save-devscript:# 运行hugo命令- hugo# 生成索引命令- echo \"ALGOLIA_ADMIN_KEY=$ALGOLIA_ADMIN_KEY\" \u003e\u003e .env- npm run algoliaafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 在travis中添加变量$ALGOLIA_ADMIN_KEY ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"参考链接 aligolia的其他配置可以看下面的链接 dreamsafari.info nashome.cn ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"Hugo使用travis自动发布","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Hugo使用travis自动发布 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"背景 从hexo迁移到hugo后，发布博客开始变的繁琐，没有hexo -d这样的快捷部署，但是好在有travis这样的免费CI平台，在使用travis来部署博客的确快捷了很多，只需要发布源码即可。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Github获取token 记下 Token 的值 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"设置Travis CI 使用github帐号注册一个travis帐号，登录在hugo仓库上打上，然后再点击setting然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"编写.trabis.yml language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.debscript:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 hugo 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色代表正在部署 红色 代表部署失败 灰色 代表部署被取消 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:4:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"相关文章 使用 Travis CI 自动部署 Hugo 博客 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:5:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"通过 Travis CI 来部署 Hugo 或者 Hexo 博客可能在配置的时候会麻烦一点，但配置好后确实是方便了不少。特别是对于 Hugo 这种没有部署插件的静态网站生成器，只能手动部署到 GitHub。 网上有很多关于用 Travis 自动部署 Hexo 的文章，却没看到几篇关于 Hugo，虽然原理都差不多，但细节上还是有很多容易让小白头疼的地方，所以今天我就来教教如何用 Travis 来自动部署 Hugo。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"正文 废话不多说，我们开始吧！ ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置代码仓库 首先确保你的 GitHub 上有这两个仓库：用来部署博客的 [用户名].github.io 和 用来存放 “源码” 的 Blog 这里与别的使用 Travis 自动部署博客教程稍微有点不同，别人家大多上将博客的源码放在 [用户名].github.io 的分支上，而不是向我一样开两个仓库 开两个仓库的好处有： 结构更清晰。与博客相关的内容都在 Blog 仓库里， [用户名].github.io 只用来提供一个 GitHub Pages 的服务 「源码」存放在 master 分支下，clone 更快 我不知道上我的原因还是 GitHub 或是 Git 的原因，我从 GitHub clone 除 master 分支以外的分支时，下载速度贼慢，只有几百 kb 每秒，clone 一个 「源码」 都至少要半个多小时 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:1","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"申请 Token 然后要去 GitHub 上申请一个新的 personal access token。 Token description 也就是 Token 的名字，可以随便填。然后一定要勾选上 repo 上的所以项目，然后别的项目一个都不要选。点 Generate token 生成 Token。 然后记下 Token 的值，也就是我打码的那一部分 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:2","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置 Travis CI 接着来到 Travis CI，使用 GitHub 帐号登录；然后为 Blog 仓库打上 ☑，然后点 setting。 然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击 Add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:3","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"编写 .travis.yml 在 Blog 的目录下创建并编辑一个 .travis.yml 文件。这个文件的作用是告诉 Travis CI 如何部署你的博客的 language:gogo:- \"1.8\"# 指定Golang 1.8# Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建# branches:# only:# - masterinstall:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.51/hugo_0.51_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装主题- git clone [你使用的主题的 Git 地址]script:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[你的名字]\"- git config user.email \"[你的邮箱]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:[用来部署博客的 Git 地址]deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 Copy 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 Blog 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色 代表正在部署 红色 代表部署失败 灰色 代表部署被取消 然后再去你的博客，如果没有出什么偏差的话就说明部署成功了 | ・ω・’） 以后的话就只需要把写好的文章推送到 Blog 仓库 下就可以了，就不需要再自己编译然后手动推送了 甚至连 Hugo 都可以不要装 | ・ω・’） ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:4","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"附录 以及一些坑 (:з)∠) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"添加 .gitignore 文件 在 Hugo 本地编译时会产生 public 文件夹，但是这个文件夹中的内容对于 Blog 仓库 来说是不需要的 (包括用来存放主题的 themes 文件夹和主题产生的 resources 文件夹也是不需要的) 我们可以用一个.gitignore 文件来排除这些内容 在 Blog 目录下创建并修改 .gitignore，然后提交到 GitHub public/* themes/* resources/* Copy ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:1","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"Travis CI 的分支白名单 我给你的 .travis.yml 文件中有怎么一段 # Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建branches:only:- master Copy 这一段的作用是限制触发构建的分支。这在正常开发中是很重要的配置，特别是在团队 (多人) 开发的场景中。 不过这里不存在这个场景，并且如果配置错了会出很大的问题，很容易坑到小白， 比如说我 (:з)∠) 所以默认就给注释掉了。 如果你晓得这是干啥的，并且觉得有必要的话，可以考虑开启 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:2","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"相关文章 使用 Hugo + GitHub Pages 搭建个人博客 为 Hugo 添加谈笑风生区 (Gitalk) 为 Hugo 博客添加字数统计 Leavelt 主题优化 为博客添加独立域名 为博客添加免费的 CDN (Cloudflare) 为 LeaveIt 主题添加阅读进度条 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:3:0","series":null,"tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":null,"content":"模板 ","date":"2021-08-04","objectID":"/2021/08/md%E6%A8%A1%E6%9D%BF/:0:0","series":null,"tags":["GitHub","博客"],"title":"md模板","uri":"/2021/08/md%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"万能代码安装说明 将以下代码放置在您希望 Disqus 加载的地方： \u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e \u003cscript\u003e /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://xinqinew.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); \u003c/script\u003e \u003cnoscript\u003ePlease enable JavaScript to view the \u003ca href=\"https://disqus.com/?ref_noscript\"\u003ecomments powered by Disqus.\u003c/a\u003e\u003c/noscript\u003e （推荐）使用您的 CMS 或平台的动态值编辑推荐的配置变量部分。 请参阅我们的文档以了解为什么定义标识符和 url 对防止重复线程很重要。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:1:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"如何显示评论计数 在网站关闭\u003c/body\u003e标签之前放置以下代码： \u003cscript id=\"dsq-count-scr\" src=\"//xinqinew.disqus.com/count.js\" async\u003e\u003c/script\u003e 将 #disqus_thread 附加到链接中的 href 属性。 这将告诉 Disqus 查找哪些链接并返回评论计数。 例如：\u003ca href=\"http://foo.com/bar.html#disqus_thread\"\u003eLink\u003c/a\u003e ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:2:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"设置完成！ 恭喜你，你安装完Disqus！这里有几页可以帮助您开始使用Disqus。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:3:0","series":null,"tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo 最终还是投入Hugo的怀抱，原因是： 熟悉和欣赏Go 发现一个超级喜欢的Hugo主题 - LoveIt 本文记录下博客从Jekyll迁移到Hugo的过程。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:0:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"创建项目 安装Hugo sudo pacman -S hugo 创建名称为Demo的新项目 hugo new site Demo 添加主题（此为必需步骤，可以选择其他主题） cd Demo \u0026\u0026 git init \u0026\u0026 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 也可以自行下载主题，放置于 Demo/themes 目录下 但作为submodule添加进Git项目是一个更好的方式 创建示例文章 hugo new posts/first.md 产生的文件位于是 Demo/content/posts/first.md 启动Hugo服务 hugo server 本地预览访问 http://localhost:1313/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:1:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"文章迁移 hugo import jekyll /Volumes/video/GitHub/xinqinew.github.io /Volumes/video/GitHub/Eureka2 Hugo提供了迁移命令import，可以方便地将Jekyll项目转换为Hugo项目，包括文章和其他静态资源文件。 命令格式是hugo import jekyll JEKYLL_ROOT_PATH TARGET_PATH，其中 JEKYLL_ROOT_PATH 是Jekyll项目主目录，TARGET_PATH 是新生成的Hugo项目目录。 以我的一篇文章为例，原Jekyll项目中的位置是 _post/2020-07-29-cpp-template-notes.md，Hugo项目中的位置是 content/post/2020-07-29-cpp-template-notes.md，需要注意的是，迁移前后文件名保持一致，划重点后面用到。 Jekyll Front Matter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- Hugo Front Matter ---categories:- 编程语言date:\"2020-07-29T00:00:00Z\"tags:- C++- Templatetitle:C++类与模板--- 同时需要注意，Jekyll和Hugo在FrontMatter变量的定义有区别，划重点。 Jekyll Hugo date post文件名或FrontMatter指定，FrontMatter重写前者 FrontMatter指定 title post文件名指定 FrontMatter指定，即文章标题 filename N/A 即文件名（不包含扩展名） section N/A content下的目录名 以 2020-07-29-cpp-template-notes.md 为例， 对于Jekyll，date是 2020-07-29，title是 cpp-template-notes； 对于Hugo，date是 2020-07-29，title是 C++类与模板，filename是 2020-07-29-cpp-template-notes。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:2:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"URL规则 URL规则在全局配置文件（config.toml）的 permalinks 进行配置，也可以使用文章HugoFrontMatter的 url 变量指定（优先级高于前者）。 需要保证，无论URL规则是否变化，都能通过原始URL访问到文章。 对于迁移后的三种情形： 保持原有URL规则 如果原Jekyll的permalink配置使用 title 变量，相应地在Hugo下使用 filename 变量，由于迁移前后文件名保持一致，这将破坏原有的URL规则，可以采取两个方案： 使用HugoFrontMatter的 url 变量指定原始URL 去除迁移后文件名的date部分 个人采用第一种，因为通过文件名可以区分哪些是迁移前的文章。 老文章保持原有URL规则，新文章采用新的URL规则 老文章使用HugoFrontMatter的 url 变量指定原始URL，新文章采用全局 permalinks 配置，这种方式实现起来最简单，但URL规则不统一，看着很不规范，不推荐！ 采用新的URL规则 如果原Jekyll的permalink配置使用 title 变量，使用HugoFrontMatter的 url 变量指定新URL； 使用HugoFrontMatter的 aliases 变量指定原始URL，实现页面重定向。 对于我的博客，原Jekyll的URL规则是 permalink:/:year/:month/:day/:title 在Hugo下使用了新的URL规则 [permalinks]posts = \"/:section/:year/:month/:day/:filename/\" JekyllFrontMatter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- HugoFrontMatter ---title:C++类与模板categories:- 编程语言tags:- C++- Templatedate:2020-07-29 00:00:00+08:00url:/posts/2020/07/29/cpp-template-notes/aliases:- /2020/07/29/cpp-template-notes/--- Hugo import命令无法满足我的场景，而且HugoFrontMatter变量按照首字符顺序排序，看着实在难受，本着轮子能造就造的原则，写了一个转换工具，仅对_posts下文章进行转换，有需要可以尝试下，项目地址是 https://github.com/caosiyang/convert-jekyll-to-hugo ，嗯，这个硬广阔以：） ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:3:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"GitHub Pages发布 执行hugo命令，在 public 目录下生成静态网站，push里面的内容到github就可以了。 Hugo官方提供的方案是submodule方式，如下： $ rm -rf public $ git submodule add -b master https://github.com/\u003cUSERNAME\u003e/\u003cUSERNAME\u003e.github.io.git public $ hugo 发布新的Hugo页面时遇到了问题，顺便说一下吧。 之前我的博客项目已经托管在GitHub，我把原repo重命名了（暂且称“A\"），新建一个repo（暂且称为“B”），名字是.github.io，然后push页面，之后浏览，“首页/分类/标签/关于”页面都是正常的，而“文章”页面还是原始的Jekyll生成的页面，初以为是缓存问题，过了一晚还这样，怀疑跟A有管，把A删除，问题仍然存在，之后又把B删除，重新建repo和push，恢复正常。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:4:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"博客历程回顾 最初产生写博客的想法是2011年，试用了当时几个流行的技术博客平台（csdn/cnblogs/cppblog），最终选择了cnblogs。 2015年了解到GitHub Pages可以搭建博客，当时已经在用GitHub，所以不假思索地转过去，使用Jekyll搭建了新博客，看了很多主题，选了一个并进行小改，但并不满意，最后抱着学习前端的想法，自己写了一个相当相当粗糙的主题，凑合用着了。 后来先后了解到Hexo和Hugo，同为热门的静态网站生成工具，前者node.js实现，后者Go实现，看过它们的主题，感觉都比Jekyll的好看，也很玄学，但迟迟没有折腾，现在想来，能坚持更博就不错了。 2020年是不平凡的一年，新冠疫情爆发，我的工作生活发生了很大变化，在一段闲暇的日子里，又开始琢磨博客，在看到一个相当中意的Hugo主题，坚定了我转到Hugo的决心，于是有了现在的博客。 参考文档 https://gohugo.io/tools/migrations/ https://gohugo.io/commands/hugo_import_jekyll/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:5:0","series":null,"tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"安装Lovelt博客","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Lovelt博客 下载地址 安装文档 参考-晓的记忆 LoveIt参考站2 LoveIt参考站3 LoveIt参考站4 参考1 参考2 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"1 准备 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2 安装 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.1 创建你的项目 hugo new site LoveIt cd LoveIt ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.2 安装主题 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt git submodule add https://ghproxy.com/https://github.com/dillonzq/LoveIt.git themes/LoveIt # 代理 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:2","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:3","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:4","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:5","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:6","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3 配置 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"google搜索优化 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源，如https://skyao.io/learning-hugo/。会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。 进入资源页面，点\"索引\"下的\"站点地图\"，在\"添加新的站点地图\"处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://skyao.io/learning-hugo/sitemap.xml。 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:1","series":null,"tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客 http://themes.jekyllrc.org/ https://jekyllthemes.io/ jekyll-rtd-theme minimal-mistakes/ flexible-jekyll ","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装先决条件 在 Mac 和 Windows 上，下载并安装Docker Desktop。在 Linux 上，安装Docker 引擎和Docker compose。 安装可能需要您重新启动计算机以使更改生效。 安装 git。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从文档示例模板创建存储库 文档示例存储库提供了一个基本的站点结构，您可以将其用作创建自己文档的起点。 使用docsy-example模板 创建自己的存储库。 通过克隆新创建的存储库，将代码下载到本地机器。 将工作目录更改为新创建的文件夹： cd docsy-example ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"构建并运行容器 文档示例存储库包括一个Dockerfile，可用于运行站点。 构建docker镜像： docker-compose build 运行已构建的图像： docker-compose up 在网页浏览器中打开地址http://localhost:1313以加载文档示例主页。您现在可以对源文件进行更改，这些更改将在浏览器中实时重新加载。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"清理 要清理系统并删除容器映像，请按照以下步骤操作。 使用Ctrl + C停止Docker作曲。 移除生成的图像 docker-compose rm ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装docsy主题","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装docsy主题 下载并安装npm ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"作为npm模块 您可以npm使用hugo-bin. 这会添加hugo-bin到您的node_modules文件夹并将依赖项添加到您的package.json文件中。要安装 Hugo 的扩展版本： npm install hugo-extended --save-dev ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装 PostCSS 要构建或更新站点的 CSS 资源，您还需要PostCSS创建最终资产。如果您需要安装它，您必须在您的机器上安装最新版本的NodeJS，以便您可以使用npmNode 包管理器。默认情况npm下，在您运行的目录下安装工具npm install： sudo npm install -D autoprefixer sudo npm install -D postcss-cli ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"选项 1：复制 Docsy 示例站点 该示例站点为您提供了一个很好的起点构建您的文档的网站，并预先配置为使用Docsy主题为Git的子模块。您可以通过以下方式复制示例站点： 使用 GitHub 用户界面 使用命令行 使用 GitHub 用户界面 这是最简单的方法，因为 Docsy 示例站点存储库是一个模板存储库。要创建您自己的 Docsy 示例站点存储库副本： 转到repo 页面并单击Use this template。 在存储库名称字段中输入您为新存储库选择的名称。您还可以添加可选的Description。 单击从模板创建存储库以创建新存储库。恭喜，您现在拥有一个 Docsy 站点存储库！ 要使用 Hugo 在本地测试您复制的站点，或进行本地编辑，您还需要制作新存储库的本地副本。为此，请使用git clone, 替换https://github.com/my/example.git为您的存储库的网址（不要忘记使用，--recurse-submodules否则您将不会下拉生成工作站点所需的一些代码）： cd /Volumes/video/GitHub/Hugo git clone --recurse-submodules --depth 1 https://github.com/xinqinew/Docsy.git //git clone --recurse-submodules --depth 1 https://ghproxy.com/https://github.com/xinqinew/Docsy.git cd Docsy hugo server 您现在可以编辑站点源文件的本地版本。要预览您的站点，请转到站点根目录并运行hugo server（请参阅 MacOS 上的已知问题）。默认情况下，您的站点将在 http://localhost:1313/ 上可用。要将更改推送到您的新存储库，请转到您的站点根目录并使用git push. ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 错误：too many open files或fatal error: pipe failed 默认情况下，MacOS 允许少量打开的文件描述符。对于较大的站点，或者当您同时运行多个应用程序时，当您运行hugo server以在本地预览站点时，您可能会收到以下错误之一： POSTCSS v7 及更早版本： ERROR 2020/04/14 12:37:16 Error: listen tcp 127.0.0.1:1313: socket: too many open files POSTCSS v8 及更高版本： fatal error: pipe failed 解决方法 暂时允许更多打开的文件： 通过运行查看您当前的设置： sudo launchctl limit maxfiles 65535通过运行以下命令增加对文件的限制。如果您的站点文件较少，您可以选择设置较低的软 ( 65535) 和硬 ( 200000) 限制。 sudo launchctl limit maxfiles 65535 200000 ulimit -n 65535 sudo sysctl -w kern.maxfiles=200000 sudo sysctl -w kern.maxfilesperproc=65535 请注意，您可能需要为每个新 shell 设置这些限制。 详细了解这些限制以及如何使它们永久化。 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:4","series":null,"tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装Eureka博客","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Eureka博客 官方文档 cd /Volumes/video/GitHub/Eureka git init git submodule add https://github.com/wangchucheng/hugo-eureka.git themes/eureka 切换版本方法如下: cd themes/eureka git checkout v0.8.2 #git checkout \u003ceureka_version\u003e #eureka_version 替换成版本号 接下来，将exampleSite中的config文件夹复制到项目根目录下，对config文件夹的内容进行配置。配置后删除原先的config.toml文件即可。 如果你是新建的Hugo项目，content文件夹下默认没有内容。你可以将exampleSite中的content文件夹复制到项目根目录下预览主题效果。 完成以上步骤后使用以下命令即可在浏览器中预览项目： hugo server 草稿不会被Hugo部署，所以你需要将内容头部的draft属性设为false或使用hugo server -D预览网站。 内容管理 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"目录结构 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文章页 文章内容为Eureka默认的文章结构，因此新建文章页时不需指定其类型。 hugo new posts/\u003cyour_post.md\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文档页 新建文档页时需指定其类型为docs。 hugo new -k docs docs/\u003cyour_doc\u003e/\u003cyour_page.md\u003e 如果你此前没有创建过文档类型的内容，你需要先生成文档列表： hugo new -k docs docs ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建作者页 新建作者页时需指定其类型为authors。 hugo new -k authors authors/\u003cyour_author\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言"],"content":"植物大战僵尸","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","series":null,"tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":["易语言"],"content":"植物大战僵尸 .版本 2 .程序集 窗口程序集_启动窗口 .程序集变量 process, 整数型 .程序集变量 BaseAddress, 整数型 .程序集变量 setoff1, 整数型 .程序集变量 setoff2, 整数型 .程序集变量 PlantAddress, 整数型 .程序集变量 ZombiesAddress, 整数型 .程序集变量 图像x, 整数型 .程序集变量 图像y, 整数型 .程序集变量 真实x, 整数型 .程序集变量 真实y, 整数型 .子程序 _选择框_不消耗阳光_被单击 .如果 (选择框_不消耗阳光.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“90 90”)) .否则 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“2b f3”)) .如果结束 .子程序 __启动窗口_创建完毕 process ＝ 进程_取进程句柄 (“PlantsVsZombies.exe”) BaseAddress ＝ 内存_读整数型 (process, 十六到十 (“6aa00c”)) ' 基址 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) ' 一级偏移 PlantAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“ac”)) ' 植物 ZombiesAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“90”)) ' 僵尸 时钟_监视进程.时钟周期 ＝ 3000 按钮割草机CALL.禁止 ＝ 真 .子程序 _按钮_阳光9999_被单击 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) 内存_写整数型 (process, setoff1 ＋ 十六到十 (“5560”), 9999) .子程序 _选择框_无冷却_被单击 .如果 (选择框_无冷却.选中 ＝ 真) 时钟1.时钟周期 ＝ 1000 .否则 时钟1.时钟周期 ＝ 0 .如果结束 .子程序 _时钟1_周期事件 .局部变量 onePlant, 整数型 .局部变量 Index, 整数型 .局部变量 setoffPlant, 整数型 setoffPlant ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .计次循环首 (10, Index) ' onePlant ＝ 内存_读整数型 (process, setoffPlant+十六到十(\"4c\") ＋ (Index － 1) × 80) 内存_写整数型 (process, setoffPlant ＋ 十六到十 (“4c”) ＋ (Index － 1) × 80, 5000) ' 无冷却 .计次循环尾 () .子程序 _选择框_无冷却1_被单击 .如果 (选择框_无冷却1.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“E9 CB 6B 2A 00 90 90”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“C7 47 24 88 13 00 00 83 47 24 01 8B 47 24 E9 24 94 D5 FF”)) .否则 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“83 47 24 01 8B 47 24”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00”)) .如果结束 .子程序 _选择框_自动收集_被单击 .如果 (选择框_自动收集.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 01”)) .否则 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 00”)) .如果结束 .子程序 _选择框_子弹叠加_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“90 90 90 90 90 90”)) .否则 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“0F 85 98 FE FF FF”)) .如果结束 .子程序 _按钮_更改卡槽_被单击 .局部变量 setoffxxx, 整数型 setoffxxx ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .如果真 (卡槽组合框.现行选中项 ＝ 0) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 1) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 2) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 18) .如果真结束 .如果真结束 .子程序 _按钮_种植CALL_被单击 asm_置代码 () asm_pushad () asm_push (-1) ' 固定-1 asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID asm_mov_eax_常数 (到整数 (编辑框_y.内容)) ' Y asm_push (到整数 (编辑框_x.内容)) ' X asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) asm_push_ebp () ' ebp asm_mov_ebx_常数 (十六到十 (“40d120”)) asm_call_ebx () ' call asm_popad () asm_ret () asm_调用函数2 (process, asm_取代码 ()) .子程序 _按钮_乱种CALL1_被单击 .局部变量 坐标x, 整数型 .局部变量 坐标y, 整数型 .局部变量 index1, 整数型 .局部变量 index2, 整数型 .局部变量 index3, 整数型 坐标x ＝ 0 坐标y ＝ 0 .计次循环首 (3, index3) .如果 (index3 ＝ 1) 编辑框_植物ID.内容 ＝ “38” .否则 .如果 (index3 ＝ 2) 编辑框_植物ID.内容 ＝ “40” .否则 编辑框_植物ID.内容 ＝ “43” .如果结束 ​ .如果结束 ​ .计次循环首 (6, index1) ​ .计次循环首 (6, index2) ​ asm_置代码 () ​ asm_pushad () ​ asm_push (-1) ' 固定-1 ​ asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID ​ asm_mov_eax_常数 (坐标y ＋ index1 － 1) ' Y ​ asm_push (到整数 (坐标x ＋ index2 － 1)) ' X ​ asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) ​ asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) ​ asm_push_ebp () ' ebp ​ asm_mov_ebx_常数 (十六到十 (“40d120”)) ​ asm_call_ebx () ' call ​ asm_popad () ​ asm_ret () ​ asm_调用函数2 (process, asm_取代码 ()) ​ .计次循环尾 () ​ .计次循环尾 () .计次循环尾 () .子程序 _选择框_重叠种植_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 ","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/:0:0","series":null,"tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":null,"content":"知识点描述","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"知识点 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"小知识 ptr 强制类型转换 lea 指令可以用来将一个内存地址直接赋给目的操作数，例如： lea eax,[ebx+8] 就是将ebx+8这个值直接赋给eax mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。 通用寄存器 32 位 16 位 8 位（高） 8 位（低） EAX AX AH AL EBX BX BH BL ECX CX CH CL EDX DX DH DL 32 位 16 位 32 位 16 位 ESI SI EBP BP EDI DI ESP SP 特殊用法 乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。 CPU 默认使用 ECX 为循环计数器。 ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。 ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。 高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。 状态标志位 进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。 溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。 符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。 零标志位（ZF），算术或逻辑操作产生的结果为零时，设置该标志位。 辅助进位标志位（AC），算术操作在 8 位操作数中产生了位 3 向位 4 的进位时，设置该标志位。 奇偶校验标志位（PF），结果的最低有效字节包含偶数个 1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行 错误检测。 64位通用寄存器 操作数大小 可用寄存器 8 位 AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L 16 位 AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W 32 位 EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D 64 位 RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15 整数常量 h 十六进制 r 编码实数 q/o 八进制 t 十进制（备用） d 十进制 y 二进制（备用） b 二进制 26 ;十进制 26d ;十进制 11010011b ;二进制 42q ;八进制 42o ;八进制 1Ah ;十六进制 0A3h ;十六进制 整型常量表达式 运算符 名称 优先级 () 圆括号 1 +,- 一元加、减 2 *, / 乘、除 3 MOD 取模 3 +, - 加、减 4 保留字列表。 $ PARITY? DWORD STDCALL ? PASCAL FAR SWORD @B QWORD FAR16 SYSCALL @F REAL4 FORTRAN TBYTE ADDR REAL8 FWORD VARARG BASIC REAL10 NEAR WORD BYTE SBYTE NEAR16 ZERO? C SDORD OVERFLOW? CARRY? SIGN? 定义段 .DATA 伪指令进行标识： .data .CODE 伪指令标识的程序区段包含了可执行的指令： .code .STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小： .stack 100h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令 一条指令有四个组成部分： 标号（可选） 指令助记符（必需） 操作数（通常是必需的） 注释（可选） 不同部分的位置安排如下所示： [label: ] mnemonic [operands] [;comment] ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"标号 数据标号 count DWORD 100 代码标号 target: mov ax,bx ... jmp target ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:1","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令助记符 助记符 说明 助记符 说明 MOV 传送（分配）数值 MUL 两个数值相乘 ADD 两个数值相加 JMP 跳转到一个新位置 SUB 从一个数值中减去另一个数值 CALL 调用一个子程序 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:2","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"操作数 示例 操作数类型 示例 操作数类型 96 整数常量 eax 寄存器 2+4 整数表达式 count 内存 STC 指令没有操作数： stc ;进位标志位置 1 INC 指令有一个操作数： inc eax ;EAX 加 1 MOV 指令有两个操作数： mov count, ebx ;将 EBX 传送给变量 count IMUL 指令有三个操作数，第一个是目的操作数，第二个和第三个是进行乘法的源操作数： imul eax,ebx,5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:3","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"注释 单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。 块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。 COMMENT ! This line is a comment. This line is also a comment. ! ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:4","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"NOP（空操作）指令 .data ;此为数据区 sum DWORD 0 ;定义名为sum的变量 .code ;此为代码区 main PROC mov eax,5 ;将数字5送入而eax寄存器 add eax,6 ;eax寄存器加6 mox sum,eax INVOKE ExitProcess,0 ;结束程序 main ENDP ; AddTwo.asm -两个 32 位整数相加 .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .code main PROC mov eax,5 ;将数字5送入eax寄存器 add eax,6 ;eax寄存器加6 INVOKE ExitProcess,0 main ENDP END main 第 3 行是 .386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。 第 4 行选择了程序的内存模式（flat），并确定了子程序的调用规范（称为 stdcall）。其原因是 32 位 Windows 服务要求使用 stdcall 规范。 第 5 行为运行时堆栈保留了 4096 字节的存储空间，每个程序都必须有。 第 6 行声明了 ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode。 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:5","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"汇编伪指令回顾 CODE 的下一行声明程序的入口 .code main PROC ENDP 伪指令标记一个过程的结束。 main ENDP END 伪指令标记一个程序的结束，并要引用程序入口： END main ; AddTwo.asm - adds two 32-bit integers. ; Chapter 3 example .386 .model flat,stdcall .stack 4096 ExitProcess PROTO,dwExitCode:DWORD 00000000 .code 00000000 main PROC 00000000 B8 00000005 mov eax, 5 00000005 83 C0 06 add eax,6 invoke ExitProcess,0 00000008 6A 00 push +000000000h 0000000A E8 00000000 E call ExitProcess 0000000F main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:6","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据类型以及数据定义详解 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"内部数据类型 类型 用法 BYTE 8 位无符号整数，B 代表字节 SBYTE 8 位有符号整数，S 代表有符号 WORD 16 位无符号整数 SWORD 16 位有符号整数 DWORD 32 位无符号整数，D 代表双（字） SDWORD 32 位有符号整数，SD 代表有符号双（字） FWORD 48 位整数（保护模式中的远指针） QWORD 64 位整数，Q 代表四（字） TBYTE 80 位（10 字节）整数，T 代表 10 字节 REAL4 32 位（4 字节）IEEE 短实数 REAL8 64 位（8 字节）IEEE 长实数 REAL10 80 位（10 字节）IEEE 扩展实数 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:1","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据定义语句 数据定义语法如下所示： [name] directive initializer [,initializer]… 下面是数据定义语句的一个例子： count DWORD 12345 伪指令 用法 伪指令 用法 DB 8位整数 DQ 64 位整数或实数 DW 16 位整数 DT 定义 80 位（10 字节）整数 DD 32 位整数或实数 ;AddTowSum.asm .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .data sum DWORD 0 .code main PROC mov eax,5 add eax,6 mov sum,eax INVOKE ExitProcess,0 main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:2","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 BYTE 和 SBYTE 数据 value1 BYTE 'A' ;字符常量 value2 BYTE 0 ;最小无符号字节 value3 BYTE 255 ;最大无符号字节 value4 SBYTE -128 ;最小有符号字节 value5 SBYTE +127 ;最大有符号字节 value6 BYTE ? ;变量 val1 DB 255 ;无符号字节 val2 DB -128 ;有符号字节 多初始值 list BYTE 10,20,30,40 偏移量 数值 0000 10 0001 20 0002 30 0003 40 list BYTE 10,20,30,40 BYTE 50,60,70,80 BYTE 81,82,83,84 list1 BYTE 10, 32, 41h, 00100010b list2 BYTE 0Ah, 20h, 'A', 22h list1与list2不同进制，但值相同 定义字符串 greeting1 BYTE \"Good afternoon\",0 greeting2 BYTE 'Good night',0 0作为结束标记 greeting1 BYTE \"Welcome to the Encryption Demo program \" BYTE \"created by Kip Irvine.\",0dh, 0ah BYTE \"If you wish to modify this program, please \" BYTE \"send me a copy.\",0dh,0ah,0 十六进制代码 0Dh 和 0Ah 也被称为 CR/LF （回车换行符）或行结束字符。 greeting1 BYTE \"Welcome to the Encryption Demo program \" 和 greeting1 \\ BYTE \"Welcome to the Encryption Demo program \" 行连续字符（\\）把两个源代码行连接成一条语句，它必须是一行的最后一个字符。上面的语句是等价的。 DUP 操作符 BYTE 20 DUP ( 0 ) ;20 个字节，值都为 0 BYTE 20 DUP ( ? ) ;20 个字节，非初始化 BYTE 4 DUP ( \"STACK\" ) ; 20 个字节： ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:3","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 WORD 和 SWORD 数据 word1 WORD 65535 ;最大无符号数 word2 SWORD -32768 ;最小有符号数 word3 WORD ? ;未初始化，无符号 val1 DW 65535 ;无符号 val2 DW -32768 ;有符号 也可以使用传统的 DW 伪指令 myList WORD 1,2,3,4,5 偏移量 数值 0000 1 0002 2 0004 3 0006 4 0008 5 array WORD 5 DUP (?) ; 5 个数值，未初始化 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:4","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 DWORD 和 SDWORD 数据 val1 DWORD 12345678h ;无符号 val2 SDWORD -2147483648 ;有符号 val3 DWORD 20 DUP (?) ;无符号数组 val1 DD 12345678h ;无符号 val2 DD -2147483648 ;有符号 pVal DWORD val3 myList DWORD 1,2,3,4,5 偏移量 数值 0000 1 0004 2 0008 3 000C 4 0010 5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:5","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 QWORD 数据 quad1 QWORD 1234567812345678h quad1 DQ 1234567812345678h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:3:6","series":null,"tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"C++关键字描述","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/","series":null,"tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["C++"],"content":"C++关键字 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量\"自动\"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ' 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: const double pi(3.14159); 或 const double pi = 3.14159; 10. const_cast用法： const_cast\u003ctype_id\u003e (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是\"继续循环\"之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是\"禁止单参数构造函数\"被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： extern “C” 声明语句 extern “C” { 声明语句块 } 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： reinpreter_cast (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 size","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","series":null,"tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["博客"],"content":"Jekyll 插入图片","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","series":null,"tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["博客"],"content":"Jekyll 插入图片 用 Markdown 插入图片是一件很简单的事，只需要这样写： ![AltText](/path/to/img.jpg) 然而，如果你需要进行更多的控制，情况立刻变得复杂了起来。由于 Markdown 秉持结构和样式分离的原则，你无法在插入图片时控制其大小。要达到这样的目的，你需要使用普通的 \u003cimg\u003e 标签： \u003cimg src=\"/path/to/img.jpg\" width=\"100\" height=\"100\" alt=\"AltText\" /\u003e 相对前一种语法，后者明显麻烦许多。所幸这种情况一般都是极少数。一般来说，我们只需要使用前一种语法。然而，有一种状况会让你需要大量使用后一种语法 —— Retina 屏幕的截图。一张 100pt * 100pt 的截图事实上是 200px * 200px。贴到文章里之后，电脑又会以 200pt * 200pt 的大小来渲染。你的截图立刻变得大而模糊。为了避免这种状况，你需要手动计算图片的实际大小，然后使用 HTML 语法插入图片。当你需要插入大量图片时，这一工作很快变得枯燥而难以忍受。 当然，你可以通过指定比例从而避免手工计算大小： \u003cimg src=\"/path/to/img.jpg\" width=\"50%\" alt=\"AltText\" /\u003e 虽然免去了计算大小，你依然需要使用冗长的 HTML 语法。能不能用 Markdown 语法来做这件事呢？ 我们知道有些 Markdown 方言支持调整图片大小，例如： Mou: ![AltText](/path/to/img.jpg =100x) MWeb: ![AltText-w100](/path/to/img.jpg) ... 显然，这些在 Jekyll 中都是不支持的。不过，我们有更好的方法： ![AltText @2x]() 只需添加 @2x 后缀，图片就会自动缩放为50%大小 这显然不是 Markdown 或 Jekyll 的功能，在你的博客中使用不会有任何效果。真正的魔法在 CSS 样式表中： .post-container img[alt~=\"@2x\"] { zoom: 50%; } 我们用到了 CSS 中的属性选择器，它可以对拥有指定属性的 HTML 元素设置样式。在这里，我们对 alt 中包含 @2x 的所有图片添加了 zoom: 50% 属性。 同理，你也可以为 iPhone * Plus 的截图设置三倍缩放： .post-container img[alt~=\"@3x\"] { zoom: 33%; } ","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/:0:0","series":null,"tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid教程收录","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid教程收录 时间管理、头脑风暴、阅读、会议记录神器-Mermaid Mermaid英文教程 Mermaid在线编辑器 Mermaid，就像用 Markdown 码字一样，高效制作简易流图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:0:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid - 流程图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"基本结构 圆角矩形 表示“开始”与“结束” 矩形表示行动方案、普通工作环节用 菱形表示问题判断或判定（审核/审批/评审）环节 用平行四边形表示输入输出 箭头代表工作流方向 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"流程图与节点的创建 graph 流程图声明 graph S[声明一个流程图] graph s(\"开始(START)\") 语法：id(\":转义字符;\") graph s(\"开始:#9829;\") ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"各方向 graph TB s[开始]--\u003e e[结束] graph BT s[开始]--\u003e e[结束] graph LR s[开始]--\u003e e[结束] graph RL s[开始]--\u003e e[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"节点形状 graph a[矩形] b(圆角矩形) c([体育场]) d[(圆柱)] e((圆形)) graph f{菱形} g{{6}} h\u003e非对称] i[/平行四边形/] j[/梯形\\] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:4","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"线条形状 graph g[开始] --- h[结束] a[开始] -.- b[结束] c[开始] === d[结束] e[开始] --\u003e f[结束] i[开始] -.-\u003e j[结束] k[开始] ==\u003e l[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:5","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"带文字的链接线 graph a[开始] --过程1--- b[结束] c[开始] --\u003e|过程2| d[结束] e[开始] -.过程3.-\u003e f[结束] g[开始] ==过程4==\u003e h[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:6","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"关系链 graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] s--走路--\u003e o[永辉超市]--付钱--\u003e e graph LR s[家] --走路--\u003eP[菜市场]--走路--\u003eL[水果店]--走路--\u003e j[超市]--\u003es graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e s s--网上--\u003e o[永辉超市]--付钱--\u003e s 正常写法 graph z[张三]--\u003eC[内卷] z--\u003eD[躺平] L[李四]--\u003eC[内卷] L--\u003eD 简易写法 graph z[张三] \u0026 L[李四]--\u003eC[内卷] \u0026 D[躺平] 不美观 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--\u003e|躺平|N[喝快乐水] 美观:加长某一项 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X---\u003e|躺平|N[喝快乐水] 增加层级:再加长 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--躺平----\u003eN[喝快乐水] 可用—-\u003e 链接线会增加3个层级的长度 一下是各个类型连接线增加层级长度语法 增加层级长度 1 2 3 实线 — —- —– 带箭头的实线 –\u003e —\u003e —-\u003e 粗实线 === ==== ===== 带箭头的粗实线 ==\u003e ===\u003e ====\u003e 虚线 -.- -..- -…- 带箭头的虚线 -.-\u003e -..-\u003e -…-\u003e ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:7","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"子图表 subgraph graph 节点关系 subgraph title //子图表的名称 子图表的节点关系 end //子图标结束标志 graph TB c1--\u003ea2 subgraph 表1 a1--\u003ea2 end subgraph 表2 b1--\u003eb2 end subgraph 表3 c1--\u003ec2 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:8","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"交互 为节点添加事件 以及点击跳转 这个现在还不是很好用 var callback = function(){ alert('A callback was triggered'); } 源代码： graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 生成效果： graph LR A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 注释 %% 源代码 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C 生成效果 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:9","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"添加样式 方式1 语法： style id key:value,key:value 源代码： graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式2 定义样式 class 语法：classDef className 样式定义 应用 :::classname 源代码： graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式3 css class形式添加样式 定义 \u003cstyle\u003e .cssClass \u003e rect{ fill:red; stroke:#FFFF00; stroke-width:4px; } \u003c/style\u003e 实例： 源代码 graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; 生成效果： graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:10","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"Mermaid - 时序图（序列图） ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"基本结构 角色 Actor 系统角色 可是是人或者其他系统子系统 对象 Object 交互过程中扮演的角色 一般位于时序图顶部 生命线 Lifeline 生命线代表时序图中的对象在一段时期内的存在 控制焦点 Activation 控制焦点代表时序图中的对象执行一项活动的时期 消息 Message 定义交互和协作中交换信息的类 基本对象声明 sequenceDiagram participant 张三 participant 李四 对象声明-别名 Aliases sequenceDiagram participant Z as 张三 participant L as 李四 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:1","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"消息 Message 语法：participant1 箭头 participant2：消息内容 sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003eL:我是没有箭头的实线 L--\u003eZ:我是没有箭头的虚线 Z-\u003e\u003eL:带箭头的实线 L--\u003e\u003eZ:带箭头的虚线 Z-xL:带x箭头实线 L-)Z:结束时候 带箭头的实线 Z--)L:结束时候 带箭头的虚线 线型对照表 线形 含义 -\u003e 无箭头的实线 –\u003e 没箭头的虚线 -» 带箭头的实线 –» 带箭头的实线 -x 带x号箭头实线 –x 结尾x号箭头实线 -) 结束 带箭头的实线 –) 结束 带箭头的虚线 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:2","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"控制焦点 Activations 语法： activate participant //激活 消息 deactivate participant //释放激活 这个有一些抽象我们用一个场景来去理解 场景1： ``` 张三：hi李四你还好么 // 李四听了开始回话 此时李四是激活状态 开始进行对话 李四：hi张三我可以听到你，我很好，不用担心。 //李四会话结束 不会再跟张三有活动 此时李四的激活状态被释放 ``` 源代码： ``` ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L ``` ``` 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L 场景2： 张三：hi李四你还好么 张三：你可以听到我说话么 //李四开始回话 被激活 李四：hi张三我可以听到你 李四：不用担心我 复制代码 源代码： ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:3","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图-批注 Note 语法： 单个对象： Note 位置 of participant:批注内容 多个对象： Note 位置 角色名称1，角色名称2:批注内容 位于对象左侧： 源代码 ```mermaid sequenceDiagram participant 张三 Note left of 张三 :我是张三 生成效果 sequenceDiagram participant 张三 Note left of 张三 :我是张三 ```mermaid sequenceDiagram participant 张三 Note right of 张三 :我是张三 sequenceDiagram participant 张三 participant 李四 Note over 张三,李四 :我是张三 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:4","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图-逻辑循环 Loop 交互过程中表示某些循环的环节 语法： loop 循环描述 循环内容 end //结束标记 复制代码 场景： 李四跟张三是好朋友 李四生病了 张三很关心他 每过一小时 为了不让张三如此担心 李四就约定每一个小时给张三发消息 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:5","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图 抉择（Alt）\u0026选项（Opt） 组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。 Alt 抉择 用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else.. 只能发生一种情况 语法： alt 第一种情况描述 具体发生的动作 else 剩余情况描述 具体发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 如果李四生病了他会说：我不是很好 如果李四很健康他会说：我很好 又是很好的一天 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end opt 选择\" 包含一个可能发生或不发生的序列 就是一种场景有可能发生也有可能不发生 语法： opt 情况描述 有可能发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 李四会可能会说谢谢你的问候也可能不会说 这个并无法预测 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:6","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"时序图 并行关系 par 并行处理: 一个对象同时发出的交互动作 基本语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end 复制代码 场景： participants: 张三 李四 王五 张三 在下午5点分别给李四和王五分一条信息：内容是吃了么 李四回复：吃了 张三回复：没吃 复制代码 源代码 ```mermaid sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 生成效果 sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 嵌套语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end par 动作描述1 participant3 -\u003e\u003e participant4:内容 and 王五发消息给A8 participant3 -\u003e\u003e participant5:内容 end 复制代码 场景： participants: 张三 李四 王五 赵六 A8 王五明天请吃饭 张三发消息问李四明天去不去 同时发消息给王五问明天都有哪些人参加 王五发消息给赵六:明天一起吃饭8 同事也发消息给A8告诉他让他带着小伙伴一起 复制代码 源代码 ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 生成效果 sequenceDiagram participant 张三 participant 李四 participant 王五 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 背景高亮 语法： rect rgba(0,213,123) 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end 生成效果： sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:7","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"类图 classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:3:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"状态图 stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:4:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"实体关系图 erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:5:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"用户旅程图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:6:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"gantt图 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:7:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"饼图 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:8:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown","Mermaid"],"content":"需求图 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:9:0","series":null,"tags":["GitHub","博客","Mermaid"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["C++"],"content":"字符的输入与输出","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"字符的输入与输出 \\b 退格 \\f 走纸换页 \\r 回车 \\t 横向跳格(ctrl-i) ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"格式化字符 %c 字符 %d 十进制整数 %s 字符串 %S or %ws 宽字符串 %x 十六进制整数 %p 指针或地址 %o 八进制整数 %f 小数(浮点数) %u 无符号十进制整数 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"scanf输入 scanf(\"%s\",\u0026str1); ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"指针读写内存","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","series":null,"tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"指针读写内存 #include \u003ccstdio\u003e#define BASE 0x00417000 int g_a = 111; //0x00417000 int g_b = 222; //0x00417004 int g_c = 333; //0x00417008 typedef struct T3 { int a1; //偏移0 int a2; //偏移4 int a3; //偏移8 }TYPE3; int main(int argc, char const *argv[]) { //指针读内存 int* p1=(int*)0x00417000; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,333 printf(\"B:%d,%d,%d \\n\",*(p1+0),*(p1+1),*(p1+2)); //B:111,222,333 printf(\"C:%d,%d,%d \\n\",p1[0],p1[1],p1[2]); //C:111,222,333 printf(\"D:%d,%d,%d \\n\",*(int*)0x0041700,*(int*)0x00417004,*(int*)0x0041708); //D:111,222,333 //用指针向内存地址写入数据 *(p1+2)=11567; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,11567 p1[2]=22567; printf(\"B:%d,%d,%d \\n\",g_a,g_b,g_c ); //B:111,222,22567 *(int*)(0x0041700+8)=333678; printf(\"C:%d,%d,%d \\n\",g_a,g_b,g_c ); //C:111,222,333678 TYPE3* p3 =(TYPE3*)0x00417000; printf(\"%p,%p,%p \\n\",\u0026p3-\u003ea1,\u0026p3-\u003ea2,\u0026p3-\u003ea3); //111,222,333678 printf(\"%d,%d,%d \\n\",p3-\u003ea1,p3-\u003ea2,p3-\u003ea3); //111,222,333678 printf(\"p3=%p,p3+1=%p,sizeof(TYPE3)=%X \\n\",p3,p3+1,sizeof(TYPE3)); //p3=00417000,p3+1=0041700C,sizeof(TYPE3)=C printf(\"p3=%p,p3+2=%p,sizeof(TYPE3)=%X \\n\",p3,p3+2,sizeof(TYPE3)); //p3=00417000,p3+2=00417018,sizeof(TYPE3)=C printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+sizeof(TYPE3)*2); //\u003e\u003e\u003e:p3+2=417018 =417018 printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+0xC*2); //\u003e\u003e\u003e:p3+2=417018 =417018 return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/:0:0","series":null,"tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++知识点","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"C++知识点（一） ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:0:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"阻断函数 getchar() //等待键盘输入回车 sysem(\"pause\")//任意键继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:1:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"常用函数 printf(\"Hello World!\") //输出函数 atoi(arg) //字符串转整数 Sleep(arg) //等待 MessageBeep(1); //播放系统音乐,方便OD定位 __declspec(naked) //裸体函数 void *memcpy(void *str1, const void *str2, size_t n) //内存copy(读取与写入) //str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 //str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 //n -- 要被复制的字节数。 //返回值 -- 该函数返回一个指向目标存储区 str1 的指针。 void *memset(void *s, int ch, size_t n); //内存设置 //将s中当前位置后面的n个字节,用 ch 替换并返回 s 。 size_t strlen(const char *string); //计算给定字符串的长度 (ANSI) size_t wcslen(const wchar_t * str); //strlen函式的宽字节版 (Unicode) BOOL CloseHandle( HANDLE hObject //对象句柄 );//关闭对象句柄。 setlocale(LC_ALL, \"chs\"); //需要实现本地化，以实现中文正常输出 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:2:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"用汇编来调用CALL int pcall =(int)MessageBoxC; __asm { push 0 //4 push 0 //3 push 0 //2 push 0 //1 call dword ptr ds:[MessageBoxA] //第一种 mov eax,MessageBoxB call eax //第二种 call pcall //第三种 ;分号 注释语句 } ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:3:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"循环 break; //退出循环 continue; //跳到循环首部,循环继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:4:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"其它 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_In_ 表示是一个输入参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"_Out_ 表示是一个输出参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026arg 引用 1.必须传变量 2.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:3","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"\u0026变量 取变量地址运算符 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:4","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"*arg 指针 1.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:5","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"冒号: 冒号代表标签,常用于goto跳转 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:6","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"typedef 关键字，作用是为一种数据类型定义一个新名字 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:7","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"三元运算子 条件式 ? 条件式为true时执行的陈述句 : 条件式为false时执行的陈述句 int ret, a = 10, b = 11; bool flag = true; if (flag) ret = a; else ret = b; 等价于 ret = flag ? a : b; ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:8","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"const 声明变量是不变的 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:9","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"define 定义宏,可用于起别名,也可带参数,如 #define hanshu(a,b) (a+b) ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:10","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"指针 LPSTR char* LPCSTR const char* LPCTSTR const TCHAR* LPTSTR TCHAR* LP = 指针 C = const 只读 TSTR = TCHAR ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:11","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"HINSTANCE “句柄型”数据类型。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:12","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"static 关键字 定义静态变量或静态函数,生存周期和全局变量一样,作用域和局部变量一样,初始化仅执行一次. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:5:13","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"char* 定义字符串 char p[256]=\"hijk\"; //可读写 char src2[]=\"opq\"; //可读写 char *p=\"abcd\"; //只读 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcpy 字符串复制(wcscpy宽字节版) char *strcpy(char* dest, const char *src); 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 strcpy_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcat 字符串连接(wcscat宽字节版) extern char *strcat(char *dest, const char *src); strcat_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:3","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strstr 查找字符串(wcsstr宽字节版) string strstr( string1，string2) ​ strstr返回一个指针，指向string2在string1中首次出现的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:4","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strchr 查找字符(wcschr宽字节版) char *strchr(const char *str, int c) 在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:5","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"strcmp 字符串比较(wcscmp宽字节版) extern int strcmp(const char *s1,const char *s2); 当s1\u003cs2时，返回为负数； 当s1=s2时，返回值= 0； 当s1\u003es2时，返回正数. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:6","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"以下仅了解 strrev strncmp strncmpi strerror strncpy strnicmp ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:6:7","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"Unicode字符串(wchar)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"wchar_t 宽字符 wchar_t c1='A'; //单个字符不用加\"L\" wchar_t wStr[]=L\"这是一段中文\"; //字符串前要加\"L\" wchar_t appName[5]=TEXT(\"test\"); //可以用TEXT()方法将char转换成wchar_t char是8位字符类型,wchar_t数据类型一般为16位或32位,wchar_t所能表示的字符数远超char型。 如果你想使用ANSI字符串，那么请使用这一套写法： char szString[100]; strcpy(szString,\"test\"); 如果你想使用Unicode字符串，那么请使用这一套： wchar_t szString[100]; wcscpyszString,L\"test\"); 如果你想通过定义_UNICODE宏，而编译ANSI或者Unicode字符串代码： TCHAR szString[100]; _tcscpy(szString,_TEXT(\"test\")); ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"相关函数见 多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:7:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"TCHAR兼容型字符串及常用函数 TCHAR ANSI Unicode TCHAR char wchar_t _tcscpy() strcpy() wcscpy() _tmain() main() wmain() _tWinMain() WinMain() wWinMain() _T\"str\" “str” L\"str\" _tprintf() printf() wprintf() _tcslen() strlen() wcslen() ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:8:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"DLL动态链接库及入口函数 LoadLibrary 加载动态链接库 HMODULE LoadLibrary(_In_ LPCTSTR lpFileName); __stdcall 参数从右向左压入堆栈 APIENTRY 则表明此函数是应用程序的入口点,其实都是__stdcall winapi 表示此函数是普通的winapi函数调用方式,其实都是__stdcall FreeLibrary 释放动态链接库 BOOL WINAPI FreeLibrary(_In_ HMODULE hModule); FreeLibraryAndExitThread 释放动态链接库并退出线程 void FreeLibraryAndExitThread( HMODULE hLibModule, //模块的句柄 DWORD dwExitCode //调用线程的退出代码 ); DLL_PROCESS_ATTACH 宏 进程载入 // 1 DLL_PROCESS_DETACH 宏 进程卸载 // 0 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:9:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"跨进程分配内存 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:0","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"VirtualAllocEx 向指定进程申请内存 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); ​ flAllocationType 可取下列值： MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储 MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存） MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用 MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效 MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志） MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98） flProtect 可取下列值 PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访 PAGE_READWRITE 区域可被应用程序读写 PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。 PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域。 PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。 PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限 PAGE_NOACCESS： 任何访问该区域的操作将被拒绝 PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached) 注:PAGE_GUARD和PAGE_NOCHACHE标志可以和其他标志合并使用以进一步指定页的特征。PAGE_GUARD标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个one-shot异常，接着取得指定的访问权限。PAGE_NOCACHE防止当它映射到虚拟页的时候被微处理器缓存。这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:1","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["C++"],"content":"VirtualFreeEx 释放申请的虚拟内存空间 BOOL WINAPI VirtualFreeEx( HANDLE hProcess, //目标进程的句柄。 LPVOID lpAddress, //指向要释放的虚拟内存空间首地址的指针 SIZE_T dwSize, //虚拟内存空间的字节数 DWORD dwFreeType );//释放类型 ​ lpAddress ​ 指向要释放的虚拟内存空间首地址的指针。 ​ 如果 dwFreeType 为 MEM_RELEASE, 则该参数必须为VirtualAllocEx的返回值. ​ dwSize ​ 虚拟内存空间的字节数 ​ 如果 dwFreeType 为 MEM_RELEASE，则 dwSize 必须为0 . 按 VirtualAllocEx申请时的大小全部释放。 ​ 如果dwFreeType 为 MEM_DECOMMIT, 则释放从lpAddress 开始的一个或多个字节 ，即 lpAddress +dwSize。 ​ dwFreeType ​ 释放类型，取值见下表： 值 释义 MEM_DECOMMIT0x400016384D 这种试 仅标示 内存空间不可用，内存页还将存在。 MEM_RELEASE0x800032768D 这种方式 很彻底，完全回收。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/:10:2","series":null,"tags":["C++"],"title":"C++知识点(一)","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80/"},{"categories":["GitHub"],"content":"GitHub回退历史版本","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"GitHub回退历史版本 前提是本地已经有了git的origin master库或者克隆需要回退的代码到本地。 ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:0","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"1. 查询历史对应不同版本的ID ，用于回退使用 git log --pretty=oneline 假设查到历史版本的id是 ： 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:1","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"2. 恢复到历史版本 git reset --hard 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:2","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"3. 把修改推到远程服务器 git push -f -u origin master ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:3","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"4. 重新更新 git pull ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:4","series":null,"tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"Git与GitHub绑定","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/","series":null,"tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["GitHub"],"content":"Git与GitHub绑定 终端输入ssh-keygen -t rsa命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 密钥和公钥生成后，把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！ 在 Git Bash 中输入ssh -T git@github.com进行测试： ","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/:0:0","series":null,"tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["博客"],"content":"Hugo常用命令","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","series":null,"tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"Hugo常用命令 新建章节 hugo new –kind chapter /_index.md 新建文件 hugo new //_index.md hugo new /.md hugo new posts/.md 解除环境限制 hugo serve -e production 生成指定模板的样例文章 hugo new –kind post-bundle posts/my-post 实时预览 hugo serve –disableFastRender ","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","series":null,"tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"安装hugo博客","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装hugo博客 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Generate new site 要產生一個新的 web site 內容，可直接執行 hugo new site ssg-site 執行後會建立一個名為 ssg-site 的資料夾，包含以下內容 . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾（可先暫時不管）。 config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。(也支援 yaml 與 json 格式) content: 放置 Markdown 文章與網頁內容的資料夾。 data: 儲存一些 configuration 檔案的地ㄌㄌ方，協助建構靜態網頁(也先不管)。 layouts: 儲存產生的網頁 layout 樣板(之後範例使用其他的 theme，先不管)。 static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。 themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:1","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Import Hugo themes Hugo 並沒有預設的 theme，所以在建立好內容資料夾後，需自行建立 theme 或使用其他 theme，在這我們已 Mainroad theme 做範例。 # 將 mainroid theme 加入 themes/ 中 cd /Users/xinqinew/ssg-site git clone https://github.com/Vimux/Mainroad.git themes/mainroad 除了使用 git 指令外，直接從 Github 上下載最新原始檔案壓縮檔，解壓縮後放到 themes 資料夾中。此外對 git 熟悉的是使用者也可用 git submodule 或 git subtree 等方式管理外部引入的 theme repo。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:2","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Configuration Hugo 在生成 SSG 時會使用到 config.toml 檔案的設定內容。我們可以將之前 Mainroad theme 中的 config.toml 修改後加以使用 # 將 mainroid 的 config.toml 覆蓋原先的預設值 cp themes/mainroad/exampleSite/config.toml . 之後編輯 config.toml 內容，將其修改為自己想要的內容。更詳細的 configuration 設定可參考 Hugo 官方文件 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:3","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新增 Blog 文章 我們可以手動新增 Markdown 文件 hugo new post/hello-world.md 之後會在 ./content/post/hello-world.md 的位置新增一個 Markdown 文件，其中預設內容會根據 archetype/default.md 這個樣板檔案內容加以建立。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:4","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"預覽內容 先將 ./content/post/hello-world.md 內容修改為 --- title: \"Hello World\" date: 2018-07-06T16:00:21+08:00 categories: - \"Blog\" tags: - \"Hugo\" draft: true --- # Hello World. Post example 之後執行以下指令 hugo server --buildDrafts 若在 Markdown 的 Front Matter，加入 draft: true，代表該篇文章為草稿不會被 Hugo 轉換為網頁。因此可在指令後加入 --buildDrafts 來轉換草稿文件。 執行成功後會在 localhost:1313 建立一個暫時的網頁，可接載在瀏覽器網址列輸入預覽結果。 Hugo Mainroad theme 結果預覽 1313 為 Hugo 的預設 Port，可以使用 --port xxx 來指定使用其他 Port ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:5","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成靜態內容 Hugo 要生成靜態網頁內容只執行 hugo 指令即可 hugo 執行後生成的網頁內容會自動加入 public 資料夾中。 public 為預設資料夾，若要修改可在 config 檔案中設定 publishDir 參數指定輸出位置。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:6","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"從 Jekyll 轉移到 Hugo 如果要從其他的 SSG 轉換到 Hugo，官方也提供了一些轉換方式。以從 Jekyll 轉換到 Hugo 為例，只要執行 hugo import jekyll [jekyll_root_path] [target_path] 就會將 Jekyll 轉換為 Hugo 格式資料夾。但這方式也不是沒問題，原先在的 Jekyll 的 theme 無法直接在 Hugo 使用，且有部分 Front Matter 無法正確轉換，因此建議還是手動轉移較好。而因爲個人轉移時選用的 theme 為 Mainroad，在過程中也遇到了一些問題，在此提出來以供參考。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Markdown Front Matter 由於 Hugo 與 Jekyll 所使用的 Front Matter 設定不同，有些部分需要每個檔案逐一修改內容，如 categories 或 tags 的內容，之前使用的 voyager theme 在執行時會成格式不對，需修改將其改為 List 結構，如在 Jekyll 中， categories: posts 是可行的，但換到 Hugo 的 Mainroad theme 時，需使用 List 結構才行，如 categories: [\"posts\"] 才可正常產生靜態網頁，否則會出現錯誤。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:1","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Math equation support 在加入數學式的支援花了一些時間去解決，主要分為兩個問題 - Markdown 轉換成 HTML 以及 Mainroad theme 的 CSS conflict 問題。 Markdown parser support 在加入數學式時，我們習慣直接使用 Latex 語法在 Markdown 中，這樣可以更容易寫出方便的數學式。而 Hugo 預設的 Markdown parser Blackfriday(使用 Go 語言實作的 Markdown parser) 會進行某些預先處理，造成 MathJax 無法正確顯示內容以及斷行的問題。因此需要將原先的 Blackfriday parser 更換成 Mmark，即在 Markdown 文件中使用 Latex 數學式語法。方法為將檔案副檔名命名為 *.mmark，或是在 Markdown Front Matter 中加入 markup: \"mmark\" 來指定使用 Mmark 處理 Markdown 文件。更詳細的內容可參考官網說明。 Katex support 雖然 Mainroad theme 雖然有支援 MathJax，但該 theme 的 CSS style 中有部分和 Katex 的 CSS 設定衝突，造成當把 Mainroad 中的 MathJax 部分的樣板原始碼換成支援 Katex 後，在顯示 Matrix 時會造成跑版。詳情狀況可參考個人發在 GitHub 上的 Issue #1445。在 Katex 小組了解問題並經過 Mainroad 作者修改樣板後即解決了該問題。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:2","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Syntax highlighting 要在 Hugo 中讓程式碼有高亮效果，可在 config 檔案中加入以下設定 # use Chroma for syntax highlight pygmentsCodeFences = true # 啟動 Code Fence 區域的高亮效果 pygmentsCodefencesGuessSyntax = true # 對沒有指定程式類型的 Code Fence 自行推導語言類型 pygmentsStyle = \"fruity\" # 指定使用的高亮風格，如 vim 或 fruity 等(預設為 \"monokai\") 若想換成其他風格可參考這裡的格式，將 pgmentsStyle 的設定修改為該風格 Hugo 就會用該風格顯示 Markdown 中 Code Fence 區段的內容。其他設定可參考 Hugo 官網關於 Syntax Hightlighting 的章節。 pygment 為原先 Hugo 所使用的 Syntax Hightlighting 工具， 在 Hugo 0.28 版後改為 Chroma 為預設內容，但設定檔仍維持原先的格式。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:3","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"首頁大綱內容 Mainroad 的 Markdown 文件顯示在列表中的大綱內容，會是最前面段落開始一直延續到預設長度為止，這在排版上會很難看，因此可以手動在 Markdown 文件中加入 ` ` 標籤隔開大綱與主題內容，如下範例 ...{大綱內容}... \u003c!--more--\u003e ...{文章內容}... 這樣在首頁的列表中就只會顯示大綱內容的部分。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:4","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Disqus Support Hugo 本身所產生的內容為靜態網頁，若要有像留言板之類的動態內容就必須藉助外部服務。Hugo 本身支援 Disqus 這個知名的 Blog 留言服務樣板，只要建立帳號取得 shortname，在 config 檔案中設定完成即可。若使用的 theme 有支援應該能正確顯示 disqusShortname = \"yourdiscussshortname\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:5","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Google Analysis support 和 Disqus 相同，Hugo 也有內部支援 Google Analysis 來統計你網站的流量與人潮。只要去 Google Analysis 申請一組 Tracking Id 並在 config 中加入設定。如 使用的 theme 有支援該功能則會自動設定 googleAnalytics = \"yourtrackingid\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:6","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Reference Hugo Mainroad theme Disqus Katex 从Jekyll迁移到Hugo，Hugo不完全指南 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"\u003c\u003e尖括号","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/","series":null,"tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"\u003c \u003e尖括号 我习惯将尖括号用于指定类型，作为参数: vector\u003cint\u003e vecOfInts ; 但是在rapidjson中，有这样的代码: document.Parse\u003c0\u003e(json) ; document.Parse方法的签名是: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 我不知道您可以在尖括号内传递值-认为尖括号仅用于类型名称。 这里的代码在做什么，为什么他在尖括号中传递一个值？ 这是一个好主意吗？什么时候？ 最佳答案 这里有两个不同的因素。 首先，可以定义除类型以外的参数化模板。例如，这是一个简单的数组类型: template \u003ctypename T, size_t N\u003e struct Array { T arr[N]; }; 我们可以这样使用 Array\u003cint, 137\u003e myArray; 我们知道vector\u003cint\u003e和vector\u003cdouble\u003e是不同的类型。但是现在我们还必须指出，Array\u003cint,137\u003e和Array\u003cint,136\u003e是不同的类型。 其次，使用模板时，编译器必须能够为所有模板参数找出一个值。使用模板类时，这就是为什么通常指定所有模板参数的原因。例如，您不说vector x，而是说类似vector\u003cdouble\u003e x。使用模板函数时，大多数时候编译器可以找出参数。例如，要使用std::sort，您只需说出类似 std::sort(v.begin(), v.end()); 但是，您也可以写 std::sort\u003cvector\u003cint\u003e::iterator\u003e(v.begin(), v.end()); 更明确地说。但是有时候，您有一个模板函数，对于该函数，并非所有参数都可以被找出来。在您的示例中，我们有: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 注意，不能仅从函数的参数推导parseFlags模板参数。因此，要调用该函数，必须指定template参数，否则编译器将无法确定该参数。这就是为什么你会写类似 Parse\u003c0\u003e(myString); 此处，0是模板参数(在编译时解析)，而myString是实际参数(在运行时解析)。 实际上，您可以使用结合了一些类型推断和一些显式类型参数的方法。例如，在Boost中，有一个函数lexical_cast可以在字符串类型之间进行转换。从非字符串类型转换为字符串类型的函数签名是 template \u003ctypename Target, typename Source\u003e Target lexical_cast(const Source\u0026 arg); 在这里，如果您调用lexical_cast，则编译器可以确定Source是什么，但如果没有一些提示，就无法推断出Target。因此，要使用lexical_cast，您需要编写类似 std::string myString = boost::lexical_cast\u003cstd::string\u003e(toConvertToString); 更一般而言，编译器说您必须指定一定数量的模板参数(可选为0)，它将尝试推断其余的参数。如果可以的话，太好了!如果不是，则为编译时错误。如果需要，可以使用此代码编写类似的函数 template \u003cint IntArgument, typename TypeArgment\u003e void DoSomething(const TypeArgument\u0026 t) { /* ... */ } 要调用此函数，您必须像这样调用它: DoSomething\u003cintArg\u003e(otherArg); 在这里，这是可行的，因为您必须显式告诉编译器IntArgument是什么，但是编译器可以从TypeArgument的参数类型推导DoSomething。 ","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/:0:0","series":null,"tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/","series":null,"tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例 雙端隊列或雙頭隊列是序列容器，兩端都有擴展和收縮功能。它們類似於向量，但是在元素的結尾和開始處插入和刪除時效率更高。與向量不同，可能無法保證連續的存儲分配。 deque::clear() clear()函數用於刪除雙端隊列容器的所有元素，從而使其大小為0。 用法: dequename.clear() Parameters : No parameters are passed. Result : All the elements of the deque are removed ( or destroyed ) 例子： Input :mydeque = {1, 2, 3, 4, 5} mydeque.clear(); Output:mydeque = {} Input :mydeque = {} mydeque.clear(); Output:mydeque = {} 錯誤和異常 1.它沒有異常拋出保證。 2.傳遞參數時顯示錯誤。 // CPP program to illustrate // Implementation of clear() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; mydeque.clear(); // Deque becomes empty  // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： No Output deque::erase() erase()函數用於從指定位置或範圍中刪除容器中的元素。 用法: 1. _**dequename.erase(position)**_ 2. _**dequename.erase(startingposition, endingposition)**_ **Parameters :** Position of the element to be removed in the form of iterator. or the range specified using start and end iterator. **Result :** Elements are removed from the specified position of the container. 例子： Input : mydeque{1, 2, 3, 4, 5}, iterator= 2 mydeque.erase(iterator); Output : 1, 2, 4, 5 Input : mydeque{1, 2, 3, 4, 5, 6, 7, 8}, iterator1= 3, iterator2= 6 mydeque.erase(iterator1, iterator2); Output : 1, 2, 3, 8 錯誤和異常 1.如果位置有效，則沒有異常拋出保證。 2.否則顯示未定義的行為。 從特定位置移除元件 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it; it = mydeque.begin(); mydeque.erase(it); // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 2 3 4 5 刪除範圍內的元素 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it1, it2; it1 = mydeque.begin(); it2 = mydeque.end(); it2--; it2--; mydeque.erase(it1, it2); // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 4 5 應用 給定一個整數列表，從雙端隊列中刪除所有偶數元素並打印雙端隊列。 Input :1, 2, 3, 4, 5, 6, 7, 8, 9 Output :1 3 5 7 9 _Explanation - 2, 4, 6 and 8 which are even are erased from the deque_ 算法 1.循環運行，直到雙端隊列大小為止。 2.檢查每個位置的元素是否可被2整除，如果是，則刪除該元素並遞減迭代器。 3.打印最終雙端隊列。 // CPP program to illustrate // Application of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }; deque\u003cint\u003e::iterator i; i = mydeque.begin(); while (i != mydeque.end()) { if (*i % 2 == 0) /* Not a good idea to erase inside loop, if you delete last element, mydeque.end() cannot be found resulting in infinite loop */ mydeque.erase(i); i++; } // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 1 3 5 7 9 clear() VS erase()。什麽時候使用什麽？ **clear()**從雙端隊列容器中刪除所有元素，從而使其大小為0。使用clear()函數刪除雙端隊列中的所有元素。 **erase()**另一方麵，“函數”用於從容器中刪除特定元素或從容器中刪除一係列元素，從而通過刪除元素的數量來減小其大小。 ","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/:0:0","series":null,"tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque insert()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_insert/","series":null,"tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque insert()用法及示例 deque::insert(函数是C++中的内置函数，用于在双端队列中插入元素。 insert()函数可以通过三种方式使用： 通过在一个位置插入新元素val来扩展双端队列。 通过在双端队列中插入n个新值val来扩展双端队列。 通过在(first，last)范围内插入新元素来扩展双端队列。 用法: deque_name.insert (iterator position, const value_type\u0026 val); deque_name.insert (iterator position, size_type n, const value_type\u0026 val); deque_name.insert (iterator position, InputIterator first, InputIterator last); 参数 position–指定要插入元素的位置。 val–指定要分配给新插入元素的值。 n–指定要插入的元素数。每个元素都初始化为val的副本。 first, last–指定迭代器，该迭代器指定要插入的元素范围。范围包括first和last之间的所有元素，包括first指向的元素，但last指向的元素。 返回值 该函数返回一个迭代器，该迭代器指向新插入的元素中的第一个。 示例1: // CPP program to illustrate the // deque::insert() function // insert elements by iterator #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; it = dq.insert(it, 10); // 1 10 2 3 4 5  std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 2 3 4 5 示例2: // CPP program to illustrate the // deque::insert() function // program for second syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); // 0 0 1 2 3 4 5  dq.insert(it, 2, 0); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 0 0 1 2 3 4 5 示例3: // CPP program to illustrate the // deque::insert() function // program for third syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; vector\u003cint\u003e v(2, 10); // 1 10 10 2 3 4 5  dq.insert(it, v.begin(), v.end()); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 10 2 3 4 5 ","date":"2021-07-24","objectID":"/2021/07/deque_insert/:0:0","series":null,"tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque 用法与示例","date":"2021-07-24","objectID":"/2021/07/deque/","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 用法与示例 本篇將介紹如何使用 C++ std deque 以及用法與範例，C++ std::deque 是一個雙向佇列(double-ended queue)，在頭尾兩端插入及刪除十分快速，在中間插入刪除元素比較費時。 std::deque 是 double-ended queue 而不是 double linked list，底層實做是用間接索引的方式實現的，類似一個 map 索引到若干個固定大小的資料區塊(連續記憶體空間)，利用兩次索引達成跟 vector 一樣的隨機訪問功能。 以下將依序介紹幾個 std::deque 容器常用的用法範例，分別為 deque 常用功能 範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 範例2. push_back 自定義類別 範例3. 用 for 迴圈遍歷 deque 容器 範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 deque 的優點與缺點 要使用 deque 容器的話，需要引入的標頭檔: \u003cdeque\u003e ","date":"2021-07-24","objectID":"/2021/07/deque/:0:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 常用功能 以下為 std::deque 內常用的成員函式 修改器 push_back: 把一個元素添加到尾端 push_front: 把一個元素插入到頭端 pop_back: 移除最後一個元素(尾端) pop_front: 移除第一個元素(頭端) insert: 插入元素 erase: 移除某個位置元素, 也可以移除某一段範圍的元素 clear: 清空容器裡所有元素 容量 empty: 回傳是否為空 size: 回傳目前長度 元素存取 [i]: 隨機存取索引值為i的元素 back: 取得最後一個元素 front: 取得第一個的元素 迭代器 begin:回傳指向第一個元素(頭端)的迭代器 cbegin:回傳指向第一個元素(頭端)的迭代器(const) end:回傳指向最後一個元素(尾端)的迭代器 cend:回傳指向最後一個元素(尾端)的迭代器(const) rbegin:回傳指向最後一個元素(尾端)的反向迭代器 crbegin:回傳指向最後一個元素(尾端)的反向迭代器(const) rend:回傳指向第一個元素(頭端)的反向迭代器 crend:回傳指向第一個元素(頭端)的反向迭代器(const) ","date":"2021-07-24","objectID":"/2021/07/deque/:1:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 以下範例為push_back(), pop_front(), push_front(), pop_back() 用法， 其中 push_back() 與 pop_front() 應該是最常用到的函式了。 另外使用 deque 相對於 queue 的好處是deque可以使用隨機訪問的功能 [i]。 std-deque.cpp // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } 輸出內容如下： 0 2 3 4 0 2 3 ","date":"2021-07-24","objectID":"/2021/07/deque/:2:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例2. push_back 自定義類別 以下範例為 std::deque 容器使用 push_back() 來推放 Student 自定義類別的範例，使用 push_back() 來放進 deque 的最尾端，這個範例限制 deque 最多塞3個，多的會用 pop_front() 給 pop 掉，最後再將 deque 容器的所有的元素印出來。 // g++ std-deque2.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; class Student { public: Student(int id) { this-\u003eid = id; } int id; }; std::deque\u003cStudent\u003e d; void deque_push_back(Student a) { d.push_back(a); if (d.size() \u003e 3) { d.pop_front(); } } int main() { Student a1(1), a2(2), a3(3), a4(4); deque_push_back(a1); deque_push_back(a2); deque_push_back(a3); deque_push_back(a4); // 印出 deque 內所有內容, c++11 才支援 for (auto \u0026i : d) { cout \u003c\u003c i.id \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/deque/:3:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例3. 用 for 迴圈遍歷 deque 容器 以下範例是用 for 迴圈配合 deque 容器的迭代器，去遍歷 deque 並且把值印出來，前兩種是從頭印到尾，後兩種是從尾印到頭。從頭端印到最尾端就是使用 begin() 搭配 end() ，從最尾端印到頭端就是使用 rbegin() 搭配 rend() 。 這裡的 begin() / end() 與 cbegin() / cend() 有什麼不同呢？begin() / end() 是回傳 iterator，而 cbegin() / cend() 是回傳 const_iterator，iterator 可以修改元素值，const_iterator 則不可修改，簡單說就是回傳的東西能不能被修改的差異，要用哪種就自行判斷要用哪種了。 cbegin(), cend(), crbegin(), crend() 是 C++11 新增的，要使用時記得編譯器要加入-std=c++11選項。 第一個 for 迴圈裡面的迭代器使用懶人快速寫法auto it = d.begin();，其全名為std::deque\u003cint\u003e::iterator it = d.begin();，如果不想寫這麼長的話，就可以像我一樣用 auto 的懶人快速寫法。 // g++ std-deque3.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 //for (std::deque\u003cint\u003e::iterator it = d.begin(); it != d.end(); ++it) { for (auto it = d.begin(); it != d.end(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從頭到尾 for (auto it = d.cbegin(); it != d.cend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.rbegin(); it != d.rend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.crbegin(); it != d.crend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } 輸出 1 2 3 4 1 2 3 4 4 3 2 1 4 3 2 1 ","date":"2021-07-24","objectID":"/2021/07/deque/:4:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 以下範例是用 while 迴圈在 deque 容器裡搜尋/尋找數字為3，這裡的 auto 懶人快速寫法如上範例解釋相同就不贅述了。 在 while 迴圈裡如果有找到就印個有找到的訊息，假如整個 while 迴圈都沒找到，最後可以判斷 it == d.end() 代表整個 deque 容器都遍歷過了也沒有找到，就印個沒找到的訊息。 // g++ std-deque4.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 int find_num = 3; //std::deque\u003cint\u003e::iterator it = d.begin(); auto it = d.begin(); while (it != d.end()) { if (*it == find_num) { cout \u003c\u003c \"Found \" \u003c\u003c find_num \u003c\u003c endl; break; } it++; } if (it == d.end()) { cout \u003c\u003c \"Not found \" \u003c\u003c find_num \u003c\u003c endl; } return 0; } 輸出 Found 3 如果將 find_num 變數改成 5 去搜尋/尋找的話則會找不到，輸出結果會變成 Not found 5 ","date":"2021-07-24","objectID":"/2021/07/deque/:5:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 的優點與缺點 deque 的優點 可以再兩端進行 push 和 pop 操作 支持隨機訪問[i] deque 的缺點 佔用記憶體較多 ","date":"2021-07-24","objectID":"/2021/07/deque/:6:0","series":null,"tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque和queue容器","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque和queue容器 标准模板库 STL 提供了两种容器：deque 和 queue，以实现和队列类似的数据 结构。deque 是一个双端队列。它类似于矢量，但允许在前端和后端高效地访问值。队列抽象数据类型就像栈抽象数据类型：它实际上是一个容器适配器。 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:0:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque容器 可以将 deque 容器想象成一个矢量，但它可以快速访问前端以及后端的元素（和矢量一样，deque 也可以使用 [] 运算符访问元素）。 图 1 deque 成员函数 使用双端队列 ADT 的程序必须包含 deque 头文件。由于本节更关心它与队列类似的特性，所以就来集中讨论一下 push_back、pop_front 和 front 成员函数，如图 1 所示。它们的示例和相应描述如表 2 所示。 成员函数 示例和描述 push_back iDeque.push back(7); 接受一个值作为参数插入到 deque 中。 参数被插入在最后一个元素之后（被推到 deque 后面） pop_front iDeque.pop front(); 删除 deque 的第一个元素并丢弃它 pop_front cout « iDeque.front() « endl; front 返回对 deque 第一个元素的引用 下面的程序演示了双端队列容器的使用： // This program demonstrates the STL deque container. #include \u003ciostream\u003e#include \u003cdeque\u003eu[sin](http://c.biancheng.net/ref/sin.html)g namespace std; int main() { deque\u003cint\u003e iDeque; cout \u003c\u003c \"I will now enqueue items. . . \\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iDeque.push_back(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while (!iDeque.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iDeque.front() \u003c\u003c endl; iDeque.pop_front(); } return 0; } 程序输出结果： I will now enqueue items. . . Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:1:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"queue容器适配器 queue 容器适配器可以建立在矢量、链表或者双端队列的基础上。默认情况下，它使用一个双端队列作为其基础。 queue 支持的插入和删除操作与栈 ADT 所支持的类似：push、pop 和 front。但是，它们的表现有所不同。queue 版本的 push 始终在队列的后面插入一个元素。queue 版本的 pop 始终从结构的前面删除一个元素。front 函数返回队列前面的元素的值。 下面的程序演示了一个队列。由于该队列的声明没有指定适配哪一种类型的容器，所以该队列将建立在一个双端队列上。 //This program demonstrates the STL queue container adapter. #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int main() { queue\u003cint\u003e iQueue; cout \u003c\u003c \"I will now enqueue items...\\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iQueue.push(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while(!iQueue.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iQueue.front () \u003c\u003c endl; iQueue.pop (); } return 0; } 程序输出结果： I will now enqueue items… Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:2:0","series":null,"tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"ifndef详解","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef详解 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:0:0","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef是\"if not defined\"的简写 #ifndef起到的效果是防止一个源文件多次包含同一个头文件, 而不是防止两个源文件包含同一个头文件。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:0","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"一、防止头文件的重复包含和编译 #ifndef \u003c标识\u003e #define \u003c标识\u003e ...... ...... #endif 标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的\".“也变成下划线，如：stdio.h #ifndef _STDIO_H #define _STDIO_H ...... ...... #endif ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:1","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"二、便于程序的调试和移植 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #ifndef 标识符 #define 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #if 表达式 程序段 1 #else 程序段 2 #endif 它的作用是当“表达式”值为真时，编译“程序段1”，否则编译“程序段2”。 注：以上三种形式中#else不是强制的，可省略；当然，当#else后需要嵌套#if时，可以使用预处理命令#elif，它相当于#else#if。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:2","series":null,"tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"queue 和 deque的区别","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/","series":null,"tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue 和 deque的区别 从使用的角度来讲主要差别就是： deque支持push_front、pop_front、push_back、pop_back。 queue支持push_back、pop_front。 deque是双端队列 #include\u003cdeque\u003e template\u003ctypename T,typename Allocator=std::allocator\u003cT\u003e\u003eclass deque; 支持push_front、pop_front、push_back、pop_back等几种操作的。queue是容器适配器，他的声明是 #include\u003cqueue\u003e template\u003ctypename T,typename Container=std::deque\u003cT\u003e\u003eclass queue; 类型Container是用来存储元素的，相当于是这个queue的实现。这个queue模板看起来像是包装了这个Container类型，只提供一些特殊的接口，使他看起来想一个queue。 模板参数Container需要满足顺序容器的条件，而且必须支持front、back、push_back、pop_front操作，标准容器中有deque和list满足。也就是说标准容器中deque和list可以封装成queue。 ","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/:0:0","series":null,"tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue与deque示例","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"queue与deque示例 queue ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:0:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例1：queue #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { queue\u003cint\u003e myQueue; cout \u003c\u003c myQueue.empty() \u003c\u003c endl; cout \u003c\u003c myQueue.size()\u003c\u003c endl; myQueue.push(1); myQueue.push(2); myQueue.push(3); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; myQueue.pop(); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; return 0; } 运行结果： 1 0 1 3 2 3 queue没找到迭代器 deque: deque是双向队列Double ended queue；can be accessed with random access iterator deque是双端队列，是可以在两端扩展和收缩的连续容器。一般deque的实现是基于某种形式的动态数组，允许单个元素用随机获取 迭代器随机读取，数组容量自动管理。 因此它有和vector相似的函数，但在序列的开始也有高效的插入和删除。但不像vector，deque的元素并不是严格连续存储的。 vector和deque有相似的接口和相似的目的，但内部实现截然不同。 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:1:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例二：deque #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cdeque\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { deque\u003cint\u003e myDeque; myDeque.push_front(1); myDeque.push_front(2); myDeque.push_back(3); myDeque.push_back(4); myDeque.push_back(5); myDeque.push_front(6); myDeque.pop_back(); deque\u003cint\u003e::iterator myItor; for(myItor=myDeque.begin(); myItor!=myDeque.end(); myItor++) cout\u003c\u003c*myItor\u003c\u003cendl; return 0; } 执行结果： 6 2 1 3 4 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:2:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例3:deque 随机访问 // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e#include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:3:0","series":null,"tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"typedef起小名","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/","series":null,"tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"typedef起小名 C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 实例 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book; int main( ) { Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 typedef vs #define #define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： 实例 #include \u003cstdio.h\u003e #define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： TRUE 的值: 1 FALSE 的值: 0 ","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/:0:0","series":null,"tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"常用头文件","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/","series":null,"tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"常用头文件 stdafx.h MFC预编译 stdio.h 输入输出 process.h 进程 stdlib.h 声明了数值与字符串转换函数, 伪随机数 生成函数, 动态内存分配函数, 进程控制函数等公共函数 Windows.h windows系统函数(如:Sleep) string.h ANSI,多字节字符串 wchar.h Unicode,宽字符串 tchar.h 混合ANSI和Unicode字符串 pthread.h 多线程 \u003ccmath\u003e 数学 \u003cctime\u003e 时间 \u003cthread\u003e 标准的线程库 ","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/:0:0","series":null,"tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"笔记queue与deque","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/","series":null,"tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["C++"],"content":"笔记queue与deque queue操作： queue\u003cint\u003eq; //创建一个int型空队列q q.empty(); //判断队列是否为空，为空返回true q.push(s); //将变量s从队尾入队 q.pop(); //将队头元素弹出 q.front(); //只返回队头元素 q.back(); //只返回队尾元素 q.size(); //返回队列中元素个数 queue两端访问,队尾插入,队首删除。 deque操作： deque\u003cint\u003e dq; //创建一个数双端队列dq dq.empty(); //判断队列是否为空，为空返回true dq.push_front(s);//将s从队头入队 dq.push_back(s);//将s从队尾入队，和普通队列方式一样 dq.front(); //只返回队头元素 dq.back(); //只返回队尾元素 dq.pop_front(); //将队头元素弹出 dq.pop_back(); //将队尾元素弹出 dq.size(); //返回队列中元素个数 dq.clear(); //将队列清空 dq.insert();//插入新元素,最多有四个参数 //迭代器 dq.begin(); //回傳指向第一個元素(頭端)的迭代器 dq.cbegin(); //回傳指向第一個元素(頭端)的迭代器(const) dq.end(); //回傳指向最後一個元素(尾端)的迭代器 dq.cend(); //回傳指向最後一個元素(尾端)的迭代器(const) dq.rbegin(); //回傳指向最後一個元素(尾端)的反向迭代器 dq.crbegin(); //回傳指向最後一個元素(尾端)的反向迭代器(const) dq.rend(); //回傳指向第一個元素(頭端)的反向迭代器 dq.crend(); //回傳指向第一個元素(頭端)的反向迭代器(const) deque两端访问,两端插入,两端删除。 auto it = d.begin();其全名為std::deque\u003cint\u003e::iterator it = d.begin(); ","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/:0:0","series":null,"tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["WOW"],"content":"64位Call的参数","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"64位Call的参数 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:0:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call上层 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+20+8_0 参数5 rsp+20+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:1:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call内 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+28+8_0 参数5 rsp+28+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:2:0","series":null,"tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["C++"],"content":"cin和cout输入输出","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"cin和cout输入输出 简单的输入输出代码示例： #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number:\"\u003c\u003cendl; cin\u003e\u003ex; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"Please input a float number:\"\u003c\u003cendl; cin\u003e\u003ey; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果如下（↙表示按下回车键）： Please input an int number: 8↙ The int number is x= 8 Please input a float number: 7.4↙ The float number is y= 7.4 cin 连续输入示例 #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number and a float number:\"\u003c\u003cendl; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果： Please input an int number and a float number: 8 7.4↙ The int number is x= 8 The float number is y= 7.4 ","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"class 类","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/","series":null,"tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["C++"],"content":"class 类 #include \u003cstdio.h\u003e//通过class关键字类定义类 class Student{ public: //类包含的变量 char *name; int age; float score; //类包含的函数 void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; int main(){ //通过类来定义变量，即创建对象 class Student stu1; //也可以省略关键字class //为类的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; //调用类的成员函数 stu1.say(); return 0; } 类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象” ","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/:0:0","series":null,"tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"如何使用 GitHub pages 首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。 进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。 创建成功之后，点击右上角的 Settings 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题 这里我们就随意选择一个主题 Cayman，来看看他的效果是什么样的 选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。 在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。 到这里如果你只是想做一个例如可以随时在互联网上访问的简历，那么你只需要 GitHub Pages 项目的主页修改你 index.md 文件就可以了，比如我给出的这个模板。 修改完后，点击上图中左下角的 Commit Changes，然后访问你的自定义域名你就可以看到如下的样式了。 如果你想做一个功能更丰富的博客，那我们继续往下走。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"配置自定义域名并免费使用 HTTPS 在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。 首先在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名 blog.moyu.life 通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 brick713.GitHub.io。添加完成后等待 DNS 解析的生效（DNS 的解析记录生效到全球可能需要几分钟时间）。 之后重新回到最开始进入过的 Settings 界面，找到 GitHub Pages 的设置，填写我们刚刚建立的子域名，以我自己的 blog.moyu.life 举例，点击保存。 保存后 GitHub 需要一定的时间生成证书并确认域名的解析是否正常，我们只需要耐心的等待即可，成功后显示结果如下 现在我们再访问 blog.moyu.life 就会发现，我们的自定义域名和 HTTPS 都生效了！可以看到证书是由著名的机构 Let’s Encrypt 提供的。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:1","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站的同步 现在我们已经有了一个基本功能健全的网站了，接下来我们需要试着对博客的内容进行管理，并且给博客添加一些更个性化的设置，官方提供两种方式： 命令行方式（Mac 和 Windows 确保拥有 Git 环境） 桌面客户端形式（需要安装官方提供的客户端） 如果你没有任何 Git 的基础，也不想进行一些繁琐的配置，那么我推荐你使用桌面客户端的形式进行管理，如果你有一定的技术基础，那么 Git 的方式则更适合你。这里我两种方法都介绍一下。 首先在命令行中切换到你自定义的路径下，然后 Clone 下来你的项目（操作需要在 Mac 的 Terminal 中完成，Windows 系统可以使用 Git-bash。）这里注意这里的 path 和 username 需要根据你个人情况进行替换。 cd ~/Path git clone https://GitHub.com/username/username.GitHub.io 接着进入你的项目的文件中，并创作一个文章。 cd username.GitHub.io echo \"Hello World 我爱这个世界\" \u003e index.md 然后按照 Git 提交内容的流程，将我们的新创作的文章上传。 git add --all git commit -m \"Firs Push\" git push -u origin master 这里可能会碰到下面的情况： 按照他的提示我们把注册 GitHub 的邮箱和用户名依次输入即可： git config user.email \"你的邮箱\" git config user.name \"你的用户名\" 之后他可能会让你输入你的 GitHub 账号和密码，不用担心，正常输入即可。当我们看到这样的提升就证明提交成功了。 可以去我们的网站主页看看是不是起了变化。 如果你是使用GitHub 桌面客户端 那么就更简单了，下载安装了客户端之后，按照客户端的提示正常登陆你的 GitHub 账号。然后 Clone 下来你的 GitHub Pages 项目。 等待 Clone 完成后，界面上会显示几种管理修改你的项目的方式。 这里我选择使用 Sublime Text 进行管理，把开始的 index.md 里的内容改为 Hello World 我也爱这个世界 保存，然后在客户端上我们能看到文件的变化，我们先点击左下角的 Commit to master，再点击 Fetch origin 就可以将内容上传。 然后你发现你的主页也发生了相应改变了。到这里你基本上就掌握了网站管理的基本流程和文章发布的基本流程，下面我们要开始来学会使用静态模板系统来管理博客了。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:2","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 的生成工具 经历了上面的步骤，现在你的已经有了一个简单的页面了，可是他还远远未满足我们的需求，我们需要利用静态模板系统来让生产接管你博客的文章的生成，让你把更多的经历投入在创作里。下面就 GitHub 官方推荐的 Jekyll 为例子来展开讲讲。 因为 Jekyll 是基于 Ruby 的静态网页生成系统，因此我们首先得安装 Ruby 环境，在 Mac 下我们可以使用的 Homebrew 来进行安装。如果是其他操作系统，可以去参考 Ruby 官方安装文档进行安装。 brew install ruby command not found: brew问题解决方案 安装brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 看到==\u003e Installation successful!就说明安装成功了。 最后更新下： brew update 等 Ruby 安装完毕后再执行以下命令完成 Jekyll 的安装。 sudo gem install jekyll bundler 然后进入你 Clone 下来的 GitHub Pages 项目的路径 cd /Volumes/video/GitHub/xinqinew.github.io 执行以下命令： jekyll new . --force 完成后，Jekyll 会在你指定的目录下生成好所有文件，你可以使用 bundle exec jekyll serve 命令，然后就可以通过访问 127.0.0.1:4000 查看初始界面的样子了。 默认的界面看起来非常的简陋也很丑，但是没关系，你可以在这些网站里根据自己的喜好找到一些美观的主题http://jekyllthemes.org/、https://jekyllthemes.io/、http://themes.jekyllrc.org/。 安装方法很简单，一般情况下只需要下载主题包解压后完整的，复制到你的 GitHub Pages 的项目目录里，并覆盖你之前的文件即可，有些特殊的主题要参考作者给的安装步骤，这里我随意的更换了一个主题。 主题里的所有关键性配置都在 _config.yml 文件中，你可以根据个人的喜好和不同主题支持的功能来修改具体的内容，这里就不做展开。 到这里完整的搭建的流程已经结束了，你已经可以正常访问你一路配置下来的博客了，接下来你只需要找一个趁手的 Markdown 编辑器来编辑在你本地 GitHub Pages 项目中的 _posts 文件夹里的文章，并使用前面提到的两种方式将文章同步到 GitHub 上即可。需要注意的是，文章的内容和标题需要按照 Jekyll 的格式进行写作。 文章的文件名遵循下面的格式： 年-月-日-标题.markdown 文章内容顶部必须有下面的 YAML 头信息： --- layout: post title: Blogging Like a Hacker --- ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:3","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"尾巴 其实除了 Jekyll 还有非常多的第三方的静态模板系统来搭建 GitHub Pages。比如： Node.js 编写的 Hexo Go 编写的 Hugo Python 编写的 Pelican 以及更人性化的 Gridea 他们在各自的基础上实现了更多的功能，比如分析统计、搜索、评论系统、广告、分享系统等。喜欢折腾的同学不妨可以尝试尝试，未来如果有机会希望能更详细的给大家分享一下。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","series":null,"tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["GitHub"],"content":"Github汉化及常用插件","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"Github汉化及常用插件 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:0:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"插件 Sourcegraph Sourcegraph 可以让你在线学习代码，可以查看变量、函数等的定义和引用情况。把指针放到想查看的变量名上，它会自动显示寻找定义和引用的提示框，点击即可。 Octotree 查看整个项目的结构 油猴 Refined GitHub ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:1:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"汉化 桌面版一键汉化 下载版 chrome版汉化 GitHub那些事儿 Hexo + GitHub Pages 搭建博客 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:2:0","series":null,"tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["Markdown"],"content":"Markdown语法","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"GitBook默认使用Markdown语法。 下面这些可以作为一个快速参考和展示。更多完整的信息，请参考 John Gruber’s original spec 和 Github-flavored Markdown info page。 标题 H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:0:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H2 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H3 H4 H5 H6 对于H1和H2，有下划线样式可供选择： Alt-H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:1","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Alt-H2 强调 强调，又叫做斜体，使用 星号 或 下划线。 重点强调，又叫做粗体，使用 星号 或 下划线。 使用 **星号和_下划线_** 组合使用强调。 删除线使用两个波浪线。划掉这个 列表 在这个例子中，前导空格和尾部空格显示为圆点 : ⋅) 有序列表的第一项 另外一个项 ..* 无序子列表 事实上序号不起作用，那只是一个数字而已 ..1. 有序子列表 最后一个项 …你可以适当的缩紧列表项中的段落。注意上面的空行和前导空格（至少一个，但是这里我们使用三个来对齐原始的Markdown内容）。 …换行而不形成段落，你需要使用两个尾部空格。.. …注意这行是分开的，但还在同一个段落中。.. …（这个违背了不需要尾部空格的典型的GFM换行行为）。 无序列表可以使用星号 或者减号 或者加号 链接 有两种创建链接的方式。 内嵌式链接 带标题的内嵌式链接 引用式链接 相对引用一个库文件 你可以在引用式链接定义中使用数字 或者空着什么都不写 link text itself 用来说明引用链接的文字可以放在后面。 脚注 Markdown默认使用的脚注样式链接不会在页面中显示。有时包含一个读者可见的非超链接注脚很有用。对于这样的注脚，GitBook支持的一种简单的语法。 Text prior to footnote reference.1 这是我们的logo（停留查看标题） 内嵌式 Logo Title Text 1alt text \" Logo Title Text 1 引用式 Logo Title Text 2alt text \" Logo Title Text 2 代码和语法高亮 代码块是Markdown规范的一部分，但是语法高亮不是。然而，很多渲染器，比如GitHub的和这里的Markdown，都支持语法高亮。支持那种语言以及语言的名字应该怎样写随渲染器的不同而变化。这里的Markdown支持许语言；查看完整的列表，以及如何写语言的名字，请参考 highlight.js 演示页. 内嵌 代码 有 反引号 包含它. 代码块要么被包含三个反引号 ``` 的行包围，要么被四个空格缩进。推荐仅仅使用被包围的代码块，它们使用方便并且只有它们支持语法高亮。 var s = \"JavaScript语法高亮\"; alert(s); s = \"Python语法高亮\" print s 没有指明语言，所有没有语法高亮。 让我们随便写个标签试试 \u003cb\u003etag\u003c/b\u003e 表格 表格不是Markdown规范的核心部分，但是它是GFM的一部分，这里的Markdown也支持它。 冒号可以用来对其列。 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. 外部的管道符 (|) 是可选的，而且不需要优雅的排列Markdown。你还可以在表格中内嵌其他Markdown。 Markdown Less Pretty Still renders nicely 1 2 3 块引用 在邮件中块引用中很方便用来仿真文本的回复。 这行是同一个块的一部分。 引用结束 当这行很长的文字被包裹的时候，它依然会被恰当的引用。让我们继续写下去来确保包裹它时对于每个人来说它足够长。你可以在块引用中使用其它Markdown。 内嵌HTML You can also use raw HTML in your Markdown, and it’ll mostly work pretty well. 你同样可以在Markdown中使用HTML，并且它能很好的工作。 Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. 水平线 三个或者更多… 连字符 星号 下划线 换行符 关于学习换行符是如何工作的，我的建议是去亲身实践并总结 – 敲击 键一次（也就是插入一个换行符），然后再敲击它两次（也就是插入两个换行），看一下发生了什么。不久你就能学会它。“Markdown Toggle” 是你的朋友。 这里有一些东西可以尝试一下： 我们以这行作为开始。 This line is separated from the one above by two newlines, so it will be a separate paragraph. 这行与上面那行被两个换行符分隔，所以它会成为一个 单独的段落。 This line is also a separate paragraph, but… This line is only separated by a single newline, so it’s a separate line in the same paragraph. 这行同样是一个单独的段落，但是… 这行仅仅被一个换行符分隔，所以它是一个在 同一段落 中的单独的行。 Youtube视频 视频不能被直接添加，但你可以添加一个链接至视频的图片，像这样： 或者，使用纯Markdown，但是会丢失掉图片的大小和边框： Comment to include in footnote. 图片 ↩︎ ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:2:0","series":null,"tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"namespace 命名空间","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","series":null,"tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"namespace 命名空间 namespace 是C++中的关键字，用来定义一个命名空间，语法格式为： namespace name{ //variables, functions, classes } name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。 namespace Li{ //小李的变量定义 FILE fp = NULL; } namespace Han{ //小韩的变量定义 FILE fp = NULL } Li::fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using Li::fp; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han :: fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using namespace Li; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp #include \u003cstdio.h\u003e//将类定义在命名空间中 namespace Diy{ class Student{ public: char *name; int age; float score; public: void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; } int main(){ Diy::Student stu1; stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; stu1.say(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"printf输出","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 函式原型： int printf ( const char * format, … ); 引數說明： %[flags][width][.precision][length]specifier %[旗標][寬度][.精度][長度修飾]資料型態 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:0:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"1. 資料型態 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 必填欄位 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.1) 字元/字串 %c, %C : 字元, char c; %s : 字元陣列, char buffer[MAX_PATH]; %S : 字元陣列(Unicode), wchar buffer[MAX_PATH]; [註] %C / %S 並未被收在標準函式庫裡，屬 MSVC 特殊支援。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:1","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.2) 整數 %d, %i : 10進制整數 , int x; [lemma] %u : 10進制無號數, unsigned int x; %o : 8進制無號數, unsigned int x; %x, %X : 16進制無號數, 小寫x輸出為\"abcdef\", 大寫 X 輸出為 \"ABCDEF\", unsigned x; %lld, %I64d : long long int, __int64 輸出型態 (註：vc6.0 下只有 __int64，沒有long long int) %llu, %I64u : unsigned long long int 輸出型態 [lemma] %d : dec; %i : integer，於 scanf 時有部份差異 (%d 只接受10進位, %i 可接受指定進位，如 0x23, 045)，但於 printf 時 %d, %i 並無顯著差異 (感謝 Jacob Lee 補充指導) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:2","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.3) 浮點數 %e, %E : 浮點數使用科學符號表示之,指數將帶正負號, float x,doubley; %f : 單精度浮點數(預設輸出精度6位), float x; (註 : 對 printf 而言, %f/%lf 可適用於 double / float) %lf : 倍精度浮點數(預設輸出精度6位), double x; %llf, %LF : 雙倍精度浮點數(預設輸出精度6位), long double x; %g, %G : 由系統決定是否採科學符號表示。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:3","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.4) 特殊 原創：edisonx.pixnet.net %p : 變數位置。 ex: int a=0, printf(\"%p\", \u0026a); 即 printf(\"%08x\", \u0026a); %n : 輸出至緩衝區之長度, ex: char str[]=\"test\", int len, printf(\"%s%n\", a, \u0026len); 輸出4bytes,len = 4 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:4","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.5) C99新增 \u003c 建議 k spec. 最清楚 \u003e (註 : C99 新增了一些資料型態在 inttypes.h / stdint.h 裡面，有興趣搜尋 n1256.pdf 下載下來 K 標準， in section 7.8 。當然 MSVC 不支援 C99 是眾所皆知的事。) 部份原則還是掌握了 %i, %u, %d, %x，另由於這部份在 printf 會顯得很亂，故直接做範例對應。掌握一原則：新的資料型態在 printf 前三個字母一定是 PRI。 “%” PRIdN , “%” PRIiN: 以十進位有號數顯示 intN_t 系列之數值。ex : int8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRId8 \" \\n\", i8); int8_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIi16 \" \\n\", i16); int8_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRId32 \" \\n\", i32); int8_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIi64 \" \\n\", i64); 另上述將 PRIdN / PRIiN ，換成 PRIoN / PRIuN / PRIxN / PRIXN ，便可轉對 uintN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdLEASTN , “%” PRIiLEASTN: 以十進位有號數顯示 int_leastN_t 系列之數值。ex : int_least8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdLEAST8 \" \\n\", i8); int_least16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiLEAST16 \" \\n\", i16); int_least32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdLEAST32 \" \\n\", i32); int_least64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiLEAST64 \" \\n\", i64); 另上述將 PRIdLEASTN / PRIiLEASTN ， 換成 PRIoLEASTN/ PRIuLEASTN/ PRIxLEASTN/ PRIXLEASTN， 便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 \"%\" PRIdFASTN , \"%\" PRIiFASTN: 以十進位有號數顯示 int_fastN_t 系列之數值。ex : int_fast8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdFAST8 \" \\n\", i8); int_fast16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiFAST16 \" \\n\", i16); int_fast32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdFAST32 \" \\n\", i32); int_fast64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiFAST64 \" \\n\", i64); 另上述將 PRIdFASTN / PRIiFASTN ，換成 PRIoFASTN/ PRIuFASTN/ PRIxFASTN/ PRIXFASTN，便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdMAX , “%” PRIdPTR : 分別顯示整數最大值與指標型態。 [註 : 特別注意 inttypes.h 裡面之型態，printf 引數和 scanf 引數差很多，一樣掌握一原則，新的資料型態在 scanf 前三個字母一定是 SCN， 如 intN_t 系列，scanf 用的是 “%” SCNdN / “%” SCNiN ； uintN_t 系列，scanf 用的是 “%” SCNoN / “%” SCNuN / “%” SCNxN / “%” SCNXN ； int_fastN_t / int_leastN_t 等系列資料型態便不贅述。 ) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:5","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"2. 寬度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位net %m : 指定輸出之寬度。ex: int a=2, b=10; printf(\"%d%5d\", a, b); 輸出為 \"2 10\" (2與10之間有3個空白，因10為5個文字寬度)。 %* : 以引數方式代入指定輸出之寬度。ex: int a=2, width=10; printf(\"%*d\",width, a); 輸出為 \" 2\" (10個文字寬度)。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:2:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"3. 長度修飾 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %h : 將數字視為 short int (%hd) 或 unsigned int (%hu), 此修飾只對整數型態之 %hi, %hd, %ho, %hu, %hx, %hX 有效。 且針對 char 可用 %hhd，unsigned char 可用 %hhu。 (註 : MSVC 認得 %hd / %hu / %hhd / %hhu , 但在 gcc 下會發出認不得的警告 ) %l : 將數字視為 long int (%ld) 或 unsigned long int (%lu), 此修飾只對整數型態之 %li, %ld, %lo, %lu, %lx, %lX 有效。 %L : 此修飾只對浮點數型態之 long double 有效, 可用於修飾 %Le, %LE, %Lf, %Lg, %LG。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:3:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"4. 精度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %.n : 欲輸出小數點後幾位數,即顯示之精度,此修飾只對浮點數資料型態有效(f,F,e,E,g), 若使用其它整數型態 (i, d, o, u, x, X) 則將 n 視為 0, 即不輸出小數位數。ex: double a=2.1234, printf(\"%.2lf\", a); 輸出則為 \"2.12\" 。 %.* : 和 %.n 相似，但其 n 值可用變數引入。ex: double a=1.3456, int preci=2, printf(\"%.*lf\",preci, a); 輸出則為 \"1.35\" 。 %m.n: 這是寬度和精度合用之方法, 代表輸出會有小數點後 n 位， 且整個輸出文字寬 m 個字(包含小數點、正負號及數字)。ex: double c = -102.34567, printf(\"%10.3lf\", c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 %*.*: 和上一說明一樣, 但寬度與精度可用引數決定。ex: double c = -102.34567, int m=10, int n=3; printf(\"%*.*lf\", m, n, c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:4:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"5. 旗標 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %- : 原本輸出預設為向右對齊，使用後輸出向左對齊, 需與[寬度]配合使用。ex: char buf[] = \"Test\"; printf(\"%-10s\"); 輸出結果為 \"Test \"， Test 後面將保留6個空白。 %+ : 需為數值型之資料型態，強制輸出正負號，可與 '-' 旗標合用。 ex: double a = 3.4567: printf(\"%-+8.2lf\", a); // '-'使輸出靠左對齊, '+'強調輸出正負號, 整體寬度為8, 小數點顯示2位。 輸出結果為 \"+3.46 \" %0 : 若輸出之左半部為空白處, 則進行補0, (所以這不能和 '-' 合用) ex: unsigned int x = 122; printf(\"%05u\", x); // 寬度為5, 前半空白補零 輸出結果為 \"00122\" %# : 對進制加上前綴符號, 只對 %o, %x 有用, %#o為8進制,前綴符號為 0, %#x為16進制,前綴符號為 0x, %#X前綴符號則為 0X。ex: unsigned int a = 15; printf(\"%u %#o %#X\", a, a, a); 輸出結果為 \"15 017 0XF\" %(空白): 若數字為正號, 則會在該數字前面加上一空白，(故不可與 ‘+’ 合用)。 ex: int a=10; printf(\"% -5d\"); // 寬度5, 向左對齊, 保留正號位置 輸出結果為 \" 10 \" ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:5:0","series":null,"tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"queue用法详解","date":"2021-07-23","objectID":"/2021/07/queue/","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue用法详解 只能访问 queue 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。 许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO 准则处理的序列来说，使用 queue 容器适配器都是好的选择。 图 1 展示了一个 queue 容器及其一些基本操作： 图 1 queue容器 queue 的生成方式和 stack 相同，下面展示如何创建一个保存字符串对象的 queue: std::queue\u003cstd::string\u003e words; 也可以使用拷贝构造函数： std::queue\u003cstd::string\u003e copy_words {words}; // A duplicate of words stack、queue 这类适配器类都默认封装了一个 deque 容器，也可以通过指定第二个模板类型参数来使用其他类型的容器： std::queue\u003cstd::string, std::list\u003cstd::string\u003e\u003ewords; 底层容器必须提供这些操作：front()、back()、push_back()、pop_front()、empty() 和 size()。 ","date":"2021-07-23","objectID":"/2021/07/queue/:0:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 操作 queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同： front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026 obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T\u0026\u0026 obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 swap(queue \u0026other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 queue 模板定义了拷贝和移动版的 operator=()，对于所保存元素类型相同的 queue 对象，它们有一整套的比较运算符，这些运算符的工作方式和 stack 容器相同。 和 stack 一样，queue 也没有迭代器。访问元素的唯一方式是遍历容器内容，并移除访问过的每一个元素。例如： 1. std::deque\u003cdouble\u003e values {1.5, 2.5, 3.5, 4.5}; std::queue\u003cdouble\u003e numbers(values); 2. 3. while (!numbers, empty()) 4. { 5. std ::cout \u003c\u003c numbers. front() \u003c\u003c \" \"; // Output the 1st element 6. numbers. pop(); // Delete the 1st element 7. } 8. std::cout \u003c\u003c std::endl; 用循环列出 numbers 的内容，循环由 empty() 返回的值控制。调用 empty() 可以保证我们能够调用一个空队列的 ftont() 函数。如代码所示，为了访问 queue 中的全部元素，必须删除它们。如果不想删除容器中的元素，必须将它们复制到另一个容器中。如果一定要这么操作，我们可能需要换一个容器。 ","date":"2021-07-23","objectID":"/2021/07/queue/:1:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 容器的实际使用 这里汇集了一些使用 queue 容器的示例。这是一个用 queue 模拟超市运转的程序。结账队列的长度是超市运转的关键因素。它会影响超市可容纳的顾客数——因为太长的队伍会使顾客感到气馁，从而放弃排队。在很多情形中——医院可用病床数会严重影响应急处理设施的运转，也会产生同样的队列问题。我们的超市模拟是一个简单模型，灵活性有限。 可以在头文件 Customer.h 中定义一个类来模拟顾客： 1. // Defines a customer by their time to checkout 2. #ifndef CUSTOMER_H 3. #define CUSTOMER_H 4. 5. class Customer 6. { 7. protected: 8. size_t service_t {}; // Time to checkout 9. public: 10. explicit Customer(size_t st = 10) :service_t {st}{} 11. 12. // Decrement time remaining to checkout 13. Customer\u0026 time_decrement() 14. { 15. if (service_t \u003e 0) 16. --service_t; 17. return *this; 18. } 19. bool done() const { return service_t == 0; } 20. }; 21. #endif 这里只有一个成员变量 service_t，用来记录顾客结账需要的时间。每个顾客的结账时间都不同。每过一分钟，会调用一次 time_decrement() 函数，这个函数会减少 service_t 的值，它可以反映顾客结账所花费的时间。当 service_t 的值为 0 时，成员函数 done() 返回 true。 超市的每个结账柜台都有一队排队等待的顾客。Checkout.h 中定义的 Checkout 类如下： 1. // Supermarket checkout - maintains and processes customers in a queue 2. #ifndef CHECKOUT_H 3. #define CHECKOUT_H 4. #include \u003cqueue\u003e // For queue container 5. #include \"Customer.h\" 6. 7. class Checkout 8. { 9. private: 10. std::queue\u003cCustomer\u003e customers; // The queue waiting to checkout 11. public: 12. void add(const Customer\u0026 customer) { customers.push(customer); } 13. size_t qlength() const { return customers.size(); } 14. 15. // Increment the time by one minute 16. void time_increment() 17. { 18. if (!customers.empty()) 19. { // There are customers waiting... 20. if (customers.front().time_decrement().done()) // If the customer is done... 21. customers.pop(); // ...remove from the queue 22. } 23. }; 24. 25. bool operator\u003c(const Checkout\u0026 other) const { return qlength() \u003c other.qlength(); } 26. bool operator\u003e(const Checkout\u0026 other) const { return qlength() \u003e other.qlength(); } 27. }; 28. #endif 这相当于自我解释。queue 容器是 Checkout 唯一的成员变量，用来保存等待结账的 Customer 对象。成员函数 add() 可以向队列中添加新顾客。只能处理队列中的第一个元素。 每过一分钟，调用一次 Checkout 对象的成员函数 time_increment(}，它会调用第一个 Customer 对象的成员函数 time_decrement() 来减少剩余的服务时间，然后再调用成员函数 done()。如果 done() 返回 true，表明顾客结账完成，因此把他从队列中移除。Checkout 对象的比较运算符可以比较队列的长度。 为了模拟超市结账，我们需要有随机数生成的功能。因此打算使用 random 头文件中的一个非常简单的工具，但不打算深入解释它。我们会在教程后面的章节深入探讨 random 头文件中的内容。程序使用了一个 uniform_int_distribution() 类型的实例。顾名思义，它定义的整数值在最大值和最小值之间均匀分布。在均匀分布中，所有这个范围内的值都可能相等。可以在 10 和 100 之间定义如下分布： std::uniform_int_distribution\u003c\u003e d {10, 100}; 这里只定义了分布对象 d，它指定了整数值分布的范围。为了获取这个范围内的随机数，我们需要使用一个随机数生成器，然后把它作为参数传给 d 的调用运算符，从而返回一个随机整数。 random 头文件中定义了几种随机数生成器。这里我们使用最简单的一个，可以按如下方式定义： std::random_device random_number_engine; 为了在 d 分布范围内生成随机数，我们可以这样写： auto value = d(random_number_engine); // Calls operator()() for d value 的值在 d 分布范围内。 完整模拟器的源文件如下： 1. // Simulating a supermarket with multiple checkouts 2. #include \u003ciostream\u003e // For s[tan](http://c.biancheng.net/ref/tan.html)dard streams 3. #include \u003ciomanip\u003e // For stream manipulators 4. #include \u003cvector\u003e // For vector container 5. #include \u003cstring\u003e // For string class 6. #include \u003cnumeric\u003e // For accumulate() 7. #include \u003calgorithm\u003e // For min_element \u0026 max_element 8. #include \u003crandom\u003e // For random number generation 9. #include \"Customer.h\" 10. #include \"Checkout.h\" 12. u[sin](http://c.biancheng.net/ref/sin.html)g std::string; 13. using distribution = std::uniform_int_distribution\u003c\u003e; 15. // Output histogram of service times 16. void histogram(const std::vector\u003cint\u003e\u0026 v, int min) 17. { 18. string bar (60, '*'); // Row of asterisks for bar 19. for (size_t i {}; i \u003c v.size(); ++i) 20. { 21. std::cout \u003c\u003c std::setw(3) \u003c\u003c i+min \u003c\u003c \" \" // Service time is index + min 22. \u003c\u003c std::setw(4) \u003c\u003c v[i] \u003c\u003c \" \" // Output no. of occurrences 23. \u003c\u003c bar.substr(0, v[i]) // ...and that no. of asterisks 24. \u003c\u003c (v[i] \u003e static_cast\u003cint\u003e(bar.size()) ? \"...\": \"\") 25. \u003c\u003c std::endl; 26. } 27. } 29. int main() 30. { 31. std::random_device random_n; 33. // Setup minimum \u0026 maximum checkout periods - times in minutes 34. int service_t_min {2}, service_t_max {15}; 35. distribution service_t_d {service_t_min, service_t_max}; 37. // Setup minimum \u0026 maximum number of customers at store ","date":"2021-07-23","objectID":"/2021/07/queue/:2:0","series":null,"tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"std命名空间","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","series":null,"tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"std命名空间 使用命名空间 std： #include \u003ccstdio\u003eint main(){ std::printf(\"http://c.biancheng.net\\n\"); return 0; } 不使用命名空间 std： #include \u003ccstdio\u003eint main(){ printf(\"http://c.biancheng.net\\n\"); return 0; } 演示了如何使用 C++ 库进行输入输出： #include \u003ciostream\u003e#include \u003cstring\u003e int main(){ //声明命名空间std using namespace std; //定义字符串变量 string str; //定义 int 变量 int age; //从控制台获取用户输入 cin\u003e\u003estr\u003e\u003eage; //将数据输出到控制台 cout\u003c\u003cstr\u003c\u003c\"已经成立\"\u003c\u003cage\u003c\u003c\"年了！\"\u003c\u003cendl; return 0; } 运行结果： C语言中文网↙ 6↙ C语言中文网已经成立6年了！ 在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明. #include \u003ciostream\u003e void func(){ //必须重新声明 using namespace std; cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ //声明命名空间std using namespace std; cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中 #include \u003ciostream\u003e//声明命名空间std using namespace std; void func(){ cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","series":null,"tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"struct 结构体","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/","series":null,"tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["C++"],"content":"struct 结构体 #include \u003cstdio.h\u003e //定义结构体 Student struct Student{ //结构体包含的成员变量 char *name; int age; float score; }; //显示结构体的成员变量 void display(struct Student stu){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", stu.name, stu.age, stu.score); } int main(){ struct Student stu1; //为结构体的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5; //调用函数 display(stu1); return 0; } 结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。### ","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","series":null,"tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["常见问题"],"content":"sublimetext常见问题","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"sublimetext常见问题 下载安装 汉化 1.点击tools—install package control 2.preferences—package control 3.选择 “Package Control: Install Package” 4.搜索LocalizedMenu并安装 乱码 推荐使用 Package Control 查找 ConvertToUTF8 进行自动下载安装与更新。 Mac使用Sublime撸C++代码 这两款软件让你在Mac上也能写C++ ","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"解决VS生成sdf和ipch文件太大占用空间问题 [工具]—\u003e[选项]—\u003e[文本编辑器]—\u003eC/C++]—\u003e[高级]—\u003e[回退位置]里面的三项属性值按下图进行修改，其中回退路径随便设置。 设置个回退路径这样可比较好管理这些庞大的臃肿的文件，可以定期清理它们，释放磁盘空间 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","series":null,"tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题 禁止win10五笔输入法的shift切换功能 方法一：win10系统添加开机启动项 使用组合键win+R打开运行窗口，输入“shell:startup”打开启动项文件夹。 可以把软件快捷方式复制到“启动项文件夹|”中。 方法二：注册表添加启动项 1、打开运行，输入“regedit”，打开注册表。 2、在注册表中找到如下位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run，右键“Run”新建一个字符串类型的键值。 3、右键新建的键值，选择“修改”，将数值名称改为 你要启动的程序名称如：ctfmon.exe，数值数据改为 程序所在位置的路径 如：C:\\windows\\system32\\ctfmon.exe (直接不能修改名字的，可以先点击重命名，改好名字，再点击修改，修改数值数据) 如何彻底关闭win10系统windows defender实时保护功能？ ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","series":null,"tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["WOW"],"content":"WOW部分功能代码","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"WOW部分功能代码 ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:0:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色名字 // pcall5(对象地址,0,1,0,0);//返回名字地址 void CPAGE1::OnBnClickedButton() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase64 = (UINT_PTR) LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387c88)+0x200);//角色对象 TPCALL5 pcall5 =(TPCALL5)(pBase64+0xA7640); // TPCALL5 pcall5 = (TPCALL5)((UINT_PTR) LoadLibraryA(\"Wow.exe\")+0xA7640); char szpAscii[256]={0}; // char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); char *putf8Name =(char*) pcall5(pRoleObj,0,1,0,0); utf8ToAscii(putf8Name,szpAscii); m_edt_strA=szpAscii; UpdateData(FALSE);//把变量的数据更新到窗口 //UpdateData(TRUE);//把窗口的数据更新到变量 } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历怪物列表 void 遍历怪物列表() { UINT64 exeBase = (UINT64)LoadLibraryA(\"Wow.exe\"); for (UINT i=0;i\u003c=0x7F;i++)//7F可能不是 对象数量 对象的分类编号 { // UINT64 vrax=0; UINT64 vrax = R8(R8(R8(exeBase+0x2387C88)+0x30)+0x10+i*3*8); if (vrax == 0 ) { break; } // else//vrdx !=0 // { // vrax = vrdx; // } UINT64 vrcx = (UINT64)R4(R8(R8(exeBase+0x2387C88)+0x30)+i*3*8);//+28 while((vrax\u00261)==0) { //遍历同类链表 //rcx = dword([[wow.exe+0x2387C88]+0x30]+i*3*8) //0x28 //+198]+20 //float x,y,z UINT64 pNode198 = R8(vrax+0x198); float x = R4F(pNode198+0x20); float y = R4F(pNode198+0x24); float z = R4F(pNode198+0x28); char buf[2048]; char asciiObjName[2048]={0}; char *pObjName=GetObjName(vrax); if (pObjName\u0026\u0026pNode198) { utf8ToAscii(pObjName,asciiObjName); } sprintf_s(buf,\"yjx:[%d] vrax=%p (%f,%f,%f) vrcx=%llx name=%p %s\\r\\n\",i,vrax,x,y,z,vrcx,pObjName,asciiObjName); MessageBoxA(0,buf,\"while\",0); vrax = R8(vrcx+vrax+8); //链表 } } } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取对象名字 char* GetObjName(UINT64 vrcx) { char *putf8Name=NULL; __try { UINT64 pBase64 = (UINT_PTR)LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387C88)+0x200); TPCALL5 pcall5 = (TPCALL5)(pBase64+0x8AE040); char szpAscii[256]={0}; putf8Name = (char*)pcall5(vrcx,0,1,0,0); }__except(1) { } return putf8Name; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"使用技能 void TGCALL::UseActionCall(UINT32 SkillID,UINT64* argBuf40,UINT64 *TargetID16) { typedef UINT64 (*TPCALL4)(UINT64 arg1,UINT64* arg2,UINT64 arg3,UINT64* arg4); TPCALL4 pcall=(TPCALL4)(GameBase::GetExeBase()+0x77DC40); __try { pcall(SkillID,argBuf40,0,TargetID16); }__except(1) { MessageBoxA(0,\"ERROR 0x77DC40\",\"错误\",MB_OK); } return; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"火球术 void CPAGE1::OnBnClickedButtonFire() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0,0}; // 0x006FCC00007B4493 /*ID1*/,0x204D880000001140 /*ID2*/};//目标怪物的ID TGCALL::UseActionCall(0x00000085,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:1","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"霜甲术 void CPAGE1::OnBnClickedButtonIce() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0/*ID1*/,0/*ID2*/}; //目标怪物的ID TGCALL::UseActionCall(0x000000A8,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:2","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"捡物 void CPAGE1::OnBnClickedButtonPick() { // TODO: 在此添加控件通知处理程序代码 TPCALL4 pcall4 = (TPCALL4)(GameBase::GetExeBase()+0xF2A620); pcall4(0,0,0,0); pcall4(1,0,0,0); pcall4(2,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"搜索选中怪身上的物品 void CPAGE1::OnBnClickedButtonSeachgoods() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase = R8(GameBase::GetExeBase()+0x21E2858); UINT64 ID1 = R8(pBase+0x30); UINT64 ID2 = R8(pBase+0x38); UINT64 arg1[40] = {ID1,ID2,0,0}; //通过选中对象ID 查找对象 TPCALL4 pcallGetObj1=(TPCALL4)(GameBase::GetExeBase()+0xB66AB0); UINT64 vrax = pcallGetObj1((UINT64)arg1,0,0,0);//一个参数 char buf[1024]; sprintf_s(buf,\"vrax=%llx \\r\\n\",vrax); TPCALL4 pcall =(TPCALL4)(R8(R8(vrax)+0x2C0));//2C0 右键单击 打开搜索物品的窗口 pcall(vrax,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:6:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色对象地址 UINT64 GameBase::GetRoleObj()//返回角色对象地址 { // return R8(R8(GetExeBase()+0x2387C88)+0x200); TPCALL2 pcall2 = (TPCALL2)(GameBase::GetExeBase()+0x1127550); const char *vrcx = \"player\"; return pcall2((UINT64)vrcx,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:7:0","series":null,"tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/","series":null,"tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串 让喊话内容支持中文 //AnsiToUtf8.h #pragma once //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); //AnsiToUtf8.cpp #include \"stdafx.h\"#include \"AsciiToUTF8.h\"#include \u003cWindows.h\u003e /* //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); */ DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf) { int WLength = MultiByteToWideChar(CP_ACP, 0, Ansi, -1, NULL, 0); LPWSTR pszW = (LPWSTR) _alloca((WLength+1) * sizeof(WCHAR)); //Ansi字符串转Unicode字符串 MultiByteToWideChar(CP_ACP, 0, Ansi, -1, pszW, WLength); //计算UTF8转换所需要空间大小 int ALength = WideCharToMultiByte(CP_UTF8, 0, pszW, -1, NULL, 0, NULL, NULL); //LPSTR pszA = (LPSTR)_alloca( ALength + 1); WideCharToMultiByte(CP_UTF8, 0, pszW, -1, szpUtf8Buf, ALength, NULL, NULL); szpUtf8Buf[ALength]=0; szpUtf8Buf[ALength+1]=0; //pszA[ALength] = 0; return ALength;//返回UTF8字符串长度 } char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr) { //预算-缓冲区中多字节的长度 //CP_OEMCP int ansiiLen =WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,nullptr,0,nullptr,nullptr); //给指向缓冲区的指针变量分配内存 //把szpUnicodeStr里存放的Unicode编码字串 转成ASCII存放到 szpAsciiStr缓冲区 //CP_OEMCP WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,szpAsciiStr,ansiiLen,nullptr,nullptr); return szpAsciiStr; } WCHAR* utf8ToUnicode(IN char*szpUtf8,OUT WCHAR*szpUniCode) { //预算_缓冲区中宽字节的长度 //CP_UTF8 963页码 int unicodeLen = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); //给指向缓冲区的指针变量分配内存 WCHAR *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); //开始向缓冲区转换字节 //CP_UTF8 963页码 也可能 MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,pUnicode,unicodeLen); wcscpy_s(szpUniCode,unicodeLen,pUnicode); free(pUnicode); return szpUniCode; } //注意此函数没检测缓冲区大小 char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii) { int iSizeUtf8 = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); WCHAR*putf8Buf =(WCHAR*)malloc(sizeof(WCHAR)*iSizeUtf8); utf8ToUnicode(szpUtf8,putf8Buf); UniCodeToAscii(putf8Buf,szpAscii); return szpAscii; } BOOL CharToHex(OUT char*szpBufHex,BYTE c) { BYTE bLow =0; BYTE bHigh = 0; bLow = c%16;//取低位0..15 bHigh = c/16;//取高位0..15 if (bHigh\u003e9) { szpBufHex[0]='A'+bHigh-10;//'B' } else//0..9 { szpBufHex[0]='0'+bHigh;//'0'+2='2' } if (bLow\u003e9)//a,b,c,e,f { szpBufHex[1]='A'+bLow-10;//'B' } else//0..9 { szpBufHex[1]='0'+bLow;//'0'+2='2' } szpBufHex[2]=0;//0 return TRUE; } DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf) { //1 //01 for (DWORD i=0;i\u003c nbDataSize;i++) { //提高速度 CharToHex(\u0026szpHexBuf[i*2],nbData[i]); } return TRUE; } ","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","series":null,"tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客 jekyll-rtd-theme 安装配置及写作 测试文档 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:0:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装时终端出现问题的解决办法 清空Gemfile文件内容 终端运行 bundle update Gemfile文件添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 终端再次运行 bundle update ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:1:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"一.安装 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"a.基于本地主题 1.清空Gemfile文件内容,并添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 2.将以下内容添加到您的网站 _config.yml title:Your awesome titlelang:endescription:Write an awesome description for your new site heretheme:jekyll-rtd-theme ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:1","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"b.基于远程主题 将以下内容添加到您的 github 存储库 _config.yml remote_theme: rundocs/jekyll-rtd-theme 删除任何其他theme或remote_theme条目 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:2","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"二.设置侧边栏(子目录) 在根目录新建子目录 子目录中必须有一个README.md 排序 _config.yml中添加以下内容 readme_index: with_frontmatter: true 在需要排序的文件中添加 格式头 --- sort: 1 # follow a certain sequence of letters or numbers --- ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:3:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"三.在README文件中列出文件 在README文件中添加 如果要列出子目录的所有文件则添加 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:4:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"四.语法 思维导图 graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 笔记 这是笔记 支持 Markdown, 文本可以是**粗体**, _斜体, or ~~删除线~~. [链接](https://github.com) 是蓝色的,且没有下划线 `inline code` [`inline code inside link`](#) 提示 它比面包盒还大.. 警告 强烈的散文可能会引起极度的脑力消耗。强烈建议读者酌情决定. 危险 疯狂的科学家在工作！ 更新 sudo bundle install sudo bundle update sudo bundle update jekyll ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:5:0","series":null,"tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"常用API函数","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"常用API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:0:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"模拟鼠标 LRESULT SendMessage(HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam); 其中Msg可以为WM_LBUTTONDOWN或WM_LBUTTONUP,表示对鼠标的软件模拟操作(虽然兼容性和安全性不如硬件模拟的mouse_event，但不改变移动鼠标指针) 故一般写作SendMessage(hwnd, WM_LBUTTONUP/WM_LBUTTONDOWN, 0, Y坐标«16+X); Msg也可以为WM_CLOSE,表示关闭窗口,其后的两个参数传0即可. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:1:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL注入 HANDLE CreateThread(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD ,LPDWORD); CreateThread 将在主线程的基础上创建一个新线程 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); VirtualAllocEx 向指定进程申请内存 FARPROC GetProcAddress(HMODULE hModule, LPCSTR); GetProcAddress 检索指定的动态链接库(DLL)中的输出库函数地址 HANDLE CreateRemoteThread(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); CreateRemoteThread 创建一个在其它进程地址空间中运行的线程 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:2:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL劫持 __asm{ } 执行括号内的汇编代码 JMP EAX 将EIP跳转到EAX执行，劫持DLL后要获取真正的原函数地址，使用时要进行跳转 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:3:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GDI绘图 HDC GetDC(HWND hWnd); 检索显示设备上下文环境的句柄 CDC CDC类定义的是设备上下文对象的类 CPoint CDC::MoveTo(int x,int y); CPoint CDC::LineTo(int x,int y); 绘制直线 BOOL CDC::Ellipse(int x1,int y1，int x2,int y2); 绘制圆形 BOOL CRgn::CreateRectRgn(int x1,int y1,int x2,int y2); 建立方形区域 BOOL CRgn::CreateEllipticRgn(int x1,int y1,int x2,int y2) 建立圆形区域 int CombineRgn(CRgn pRgn1,CRgn pRgn2,int nCombineMode ); 合并区域(圆点准心为使得中间透明采取大圆-小圆的区域) BOOL FillRgn(CRgn pRgn,CBrush pBrush ); 填充形状 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:4:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"设置钩子API HHOOK WINAPI SetWindowsHookEx（ _In_ int idHook，　//设置钩子的类型.意思就是我要设置的钩子是什么钩子. 可以是监视窗口过程.可以是监视消息队列. _In_ HOOKPROC lpfn，　//根据钩子类型.设置不同的回调函数. _In_ HINSTANCE hMod，　//钩子设置的Dll实例句柄,就是DLL的句柄 _In_ DWORD dwThreadId　//设置钩子的线程ID. 如果为0 则设置为全局钩子. ）;　//HHOOK 返回值. 是一个钩子过程句柄. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"输入与输出 #include \u003ciostream\u003e //输出 int a =1; printf(\"Hello \\n\"); printf(\"%d\",a); //输入 scanf_s(\"%d\",\u0026a); //输入一个值，并赋值给a ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:6:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"其它API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:0","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"MoveWindow BOOL MoveWindow( HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint ); 改变指定窗口的位置和大小 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:1","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindow BOOL IsWindow(HWND hWnd)； 判断是否是有效窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:2","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindow BOOL ShowWindow(HWND hWnd, int nCmdShow); 显示隐藏窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:3","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindowAsync BOOL ShowWindowAsync(HWND hWnd，int nCmdshow)； 异步显示窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:4","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowVisible BOOL IsWindowVisible(HWND hWnd); 获取窗口可视状态,即显示或隐藏 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:5","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsZoomed BOOL IsZoomed(HWND hWnd)； 窗口是否是最大化 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:6","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowUnicode BOOL IswindowUnicode(HWND hwnd)； 判断窗口字符集 由RegisterClassA 还是RegisterClassW注册 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:7","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"CloseWindow BOOL CloseWindow(HWND hWnd); 关闭窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:8","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"WindowFromPoint HWND WindowFromPoint(POINT Point)； 获取指定坐标处的窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:9","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ChildWindowFromPoint HWND ChildWindowFromPoint (HWND hWndParent, POINT Point); 获取指定窗口 坐标处子窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:10","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetWindowText Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount); 获取窗口标题字符串 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:11","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetClassName int GetClassName(HWND hWnd, LPTSTR IpClassName, int nMaxCount); 获取窗口注册的类名,由RegisterClass注册时的名字 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:12","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"BringWindowToTop B00L BringWindowToTop(HWND hWnd); 窗口激活并切换到Z序顶层 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:13","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnableWindow BOOL EnableWindow(HWND hWnd，BOOL bEnable); 是否接收键盘鼠标消息 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:14","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnumChildWindows BOOL EnumChildWindows(HWND hWndParent,WNDENUMPROC lpEnumFunc, LPARAM lParam); 遍历子窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:15","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowPos WINUSERAPI BOOL WINAPI SetWindowPos(HWND hWnd,HWND hWndInsertAfter,int X,int Y,int cx, int cy, UINT uFlags); 窗口位置设置 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:16","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowText BOOL SetWindowText(HWNDhwnd,LPCTSTRlpString); 设置窗口标题,SetWindowText也分A和W两种 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:7:17","series":null,"tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["WOW"],"content":"模块及进程相关代码","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"模块及进程相关代码 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:0:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"句柄 进程 内存 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"窗口句柄 HWND FindWindow( LPCTSTR IpClassName， //窗口的类名 LPCTSTR IpWindowName); //窗口的标题 HWND FindWindowW(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用Unicode字符集,IpWindowName前要加L,如L”魔兽世界“ HWND FindWindowA(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用多字节字符集 HWND FindWindowEx( //该函数获得一个窗口的句柄，该窗口的类名和窗口名与给定的字符串相匹配 HWND hwndParent, //要查找子窗口的父窗口句柄 HWND hwndChildAfter, //子窗口句柄 LPCTSTR lpszClass, //窗口的类名 LPCTSTR lpszWindow); //窗口的标题 //如果hwnjParent为NULL，则函数以桌面窗口为父窗口，查找桌面窗口的所有子窗口。 //如果hwndParent为HWND_MESSAGE，函数仅查找所有消息窗口。 //子窗口必须为hwndPareRt窗口的直接子窗口而非后代窗口。 //如果HwndChildAfter为NULL，查找从hwndParent的第一个子窗口开始。 //如果hwndParent 和 hwndChildAfter同时为NULL，则函数查找所有的顶层窗口及消息窗口。 通过类名或窗口名查找，返回窗口句 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:1","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程ID和线程ID DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId); 得到窗口句柄后通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:2","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程句柄 HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId); 打开一个已存在的进程对象，并返回进程的句柄 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:3","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"写入内存 三种方式： 函数WriteProcessMemory（远程跨进程） bool WriteProcessMemory( HANDLE hProcess, //进程句柄 LPVOID lpBaseAddress, //内存首地址 LPVOID lpBuffer, //指向要写的数据的指针 DWORD nSize, //字节数 LPDWORD lpNumberOfBytesWritten ); //这个是返回实际写入的字节 能写入某一进程的内存区域。入口区必须可以访问，否则操作将失败 指针读取 *(DWORD*) （需要注入） 内联汇编（需要注入） ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:4","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"读取内存 HWND ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead); 根据进程句柄读入该进程的某个内存空间lpBaseAddress的nSize字节，并写入缓冲区lpBuffer，多次计算基址和偏移即可 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:5","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"加载模块 HMODULE WINAPI GetModuleHandle( //获取一个应用程序或动态链接库的模块句柄 _In_opt_LPCTSTR lpModuleName //指定模块名 ); //实例 DWORD B =(DWORD)GetModuleHandleA(\"ELEMENTCLIENT.EXE\"); ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:2:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历模块 int 遍历进程模块(DWORD 进程PID) { HMODULE hMods[1024]; //20*sizeof(HMODULE) HANDLE 进程句柄; DWORD cbNeeded; unsigned int i; //Print the proess identifier. printf(\"\\nprocess ID: %u\\n\",进程PID); //Get a handle to the process. 进程句柄=OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程PID); if (NULL == 进程句柄) return 1; //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return 0; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:3:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取窗口句柄 HWND CFINDCODE::GetGameHwnd(void) { HWND hNext = FindWindowExA(HWND_DESKTOP,0,0,0); HWND h2 = FindWindowExA(HWND_DESKTOP,hNext,0,0); int i =0; while(h2) { char buf[256]={0}; GetWindowTextA(h2,buf,256); if (strstr(buf,szGameSubCaption)) { break; } h2 = FindWindowExA(HWND_DESKTOP,h2,0,0); } return h2; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:4:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程ID DWORD CFINDCODE::GetPID() { HWND h=GetGameHwnd(); DWORD dwpid=0; GetWindowThreadProcessId(h,\u0026dwpid); return dwpid; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:5:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程句柄 HANDLE CFINDCODE::GetGameHp() { DWORD dwPid = GetPID(); HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS,0,dwPid); // printf(\"hp=%hp, pid=%d\\r\\n\",hp,dwPid); return hp; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:6:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块起始地址 UINT_PTR CFINDCODE::GetExeBase() { UINT_PTR exeBase64=NULL; HMODULE hMods[1024]; //20*sizeof(HMODULE) DWORD cbNeeded; unsigned int i; HANDLE 进程句柄=GetGameHp(); //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //如果是“*.exe”的模块,直接返回基址 if (strstr(szModName,\".exe\")) { exeBase64 = (UINT_PTR)hMods[i]; } //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); // printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return exeBase64; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:7:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE结束地址 UINT_PTR CFINDCODE::GetExeEnd() { // HANDLE 进程句柄=GetGameHp(); // UINT_PTR 模块基址 = GetExeBegin(); // MEMORY_BASIC_INFORMATION meminfo; // //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 // SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); // UINT_PTR 结束地址=(UINT_PTR)meminfo.AllocationBase+meminfo.RegionSize; // printf(\"GetExeEnd: AllocationBase=%llx,RegionSize=%X 结束地址=%llx \\r\\n\",meminfo.AllocationBase,meminfo.RegionSize,结束地址); // return 结束地址; return GetExeBase()+GetExeSize(); } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:8:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块大小 SIZE_T CFINDCODE::GetExeSize(); { static SIZE_T nSize=0; if (nSize) { /* code */ return nSize; } HANDLE 进程句柄=GetGameHp(); UINT_PTR 模块基址 = GetExeBase(); MEMORY_BASIC_INFORMATION meminfo; //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); nSize = meminfo.RegionSize; CloseHandle(进程句柄); return nSize; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:9:0","series":null,"tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["博客"],"content":"LoveIt - 1前期准备","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"前言 这篇教程介绍了如何搭建这样效果的博客。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"所需步骤 可以从这样的角度出发： 注册域名。 使用CDN加快网站访问速度。 网站内容需要部署在服务器或对象存储平台上。 重要的是放什么内容。博客需要选择框架，或自己开发。 框架确定后，选择主题，或自己开发。 配置主题。 发表第一篇Hello World！ 在这个过程中，前期准备阶段包括：框架选择、主题选择、注册域名、备案和CDN配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"博客框架 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"框架选择 Wordpress 缺点：不安全。 主题推荐：Sakura Hexo 缺点：渲染生成文章速度不如Hugo。 主题推荐：matery Hugo The world’s fastest framework for building websites. ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"结论 选择Hugo框架。 静态博客方便备份。 用Markdown写文章，方便以后迁移。 缺点，使用对象存储服务需要支付流量费，存在被DDOS的风险。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"下载 Hugo和Hugo extend区别 Hugo extend支持Sass/SCSS。下载地址 Windows可考虑使用scoop下载, 安装与升级很方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"Hugo主题 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt 功能很全面的一个主题，支持很多功能，节省了不少自己折腾的时间。LoveIt主题介绍 安装主题有两种方案，如果不修改主题配置和模板，可以直接添加添加子模块，这样比较简单。 修改主题会麻烦一些，但是可以让自己的博客与众不同。需要将Fork到自己的仓库，有一个缺点，fork后添加的submodule是自己的仓库，使用Dependabot需要手动和上游同步之后，才会触发blog仓库更新检查。所以不适用Dependabot。 不修改主题模板 添加子模块到blog仓库的themes目录下。 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 可设置Dependabot自动合并主题更新，参考：About Dependabot version updates和Automate Theme Update。 Fork主题后进行DIY fork主题到自己的仓库。 添加子模块： git submodule add \u003c自己仓库的url\u003e \u003cpath\u003e 设置上游进行同步，在主题目录中执行 git remote add upstream \u003c上游主题的url\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"toha toha是一个非常适合做个人简历的主题。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"注册域名 万网注册域名。 配置DNS解析，域名邮箱解析等可能存在冲突。 参考DNS解析冲突规则 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"HTTPS证书 使用HTTPS证书避免HTTP劫持风险，劫持https请求需要伪造证书。 阿里云可申请免费HTTPS证书，但是一个子域名需要单独申请一个证书。 Chrome浏览器HTTP网站显示“不安全”，是怎么回事? 谷歌从Chrome 56版本浏览器开始对使用HTTP协议传输密码信息的网站进行“不安全”警告；而2018年7月，谷歌Chrome 68将对所有HTTP网站显示“不安全”警告。随着Chrome浏览器的版本升级，会有越来越多的用户看到HTTP网站的“不安全”警告。来源：https://www.sohu.com/a/242732942_188485 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"备案 IPC备案 公安备案 如果在万网购买的域名，备案过程很简单，按要求填写信息，上传照片即可。注意照片要合要求，否则可能会被打回来重新上传。 香港，国外的服务器不需要备案。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"CDN 购买CDN资源包，加速域名访问。静态博客不需要购买动态请求次数。 以上步骤完成后，将域名解析到CDN，CDN加速源站或对象存储服务（在部署阶段介绍）。访问域名，确定CDN是否加速。 通过ping命令查看IP是否为CDN的IP。 打开Chrome控制台，查看返回包头是否有X-Cache字段。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:7:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt - 2部署","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"前言 完成前期的准备工作后，在部署阶段需要配置服务器或对象存储服务。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储和服务器对比 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储平台 国内有阿里云OSS、腾讯COS、又拍云、七牛云等。国外有Github Pages、Netlify、Azure、Google等，其中Github Pages免费，但是有个说法：Github屏蔽百度爬虫，使用Github Pages的网站百度搜不到。 对象存储平台也可以做为Markdown图床，配合CDN，加快图片加载速度。 笔者的服务器是阿里家的，所以对象存储也用了阿里云OSS。 阿里云OSS部署参考 Hugo 静态网站部署及免费 HTTPS 证书配置 OSS常用工具汇总 对象存储的配置非常简单，哈喽沃德先生的这篇文章已经很详细了，按照这篇文章可以完成上传操作。文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 需要注意的是，上传的Bucket要设置为公共读权限，同时限制Refer，做好防盗链。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器 平时有使用VPS需求，可选择使用VPS。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对比 对象存储： 优点：便宜，不需要搭建环境。 缺点：流量费用，要考虑图床的防盗链。 服务器： 优点各种踩坑😔，可以提升技能。 费用： 对象存储平台不考虑流量费：7.2元/年。 阿里云服务器，学生党及年龄小于等于24岁：10元/月；不满足以上条件的个人：121元/月。 结论 对象存储上手简单，成本低。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器环境 不使用服务器部署的读者，可跳过这部分。 操作系统Ubuntu 更新安装源 apt update 修改hostname hostnamectl --static set-hostname localhost 重启 安装软件 apt install git apt install nginx apt install rz apt install unzip ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"SSH安全配置 安全组限制IP通过SSH远程登陆。如果使用Github Action安全组无法限制，Github Action的服务器部署在Azure上，官方文档中包含几万行IP段，不适合做限制。 修改22端口。由于第一个原因，只能修改端口。否则Massscan3分钟全网段扫描，触发SSH口令暴力破解，几乎每天都有告警。注意！修改之后，确定其他端口可以登陆再关闭22端口。 配置SSH key避免执行git命令时用户密码验证。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"Nginx配置 root权限启动。避免前端访问403的问题。/etc/nginx/nginx.conf中启动配置的用户与实际启动nginx的用户需要保持一致，可修改为低权限用户启动。 如果Nginx版本存在漏洞，以root权限启动，存在被拿到root权限的风险。 配置 /etc/nginx/nginx.conf ... include /etc/nginx/conf.d/*.conf; # 注释下面这行。如果sites-enabled/路径下存在默认配置文件，可能覆盖/etc/nginx/conf.d/default.conf配置 # include /etc/nginx/sites-enabled/*; ... 配置 /etc/nginx/conf.d/default.conf server { listen 80; server_name www.xiaodejiyi.com xiaodejiyi.com; # 注意www和没有www都要配置 index index.html index.htm; root /var/www/html/public; location / { root /var/www/html/public; index index.html; } error_page 404 /404.html; } ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"上传 将blog的public目录压缩为zip格式，使用rz命令上传到服务器上，unzip命令解压到Nginx配置的网站根目录中。 正常情况下，域名解析到CDN，CDN设置源站IP。到这一部可以访问域名，查看部署结果。如果blog配置未完成，可以先上传一张图片做测试。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"参考 阿里云帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"LoveIt - 3主题配置","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"前言 博客部署完成后，恭喜你可以发表第一篇：Hello world！但是LoveIt这么好用的主题，不配置一番可惜了。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"基本功能配置 主题配置最好参考已有的配置，比如LoveIt作者写的介绍，还有主题目录下的配置文件\\themes\\LoveIt\\exampleSite\\config.toml文件。 笔者认为一些配置项解释的不够清楚，所以将网站的源码放在了Github上，仅供参考。 下面介绍其中一些配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"双语言配置 配置后需要每篇文章存在多个语言的文件，否则会报错。 例如：content\\about\\index.en.md、content\\about\\index.zh-cn.md ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"Gravatar头像 gravatar头像注册，需要使用wordpress帐号，注册帐号时，有些邮箱的邮件会被过滤，使用163邮箱等了1个多小时方才收到注册的邮件。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"图片画廊功能 在配置文件config.toml中开启lightgallery # 是否使用 lightgallery lightgallery = true 或者在文章的头部参数中设置lightgallery: true 最后文章中的图片引用格式为：![weichat](/images/weichat-logo_500px.png \"公众号\")，注意路径后面要加\"内容\"。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"搜索配置 使用algolia作为搜索引擎，因为lunr的加载速度会让你等到花都谢了。虽然algolia需要上传index.json，但是可以使用Algolia Atomic简化操作。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"评论系统设置 国内不能用disqus，不过还有Valine评论系统。留言可以设置邮件提醒功能，但是LeanCloud的云引擎域名需要使用自己的域名并配置DNS解析。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:5","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息设置 首页的社交信息，不同语言的界面，可分别设置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:6","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息拓展 以微信公众号为例。 在config.toml的社交信息中添加 # 作者的社交信息设置[social]...Wechat = \"https://img.xiaodejiyi.com/img/wechat%20logo_500px.png\"... 配置themes\\LoveIt\\assets\\data\\social.yml: # 064: wechatwechat:# weight值排序Weight:2Title:公众号Newtab:trueIcon:Simpleicons:wechat 其中图标可参考其他形式，如： # Src形式cnblog:Weight:1Prefix:https://www.cnblogs.com/Title:博客园Icon:# themes\\LoveIt\\assets\\svg\\icons\\cnblog.svgSrc:svg/icons/cnblog.svg# fontawesome class形式mastodon:Weight:56Prefix:https://mastodon.social/Title:MastodonIcon:Class:fab fa-mastodon fa-fw# Simpleiconsgooglescholar:Weight:54Template:https://scholar.google.com/citations?%vTitle:Google ScholarIcon:# themes\\LoveIt\\assets\\lib\\simple-iconsSimpleicons:googlescholar ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:7","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"使用站长工具，向搜索引擎提交网站地图 让搜索引擎收录网站内容。 百度搜索资源平台 https://ziyuan.baidu.com/site/index#/ Google search console https://search.google.com/search-console/about?hl=zh-CN # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [verification] google = \"xxxxxxxxxxxxxxxx\" bing = \"\" yandex = \"\" pinterest = \"\" baidu = \"code-xxxxxxx\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:8","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站统计与分析 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站流量分析 分析网站点击流量，访客IP等数据。 Google Analytics 百度统计 注册后，需要先添加DNS解析，验证域名所有权，可能会与其他解析记录存在冲突。 解决方法，暂停其他解析，验证所有权通过后，在网站分析中配置ID，最后删除验证的DNS解析，重新开启其他冲突的解析记录。 # Google网站分析配置 [analytics] enable = true # Google Analytics [analytics.google] id = \"G-xxxxxxx\" # 是否匿名化用户 IP anonymizeIP = true 百度统计需要在网站代码中加入百度的统计代码，可以在themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中添加以下代码。 {{- /* baidu Analytics */ -}} \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); # 需要修改为自己的url hm.src = \"https://hm.baidu.com/hm.js?9c04b6d35915817e67da8ad2fdcfbfdf\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e # 下面网站访问数量统计中，友盟+和51LA也可以加在这里。 {{- /* 51la Analytics */ -}} \u003cscript type=\"text/javascript\" src=\"//js.users.51.la/21009067.js\"\u003e\u003c/script\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站访问数量统计 对比样式之后，选择了51LA统计。也可以用JS修改统计的样式。 这三个访问统计都需要在网站代码中加入统计的JS代码。注册后，获取JS统计代码，可以和网站流量分析中百度分析一样加到themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中。 不算子 样式： 本文总阅读量929966次 本站总访问量3152598次 本站总访客数672421人 友盟+ 互联网数据服务平台缔元信和CNZZ合并成为友盟+。 样式： 站长统计 | 今日IP[43] | 今日PV[191] | 昨日IP[31] | 昨日PV[133] | 当前在线[5] 51LA 样式： 总访问量 21,195，本月访问量 2,820，昨日访问量 93，今日访问量 103，当前在线 4 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"归档页面文章总数 在themes\\LoveIt\\layouts\\_default\\section.html中添加以下代码： \u003c!-- articles --\u003e \u003cspan style=\"font-size:.8rem;font-weight:500;\"\u003e {{- len ( where .Site.RegularPages \"Section\" \"posts\" ) | dict \"Nums\" | T \"totalPageNums\" -}} \u003c/span\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [totalPageNums] other = \"共 {{ .Nums }} 篇文章\" # themes\\LoveIt\\i18n\\en.toml [totalPageNums] other = \" {{ .Nums }} articles\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站总字数统计 参考Hugo 总文章数和总字数。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"底部链接设计 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"关于知识共享许可协议 可以看这篇“知识共享”（CC协议）简单介绍，笔者最终决定采用：知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站运行时间 在themes\\LoveIt\\layouts\\partials\\footer.html中加入以下代码。 {{- /* Hugo and LoveIt */ -}} {{- if ne .Site.Params.footer.hugo false -}} \u003cdiv class=\"footer-line\"\u003e # 运行时间在这里 \u003cspan id=\"timeDate\"\u003e{{ T \"worktime\" }}\u0026nbsp;|\u0026nbsp;\u003c/span\u003e \u003cscript\u003e var now = new Date(); function createtime() { var start_time= new Date(\"09/16/2020 00:00:00\"); now.setTime(now.getTime()+250); days = (now - start_time ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); var worktime = document.getElementById(\"timeDate\").innerHTML.replace(/time/, Math.floor(days)); document.getElementById(\"timeDate\").innerHTML = worktime ; } createtime(); \u003c/script\u003e {{- $hugo := printf `\u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener noreffer\" title=\"Hugo %v\"\u003eHugo\u003c/a\u003e` hugo.Version -}} {{- $theme := .Scratch.Get \"version\" | printf `\u003ca href=\"https://github.com/dillonzq/LoveIt\" target=\"_blank\" rel=\"noopener noreffer\" title=\"LoveIt %v\"\u003e\u003ci class=\"far fa-kiss-wink-heart fa-fw\"\u003e\u003c/i\u003e LoveIt\u003c/a\u003e` -}} {{- dict \"Hugo\" $hugo \"Theme\" $theme | T \"poweredBySome\" | safeHTML }} \u003c/div\u003e {{- end -}} i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [worktime] other = \"运行 time 天\" # themes\\LoveIt\\i18n\\en.toml [worktime] other = \"Almost time days.\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"小徽章 如果你喜欢这样的小徽章，前往shield进行DIY吧！参考动态小牌子制作 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"第三方库配置 使用jsdelivr加速第三方库文件的加载。 LoveIt主题对cdn文件的加载过程是这样的。 配置文件中补充cdn文件名称，可以直接复制主题的cdn文件到blog的assets/data/cdn/目录下。 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\"jsdelivr.yml\") # 位于 \"themes/LoveIt/assets/data/cdn/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/cdn/\" data = \"\" themes\\LoveIt\\layouts\\partials\\init.html中读取cdn文件中的数据，.Scratch.Set \"cdn\" $cdn设置全局变量，之后在其他文件中使用.Scratch.Get \"cdn\"获取cdn数据。 themes\\LoveIt\\layouts\\partials\\assets.html将cdn中的第三方库渲染后，追加在页面结尾部分。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"调用JS的三种方法 查找jsdelivr已有的第三方库，加入jsdelivr.yml中。 在themes\\LoveIt\\layouts\\partials\\assets.html中添加jquery.min.js，需要jquery文件位于assets\\js\\jquery.min.js。 {{- /* custom jquery */ -}} {{- $source := $cdn.jqueryJS | default ( resources.Get \"js/jquery.min.js\" ) -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} 配置文件中添加第三方库配置 # 第三方库配置 [page.library] [page.library.css] # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" # css路径：assets\\css\\custom.css customCSS = \"css/custom.css\" [page.library.js] # someJavascript = \"some.js\" # 位于 \"assets/\" # 或者 # someJavascript = \"https://cdn.example.com/some.js\" customJS = \"js/custom.js\" 完成以上配置后，可满足很多功能需求。但如果要拓展主题功能，像分类，列表页面，则需要学习Hugo语法。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"LoveIt - 4功能拓展","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"前言 本文介绍一些拓展功能，如文章页面功能增加二级菜单，相关文章推荐和赞赏。另外，使用脚本会大大简化写作后的上传流程。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"文章页面功能 这部分功能的拓展主要是用前端的JS和CSS，如果对前端不了解，可以参考放在Github上的网站源码。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"二级菜单 导航栏放都太多链接不分主次，不够简洁。尝试多种方案后，做出了现在的二级菜单。 使用bootstrap框架 引入了太多样式，界面被扰乱，不够友好。 Select标签 样式单一，不能修改。 Hover属性 多个二级菜单不能使用相同参数的绝对定位，拓展太麻烦。 最终方案是：引入Jquery，使用Jquery的slideToggle()方法。可拓展，不影响原有界面。步骤如下。 调整下拉菜单的样式 /* dropdown menus css*/ .dropdown { position: relative; display: inline; margin: 0px; } .dropdown-menu { position: absolute; left: 0; z-index: 1000; float: left; min-width: auto; padding: 2px 1px; font-size: 14px; text-align: left; list-style: none; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu-mobile { width: 100%; position: relative; background: transparent; text-align: center; } .dropdown-menu.show { display: block; } .dropdown-item { display: block; margin: .4rem 0.5rem; clear: both; font-weight: 400; color: #212529; text-align: inherit; white-space: nowrap; background-color: transparent; line-height: 1.5rem; } .btn { vertical-align: inherit; font-weight: 400; color: #212529; text-align: center; -webkit-user-select: none; user-select: none; background-color: transparent; font-size: 1rem; border-radius: .25rem; } /* dropdown menus css*/ 调用JS $(\".dropdown\").each(function() { $(this).on(\"click\", function(e) { // 收起其他菜单 if (isMobile()) { $(\".menu\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } else { $(\".menu-inner\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } e.stopPropagation(); var downmenu = $(this).children(\"div\"); // 展开菜单 downmenu.slideToggle(\"fast\"); // 点击其他地方，隐藏菜单 if (downmenu.is(\":visible\")) { $(document).one(\"click\", function() { downmenu.slideUp(\"fast\"); }); } }); }); # 移动端 function isMobile(){ return window.matchMedia(\"only screen and (max-width: 680px)\").matches; } 修改菜单模板，详细代码参考header.html \u003cdiv class=\"menu\" style=\"overflow: visible\"\u003e \u003cdiv class=\"menu-inner\"\u003e {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\" style=\"display: inline;\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu\" style=\"display: none;\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active {{ end }}\" href=\"{{ $url }}\"{{ with .Title }} title=\"{{ . }}\"{{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e {{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} {{- end -}} {{- /* Mobile header */ -}} {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu dropdown-menu-mobile\" style=\"display: none\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item\" href=\"{{ $url }}\" title=\"{{ .Title }}\"{{ i","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"相关文章推荐 参考Related Content themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*see also*/ -}} # 显示tag分类相关的前5篇文章 {{ $related := .Site.RegularPages.RelatedIndices . \"tags\" | first 5 }} {{ with $related }} \u003cdiv id=\"related-article\"\u003e \u003cp\u003e{{- T \"seeAlso\" -}}\u003c/p\u003e \u003cul\u003e {{ range . }} \u003cli\u003e\u003ca href=\"{{ .RelPermalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/div\u003e {{ end }} ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"赞赏 赞赏功能需要在data\\imgURL.toml中添加图片的URL。 alipay = \"https://img.xiaodejiyi.com/img/alipay.jpg\"weichatPay = \"https://img.xiaodejiyi.com/img/wechat%20pay.jpg\" 然后在模板文件themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /* sponsor */ -}} \u003cdiv style=\"text-align:center;margin-bottom:30px;\"\u003e \u003ch5 style=\"font-weight:600;margin-bottom:10px;\"\u003e「\u0026nbsp;{{- T \"thanksSponsor\" -}}\u0026nbsp;」\u003c/h5\u003e \u003cbutton id=\"rewardButton\"\u003e\u003cspan\u003e{{- T \"tips\" -}}\u003c/span\u003e\u003c/button\u003e \u003cdiv id=\"QR\" style=\"display: none;\"\u003e \u003cdiv id=\"wechat\" style=\"display:inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"wechat_qr\" src=\"{{ .Site.Data.imgURL.weichatPay }}\" alt=\"WeChat Pay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"weichatTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003cdiv id=\"alipay\" style=\"display: inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"alipay_qr\" src=\"{{ .Site.Data.imgURL.alipay }}\" alt=\"Alipay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"aliTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"版权声明 themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*copyright*/ -}} \u003cdiv id=\"copyright-container\"\u003e \u003cul class=\"post-copyright\"\u003e \u003cli class=\"post-copyright-author\"\u003e \u003cstrong\u003e{{- T \"articleAuthor\" -}}：\u003c/strong\u003e\u003ca href=\"{{ $.Site.Author.link | default .Site.Home.RelPermalink }}\" target=\"_blank\"\u003e{{ T \"penname\" }}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-link\"\u003e \u003cstrong\u003e{{- T \"articleLink\" -}}：\u003c/strong\u003e\u003ca href=\"#\" target=\"_blank\" title=\"{{ .Title }}\"\u003e{{- .Permalink | safeHTML -}}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-license\"\u003e \u003cstrong\u003e{{- T \"copyRight\" -}}：\u003c/strong\u003e {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e 需要使用T函数翻译并且根据不同语言传递参数。 [copyRightMsg] other = \"本站所有文章除特别声明外，均采用 {{ .preCopyRight }} 转载请注明来自 {{ .afterCopyRight }} \" .Site.Params.footer.license在config.toml中设置: license = 'https://creativecommons.org/licenses/by-nc-sa/4.0/' ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"同步文章到服务器 如果需要了解同步文章到对象存储平台，请参考Hugo 静态网站部署及免费 HTTPS 证书配置和OSS常用工具汇总。 文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 文章同步到服务器的步骤如下。 本地创建博客文章 配置SSH免密登陆 使用Python脚本生成网站静态资源，提交变更 Github Action使用rsync同步网站静态资源到服务器，并使用atomic-algolia同步index.json到Algolia。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"创建文章 在archetypes目录下的创建模板文件，使用hugo new --kind post-bundle posts/my-post生成指定模板的样例文章，不需要每次复制文章头部参数。 archetypes\\post-bundle\\index.md文件内容。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:1","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"SSH免密登陆 注意！服务器端要配置authorized_keys。参考设置 SSH 通过密钥登录 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:2","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"注册Algolia 使用Algolia搜索引擎为博客提供搜索功能。参考搜索配置 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:3","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"本地同步与备份脚本 在博客目录下执行该脚本，先推送blog到Github的blog仓库，再本地备份。(相信看到这里的读者都有Github帐号了) import time import os, sys def main(msg): # 备份blog/ print(\"*\"*10+\"push blog/\"+\"*\"*10, end=\"\\n\\n\") # 生成静态页面 os.system('hugo') # 需要安装Git os.system('git add .') os.system('git commit -m \"{}\"'.format(msg)) os.system('git push') local_back = input('\\n本地备份？提示: y\\n') if local_back == 'y': #7z、winrar压缩参数是一样的，只有winrar的话，7z换成winrar也可以运行 os.system(r'7z a D:\\src\\xxxxx.rar D:\\src\\xxxxx') os.system(r'move D:\\src\\code\\xxxxx.rar D:\\backup\\xxxxx') print('本地备份完成！') print('over...') if __name__ == '__main__': msg = input('commit: ') main(msg) 如果需要安装Git，试试Scoop，它用来安装应用程序非常方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:4","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"Github Action blog/文件根目录下创建package.json文件，并在scripts模块中加入\"algolia\": \"atomic-algolia\"。 { \"name\": \"algolia\", \"version\": \"0.2.0\", \"description\": \"atomic-algolia package\", \"private\": true, \"scripts\": { \"algolia\": \"atomic-algolia\" } } 在Github的Blog仓库中添加Secrets变量 同步index.json到Algolia需要配置如下变量： ALGOLIA_ADMIN_KEY ALGOLIA_APP_ID ALGOLIA_INDEX_NAME rsync同步需要配置如下变量 HOST PORT USER REMOTE_PATH Nginx中配置的网站根目录 SSH_KEY 使用Github Action，创建workflow，复制以下代码。 name: deploy_blog on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps:- name:Check Outuses:actions/checkout@v2#同步blog搜索- name:Use Node.jsuses:actions/setup-node@v1with:node-version:'12.x'- name:Install automic-algoliaenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:zh-cnALGOLIA_INDEX_FILE:\"./public/index.json\"run:| npm install atomic-algolianpm run algolia# 同步英语文章的json- name:en jsonenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:enALGOLIA_INDEX_FILE:\"./public/en/index.json\"run:| npm run algolia- name:deploy to serveruses:AEnterprise/rsync-deploy@v1.0env:DEPLOY_KEY:${{ secrets.SSH_KEY }}# avzr参数，增量备份本地文件。-delete 删除目标地址中本地没有的文件ARGS:\"-avzr --delete\"SERVER_PORT:${{ secrets.PORT }}FOLDER:\"./public/\"SERVER_IP:${{ secrets.HOST }}USERNAME:${{ secrets.USER }}SERVER_DESTINATION:${{ secrets.REMOTE_PATH }} 如果出现问题，先在本地创建linux虚拟机，测试rsync命令，确定服务器同步是否正常。 代码改变世界，现在，写作多么简单。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:5","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo官方文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"LoveIt - 5页面模板","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"前言 最初在制作友链界面时，没有学习Hugo框架，一头雾水。网上有关的教程甚少，只能去学一遍Hugo。 在学习Hugo的过程中，了解了列表模板，分类模板。开发了几个功能页面，如：留言板，友链，记忆分类等。 本文介绍这些功能页面。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:1:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"里程碑页面 首先需要了解头部参数type，通过type指定文章使用的模板类型，默认为page类型。 要注意特殊模板的文章放在一般content根目录下，模板放在layouts目录下。 里程碑界面依据themes\\LoveIt\\layouts\\posts\\single.html修改，删除赞赏，相关文章推荐等功能。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- .Scratch.Delete \"this\" -}} {{- $params := .Scratch.Get \"params\" -}} {{- $toc := $params.toc -}} {{- if eq $toc true -}} {{- $toc = .Site.Params.page.toc | default dict -}} {{- else if eq $toc false -}} {{- $toc = dict \"enable\" false -}} {{- end -}} {{- /* Auto TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"toc\" id=\"toc-auto\"\u003e \u003ch2 class=\"toc-title\"\u003e{{ T \"contents\" }}\u003c/h2\u003e \u003cdiv class=\"toc-content{{ if eq $toc.auto false }} always-active{{ end }}\" id=\"toc-content-auto\"\u003e\u003c/div\u003e \u003c/div\u003e {{- end -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e \u003ci class=\"fas fa-monument fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} \u003c/h1\u003e {{- /* Static TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003cdiv id=\"post-footer\"\u003e\u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 这个模板也可以制作“爱情故事”。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:2:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"关于页面 相对里程碑界面，关于界面又删除了目录。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e{{ .Title }}\u003c/h1\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c!-- 这里的版权声明是根据文章内容添加的，可删除 --\u003e {{- /*copyright*/ -}} {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 类似的留言板页面可以使用默认的\"page\"类型。如果页面中有标题，同时不希望有目录，“关于”页面的模板更合适。或者使用头部参数toc: false禁用目录。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:3:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"列表模板 列表页面是在文章的头部自定义参数，在模板中渲染。例如友链模板，参考LoveIt-extend/content/links/index.zh-cn.md。 头部参数需要按照yml文件的格式，注意不能用tab缩进。 links:me:name:我 weight:1people:- name:朤尧url:https://www.xiaodejiyi.com/avatar:https://www.gravatar.com/avatar/ae94c8d8ca3d56eb035a3e62c2595150?s=240\u0026d=mpdescription:just do sth i should do.friends:name:朋友 weight:2people: links模板为： \u003c!-- links按照weight排序，排序后改变了原来的数组结构，相当于weight变为key值，其他数据组成value --\u003e {{- range $weight, $website := sort .Params.links \"weight\" -}} \u003ch3 id=\"{{ $website.name }}\" tabindex=\"-1\" style=\"outline: none;\"\u003e\u003ca href=\"#{{ $website.name }}\"\u003e\u003c/a\u003e{{ $website.name }}\u003c/h3\u003e \u003cul style=\"list-style: none;\" id=\"firendLink\"\u003e {{- range $website.people -}} \u003cli\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"media\"\u003e \u003cdiv class=\"media-left\"\u003e\u003cimg src=\"{{ .avatar }}\" width=\"55\"\u003e\u003c/div\u003e \u003cdiv class=\"media-content\"\u003e \u003ci class=\"fa fa-user-ninja fa-fw\"\u003e\u003c/i\u003e \u003c!-- . 是 当前作用域 --\u003e {{ .name }}\u0026nbsp;\u003ci class=\"fa fa-link fa-fw\"\u003e\u003c/i\u003e \u003ca href=\"{{ .url }}\" target=\"_blank\"\u003e{{ .url }}\u003c/a\u003e \u003cp\u003e{{ .description }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/li\u003e {{- end -}} \u003c/ul\u003e {{- end -}} 不过这里有一个Bug，content\\links\\index.zh-cn.md正文部分不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 生成目录的代码： \u003c!-- 修改前的侧边目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e \u003c!-- 修改后links的目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e {{- /* modify director */ -}} {{- range $weight, $website := sort .Params.links \"weight\" -}} {{- $groupName := dict \"Content\" $website.name \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003cli\u003e\u003ca href=\"#{{ $groupName }}\"\u003e{{ $groupName }}\u003c/a\u003e\u003c/li\u003e {{- end -}} \u003c/ul\u003e \u003c/nav\u003e \u003c/div\u003e \u003c/div\u003e 问题不大，还能用。同理，可以使用列表模板制作说说，相册，视频页面，只是样式设计上不同。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:4:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"分类模板 分类模板，需要考虑模板的渲染顺序，这个顺序很长，参考Hugo’s Lookup Order，而且需要其他背景知识，如type的详细分类等等。 不过，按照以下步骤，你不需要深入研究这个复杂的顺序。 在config.toml中配置分类 categories和tags为默认分类 [taxonomies]# 左边单数，右边复数形式category = \"categories\"tag = \"tags\"booklist = \"booklist\" 创建样例文章 在文章的头部参数中添加分类，注意要有中括号： categories: [\"demo1\"]tags: [\"demo2\"]booklist:[\"demo3\"] 创建分类模板 首先要覆盖主题默认的分类模板，分析默认模板themes\\LoveIt\\layouts\\taxonomy\\list.html的代码： ... {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} {{- printf \"%v - %v\" (T $taxonomy | default $taxonomy) .Title -}} {{- end -}} ... 可以发现，默认模板中包含了category,tag和其他，这三种模板。 所以覆盖需要将这个模板拆开，复制到博客的layouts目录下，分别命名为：categories,tags,taxonomy。内容上可以不修改，也可以将if语句剪枝。例如layouts\\categories\\list.html： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 覆盖之后，创建booklist分类的模板，复制categories分类的模板，修改为： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"booklist\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 是的，将if判断的category改为booklist，再换个Font Awesome图标。不要忘了还有layouts\\booklist\\terms.html也要改，同样修改if判断，改标题，改图标。 刷新界面，看看booklist分类有没有demo3的文章。如果没有，hugo server重新启动，现在应该有了。Hugo在这方面不能实时刷新。 首页文章增加分类 回到首页，你会发现，文章只有categories和tags的分类：demo1和demo2。添加demo3需要在themes\\LoveIt\\layouts\\_default\\summary.html中加入新的分类。 {{- $booklist := slice -}} {{- range .Params.booklist -}} {{- $category := partialCached \"function/path.html\" . . | printf \"/booklist/%v\" | $.Site.GetPage -}} {{- $booklist = $booklist | append (printf `\u003ca href=\"%v\"\u003e\u003ci class=\"fas fa-file-alt fa-fw\"\u003e\u003c/i\u003e%v\u003c/a\u003e` $category.RelPermalink $category.Title) -}} {{- end -}} {{- with delimit $booklist \"\u0026nbsp;\" -}} \u0026nbsp;\u003cspan class=\"post-category\"\u003e {{- . | safeHTML -}} \u003c/span\u003e {{- end -}} 继续加其他分类，只需要再复制一段，用编辑器Ctrl+H替换代码中的booklist。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:5:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"笔记页面 博客最初的设计是Hugo写文章，VuePress记笔记。在写这篇教程的过程中发现，如果把OneNote记的笔记放到VuePress上，再写文章，这会消耗大量时间。 不过VuePress能给文章加上一个背景知识。权衡之后放弃了VuePress。 如果你需要搭建一个笔记网站，可以考虑VuePress和Hugo的learn主题。 VuePress搭建过程可以参考B站教程和VuePress 中文文档。 搭建时需要注意这两点： Auto Sidebar插件自动生成侧边导航栏，如果没有这个插件，VuePress会繁琐得不想再用。 内置搜索只为页面的标题、h2、h3以及tags构建搜索索引。docsearch只支持技术文档，不支持博客索引和商业内容。Algolia搜索的方法可行，但是配置Algolia步骤很麻烦。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:6:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"最后 博客搭建教程结束，如果你想要添加更多的功能，更灵活的开发自己的博客，那么学习Hugo框架吧！只是这需要投入一些成本，学习Hugo花了11个小时，开发又用了95个小时。或许你还需要了解下自媒体以及公众号，知乎等其他写作平台，这消耗了28个小时。（番茄工作法统计得出） 专心于博客的内容创作或许是更好的选择，希望这篇教程可以帮到你。 如果想学习Hugo，那么Hugo论坛是一个不错的地方。 我为什么要搭博客呢？把知识留下来！ ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:7:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"参考 Hugo官方文档 LoveIt-extend LoveIt Theme ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:8:0","series":null,"tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"alloc创建一个对象","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","series":null,"tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"​ alloc创建一个对象 dealloc销毁对象 retain增加对象的保留计数器值 release减少对象的保留计数器值 retainCount获得保留计数器的当前值 autorelease将来一个时间自动释放 NSAutoreleasePool自动释放池 ","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/:0:0","series":null,"tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"NSArray","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/","series":null,"tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSArray 是一个Cocoa类，用来存储对象的有序列表 arrayWithObjects用来创建新的NSArray initWithObjects 初始化数组并赋值 objectAtIndex获取指定索引处的对象 componentsSeparatedByString切分NSArray componentsJoinedByString合并NSArray NSMutableArray可变数组 arrayWithCapacity创建可变数组 addObject在数组末尾添加对象 removeObjectAtIndex删除特定索引处的对象 ","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/:0:0","series":null,"tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSEnumerator","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/","series":null,"tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSEnumerator 用来描述集合运算的方式 objectEnumerator向数组请求枚举器 reverseObjectEnumerator从后向前浏览集合 nextObject下一个对象 NSDictionary字典，在给定的关键字下存储一个数值 dictionaryWithObjectsAndKeys创建字典 objectForKey获取字典中的值，向方法传递之前用来存储该值的关键字 NSMutableDictionary可变字典 dictionary可以向类NSMutableDictionary发送dictionary消息创建可变字典 dictionaryWithCapacity创建可变字典 setObject: forkey:给字典添加元素 removeObjectForKey删除可变字典中的关键字 ","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSNumber","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","series":null,"tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSNumber 用来包装基本数据类型 numberWithInt创建NSNumber intValue提取NSNumber NSValue可以包装任意值 valueWithBytes: objCType:创建新NSValue getValue提取NSValue @encode编译器指令可以接受数据类型的名称并为你生成合适的字符串 valueWithSize将struct型数据转换成NSValue NSNull代表无 NSFileManager对文件系统进行操作 defaultManager创建NSFileManager对象 stringByExpandingTildeInpath替换当前用户的主目录 NSDirectoryEnumerator 是NSEnumerator的子类，调用nextObject时返回该目录中一个文件的另一个路径，这个方法也可以搜索子目录。 pathExtension输出文件的扩展名(去掉了扩展名前面的点) ","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","series":null,"tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSPredicate类","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/","series":null,"tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"NSPredicate类 用于制定过滤器的条件 +predicateWithFormat创建谓词 -evaluateWithObject通知谓词根据指定的对象计算自身的值 -filteredArrayUsingPredicate循环过滤数组内容，根据谓词计算每个对象的值，并将值为Yes的对象累积到将被返回的新数组中 copy指针复制，浅拷贝，返回的是不能修改的对象 mutableCopy对象复制，深拷贝，返回的是可修改的对象 -filterUsingPredicate针对可变数组进行过滤及返回 predicateWithSubstitutionVariables构造新的专用谓词，创建一个键/值对字典，其中，键是变量名，值是插入谓词的内容 \u0026\u0026 AND 和 || OR 或 ! NOT 非 BETWEEN { }之间 BEGINSWITH检查某个字符串是否以另一个字符串开头 ENDSWITH检查某个字符串是否以另一个字符串结尾 CONTAINS检查某个字符串是否在另一个字符串内部 [c]不区分大小写 [d]不区分发音符号 [cd]不区分以上两项 LIKE 匹配运算符 ","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/:0:0","series":null,"tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"协议","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/","series":null,"tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"​ 协议 @protocol创建协议 encodeWithCoder用于接受对象的实例变量并将其转换为NSCoder类的对象 initWithCoder从NSCoder类的对象中提取经过转换的冻结的实例变量并使用它们初始化一个新对象 copyWithZone复制到一块可供分配的内存区域 class所属的类 allocWithZone分配内存并创建一个该类的新对象 @optional协议中的可选方法 @required协议中的必选方法 ","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/:0:0","series":null,"tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"多视图应用程序","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","series":null,"tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"多视图应用程序 UITabBarController标签栏界面 UINavigationController导航栏界面 addSubview添加视图，是将view加到所有层的最顶层 insertSubview在索引位置插入视图 initWithNibName: bundle:加载nib文件 removeFromSuperview从父视图删除 beginAnimation: context:声明动画块 setAnimationDuration:动画持续时间 setAnimationCurve:动画曲线 setAnimationTransition:动画转换类型 ","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:0","series":null,"tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"导航控制器和表视图(一)","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/","series":null,"tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"​ 导航控制器和表视图(一) UINavigationController 导航控制器 accessoryType 附件类型 navigationController 导航控制器属性 pushViewController: 入栈方法 viewWillAppear: 视图出现时加载 NSIndexPath 属性,索引路径 UITableViewCellAccessoryCheckmark 属性,检查标记(对勾) UITableViewCellAccessoryNone 属性,无标记 deselectRowAtIndexPath 取消选中某行 buttonWithType 按钮格式 setBackgroundImage 设置背景图片 addTarget 添加目标 forControlEvents 按钮事件 accessoryView 附加视图 buttonTapped: 轻击按钮 ","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/:0:0","series":null,"tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"文件加载和保存","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/","series":null,"tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"​ 文件加载和保存 date获取当前的时间和日期 dateWithTimeIntervalSinceNow获取与当前时间相隔一定时差的日期 const它限定一个变量不允许被改变 writeToFile:atomically:将属性列表写入文件 arrayWithContentsOfFile读取文件 code编码 decode解码 encodeSomething: forKey:编码方法 decodeSomethingForKey解码方法 NSKeyedArchiver归档 archivedDataWithRootObject创建归档实例 NSKeyedUnarchiver重新创建档案,和归档相反 unarchiveObjectWithData重新创建档案实例 ","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/:0:0","series":null,"tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"更丰富的用户界面(一)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/","series":null,"tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(一) resignFirstResponder取消第一响应者状态 UISlider滑块控件 UISegmentedControl分段开关控件 #define定义常量 UISwitch切换开关控件 UITxtField文本控件 { isOn 获取切换开关控件的状态 setOn设置切换开关控件的状态 animated移动方式 YES为缓慢 NO为瞬间 } selectedSegmentIndex分段控件索引 hidden隐藏 { UIActionSheet操作表控件 initWithTitle:初始化操作表 delegate:操作表响应的委托 cancelButtonTitle:取消按钮 destructiveButtonTitle:继续按钮 otherButtonTitles:其它按钮 } ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/:0:0","series":null,"tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(二)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/","series":null,"tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"更丰富的用户界面(二) showInView:在视图中显示 view视图 { UIAlertViewDelegate警报委托控件 UIActionSheetDelegate操作表委托控件(在例子中作为协议) actionSheet: didDismissWithButtonIndex:(在例子中作为协议的方法) } buttonIndex 按钮的索引 cancelButtonIndex 取消按钮的索引 { UIAlertView 警报控件 initWithTitle:初始化警报 message:警报内容 delegate:警报响应的委托 cancelButtonTitle:取消按钮 otherButtonTitles:其它按钮 } viewDidLoad视图加载方法 viewDidUnload视图卸载方法 UIImage图像控件 imageNamed: 加载图像文件 UIImageView 图像视图控件 initWithImage: 初始化图像视图 ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/:0:0","series":null,"tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"特性","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/","series":null,"tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"​ 特性 @property表示声明了一个新对象的属性，自动声明属性的setter和getter方法 @synthesize 表示创建该属性的访问器 readwrite读写属性 readonly只读 ","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/:0:0","series":null,"tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"笔记1","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/","series":null,"tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"​ 笔记1 \\n换行符 new 是alloc和init的结合 double精度是float的两倍 char单个字符 %o 八进制整数 %x十六进制整数 %f浮点计数法 %e科学计数法 %g %a和%f一样 long扩展值域，输出时要在%后添加l long long 特定扩展%后加ll short缩小值域 %后加h unsigned正数(无符号) id NSLog字符%p ","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/:0:0","series":null,"tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"自动旋转和自动调整大小","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/","series":null,"tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"​ 自动旋转和自动调整大小 shouldAutorotateToInterfaceOrientation:旋转支持 willAnimateRotationToInterfaceOrientation: duration: 此方法将在旋转开始之后，最后的旋转动画发生之前自动调用 UIInterfaceOrientation界面方向控件 NSTimeInterval间隔时间 frame框架 CGRectMake大小和位置 transform变换 bounds边界 ","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/:0:0","series":null,"tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"键/值编码","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/","series":null,"tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"​ 键/值编码 count计数 -valueForKey: 读取方法,以字符串的形式向对象发送消息 -setValue: forKey: 设置方法,以字符串的形式向对象发送消息(设置标量值需要封装数据) -valueForKeyPath: 路径读取方法 -setValue: forKeyPath: 路径设置方法 @运算符,它获取左侧指定的集合,对该集合中的每个对象使用右侧的键路径,然后将结果转换为一个集合 @count计数 @sum求和 @avg求平均值 @min取最小值 @max取最大值 @distinctUnionOfObjects取交集 lastObject方法,最后一个对象 dictionaryWithValuesForKeys它接受一个字符串数组,该数组中的数据成为键,对每个键使用读取方法,然后为键字符串和刚才获得的值构建一个字典. setValuesForKeysWithDictionary批量修改,用字典来修改键值 setNilValueForKey重设nil意义 valueForUndefinedKey:读取未知键 setValue: forUndefinedKey: 设置未知键 ","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/:0:0","series":null,"tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"2021 ","date":"2020-07-01","objectID":"/milestone/:0:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"5月 10日，开始学习《Shark恒零基础百集软件逆向教程》，暂时学完前两期。历时两周。 25日，开始学习《2020DNF》、《2020DOF》、《2021DNF不完整》系列教程。历时5天。 30日，开始学习《英雄联盟LOL》、《亿万僵尸》、《CE WALKer》，历时9天。 ","date":"2020-07-01","objectID":"/milestone/:1:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"6月 8日，开始学习《小冷过游戏检测技术》及相关过检测教程，历时4天。期间还看了WOW按键视频。 12日，开始学习《植物大战僵尸》，历时9天。 23日，开始学习《CS》。 27日，开始各种尝试，然后放弃，继续看其它教程。 ","date":"2020-07-01","objectID":"/milestone/:2:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"7月 3日，开始学习《郁金香2020 WOW》，教程未完待续。历时19天。 24日，开始学习《郁金香2019 VS2010》，教程不完整，历时16天。 26日，开始利用闲暇时间搭建博客，用于记录笔记及心路历程。尝试搭了5个不同的博客，第一款基于jekyll框架，效果不理想，之后不断摸索。 ","date":"2020-07-01","objectID":"/milestone/:3:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"8月 4日，博客最终锁定了Hugo框架LoveIt模板，也就是现在看到的样子。 10日，开始学习《任鸟飞2015天涯明月刀》，历时18天。 28日，开始学习《任鸟飞2019 C++之灵魂起源》，历时3天 ","date":"2020-07-01","objectID":"/milestone/:4:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"9月 1日，开始学习《任鸟飞2016 画江山》，历时18天 19日，开始学习《任鸟飞 封包的加密与解密、线程发包专题》，历时8天 27日，开始学习《任鸟飞逆向C++基础篇》,历时4天 ","date":"2020-07-01","objectID":"/milestone/:5:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"10月 1日，《任鸟飞逆向C++进阶篇》只学了前3节，其它需要付费。开始学习《飞郁网络培训 2018-2019》,历时12天 13日，粗看《3D游戏逆向试看》 研究目录 Shark恒零基础百集软件逆向教程（23:28） 《2020DNF》（6:53） 《2020DOF》（3:08） 《2021DNF不完整》（12:46） 英雄联盟LOL（3:16） 亿万僵尸（2:13） CE WALKer（6:38） 小冷过游戏检测技术（3:38） 植物大战僵尸（19:19） CS（4:54） 郁金香2020 WOW（21:13） 郁金香2019 VS2010（21:08） 任鸟飞2015 天涯明月刀 （26:40） 任鸟飞2019 C++之灵魂起源 不完整（12:07） 任鸟飞2016 画江山 （14:00） 任鸟飞 封包的加密与解密、线程发包专题 （4:06） 任鸟飞逆向C++基础篇 （6:21） 任鸟飞逆向C++进阶篇 收费（19:26） 任鸟飞逆向C++高级篇 收费（7:08） 飞郁网络培训 2018-2019 (17:08) 3D游戏逆向试看（8:17） 任鸟飞2016 LOL 不完整（6:24） 逆风魔兽 (11:40) 逆风游戏逆向C++\u0026易语言编程特训班(5:10) 逆风游戏安全逆向编程暑期班 微尘系列教程 IOS逆向分析 iOS底层原理班-大神MJ精选 安卓逆向 AGP论坛驱动教程 逆向4_X64dbg_翠翠妹子 (3:48) 汇编-魔鬼作坊 (3:13) 重楼(12:32) 梦无极过游戏驱动保护教程（25:20） 唐三藏逆向（2:11） HaiVince CE插件（00:16）需加群 ","date":"2020-07-01","objectID":"/milestone/:6:0","series":null,"tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","series":null,"tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"这个地方不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 ","date":"0001-01-01","objectID":"/links/:0:0","series":null,"tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"content ","date":"0001-01-01","objectID":"/websites/:0:0","series":null,"tags":null,"title":"网站收藏","uri":"/websites/"}]