[{"categories":null,"content":"LoveIt主题介绍：https://hugoloveit.com/zh-cn/ LoveIt主题仓库：https://github.com/dillonzq/LoveIt 更新搜索专用 shenweiwei hugo serve -e production ","date":"2021-08-01","objectID":"/2021/08/hello-world/:0:0","tags":null,"title":"LoveIt 主题","uri":"/2021/08/hello-world/"},{"categories":null,"content":"content.","date":"2021-08-01","objectID":"/2021/08/hello-world/:1:0","tags":null,"title":"LoveIt 主题","uri":"/2021/08/hello-world/"},{"categories":["Git"],"content":"pwd 显示当前目录 git init 初始化仓库 ls -ah 查看隐藏文件及目录 git add readme.txt 添加文件 参考网站-廖雪峰 ","date":"2021-08-06","objectID":"/2021/08/git%E7%AC%94%E8%AE%B0/:0:0","tags":["Git"],"title":"Git笔记","uri":"/2021/08/git%E7%AC%94%E8%AE%B0/"},{"categories":["GitHub"],"content":"首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可)。 等几分钟，等到它显示 “好消息！Cloudflare 正在保护您的站点” 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/:0:0","tags":["GitHub","域名"],"title":"Github绑定Cloudflare及freenom","uri":"/2021/08/github%E7%BB%91%E5%AE%9Acloudflare%E5%8F%8Afreenom/"},{"categories":["GitHub"],"content":"freenom域名申请 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:0:0","tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["GitHub"],"content":"freenom.com设置DNS freenom.com中选择Services-My Domains-\u003eManage Domain 然后选择选择下面的nameservers-\u003ecustom nameservers(enter below) 前面两行分别填入 BROAD.DNSPOD.NET PHONE.DNSPOD.NET 然后点击Change Nameservers 上述操作的意思是,不使用freenom.com的默认DNS,而是授权给DNSpod来处理域名解析 DNSpod设置 进入DNSPOD,实名认证后选择: DNS管理-\u003e我的域名-\u003e添加域名xinqi.cf https://console.dnspod.cn/dns/list 然后点击绿色小按钮右侧的域名xinqi.cf得到 下图: https://console.dnspod.cn/dns/yuchi.ml/record githubpage设置 ","date":"2021-08-05","objectID":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/:1:0","tags":["GitHub","域名"],"title":"Github绑定freenom域名","uri":"/2021/08/github%E7%BB%91%E5%AE%9Afreenom%E5%9F%9F%E5%90%8D/"},{"categories":["博客"],"content":"GitHub Pages 不仅不花钱，而且还有免费的证书拿，可以说是相当划算的。但有个问题就是 GitHub 的服务器都部署在海外，也就是说在国内访问本博客的速度的速度会比较慢 (Ping 下来 100 到 200 多毫秒)。 解决这一问题的最优解就是使用 CDN。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:0:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"CDN 是什么？ 内容分发网络（英语：Content delivery network 或 Content distribution network，缩写：CDN）是指一种透过互联网互相连接的计算机网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。  —— 维基百科 简单来说，CDN 就是部署在世界各地的缓存服务器，它们会提前缓存网站上的资源，然后当用户想要访问相关资源时，直接从 CDN 服务器上取就可以了。这样不仅可以增加访问速度减少访问延迟，还可以减缓网站服务器上的压力。 世界上的 CDN 服务提供商有很多，七牛云、阿里云、腾讯云等等都提供了 CDN 服务，它们有的收费有的部分免费。我今天选择的 CDN 服务来自于 Cloudflare。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:1:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"Why Cloudflare？ Cloudflare 是全球最大的 DNS 服务提供商之一 (号称是全球最快的 DNS 1.1.1.1 就是它们搞的)。除此之外他们还提供 CDN、SSL 证书、DDos 保护等服务，并且 Cloudflare 与百度有合作，在国内也部署有大量的节点，还能顺便解决百度爬无法抓取 GitHub Pages 的问题。我今天要使用的就是免费版的 SSL 证书以及 CDN 服务。 除了 Cloudflare 比较 NB 以外选择他的另一个更重要的原因是国内的 CDN 无一例外都要要求域名在公安局备过案。作为一个遵纪守法的好市民，我肯定是不怕什么公安局备案的，我主要是觉得太麻烦了。并且在公安局备案后，放到网站上的那个小图标有点丑 ,,Ծ‸Ծ,, ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:2:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"配置 CDN 首先要去 Cloudflare 注册一个帐号。注册好后点击 Add site 添加你的网站。 添加好后选择免费的那个计划 (Plan)，有钱也可以选择收费的，提供的服务更多。 然后 Cloudflare 会读取你的 DNS 配置，没有问题的话直接点 Continue 即可。 然后 Cloudflare 会要求你将你的 DNS 服务器替换成他提供的，到你的域名商那里设置一下即可 (添加或替换均可) 等几分钟，等到它显示 Great news! Cloudflare is now protecting your site 就说明设置成功了。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:3:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"设置 SSL 证书 除了免费的 DNS 和 CDN 以外，Cloudflare 还提供了免费的 SSL 证书。 Cloudflare 的 SSL 证书默认是已经开启了的。不过最好还是在 Crypto 页面将 Always Use HTTPS 勾选上，这个选项可以自动在访问你的网站时将所有的 http 的链接重定向到相应的 https 链接上。 ","date":"2021-08-05","objectID":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/:4:0","tags":["GitHub","博客"],"title":"为博客添加免费的 CDN (Cloudflare)","uri":"/2021/08/%E4%B8%BA%E5%8D%9A%E5%AE%A2%E6%B7%BB%E5%8A%A0%E5%85%8D%E8%B4%B9%E7%9A%84-cdn-cloudflare/"},{"categories":["博客"],"content":"使用Hugo+LoveIt主题搭建博客 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 Hugo 可参考Hugo 官方的 Quick Start ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装二进制（Mac） # 使用brew安装hugo brew install hugo # 创建新项目（网站） hugo new site my_website # 生成用于发布的静态文件（不包含草稿） hugo # 生成用于发布的静态文件（包括草稿） hugo -D # 本地运行网站 hugo server ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"直接使用 Docker # 创建新项目（网站） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo \\ new site my_website # 生成用于发布的静态文件（不包含草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo # 生成用于发布的静态文件（包括草稿） docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo -D # 本地运行网站 docker run --rm -it \\ -v $(pwd):/src \\ -p 1313:1313 \\ klakegg/hugo \\ server 可以在镜像后面增加版本号，指定使用的hugo版本 # 比如 docker run --rm -it \\ -v $(pwd):/src \\ klakegg/hugo:0.82.0 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装 LoveIt 主题 # 位于你的博客项目根目录 git clone https://github.com/dillonzq/LoveIt.git themes/LoveIt 代码克隆成功后在./themes文件夹下应出现LoveIt文件夹。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"项目文件树结构 . ├── archetypes # markdown文章的模版 ├── config.toml # 配置文件 ├── content # 网站内容，主要保存文章 ├── data # 生成网站可用的数据文件，可用在模版中 ├── layouts # 生成网站时可用的模版 ├── public # 通过hugo命令生成的静态文件，主要发布这个 ├── resources # 通过hugo命令一起生成的资源文件，暂时不知道什么用 ├── static # 静态文件，比如文章中的图片/视频文件、缩略图等 └── themes # 保存可用的hugo主题 通常，我们只会用到以下几个文件夹的东西 config.toml ：保存 hugo 的配置，包括主题的配置等。详细设置见下方 #网站配置 content：保存网站的各种内容，比如文章。 archetypes： 保存文章的 markdown 模版，通常包括文章的前缀注释，是一些在创建新文章时会被用到。 static ：保存文章中用到的静态文件，比如图片、网站缩略图等。 public ：通过hugo命令生成的静态 html 文件、css、js 等。在服务器上发布时主要发布这个文件夹。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置网站设置 配置文件位置：./config.toml 引用 具体的配置条目参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置缩略图 使用的网站：https://realfavicongenerator.net/ 获取缩略图的各种格式 下载到的全部内容\" 下载到的全部内容 将整个压缩包的文件（包括图片之外的文件）放到./static下 重启浏览器，应该可以看到标签上的缩略图出现了。 浏览器标签出现缩略图\" 浏览器标签出现缩略图 缩略图没生效？ 缩略图未生效的原因可能是浏览器使用了之前的缓存。尝试： 彻底关闭并重启浏览器。 通过这个步骤强制删除缓存。 强制 Chrome 禁用网页缓存。 打开 Chrome 开发者工具。（网页空白处右键-检查，或者按 F12） 在Network栏勾选Disable cache。 或者在设置里找到Preferences -\u003e Network -\u003e Disable cache ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:5:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"开始写第一篇文章 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"文章前缀参数 在每篇 markdown 文章最前面可以用一部分注释来告诉LoveIt主题，这篇文章的属性，譬如文章标签、分类、是否为草稿等。 引用 详细可参考LoveIt 官方文档 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"将文章前缀参数保存在 markdown 模版中 模版文件位置：./archetypes/default.md 我使用的md模版 --- title: \"{{ replace .TranslationBaseName \"-\" \" \" | title }}\" subtitle: \"\" date: {{ .Date }} draft: true tags: [] categories: [] hiddenFromHomePage: false hiddenFromSearch: false featuredImage: \"\" featuredImagePreview: \"\" license: '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' --- ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成新文章 生成新文章的命令： hugo new posts/文章标题.md 执行完成后，在./content/posts目录下应该可以看到新文件，同时里面已经有 markdown 模版中的文章前缀参数。 技巧 也可以手动复制旧文章来生成新文章，不通过命令。 也可以在content文件夹下建新的文件夹，方便管理。这种情况下生成的静态 Html 文件路由效果如下： . └── content └── about | └── index.md // \u003c- https://example.com/about/ ├── posts | ├── firstpost.md // \u003c- https://example.com/posts/firstpost/ | ├── happy | | └── ness.md // \u003c- https://example.com/posts/happy/ness/ | └── secondpost.md // \u003c- https://example.com/posts/secondpost/ └── quote ├── first.md // \u003c- https://example.com/quote/first/ └── second.md // \u003c- https://example.com/quote/second/ ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:3","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"本地调试 本地调试命令： hugo server --disableFastRender 本地运行网站\" 本地运行网站 出现成功的提示后在浏览器打开http://localhost:1313即可看到网站。 Bug 如果你看到如图的编译错误，可能是因为你的文章除了前缀参数外没有任何内容。随便写几句话就可以解决这个问题。 有文章为空时的编译报错\" 有文章为空时的编译报错 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:6:4","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 Github 仓库 个人建议创建两个仓库： 一个用于托管博客项目源文件，包括配置文件等包含后续可能配置 API KEY 的东西。设置权限为 Private（不公开） 一个用于托管博客编译后生成的静态 Html 文件(即使用 hugo 命令编译生成的public文件夹)，并配置该仓库使用 Github Pages，然后 Github 就会自动检测到它其中的静态Html文件并搭建网站。设置权限为 Public（公开） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第一个仓库 按照常规方式创建仓库即可，反正设置为private权限等级，也没人看得见。 第一个仓库示例，保存博客源代码\" 第一个仓库示例，保存博客源代码 链接本地仓库与远端仓库 ## 位于博客源代码根目录 ## 初始化本地Git仓库 git init ## 设置名为Origin的远端Git仓库 git remote add origin {{这里替换成你的仓库在Github Clone用的地址}} ## 选择所有文件 git add -A ## Push到github git push -u origin master 创建.gitignore 在源代码项目中创建.gitignore文件，来防止把生成的静态文件上传。创建位置如下： . ├── .git ├── .github ├── .gitignore \u003c---- 在根目录下 ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes 在.gitignore中写入/public，来防止 Git 将其上传。 cat .gitignore ## 输出 /public ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"第二个仓库 创建仓库，注意名称 第二个仓库名字比较重要，必须是{{你的github用户名}}.github.io。 比如我的 Github 名字为JellyZhang,那么我需要创建的仓库名称为JellyZhang.github.io，如图所示。 第二个仓库示例（注意仓库名称与自己用户名对应）\" 第二个仓库示例（注意仓库名称与自己用户名对应） 在仓库设置里设置启用Github Pages 找到仓库设置\" 找到仓库设置 找到Pages一栏\" 找到Pages一栏 设置Branch与静态文件位置\" 设置Branch与静态文件位置 这个地方设置Branch为master，静态文件位置为/(root)，原因是我们在下个步骤中会直接将生成的public文件夹中的内容push到master分支的/目录下。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:7:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"给源代码仓库添加 Github Action ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"创建 CI 脚本 什么是Github Action? Github Action 是 Github 提供的 CI 系统，可以让用户编写脚本，并在触发指定的操作后（比如新 commit push 到仓库），自动触发脚本。它可以： 编译项目 测试项目 登陆远程服务器 发布服务 等等…… 在源代码项目根目录下新建.github/workflow/main.yml。(通过 Github Action 网页端操作也可以) . ├── .git ├── .github │ └── workflows │ └── main.yml \u003c---在这里创建 ├── .gitignore ├── README.md ├── archetypes ├── config.toml ├── content ├── data ├── layouts ├── public ├── resources ├── static └── themes main.yml脚本内容： # This is a basic workflow to help you get started with Actionsname:CI# Controls when the action will run.on:# Triggers the workflow on push or pull request events but only for the master branchpush:branches:[master]pull_request:branches:[master]# Allows you to run this workflow manually from the Actions tabworkflow_dispatch:# A workflow run is made up of one or more jobs that can run sequentially or in paralleljobs:# This workflow contains a single job called \"build\"build:# The type of runner that the job will run onruns-on:ubuntu-latest# Steps represent a sequence of tasks that will be executed as part of the jobsteps:# Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it- uses:actions/checkout@v2with:submodules:true# Fetch Hugo themes (true OR recursive)fetch-depth:0# Fetch all history for .GitInfo and .Lastmod- name:Hugo setup# You may pin to the exact commit or the version.# uses: peaceiris/actions-hugo@2e89aa66d0093e4cd14751b3028fc1a179452c2euses:peaceiris/actions-hugo@v2.4.13with:# The Hugo version to download (if necessary) and use. Example: 0.58.2hugo-version:latest# optional, default is latest# Download (if necessary) and use Hugo extended version. Example: trueextended:true# optional, default is false- name:Buildrun:hugo- name:Pushes to another repositoryuses:cpina/github-action-push-to-another-repository@masterenv:API_TOKEN_GITHUB:${{ secrets.API_TOKEN_GITHUB }}with:source-directory:\"public\"destination-github-username:\"这里输入你的Github用户名\"destination-repository-name:\"这里输入你的Github用户名.github.io\"user-email:这里输入你的Github邮箱 需要自定义的部分 注意on里的 branch 是否和自己的相同，因为现在 Github 默认分支为 main。 同时最后三行内容需要自行替换。 脚本主要做了以下事情： 创建一个 Hugo 环境 使用 hugo 命令编译代码，产生 public 文件夹 将 public 文件 push 到你的Github用户名.github.io仓库。（也就是你之前创建的第二个仓库） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"设置 Push 用的密钥 为了让 Github Action 脚本有权限将代码 Push 到我们的xx.github.io仓库，我们需要申请一个密钥并告诉它。在 Github 设置中找到Developer settings/Personal access tokens 个人密钥设置界面\" 个人密钥设置界面 新建一个密钥，权限设置把Repo打勾。 新建密钥\" 新建密钥 回到第一个仓库的设置里，选择Secrets（密钥） 仓库密钥设置\" 仓库密钥设置 新建密钥，将刚才生成的个人密钥填进去，名字设为API_TOKEN_GITHUB(跟 CI 脚本里的名称对应即可) 新建仓库密钥\" 新建仓库密钥 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:2","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"观察效果 在 Push 新修改到第一个仓库后，在Action界面可以看到新的workflow开始运行了。 第一个仓库workflow界面（图中已经完成）\" 第一个仓库workflow界面（图中已经完成） 在workflow结束后，可以在第二个仓库看到新的Push 第二个仓库自动push了新的静态页面\" 第二个仓库自动push了新的静态页面 在等待 1-2 分钟后，即可在xx.github.io观察到变化。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:8:3","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置评论系统 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"GitTalk GitTalk是基于 github 的 repo issues 作为数据库来存储评论的。 Love-It主题集成了GitTalk ，需要使用的话只需要在config.toml里填写指定信息就可以了。 首先要去Github -\u003e Settings -\u003e Developer Settings -\u003e OAuth App 里注册一个新的 OAuth App 来给 Gitalk 使用。 两个 Url 填自己博客的地址就行。 注册OAuth App\" 注册OAuth App 修改config.toml: [params.page.comment] enable = true \u003c-- 启用评论系统 ... [params.page.comment.gitalk] enable = true owner = \"JellyZhang\" \u003c-- Github用户名 repo = \"blog-comment\" \u003c-- 用来存放评论的repo名称 clientId = \"\" \u003c-- 申请好的OAuth的ClientId clientSecret = \"\" \u003c-- 申请好的OAuth的ClientSecret 升级Gitalk来防止403问题 Gitalk 1.6.2版本 存在一个自身 Bug，它里面用到了一个链接来依赖某个下游，而事实上这个链接是 demo 演示用的，已经因为滥用被取消了，所以需要将 LoveIt 主题使用的 1.6.2 版本改成1.7.2 修改./themes/LoveIt/assets/data/cdn/jsdelivr.yml中的Gitalk的链接： ...metingJS:meting@2.0.1/dist/Meting.min.js# gitalk@1.6.2 https://github.com/gitalk/gitalkgitalkCSS:gitalk@1.7.2/dist/gitalk.min.css \u003c-- 改为1.7.2gitalkJS:gitalk@1.7.2/dist/gitalk.min.js \u003c-- 改为1.7.2# valine@1.4.14 https://valine.js.org/valineJS:valine@1.4.14/dist/Valine.min.js... 在本地环境看不到生效？ 评论系统在本地运行时不生效，需要 publish 后查看效果。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:9:1","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置搜索系统 LoveIt集成了两种搜索引擎，Lunr和algolia。 两种搜索引擎的区别 参考LoveIt 官方文档 lunr: 简单, 无需同步 index.json, 没有 contentLength 的限制, 但占用带宽大且性能低 (特别是中文需要一个较大的分词依赖库) algolia: 高性能并且占用带宽低, 但需要同步 index.json 且有 contentLength 的限制 我这里记录algolia的配置方法。 首先需要在配置文件中新增Outputs的JSON类型，用于产生index.json文件来提供给搜索引擎。 config.toml: [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] 设置后，在使用hugo命令编译后应该可以在public文件夹下找到index.json 之后在algolia注册账号并创建一个application与index: 创建application, freePlan一般够用\" 创建application, freePlan一般够用 然后在API Keys里找到appID和searchKey: 在API Keys里找到appId与searchKey\" 在API Keys里找到appId与searchKey config.toml: [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] index = \"\" \u003c--- 你创建的index的名字 appID = \"\" \u003c--- Application ID searchKey = \"\" \u003c--- Search-Only API Key 然后可以上传生成的index.json到 algolia 来生成索引，实现搜索功能。 手动上传index.json的方法\" 手动上传index.json的方法 当然，每次生成完上传index.json未免太过麻烦，况且我们还是用Github Action来自动编译的，因此接下来我们让Github Action来帮我们上传index.json到algolia。 首先生成一个 Admin API Key 用于调用 API 来上传 index.json: 生成Admin API Key\" 生成Admin API Key 然后修改我们的Github Action的脚本： 在`main.yml`末尾加上：- name:Algolia Index Uploader# You may pin to the exact commit or the version.# uses: rxrw/algolia-index-uploader@294d1d600c4a2197a64903b6161cc80acea1becbuses:rxrw/algolia-index-uploader@v1with:# Your Algolia IndexPathindex_path:public/index.json \u003c-- 生成的index.json位置，默认即可# Algolia Index Idalgolia_index_id:XXXXXXXXX \u003c-- 你的indexId, 即之前获得的`application ID`# Algolia Index Namealgolia_index_name:XXXX \u003c--- 你创建的index名字# Algolia Admin Keyalgolia_index_admin_key:XXXXXXXXXXXX \u003c--- 上图中获取的admin Key 之后运行脚本即可在algolia在 dashboard 里看到新增的记录。 algolia新增了record\" algolia新增了record 删除文章后需要删除旧Record 每次上传的记录是增量的，意味着不会清除旧的记录。 因此如果删除了发布过的旧文章，需要手动去algolia网站上清理相关的 Object。（也可以使用 Clear 功能全部清除） ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:10:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Analytics 网站分析 Google analytics是将用户的动作行为收集后发送到 Google，交由 Google 进行统计与分析，形成看板。 在Google analytics创建媒体资源 –\u003e 添加数据流 –\u003e 网站，之后在数据流详情里获取到衡量ID: 获取衡量ID\" 获取衡量ID 之后可以在Dashboard里查看网站的用户行为，有很多内容可以慢慢探索。 Google analytics Dashboard\" Google analytics Dashboard ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:11:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"配置 Google Search Console 首先确定自己的站点地图有正常生成。打开/sitemap.xml链接： sitemap\" sitemap 之后在Google Search Console里填写自己站点地图的链接，可以帮助谷歌爬虫了解网站结构。 上传sitemap\" 上传sitemap 显示`无法获取`? 事实上是没有问题的，谷歌可能有点延迟。可以在bing webmaster tool 导入 Google 的设置，可以看到 bing 是可以立即获取的。 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:12:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"参考文献 LoveIt 官方文档 Hugo 官方文档 刷新 Chrome 缓存 ","date":"2021-08-05","objectID":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/:13:0","tags":["GitHub","博客"],"title":"使用Hugo+LoveIt主题搭建博客","uri":"/2021/08/%E4%BD%BF%E7%94%A8hugo-loveit%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"},{"categories":null,"content":"欢迎留言！😄 ","date":"2021-08-04","objectID":"/message-board/:0:0","tags":null,"title":"留言板","uri":"/message-board/"},{"categories":["博客"],"content":"Hugo使用algolia搜索 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:0:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"背景 在将hexo迁移到hugo后我就开始折腾博客搜索了，下面的配置正对loveit主题配置 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:1:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"开启algolia搜索 在config.toml中添加下面字段，xxxxx是必填，你可以参考loveit主题中的config.toml # 搜索配置 [languages.zh-cn.params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"algolia\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [languages.zh-cn.params.search.algolia] # algolia注册的索引名称 index = \"xxxxx\" # 在你注册完成后，点击API Keys就能看见下面的参数 appID = \"xxxxx\" searchKey = \"xxxxx\" ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:2:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"自动提交索引到algolia 又又用到了npm,好在集成到travis中眼不见为净。 在config.toml同级目录下运行npm init，一路回车即可。 修改npm int生成的package.json添加下面字段 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在config.toml同级目录添加.env文件并添加下面字段 ❯ cat .env ALGOLIA_APP_ID=U9QMQ70DKL ALGOLIA_INDEX_NAME=gaojila.github.io ALGOLIA_INDEX_FILE=public/index.json 修改.travis.yml文件如下 language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装搜索插件- npm install atomic-algolia --save-devscript:# 运行hugo命令- hugo# 生成索引命令- echo \"ALGOLIA_ADMIN_KEY=$ALGOLIA_ADMIN_KEY\" \u003e\u003e .env- npm run algoliaafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 在travis中添加变量$ALGOLIA_ADMIN_KEY ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:3:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"参考链接 aligolia的其他配置可以看下面的链接 dreamsafari.info nashome.cn ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/:4:0","tags":["GitHub","博客"],"title":"Hugo使用algolia搜索","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/"},{"categories":["博客"],"content":"Hugo使用travis自动发布","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Hugo使用travis自动发布 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:0:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"背景 从hexo迁移到hugo后，发布博客开始变的繁琐，没有hexo -d这样的快捷部署，但是好在有travis这样的免费CI平台，在使用travis来部署博客的确快捷了很多，只需要发布源码即可。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:1:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"Github获取token 记下 Token 的值 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:2:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"设置Travis CI 使用github帐号注册一个travis帐号，登录在hugo仓库上打上，然后再点击setting然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:3:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"编写.trabis.yml language:gogo:- \"1.8\"# 指定Golang 1.8install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.71.1/hugo_0.71.1_Linux-64bit.deb- sudo dpkg -i hugo*.debscript:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[gaojila]\"- git config user.email \"[redgaojila@gmail.com]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:\"github.com/gaojila/gaojila.github.io\"deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 hugo 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色代表正在部署 红色 代表部署失败 灰色 代表部署被取消 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:4:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"相关文章 使用 Travis CI 自动部署 Hugo 博客 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/:5:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83/"},{"categories":["博客"],"content":"通过 Travis CI 来部署 Hugo 或者 Hexo 博客可能在配置的时候会麻烦一点，但配置好后确实是方便了不少。特别是对于 Hugo 这种没有部署插件的静态网站生成器，只能手动部署到 GitHub。 网上有很多关于用 Travis 自动部署 Hexo 的文章，却没看到几篇关于 Hugo，虽然原理都差不多，但细节上还是有很多容易让小白头疼的地方，所以今天我就来教教如何用 Travis 来自动部署 Hugo。 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:0:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"正文 废话不多说，我们开始吧！ ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置代码仓库 首先确保你的 GitHub 上有这两个仓库：用来部署博客的 [用户名].github.io 和 用来存放 “源码” 的 Blog 这里与别的使用 Travis 自动部署博客教程稍微有点不同，别人家大多上将博客的源码放在 [用户名].github.io 的分支上，而不是向我一样开两个仓库 开两个仓库的好处有： 结构更清晰。与博客相关的内容都在 Blog 仓库里， [用户名].github.io 只用来提供一个 GitHub Pages 的服务 「源码」存放在 master 分支下，clone 更快 我不知道上我的原因还是 GitHub 或是 Git 的原因，我从 GitHub clone 除 master 分支以外的分支时，下载速度贼慢，只有几百 kb 每秒，clone 一个 「源码」 都至少要半个多小时 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:1","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"申请 Token 然后要去 GitHub 上申请一个新的 personal access token。 Token description 也就是 Token 的名字，可以随便填。然后一定要勾选上 repo 上的所以项目，然后别的项目一个都不要选。点 Generate token 生成 Token。 然后记下 Token 的值，也就是我打码的那一部分 (一定要记下来，因为离开这个页面之后就没有机会再次查看了) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:2","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"设置 Travis CI 接着来到 Travis CI，使用 GitHub 帐号登录；然后为 Blog 仓库打上 ☑，然后点 setting。 然后填写 Environment Variables。 Name 填写： GITHUB_TOKEN Value 填写：刚刚在 GitHub 申请到的 Token 的值 点击 Add ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:3","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"编写 .travis.yml 在 Blog 的目录下创建并编辑一个 .travis.yml 文件。这个文件的作用是告诉 Travis CI 如何部署你的博客的 language:gogo:- \"1.8\"# 指定Golang 1.8# Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建# branches:# only:# - masterinstall:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.51/hugo_0.51_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装主题- git clone [你使用的主题的 Git 地址]script:# 运行hugo命令- hugoafter_script:# 部署- cd ./public- git init- git config user.name \"[你的名字]\"- git config user.email \"[你的邮箱]\"- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push --force --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master# Github Pages- git push --quiet \"https://$GITHUB_TOKEN@${GH_REF}\" master:master --tagsenv:global:# Github Pages- GH_REF:[用来部署博客的 Git 地址]deploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支 Copy 将上面的配置文件按照你的实际情况更改。 然后将代码提交到 Blog 仓库 里。等个一两分钟，就可以在 Travis CI 上查看部署情况了 绿色 代表部署成功 黄色 代表正在部署 红色 代表部署失败 灰色 代表部署被取消 然后再去你的博客，如果没有出什么偏差的话就说明部署成功了 | ・ω・’） 以后的话就只需要把写好的文章推送到 Blog 仓库 下就可以了，就不需要再自己编译然后手动推送了 甚至连 Hugo 都可以不要装 | ・ω・’） ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:1:4","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"附录 以及一些坑 (:з)∠) ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"添加 .gitignore 文件 在 Hugo 本地编译时会产生 public 文件夹，但是这个文件夹中的内容对于 Blog 仓库 来说是不需要的 (包括用来存放主题的 themes 文件夹和主题产生的 resources 文件夹也是不需要的) 我们可以用一个.gitignore 文件来排除这些内容 在 Blog 目录下创建并修改 .gitignore，然后提交到 GitHub public/* themes/* resources/* Copy ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:1","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"Travis CI 的分支白名单 我给你的 .travis.yml 文件中有怎么一段 # Specify which branches to build using a safelist# 分支白名单限制：只有 master 分支的提交才会触发构建branches:only:- master Copy 这一段的作用是限制触发构建的分支。这在正常开发中是很重要的配置，特别是在团队 (多人) 开发的场景中。 不过这里不存在这个场景，并且如果配置错了会出很大的问题，很容易坑到小白， 比如说我 (:з)∠) 所以默认就给注释掉了。 如果你晓得这是干啥的，并且觉得有必要的话，可以考虑开启 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:2:2","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":["博客"],"content":"相关文章 使用 Hugo + GitHub Pages 搭建个人博客 为 Hugo 添加谈笑风生区 (Gitalk) 为 Hugo 博客添加字数统计 Leavelt 主题优化 为博客添加独立域名 为博客添加免费的 CDN (Cloudflare) 为 LeaveIt 主题添加阅读进度条 ","date":"2021-08-04","objectID":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/:3:0","tags":["GitHub","博客"],"title":"Hugo使用travis自动发布 出处","uri":"/2021/08/hugo%E4%BD%BF%E7%94%A8travis%E8%87%AA%E5%8A%A8%E5%8F%91%E5%B8%83-%E5%87%BA%E5%A4%84/"},{"categories":null,"content":"模板 ","date":"2021-08-04","objectID":"/2021/08/md%E6%A8%A1%E6%9D%BF/:0:0","tags":["GitHub","博客"],"title":"md模板","uri":"/2021/08/md%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"万能代码安装说明 将以下代码放置在您希望 Disqus 加载的地方： \u003cdiv id=\"disqus_thread\"\u003e\u003c/div\u003e \u003cscript\u003e /** * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables */ /* var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; */ (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://xinqinew.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); \u003c/script\u003e \u003cnoscript\u003ePlease enable JavaScript to view the \u003ca href=\"https://disqus.com/?ref_noscript\"\u003ecomments powered by Disqus.\u003c/a\u003e\u003c/noscript\u003e （推荐）使用您的 CMS 或平台的动态值编辑推荐的配置变量部分。 请参阅我们的文档以了解为什么定义标识符和 url 对防止重复线程很重要。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:1:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"如何显示评论计数 在网站关闭\u003c/body\u003e标签之前放置以下代码： \u003cscript id=\"dsq-count-scr\" src=\"//xinqinew.disqus.com/count.js\" async\u003e\u003c/script\u003e 将 #disqus_thread 附加到链接中的 href 属性。 这将告诉 Disqus 查找哪些链接并返回评论计数。 例如：\u003ca href=\"http://foo.com/bar.html#disqus_thread\"\u003eLink\u003c/a\u003e ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:2:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"设置完成！ 恭喜你，你安装完Disqus！这里有几页可以帮助您开始使用Disqus。 ","date":"2021-08-04","objectID":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/:3:0","tags":["GitHub","disqus","留言板"],"title":"留言板disqus安装","uri":"/2021/08/%E7%95%99%E8%A8%80%E6%9D%BFdisqus%E5%AE%89%E8%A3%85/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"从Jekyll迁移到Hugo 最终还是投入Hugo的怀抱，原因是： 熟悉和欣赏Go 发现一个超级喜欢的Hugo主题 - LoveIt 本文记录下博客从Jekyll迁移到Hugo的过程。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:0:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"创建项目 安装Hugo sudo pacman -S hugo 创建名称为Demo的新项目 hugo new site Demo 添加主题（此为必需步骤，可以选择其他主题） cd Demo \u0026\u0026 git init \u0026\u0026 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 也可以自行下载主题，放置于 Demo/themes 目录下 但作为submodule添加进Git项目是一个更好的方式 创建示例文章 hugo new posts/first.md 产生的文件位于是 Demo/content/posts/first.md 启动Hugo服务 hugo server 本地预览访问 http://localhost:1313/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:1:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"文章迁移 hugo import jekyll /Volumes/video/GitHub/xinqinew.github.io /Volumes/video/GitHub/Eureka2 Hugo提供了迁移命令import，可以方便地将Jekyll项目转换为Hugo项目，包括文章和其他静态资源文件。 命令格式是hugo import jekyll JEKYLL_ROOT_PATH TARGET_PATH，其中 JEKYLL_ROOT_PATH 是Jekyll项目主目录，TARGET_PATH 是新生成的Hugo项目目录。 以我的一篇文章为例，原Jekyll项目中的位置是 _post/2020-07-29-cpp-template-notes.md，Hugo项目中的位置是 content/post/2020-07-29-cpp-template-notes.md，需要注意的是，迁移前后文件名保持一致，划重点后面用到。 Jekyll Front Matter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- Hugo Front Matter ---categories:- 编程语言date:\"2020-07-29T00:00:00Z\"tags:- C++- Templatetitle:C++类与模板--- 同时需要注意，Jekyll和Hugo在FrontMatter变量的定义有区别，划重点。 Jekyll Hugo date post文件名或FrontMatter指定，FrontMatter重写前者 FrontMatter指定 title post文件名指定 FrontMatter指定，即文章标题 filename N/A 即文件名（不包含扩展名） section N/A content下的目录名 以 2020-07-29-cpp-template-notes.md 为例， 对于Jekyll，date是 2020-07-29，title是 cpp-template-notes； 对于Hugo，date是 2020-07-29，title是 C++类与模板，filename是 2020-07-29-cpp-template-notes。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:2:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"URL规则 URL规则在全局配置文件（config.toml）的 permalinks 进行配置，也可以使用文章HugoFrontMatter的 url 变量指定（优先级高于前者）。 需要保证，无论URL规则是否变化，都能通过原始URL访问到文章。 对于迁移后的三种情形： 保持原有URL规则 如果原Jekyll的permalink配置使用 title 变量，相应地在Hugo下使用 filename 变量，由于迁移前后文件名保持一致，这将破坏原有的URL规则，可以采取两个方案： 使用HugoFrontMatter的 url 变量指定原始URL 去除迁移后文件名的date部分 个人采用第一种，因为通过文件名可以区分哪些是迁移前的文章。 老文章保持原有URL规则，新文章采用新的URL规则 老文章使用HugoFrontMatter的 url 变量指定原始URL，新文章采用全局 permalinks 配置，这种方式实现起来最简单，但URL规则不统一，看着很不规范，不推荐！ 采用新的URL规则 如果原Jekyll的permalink配置使用 title 变量，使用HugoFrontMatter的 url 变量指定新URL； 使用HugoFrontMatter的 aliases 变量指定原始URL，实现页面重定向。 对于我的博客，原Jekyll的URL规则是 permalink:/:year/:month/:day/:title 在Hugo下使用了新的URL规则 [permalinks]posts = \"/:section/:year/:month/:day/:filename/\" JekyllFrontMatter ---layout:posttitle:C++类与模板categories:[编程语言 ]tags:[C++, Template ]--- HugoFrontMatter ---title:C++类与模板categories:- 编程语言tags:- C++- Templatedate:2020-07-29 00:00:00+08:00url:/posts/2020/07/29/cpp-template-notes/aliases:- /2020/07/29/cpp-template-notes/--- Hugo import命令无法满足我的场景，而且HugoFrontMatter变量按照首字符顺序排序，看着实在难受，本着轮子能造就造的原则，写了一个转换工具，仅对_posts下文章进行转换，有需要可以尝试下，项目地址是 https://github.com/caosiyang/convert-jekyll-to-hugo ，嗯，这个硬广阔以：） ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:3:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"GitHub Pages发布 执行hugo命令，在 public 目录下生成静态网站，push里面的内容到github就可以了。 Hugo官方提供的方案是submodule方式，如下： $ rm -rf public $ git submodule add -b master https://github.com/\u003cUSERNAME\u003e/\u003cUSERNAME\u003e.github.io.git public $ hugo 发布新的Hugo页面时遇到了问题，顺便说一下吧。 之前我的博客项目已经托管在GitHub，我把原repo重命名了（暂且称“A\"），新建一个repo（暂且称为“B”），名字是.github.io，然后push页面，之后浏览，“首页/分类/标签/关于”页面都是正常的，而“文章”页面还是原始的Jekyll生成的页面，初以为是缓存问题，过了一晚还这样，怀疑跟A有管，把A删除，问题仍然存在，之后又把B删除，重新建repo和push，恢复正常。 ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:4:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"博客历程回顾 最初产生写博客的想法是2011年，试用了当时几个流行的技术博客平台（csdn/cnblogs/cppblog），最终选择了cnblogs。 2015年了解到GitHub Pages可以搭建博客，当时已经在用GitHub，所以不假思索地转过去，使用Jekyll搭建了新博客，看了很多主题，选了一个并进行小改，但并不满意，最后抱着学习前端的想法，自己写了一个相当相当粗糙的主题，凑合用着了。 后来先后了解到Hexo和Hugo，同为热门的静态网站生成工具，前者node.js实现，后者Go实现，看过它们的主题，感觉都比Jekyll的好看，也很玄学，但迟迟没有折腾，现在想来，能坚持更博就不错了。 2020年是不平凡的一年，新冠疫情爆发，我的工作生活发生了很大变化，在一段闲暇的日子里，又开始琢磨博客，在看到一个相当中意的Hugo主题，坚定了我转到Hugo的决心，于是有了现在的博客。 参考文档 https://gohugo.io/tools/migrations/ https://gohugo.io/commands/hugo_import_jekyll/ https://gohugo.io/hosting-and-deployment/hosting-on-github/ ","date":"2021-08-02","objectID":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/:5:0","tags":["GitHub","博客"],"title":"从Jekyll迁移到Hugo","uri":"/2021/08/%E4%BB%8Ejekyll%E8%BF%81%E7%A7%BB%E5%88%B0hugo/"},{"categories":["博客"],"content":"安装Lovelt博客","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Lovelt博客 下载地址 安装文档 参考-晓的记忆 LoveIt参考站2 LoveIt参考站3 LoveIt参考站4 参考1 参考2 图标fontawesome 图标dashgame 留言板disqus 留言板valine 搜索algolia 自动发布travis google分析 sitemaps.xml检查 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"1 准备 推荐使用 Hugo extended 版本 由于这个主题的一些特性需要将 SCSS 转换为 CSS, 推荐使用 Hugo extended 版本来获得更好的使用体验. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2 安装 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.1 创建你的项目 hugo new site LoveIt cd LoveIt ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.2 安装主题 git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt git submodule add https://ghproxy.com/https://github.com/dillonzq/LoveIt.git themes/LoveIt # 代理 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:2","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.3 基础配置 以下是 LoveIt 主题的基本配置: baseURL = \"http://example.org/\" # [en, zh-cn, fr, ...] 设置默认的语言 defaultContentLanguage = \"zh-cn\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 网站标题 title = \"我的全新 Hugo 网站\" # 更改使用 Hugo 构建网站时使用的默认主题 theme = \"LoveIt\" [params] # LoveIt 主题版本 version = \"0.2.X\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:3","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.4 创建你的第一篇文章 以下是创建第一篇文章的方法: hugo new posts/first_post.md 默认情况下, 所有文章和页面均作为草稿创建. 如果想要渲染这些页面, 请从元数据中删除属性 draft: true, 设置属性 draft: false 或者为 hugo 命令添加 -D/--buildDrafts 参数. ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:4","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.5 在本地启动网站 使用以下命令启动网站: hugo serve 去查看 http://localhost:1313. 由于本主题使用了 Hugo 中的 .Scratch 来实现一些特性, 非常建议你为 hugo server 命令添加 --disableFastRender 参数来实时预览你正在编辑的文章页面. hugo serve --disableFastRender ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:5","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"2.6 构建网站 当你准备好部署你的网站时, 运行以下命令: hugo 会生成一个 public 目录, 其中包含你网站的所有静态内容和资源. 现在可以将其部署在任何 Web 服务器上. 网站内容可以通过 Netlify 自动发布和托管 (了解有关通过 Netlify 进行 HUGO 自动化部署 的更多信息). 或者, 您可以使用 AWS Amplify, Github pages, Render 以及更多… ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:2:6","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3 配置 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"3.1 网站配置 除了 Hugo 全局配置 和 菜单配置 之外, LoveIt 主题还允许您在网站配置中定义以下参数 (这是一个示例 config.toml, 其内容为默认值). 请打开下面的代码块查看完整的示例配置 : [params] # LoveIt 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是我的全新 Hugo 网站\" # 网站关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 哪种哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = false # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2019 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 # 被 params.page 中的 hiddenFromHomePage 替代 # 当你没有在文章前置参数中设置 \"hiddenFromHomePage\" 时的默认行为 defaultHiddenFromHomePage = false # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true # # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:3:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"google搜索优化 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"提交给Google网站站长 打开 Google网站站长，点击 “SEARCH CONSOLE ” 进入，然后添加资源，如https://skyao.io/learning-hugo/。会要求下载一个html文件如google571325××××.html做验证，将这个文件保存到hugo站点根目录下的static子目录，更新站点内容让google search console可以访问到进行验证即可。 进入资源页面，点\"索引\"下的\"站点地图\"，在\"添加新的站点地图\"处输入当前hugo站点的sitemap，这个文件hugo会默认生成，就在根路径下，如https://skyao.io/learning-hugo/sitemap.xml。 ","date":"2021-08-02","objectID":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/:4:1","tags":["GitHub","博客"],"title":"安装Lovelt博客","uri":"/2021/08/%E5%AE%89%E8%A3%85loveit%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"不错的博客 http://themes.jekyllrc.org/ https://jekyllthemes.io/ jekyll-rtd-theme minimal-mistakes/ flexible-jekyll ","date":"2021-08-01","objectID":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"不错的博客","uri":"/2021/08/%E4%B8%8D%E9%94%99%E7%9A%84%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从模版安装Docsy博客 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装先决条件 在 Mac 和 Windows 上，下载并安装Docker Desktop。在 Linux 上，安装Docker 引擎和Docker compose。 安装可能需要您重新启动计算机以使更改生效。 安装 git。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"从文档示例模板创建存储库 文档示例存储库提供了一个基本的站点结构，您可以将其用作创建自己文档的起点。 使用docsy-example模板 创建自己的存储库。 通过克隆新创建的存储库，将代码下载到本地机器。 将工作目录更改为新创建的文件夹： cd docsy-example ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"构建并运行容器 文档示例存储库包括一个Dockerfile，可用于运行站点。 构建docker镜像： docker-compose build 运行已构建的图像： docker-compose up 在网页浏览器中打开地址http://localhost:1313以加载文档示例主页。您现在可以对源文件进行更改，这些更改将在浏览器中实时重新加载。 ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"清理 要清理系统并删除容器映像，请按照以下步骤操作。 使用Ctrl + C停止Docker作曲。 移除生成的图像 docker-compose rm ","date":"2021-08-01","objectID":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"从模版安装Docsy博客","uri":"/2021/08/%E4%BB%8E%E6%A8%A1%E7%89%88%E5%AE%89%E8%A3%85docsy%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装docsy主题","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装docsy主题 下载并安装npm ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:0:0","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:0","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"作为npm模块 您可以npm使用hugo-bin. 这会添加hugo-bin到您的node_modules文件夹并将依赖项添加到您的package.json文件中。要安装 Hugo 的扩展版本： npm install hugo-extended --save-dev ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:1","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装 PostCSS 要构建或更新站点的 CSS 资源，您还需要PostCSS创建最终资产。如果您需要安装它，您必须在您的机器上安装最新版本的NodeJS，以便您可以使用npmNode 包管理器。默认情况npm下，在您运行的目录下安装工具npm install： sudo npm install -D autoprefixer sudo npm install -D postcss-cli ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:2","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"选项 1：复制 Docsy 示例站点 该示例站点为您提供了一个很好的起点构建您的文档的网站，并预先配置为使用Docsy主题为Git的子模块。您可以通过以下方式复制示例站点： 使用 GitHub 用户界面 使用命令行 使用 GitHub 用户界面 这是最简单的方法，因为 Docsy 示例站点存储库是一个模板存储库。要创建您自己的 Docsy 示例站点存储库副本： 转到repo 页面并单击Use this template。 在存储库名称字段中输入您为新存储库选择的名称。您还可以添加可选的Description。 单击从模板创建存储库以创建新存储库。恭喜，您现在拥有一个 Docsy 站点存储库！ 要使用 Hugo 在本地测试您复制的站点，或进行本地编辑，您还需要制作新存储库的本地副本。为此，请使用git clone, 替换https://github.com/my/example.git为您的存储库的网址（不要忘记使用，--recurse-submodules否则您将不会下拉生成工作站点所需的一些代码）： cd /Volumes/video/GitHub/Hugo git clone --recurse-submodules --depth 1 https://github.com/xinqinew/Docsy.git //git clone --recurse-submodules --depth 1 https://ghproxy.com/https://github.com/xinqinew/Docsy.git cd Docsy hugo server 您现在可以编辑站点源文件的本地版本。要预览您的站点，请转到站点根目录并运行hugo server（请参阅 MacOS 上的已知问题）。默认情况下，您的站点将在 http://localhost:1313/ 上可用。要将更改推送到您的新存储库，请转到您的站点根目录并使用git push. ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:3","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"苹果系统 错误：too many open files或fatal error: pipe failed 默认情况下，MacOS 允许少量打开的文件描述符。对于较大的站点，或者当您同时运行多个应用程序时，当您运行hugo server以在本地预览站点时，您可能会收到以下错误之一： POSTCSS v7 及更早版本： ERROR 2020/04/14 12:37:16 Error: listen tcp 127.0.0.1:1313: socket: too many open files POSTCSS v8 及更高版本： fatal error: pipe failed 解决方法 暂时允许更多打开的文件： 通过运行查看您当前的设置： sudo launchctl limit maxfiles 65535通过运行以下命令增加对文件的限制。如果您的站点文件较少，您可以选择设置较低的软 ( 65535) 和硬 ( 200000) 限制。 sudo launchctl limit maxfiles 65535 200000 ulimit -n 65535 sudo sysctl -w kern.maxfiles=200000 sudo sysctl -w kern.maxfilesperproc=65535 请注意，您可能需要为每个新 shell 设置这些限制。 详细了解这些限制以及如何使它们永久化。 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/:1:4","tags":["GitHub","博客"],"title":"安装docsy主题","uri":"/2021/08/%E5%AE%89%E8%A3%85docsy%E4%B8%BB%E9%A2%98/"},{"categories":["博客"],"content":"安装Eureka博客","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装Eureka博客 官方文档 cd /Volumes/video/GitHub/Eureka git init git submodule add https://github.com/wangchucheng/hugo-eureka.git themes/eureka 切换版本方法如下: cd themes/eureka git checkout v0.8.2 #git checkout \u003ceureka_version\u003e #eureka_version 替换成版本号 接下来，将exampleSite中的config文件夹复制到项目根目录下，对config文件夹的内容进行配置。配置后删除原先的config.toml文件即可。 如果你是新建的Hugo项目，content文件夹下默认没有内容。你可以将exampleSite中的content文件夹复制到项目根目录下预览主题效果。 完成以上步骤后使用以下命令即可在浏览器中预览项目： hugo server 草稿不会被Hugo部署，所以你需要将内容头部的draft属性设为false或使用hugo server -D预览网站。 内容管理 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"目录结构 ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文章页 文章内容为Eureka默认的文章结构，因此新建文章页时不需指定其类型。 hugo new posts/\u003cyour_post.md\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建文档页 新建文档页时需指定其类型为docs。 hugo new -k docs docs/\u003cyour_doc\u003e/\u003cyour_page.md\u003e 如果你此前没有创建过文档类型的内容，你需要先生成文档列表： hugo new -k docs docs ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新建作者页 新建作者页时需指定其类型为authors。 hugo new -k authors authors/\u003cyour_author\u003e ","date":"2021-08-01","objectID":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/:1:3","tags":["GitHub","博客"],"title":"安装Eureka博客","uri":"/2021/08/%E5%AE%89%E8%A3%85eureka%E5%8D%9A%E5%AE%A2/"},{"categories":["易语言"],"content":"植物大战僵尸","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/","tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":["易语言"],"content":"植物大战僵尸 .版本 2 .程序集 窗口程序集_启动窗口 .程序集变量 process, 整数型 .程序集变量 BaseAddress, 整数型 .程序集变量 setoff1, 整数型 .程序集变量 setoff2, 整数型 .程序集变量 PlantAddress, 整数型 .程序集变量 ZombiesAddress, 整数型 .程序集变量 图像x, 整数型 .程序集变量 图像y, 整数型 .程序集变量 真实x, 整数型 .程序集变量 真实y, 整数型 .子程序 _选择框_不消耗阳光_被单击 .如果 (选择框_不消耗阳光.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“90 90”)) .否则 内存_写字节集 (process, 十六到十 (“41BA74”), 还原字节集2 (“2b f3”)) .如果结束 .子程序 __启动窗口_创建完毕 process ＝ 进程_取进程句柄 (“PlantsVsZombies.exe”) BaseAddress ＝ 内存_读整数型 (process, 十六到十 (“6aa00c”)) ' 基址 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) ' 一级偏移 PlantAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“ac”)) ' 植物 ZombiesAddress ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“90”)) ' 僵尸 时钟_监视进程.时钟周期 ＝ 3000 按钮割草机CALL.禁止 ＝ 真 .子程序 _按钮_阳光9999_被单击 setoff1 ＝ 内存_读整数型 (process, BaseAddress ＋ 十六到十 (“768”)) 内存_写整数型 (process, setoff1 ＋ 十六到十 (“5560”), 9999) .子程序 _选择框_无冷却_被单击 .如果 (选择框_无冷却.选中 ＝ 真) 时钟1.时钟周期 ＝ 1000 .否则 时钟1.时钟周期 ＝ 0 .如果结束 .子程序 _时钟1_周期事件 .局部变量 onePlant, 整数型 .局部变量 Index, 整数型 .局部变量 setoffPlant, 整数型 setoffPlant ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .计次循环首 (10, Index) ' onePlant ＝ 内存_读整数型 (process, setoffPlant+十六到十(\"4c\") ＋ (Index － 1) × 80) 内存_写整数型 (process, setoffPlant ＋ 十六到十 (“4c”) ＋ (Index － 1) × 80, 5000) ' 无冷却 .计次循环尾 () .子程序 _选择框_无冷却1_被单击 .如果 (选择框_无冷却1.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“E9 CB 6B 2A 00 90 90”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“C7 47 24 88 13 00 00 83 47 24 01 8B 47 24 E9 24 94 D5 FF”)) .否则 内存_写字节集 (process, 十六到十 (“48728c”), 还原字节集2 (“83 47 24 01 8B 47 24”)) 内存_写字节集 (process, 十六到十 (“72de5c”), 还原字节集2 (“00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00”)) .如果结束 .子程序 _选择框_自动收集_被单击 .如果 (选择框_自动收集.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 01”)) .否则 内存_写字节集 (process, 十六到十 (“43158b”), 还原字节集2 (“80 7B 50 00”)) .如果结束 .子程序 _选择框_子弹叠加_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“90 90 90 90 90 90”)) .否则 内存_写字节集 (process, 十六到十 (“464a96”), 还原字节集2 (“0F 85 98 FE FF FF”)) .如果结束 .子程序 _按钮_更改卡槽_被单击 .局部变量 setoffxxx, 整数型 setoffxxx ＝ 内存_读整数型 (process, setoff1 ＋ 十六到十 (“144”)) .如果真 (卡槽组合框.现行选中项 ＝ 0) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“5c”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 1) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“ac”), 18) .如果真结束 .如果真结束 .如果真 (卡槽组合框.现行选中项 ＝ 2) .如果真 (植物组合框.现行选中项 ＝ 0) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 0) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 1) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 2) .如果真结束 .如果真 (植物组合框.现行选中项 ＝ 2) 内存_写整数型 (process, setoffxxx ＋ 十六到十 (“fc”), 18) .如果真结束 .如果真结束 .子程序 _按钮_种植CALL_被单击 asm_置代码 () asm_pushad () asm_push (-1) ' 固定-1 asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID asm_mov_eax_常数 (到整数 (编辑框_y.内容)) ' Y asm_push (到整数 (编辑框_x.内容)) ' X asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) asm_push_ebp () ' ebp asm_mov_ebx_常数 (十六到十 (“40d120”)) asm_call_ebx () ' call asm_popad () asm_ret () asm_调用函数2 (process, asm_取代码 ()) .子程序 _按钮_乱种CALL1_被单击 .局部变量 坐标x, 整数型 .局部变量 坐标y, 整数型 .局部变量 index1, 整数型 .局部变量 index2, 整数型 .局部变量 index3, 整数型 坐标x ＝ 0 坐标y ＝ 0 .计次循环首 (3, index3) .如果 (index3 ＝ 1) 编辑框_植物ID.内容 ＝ “38” .否则 .如果 (index3 ＝ 2) 编辑框_植物ID.内容 ＝ “40” .否则 编辑框_植物ID.内容 ＝ “43” .如果结束 ​ .如果结束 ​ .计次循环首 (6, index1) ​ .计次循环首 (6, index2) ​ asm_置代码 () ​ asm_pushad () ​ asm_push (-1) ' 固定-1 ​ asm_push (到整数 (编辑框_植物ID.内容)) ' 植物ID ​ asm_mov_eax_常数 (坐标y ＋ index1 － 1) ' Y ​ asm_push (到整数 (坐标x ＋ index2 － 1)) ' X ​ asm_mov_ebp_ptr (十六到十 (“6a9ec0”)) ​ asm_mov_ebp_ptr_ebp_add (十六到十 (“768”)) ​ asm_push_ebp () ' ebp ​ asm_mov_ebx_常数 (十六到十 (“40d120”)) ​ asm_call_ebx () ' call ​ asm_popad () ​ asm_ret () ​ asm_调用函数2 (process, asm_取代码 ()) ​ .计次循环尾 () ​ .计次循环尾 () .计次循环尾 () .子程序 _选择框_重叠种植_被单击 .如果 (选择框_子弹叠加.选中 ＝ 真) 内存_写字节集 ","date":"2021-07-29","objectID":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/:0:0","tags":["易语言"],"title":"植物大战僵尸","uri":"/2021/07/%E6%A4%8D%E7%89%A9%E5%A4%A7%E6%88%98%E5%83%B5%E5%B0%B8/"},{"categories":null,"content":"知识点描述","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"知识点 通用寄存器 32 位 16 位 8 位（高） 8 位（低） EAX AX AH AL EBX BX BH BL ECX CX CH CL EDX DX DH DL 32 位 16 位 32 位 16 位 ESI SI EBP BP EDI DI ESP SP 特殊用法 乘除指令默认使用EAX。它常常被称为扩展累加器（extended accumulator）寄存器。 CPU 默认使用 ECX 为循环计数器。 ESP 用于寻址堆栈（一种系统内存结构）数据。它极少用于一般算术运算和数据传输，通常被称为扩展堆栈指针（extended stack pointer）寄存器。 ESI 和 EDI 用于高速存储器传输指令，有时也被称为扩展源变址（extended source index）寄存器和扩展目的变址（extended destination index）寄存器。 高级语言通过 EBP 来引用堆栈中的函数参数和局部变量。除了高级编程，它不用于一般算术运算和数据传输。它常常被称为扩展帧指针（extended frame pointer）寄存器。 状态标志位 进位标志位（CF），与目标位置相比，无符号算术运算结果太大时，设置该标志位。 溢出标志位（OF），与目标位置相比，有符号算术运算结果太大或太小时，设置该标志位。 符号标志位（SF），算术或逻辑操作产生负结果时，设置该标志位。 零标志位（ZF），算术或逻辑操作产生的结果为零时，设置该标志位。 辅助进位标志位（AC），算术操作在 8 位操作数中产生了位 3 向位 4 的进位时，设置该标志位。 奇偶校验标志位（PF），结果的最低有效字节包含偶数个 1 时，设置该标志位，否则，清除该标志位。一般情况下，如果数据有可能被修改或损坏时，该标志位用于进行 错误检测。 64位通用寄存器 操作数大小 可用寄存器 8 位 AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L、R9L、R10L、R11L、R12L、R13L、R14L、R15L 16 位 AX、BX、CX、DX、DI、SI、BP、SP、R8W、R9W、R10W、R11W、R12W、R13W、R14W、R15W 32 位 EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D、R9D、R10D、R11D、R12D、R13D、R14D、R15D 64 位 RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8、R9、R10、R11、R12、R13、R14、R15 整数常量 h 十六进制 r 编码实数 q/o 八进制 t 十进制（备用） d 十进制 y 二进制（备用） b 二进制 26 ;十进制 26d ;十进制 11010011b ;二进制 42q ;八进制 42o ;八进制 1Ah ;十六进制 0A3h ;十六进制 整型常量表达式 运算符 名称 优先级 () 圆括号 1 +,- 一元加、减 2 *, / 乘、除 3 MOD 取模 3 +, - 加、减 4 保留字列表。 $ PARITY? DWORD STDCALL ? PASCAL FAR SWORD @B QWORD FAR16 SYSCALL @F REAL4 FORTRAN TBYTE ADDR REAL8 FWORD VARARG BASIC REAL10 NEAR WORD BYTE SBYTE NEAR16 ZERO? C SDORD OVERFLOW? CARRY? SIGN? 定义段 .DATA 伪指令进行标识： .data .CODE 伪指令标识的程序区段包含了可执行的指令： .code .STACK 伪指令标识的程序区段定义了运行时堆栈，并设置了其大小： .stack 100h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令 一条指令有四个组成部分： 标号（可选） 指令助记符（必需） 操作数（通常是必需的） 注释（可选） 不同部分的位置安排如下所示： [label: ] mnemonic [operands] [;comment] ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"标号 数据标号 count DWORD 100 代码标号 target: mov ax,bx ... jmp target ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:1","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"指令助记符 助记符 说明 助记符 说明 MOV 传送（分配）数值 MUL 两个数值相乘 ADD 两个数值相加 JMP 跳转到一个新位置 SUB 从一个数值中减去另一个数值 CALL 调用一个子程序 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:2","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"操作数 示例 操作数类型 示例 操作数类型 96 整数常量 eax 寄存器 2+4 整数表达式 count 内存 STC 指令没有操作数： stc ;进位标志位置 1 INC 指令有一个操作数： inc eax ;EAX 加 1 MOV 指令有两个操作数： mov count, ebx ;将 EBX 传送给变量 count IMUL 指令有三个操作数，第一个是目的操作数，第二个和第三个是进行乘法的源操作数： imul eax,ebx,5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:3","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"注释 单行注释，用分号（;）开始。汇编器将忽略在同一行上分号之后的所有字符。 块注释，用 COMMENT 伪指令和一个用户定义的符号开始。汇编器将忽略其后所有的文本行，直到相同的用户定义符号出现为止。 COMMENT ! This line is a comment. This line is also a comment. ! ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:4","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"NOP（空操作）指令 .data ;此为数据区 sum DWORD 0 ;定义名为sum的变量 .code ;此为代码区 main PROC mov eax,5 ;将数字5送入而eax寄存器 add eax,6 ;eax寄存器加6 mox sum,eax INVOKE ExitProcess,0 ;结束程序 main ENDP ; AddTwo.asm -两个 32 位整数相加 .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .code main PROC mov eax,5 ;将数字5送入eax寄存器 add eax,6 ;eax寄存器加6 INVOKE ExitProcess,0 main ENDP END main 第 3 行是 .386 伪指令，它表示这是一个 32 位程序，能访问 32 位寄存器和地址。 第 4 行选择了程序的内存模式（flat），并确定了子程序的调用规范（称为 stdcall）。其原因是 32 位 Windows 服务要求使用 stdcall 规范。 第 5 行为运行时堆栈保留了 4096 字节的存储空间，每个程序都必须有。 第 6 行声明了 ExitProcess 函数的原型，它是一个标准的 Windows 服务。原型包含了函数名、PROTO 关键字、一个逗号，以及一个输入参数列表。ExitProcess 的输入参数名称为 dwExitCode。 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:5","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"汇编伪指令回顾 CODE 的下一行声明程序的入口 .code main PROC ENDP 伪指令标记一个过程的结束。 main ENDP END 伪指令标记一个程序的结束，并要引用程序入口： END main ; AddTwo.asm - adds two 32-bit integers. ; Chapter 3 example .386 .model flat,stdcall .stack 4096 ExitProcess PROTO,dwExitCode:DWORD 00000000 .code 00000000 main PROC 00000000 B8 00000005 mov eax, 5 00000005 83 C0 06 add eax,6 invoke ExitProcess,0 00000008 6A 00 push +000000000h 0000000A E8 00000000 E call ExitProcess 0000000F main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:1:6","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据类型以及数据定义详解 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"内部数据类型 类型 用法 BYTE 8 位无符号整数，B 代表字节 SBYTE 8 位有符号整数，S 代表有符号 WORD 16 位无符号整数 SWORD 16 位有符号整数 DWORD 32 位无符号整数，D 代表双（字） SDWORD 32 位有符号整数，SD 代表有符号双（字） FWORD 48 位整数（保护模式中的远指针） QWORD 64 位整数，Q 代表四（字） TBYTE 80 位（10 字节）整数，T 代表 10 字节 REAL4 32 位（4 字节）IEEE 短实数 REAL8 64 位（8 字节）IEEE 长实数 REAL10 80 位（10 字节）IEEE 扩展实数 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:1","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"数据定义语句 数据定义语法如下所示： [name] directive initializer [,initializer]… 下面是数据定义语句的一个例子： count DWORD 12345 伪指令 用法 伪指令 用法 DB 8位整数 DQ 64 位整数或实数 DW 16 位整数 DT 定义 80 位（10 字节）整数 DD 32 位整数或实数 ;AddTowSum.asm .386 .model flat,stdcall .stack 4096 ExitProcess PROTO, dwExitCode:DWORD .data sum DWORD 0 .code main PROC mov eax,5 add eax,6 mov sum,eax INVOKE ExitProcess,0 main ENDP END main ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:2","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 BYTE 和 SBYTE 数据 value1 BYTE 'A' ;字符常量 value2 BYTE 0 ;最小无符号字节 value3 BYTE 255 ;最大无符号字节 value4 SBYTE -128 ;最小有符号字节 value5 SBYTE +127 ;最大有符号字节 value6 BYTE ? ;变量 val1 DB 255 ;无符号字节 val2 DB -128 ;有符号字节 多初始值 list BYTE 10,20,30,40 偏移量 数值 0000 10 0001 20 0002 30 0003 40 list BYTE 10,20,30,40 BYTE 50,60,70,80 BYTE 81,82,83,84 list1 BYTE 10, 32, 41h, 00100010b list2 BYTE 0Ah, 20h, 'A', 22h list1与list2不同进制，但值相同 定义字符串 greeting1 BYTE \"Good afternoon\",0 greeting2 BYTE 'Good night',0 0作为结束标记 greeting1 BYTE \"Welcome to the Encryption Demo program \" BYTE \"created by Kip Irvine.\",0dh, 0ah BYTE \"If you wish to modify this program, please \" BYTE \"send me a copy.\",0dh,0ah,0 十六进制代码 0Dh 和 0Ah 也被称为 CR/LF （回车换行符）或行结束字符。 greeting1 BYTE \"Welcome to the Encryption Demo program \" 和 greeting1 \\ BYTE \"Welcome to the Encryption Demo program \" 行连续字符（\\）把两个源代码行连接成一条语句，它必须是一行的最后一个字符。上面的语句是等价的。 DUP 操作符 BYTE 20 DUP ( 0 ) ;20 个字节，值都为 0 BYTE 20 DUP ( ? ) ;20 个字节，非初始化 BYTE 4 DUP ( \"STACK\" ) ; 20 个字节： ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:3","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 WORD 和 SWORD 数据 word1 WORD 65535 ;最大无符号数 word2 SWORD -32768 ;最小有符号数 word3 WORD ? ;未初始化，无符号 val1 DW 65535 ;无符号 val2 DW -32768 ;有符号 也可以使用传统的 DW 伪指令 myList WORD 1,2,3,4,5 偏移量 数值 0000 1 0002 2 0004 3 0006 4 0008 5 array WORD 5 DUP (?) ; 5 个数值，未初始化 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:4","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 DWORD 和 SDWORD 数据 val1 DWORD 12345678h ;无符号 val2 SDWORD -2147483648 ;有符号 val3 DWORD 20 DUP (?) ;无符号数组 val1 DD 12345678h ;无符号 val2 DD -2147483648 ;有符号 pVal DWORD val3 myList DWORD 1,2,3,4,5 偏移量 数值 0000 1 0004 2 0008 3 000C 4 0010 5 ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:5","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":null,"content":"定义 QWORD 数据 quad1 QWORD 1234567812345678h quad1 DQ 1234567812345678h ","date":"2021-07-28","objectID":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/:2:6","tags":null,"title":"知识点","uri":"/2021/07/%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"C++关键字描述","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/","tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["C++"],"content":"C++关键字 1. asm asm (指令字符串)：允许在 C++ 程序中嵌入汇编代码。 2. auto auto（自动，automatic）是存储类型标识符，表明变量\"自动\"具有本地范围，块范围的变量声明（如for循环体内的变量声明）默认为auto存储类型。 3. bool bool（布尔）类型，C++ 中的基本数据结构，其值可选为 true（真）或者 false（假）。C++ 中的 bool 类型可以和 int 混用，具体来说就是 0 代表 false，非 0 代表 true。bool 类型常用于条件判断和函数返回值。 4. break break（中断、跳出），用在switch语句或者循环语句中。程序遇到 break 后，即跳过该程序段，继续后面的语句执行。 5. case 用于 switch 语句中，用于判断不同的条件类型。 6. catch catch 和 try 语句一起用于异常处理。 7. char char（字符，character）类型，C++ 中的基本数据结构，其值一般为 0~255 的 int。这 256 个字符对应着 256 个 ASCII 码。char 类型的数据需要用单引号 ' 括起来。 8.class class（类）是 C++ 面向对象设计的基础。使用 class 关键字声明一个类。 9. const const（常量的，constant）所修饰的对象或变量不能被改变，修饰函数时，该函数不能改变在该函数外面声明的变量也不能调用任何非const函数。在函数的声明与定义时都要加上const，放在函数参数列表的最后一个括号后。在 C++ 中，用 const 声明一个变量，意味着该变量就是一个带类型的常量，可以代替 #define，且比 #define 多一个类型信息，且它执行内链接，可放在头文件中声明；但在 C 中，其声明则必须放在源文件（即 .C 文件）中，在 C 中 const 声明一个变量，除了不能改变其值外，它仍是一具变量。如: const double pi(3.14159); 或 const double pi = 3.14159; 10. const_cast用法： const_cast\u003ctype_id\u003e (expression) 该运算符用来修改类型的 const 或 volatile 属性。除了 const 或 volatile 修饰之外， type_id 和 expression 的类型是一样的。常量指针被转化成非常量指针，并且仍然指向原来的对象；常量引用被转换成非常量引用，并且仍然指向原来的对象；常量对象被转换成非常量对象。 11. continue continue（继续）关键字用于循环结构。它使程序跳过代码段后部的部分，与 break 不同的是，continue 不是进入代码段后的部分执行，而是重新开始新的循环。因而它是\"继续循环\"之意，不是 break（跳出）。 12. default default（默认、缺省）用于 switch 语句。当 switch 所有的 case 都不满足时，将进入 default 执行。default 只能放在 switch 语句所有的 case 之后，并且是可选的。 13. delete delete（删除）释放程序动态申请的内存空间。delete 后面通常是一个指针或者数组 []，并且只能 delete 通过 new 关键字申请的指针，否则会发生段错误。 14. do do-while是一类循环结构。与while循环不同，do-while循环保证至少要进入循环体一次。 15. double double（双精度）类型，C++ 中的基本数据结构，以双精度形式存储一个浮点数。 16. dynamic_cast dynamic_cast（动态转换），允许在运行时刻进行类型转换，从而使程序能够在一个类层次结构安全地转换类型。dynamic_cast 提供了两种转换方式，把基类指针转换成派生类指针，或者把指向基类的左值转换成派生类的引用。 17. else else 紧跟在 if 后面，用于对 if 不成立的情况的选择。 18. enum enum（枚举）类型，给出一系列固定的值，只能在这里面进行选择一个。 19. explicit explicit（显式的）的作用是\"禁止单参数构造函数\"被用于自动型别转换，其中比较典型的例子就是容器类型。在这种类型的构造函数中你可以将初始长度作为参数传递给构造函数。 20. export 为了访问其他编译单元（如另一代码文件）中的变量或对象，对普通类型（包括基本数据类、结构和类），可以利用关键字 extern，来使用这些变量或对象时；但是对模板类型，则必须在定义这些模板类对象和模板函数时，使用标准 C++ 新增加的关键字 export（导出）。 21. extern extern（外部的）声明变量或函数为外部链接，即该变量或函数名在其它文件中可见。被其修饰的变量（外部变量）是静态分配空间的，即程序开始时分配，结束时释放。用其声明的变量或函数应该在别的文件或同一文件的其它地方定义（实现）。在文件内声明一个变量或函数默认为可被外部使用。在 C++ 中，还可用来指定使用另一语言进行链接，这时需要与特定的转换符一起使用。目前仅支持 C 转换标记，来支持 C 编译器链接。使用这种情况有两种形式： extern “C” 声明语句 extern “C” { 声明语句块 } 22. false false（假的），C++ 的基本数据结构 bool 类型的值之一。等同于 int 的 0 值。 23. float float（浮点数），C++ 中的基本数据结构，精度小于 double。 24. for for 是 C++ 中的循环结构之一。 25. friend friend（友元）声明友元关系。友元可以访问与其有 friend 关系的类中的 private/protected 成员，通过友元直接访问类中的 private/protected 成员的主要目的是提高效率。友元包括友元函数和友元类。 26. goto goto（转到），用于无条件跳转到某一标号处开始执行。 27. if if（如果），C++ 中的条件语句之一，可以根据后面的 bool 类型的值选择进入一个分支执行。 28. inline inline（内联）函数的定义将在编译时在调用处展开。inline 函数一般由短小的语句组成，可以提高程序效率。 29. int int（整型，integer），C++ 中的基本数据结构，用于表示整数，精度小于 long。 30. long long（长整型，long integer），C++ 中的基本数据结构，用于表示长整数。 31. mutable mutable（易变的）是 C++ 中一个不常用的关键字。只能用于类的非静态和非常量数据成员。由于一个对象的状态由该对象的非静态数据成员决定，所以随着数据成员的改变，对像的状态也会随之发生变化。如果一个类的成员函数被声明为 const 类型，表示该函数不会改变对象的状态，也就是该函数不会修改类的非静态数据成员。但是有些时候需要在该类函数中对类的数据成员进行赋值，这个时候就需要用到 mutable 关键字。 32. namespace namespace（命名空间）用于在逻辑上组织类，是一种比类大的结构。 33. new new（新建）用于新建一个对象。new 运算符总是返回一个指针。由 new 创建 34. operator operator（操作符）用于操作符重载。这是 C++ 中的一种特殊的函数。 35. private private（私有的），C++ 中的访问控制符。被标明为 private 的字段只能在本类以及友元中访问。 36. protected protected（受保护的），C++ 中的访问控制符。被标明为 protected 的字段只能在本类以及其继承类和友元中访问。 37. public public（公有的），C++ 中的访问控制符。被标明为 public 的字段可以在任何类 38.register register（寄存器）声明的变量称着寄存器变量，在可能的情况下会直接存放在机器的寄存器中；但对 32 位编译器不起作用，当 global optimizations（全局优化）开的时候，它会做出选择是否放在自己的寄存器中；不过其它与 register 关键字有关的其它符号都对32位编译器有效。 39. reinterpret_cast 用法： reinpreter_cast (expression) type-id 必须是一个指针、引用、算术类型、函数指针或者成员指针。它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。 40. return return（返回）用于在函数中返回值。程序在执行到 return 语句后立即返回，return 后面的语句无法执行到。 41. short short（短整型，short integer），C++ 中的基本数据结构，用于表示整数，精度小于 int。 42. signed signed（有符号），表明该类型是有符号数，和 unsigned 相反。数字类型（整型和浮点型）都可以用 signed 修饰。但默认就是 signed，所以一般不会显式使用。 43. sizeof 由于 C++ 每种类型的大小都是由编译器自行决定的，为了增加可移植性，可以用 size","date":"2021-07-27","objectID":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/:0:0","tags":["C++"],"title":"C++关键字","uri":"/2021/07/%E5%85%B3%E9%94%AE%E5%AD%97/"},{"categories":["博客"],"content":"Jekyll 插入图片","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/","tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["博客"],"content":"Jekyll 插入图片 用 Markdown 插入图片是一件很简单的事，只需要这样写： ![AltText](/path/to/img.jpg) 然而，如果你需要进行更多的控制，情况立刻变得复杂了起来。由于 Markdown 秉持结构和样式分离的原则，你无法在插入图片时控制其大小。要达到这样的目的，你需要使用普通的 \u003cimg\u003e 标签： \u003cimg src=\"/path/to/img.jpg\" width=\"100\" height=\"100\" alt=\"AltText\" /\u003e 相对前一种语法，后者明显麻烦许多。所幸这种情况一般都是极少数。一般来说，我们只需要使用前一种语法。然而，有一种状况会让你需要大量使用后一种语法 —— Retina 屏幕的截图。一张 100pt * 100pt 的截图事实上是 200px * 200px。贴到文章里之后，电脑又会以 200pt * 200pt 的大小来渲染。你的截图立刻变得大而模糊。为了避免这种状况，你需要手动计算图片的实际大小，然后使用 HTML 语法插入图片。当你需要插入大量图片时，这一工作很快变得枯燥而难以忍受。 当然，你可以通过指定比例从而避免手工计算大小： \u003cimg src=\"/path/to/img.jpg\" width=\"50%\" alt=\"AltText\" /\u003e 虽然免去了计算大小，你依然需要使用冗长的 HTML 语法。能不能用 Markdown 语法来做这件事呢？ 我们知道有些 Markdown 方言支持调整图片大小，例如： Mou: ![AltText](/path/to/img.jpg =100x) MWeb: ![AltText-w100](/path/to/img.jpg) ... 显然，这些在 Jekyll 中都是不支持的。不过，我们有更好的方法： ![AltText @2x]() 只需添加 @2x 后缀，图片就会自动缩放为50%大小 这显然不是 Markdown 或 Jekyll 的功能，在你的博客中使用不会有任何效果。真正的魔法在 CSS 样式表中： .post-container img[alt~=\"@2x\"] { zoom: 50%; } 我们用到了 CSS 中的属性选择器，它可以对拥有指定属性的 HTML 元素设置样式。在这里，我们对 alt 中包含 @2x 的所有图片添加了 zoom: 50% 属性。 同理，你也可以为 iPhone * Plus 的截图设置三倍缩放： .post-container img[alt~=\"@3x\"] { zoom: 33%; } ","date":"2021-07-27","objectID":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/:0:0","tags":["GitHub","博客"],"title":"Jekyll 插入图片","uri":"/2021/07/jekyll%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/"},{"categories":["Markdown"],"content":"Mermaid教程收录","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid教程收录 时间管理、头脑风暴、阅读、会议记录神器-Mermaid Mermaid英文教程 Mermaid在线编辑器 Mermaid，就像用 Markdown 码字一样，高效制作简易流图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:0:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid - 流程图 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"基本结构 圆角矩形 表示“开始”与“结束” 矩形表示行动方案、普通工作环节用 菱形表示问题判断或判定（审核/审批/评审）环节 用平行四边形表示输入输出 箭头代表工作流方向 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:1","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"流程图与节点的创建 graph 流程图声明 graph S[声明一个流程图] graph s(\"开始(START)\") 语法：id(\":转义字符;\") graph s(\"开始:#9829;\") ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:2","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"各方向 graph TB s[开始]--\u003e e[结束] graph BT s[开始]--\u003e e[结束] graph LR s[开始]--\u003e e[结束] graph RL s[开始]--\u003e e[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:3","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"节点形状 graph a[矩形] b[圆角矩形] c([体育场]) d[(圆柱)] e((圆形)) graph f{菱形} g{{6}} h\u003e非对称] i[/平行四边形/] j[/梯形\\] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:4","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"线条形状 graph g[开始] --- h[结束] a[开始] -.- b[结束] c[开始] === d[结束] e[开始] --\u003e f[结束] i[开始] -.-\u003e j[结束] k[开始] ==\u003e l[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:5","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"带文字的链接线 graph a[开始] --过程1--- b[结束] c[开始] --\u003e|过程2| d[结束] e[开始] -.过程3.-\u003e f[结束] g[开始] ==过程4==\u003e h[结束] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:6","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"关系链 graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e e[结束买菜] s--走路--\u003e o[永辉超市]--付钱--\u003e e graph LR s[家] --走路--\u003eP[菜市场]--走路--\u003eL[水果店]--走路--\u003e j[超市]--\u003es graph LR s[买菜] --走路--\u003eP[菜市场]--付钱--\u003e s s--网上--\u003e o[永辉超市]--付钱--\u003e s 正常写法 graph z[张三]--\u003eC[内卷] z--\u003eD[躺平] L[李四]--\u003eC[内卷] L--\u003eD 简易写法 graph z[张三] \u0026 L[李四]--\u003eC[内卷] \u0026 D[躺平] 不美观 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--\u003e|躺平|N[喝快乐水] 美观:加长某一项 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X---\u003e|躺平|N[喝快乐水] 增加层级:再加长 graph z[张三]--\u003eX{选择躺平还是内卷} x--内卷--\u003eY[努力] Y--努力--\u003eR[重新思考] R--\u003eX X--躺平----\u003eN[喝快乐水] 可用—-\u003e 链接线会增加3个层级的长度 一下是各个类型连接线增加层级长度语法 增加层级长度 1 2 3 实线 — —- —– 带箭头的实线 –\u003e —\u003e —-\u003e 粗实线 === ==== ===== 带箭头的粗实线 ==\u003e ===\u003e ====\u003e 虚线 -.- -..- -…- 带箭头的虚线 -.-\u003e -..-\u003e -…-\u003e ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:7","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"子图表 subgraph graph 节点关系 subgraph title //子图表的名称 子图表的节点关系 end //子图标结束标志 graph TB c1--\u003ea2 subgraph 表1 a1--\u003ea2 end subgraph 表2 b1--\u003eb2 end subgraph 表3 c1--\u003ec2 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:8","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"交互 为节点添加事件 以及点击跳转 这个现在还不是很好用 var callback = function(){ alert('A callback was triggered'); } 源代码： ```mermaid graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 生成效果 ```mermaid graph LR; A--\u003eB; B[跳转百度]--\u003eC; C--\u003eD; click A callback \"Tooltip for a callback\" click B \"http://www.baidu.com\" \"This is a tooltip for a link\" click A call callback() \"Tooltip for a callback\" click B href \"http://www.github.com\" \"This is a tooltip for a link\" 注释 %% 源代码 ```mermaid graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C 生成效果 graph LR %% this is a comment A -- text --\u003e B{node} A -- text --\u003e B -- text2 --\u003e C ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:9","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"添加样式 方式1 语法： style id key:value,key:value 源代码： ```mermaid graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 生成效果 graph LR s[\"开始(实线边框，4px，边框颜色：#007fff 掘金蓝 ,背景色：red)\"] e[\"结束(虚线边框，4px，边框颜色：red,背景色：#007fff 掘金蓝 文本颜色为白色)\"] style s fill:red ,stroke:#007fff,stroke-width:4px style e fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式2 定义样式 class 语法：classDef className 样式定义 应用 :::classname 源代码： ```mermaid graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 复制代码 生成效果 graph LR s[开始]:::ownstyle--\u003ee[结束] classDef ownstyle fill:#007fff,stroke:red,stroke-width:4px,stroke-dasharray: 5 5,color:#fff 方式3 css class形式添加样式 定义 \u003cstyle\u003e .cssClass \u003e rect{ fill:red; stroke:#FFFF00; stroke-width:4px; } \u003c/style\u003e 实例： 源代码 ```mermaid graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; 生成效果： ```mermaid graph LR; A--\u003eB[AAA\u003cspan\u003eBBB\u003c/span\u003e]; B--\u003eD; class A cssClass; ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:1:10","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"Mermaid - 时序图（序列图） ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"基本结构 角色 Actor 系统角色 可是是人或者其他系统子系统 对象 Object 交互过程中扮演的角色 一般位于时序图顶部 生命线 Lifeline 生命线代表时序图中的对象在一段时期内的存在 控制焦点 Activation 控制焦点代表时序图中的对象执行一项活动的时期 消息 Message 定义交互和协作中交换信息的类 基本对象声明 sequenceDiagram participant 张三 participant 李四 对象声明-别名 Aliases sequenceDiagram participant Z as 张三 participant L as 李四 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:1","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"消息 Message 语法：participant1 箭头 participant2：消息内容 sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003eL:我是没有箭头的实线 L--\u003eZ:我是没有箭头的虚线 Z-\u003e\u003eL:带箭头的实线 L--\u003e\u003eZ:带箭头的虚线 Z-xL:带x箭头实线 L-)Z:结束时候 带箭头的实线 Z--)L:结束时候 带箭头的虚线 线型对照表 线形 含义 -\u003e 无箭头的实线 –\u003e 没箭头的虚线 -» 带箭头的实线 –» 带箭头的实线 -x 带x号箭头实线 –x 结尾x号箭头实线 -) 结束 带箭头的实线 –) 结束 带箭头的虚线 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:2","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"控制焦点 Activations 语法： activate participant //激活 消息 deactivate participant //释放激活 这个有一些抽象我们用一个场景来去理解 场景1： ``` 张三：hi李四你还好么 // 李四听了开始回话 此时李四是激活状态 开始进行对话 李四：hi张三我可以听到你，我很好，不用担心。 //李四会话结束 不会再跟张三有活动 此时李四的激活状态被释放 ``` 源代码： ``` ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L ``` ``` 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L L-\u003e\u003eZ:hi张三我可以听到你，我很好，不用担心。 deactivate L 场景2： 张三：hi李四你还好么 张三：你可以听到我说话么 //李四开始回话 被激活 李四：hi张三我可以听到你 李四：不用担心我 复制代码 源代码： ```mermaid sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L 生成效果： sequenceDiagram participant Z as 张三 participant L as 李四 Z-\u003e\u003eL:hi李四你还好么 activate L Z-\u003e\u003eL:你可以听到我说话么 activate L L-\u003e\u003eZ:hi张三我可以听到你 deactivate L L-\u003e\u003eZ:我很好，不用担心。 deactivate L ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:3","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图-批注 Note 语法： 单个对象： Note 位置 of participant:批注内容 多个对象： Note 位置 角色名称1，角色名称2:批注内容 位于对象左侧： 源代码 ```mermaid sequenceDiagram participant 张三 Note left of 张三 :我是张三 复制代码 生成效果 sequenceDiagram participant 张三 Note left of 张三 :我是张三 sequenceDiagram participant 张三 Note right of 张三 :我是张三 sequenceDiagram participant 张三 participant 李四 Note over 张三,李四 :我是张三 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:4","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图-逻辑循环 Loop 交互过程中表示某些循环的环节 语法： loop 循环描述 循环内容 end //结束标记 复制代码 场景： 李四跟张三是好朋友 李四生病了 张三很关心他 每过一小时 为了不让张三如此担心 李四就约定每一个小时给张三发消息 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三-\u003e\u003e李四:李四你好么 loop 每过一小时李四发消息给张三 李四 --\u003e 张三:我很好 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:5","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图 抉择（Alt）\u0026选项（Opt） 组合片段用来解决交互执行的条件及方式。它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。 Alt 抉择 用来指明在两个或更多的消息序列之间的互斥的选择，相当于经典的if..else.. 只能发生一种情况 语法： alt 第一种情况描述 具体发生的动作 else 剩余情况描述 具体发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 如果李四生病了他会说：我不是很好 如果李四很健康他会说：我很好 又是很好的一天 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你生病了么 alt 第一种情况描述 李四--\u003e\u003e张三:是的，我很难受 else 剩余情况描述 李四--\u003e\u003e张三:我没生病，挺好的 end opt 选择\" 包含一个可能发生或不发生的序列 就是一种场景有可能发生也有可能不发生 语法： opt 情况描述 有可能发生的动作 end 复制代码 场景： 场景:张三：李四你还好么 李四会可能会说谢谢你的问候也可能不会说 这个并无法预测 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 张三 -\u003e\u003e李四:你还好么 opt 可能的回答 李四--\u003e\u003e张三:谢谢你的问候 end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:6","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"时序图 并行关系 par 并行处理: 一个对象同时发出的交互动作 基本语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end 复制代码 场景： participants: 张三 李四 王五 张三 在下午5点分别给李四和王五分一条信息：内容是吃了么 李四回复：吃了 张三回复：没吃 复制代码 源代码 ```mermaid sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 复制代码 生成效果 sequenceDiagram autonumber participant 张三 participant 李四 participant 王五 par [给李四发消息] 张三 -\u003e\u003e 李四: 吃了么 and [王五发送消息] 张三 -\u003e\u003e 王五: 吃了么 end 李四 -\u003e\u003e 张三:没吃呢 王五 -\u003e\u003e 张三:吃了 嵌套语法： par 动作描述1 participant1 -\u003e\u003e participant2: 内容 and 动作描述2 participant1 -\u003e\u003e participant3: 内容 end par 动作描述1 participant3 -\u003e\u003e participant4:内容 and 王五发消息给A8 participant3 -\u003e\u003e participant5:内容 end 复制代码 场景： participants: 张三 李四 王五 赵六 A8 王五明天请吃饭 张三发消息问李四明天去不去 同时发消息给王五问明天都有哪些人参加 王五发消息给赵六:明天一起吃饭8 同事也发消息给A8告诉他让他带着小伙伴一起 复制代码 源代码 ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 复制代码 生成效果 sequenceDiagram participant 张三 participant 李四 participant 王五 participant 赵六 participant A8 par 张三发消息给李四 张三 --\u003e\u003e 李四:明天王5请客吃饭 and 张三发消息给王五 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end par 王五发消息给赵六 王五-\u003e\u003e赵六:明天准时到场哈 and 王五发消息给A8 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end 背景高亮 语法： rect rgba(0,213,123) 复制代码 源代码： ```mermaid sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end 复制代码 生成效果： sequenceDiagram participant 张三 participant 李四 participant 王五 participant 张三 participant 赵六 participant A8 par 张三发消息给李四 rect rgba(0,113,133) 张三 --\u003e\u003e 李四:明天王5请客吃饭 end and 张三发消息给王五 rect rgba(0,113,133) 张三 --\u003e\u003e 王五: 明天吃饭都有谁呢 end end par 王五发消息给赵六 rect rgba(0,213,123) 王五-\u003e\u003e赵六:明天准时到场哈 end and 王五发消息给A8 rect rgba(0,213,123) 王五 -\u003e\u003eA8:明天带上你的伙伴一起来哈 end end ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:2:7","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"类图 classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:3:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"状态图 stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:4:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"实体关系图 erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:5:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"用户旅程图 journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:6:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"gantt图 gantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:7:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"饼图 pie title Pets adopted by volunteers \"Dogs\" : 386 \"Cats\" : 85 \"Rats\" : 15 ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:8:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["Markdown"],"content":"需求图 requirementDiagram requirement test_req { id: 1 text: the test text. risk: high verifymethod: test } element test_entity { type: simulation } test_entity - satisfies -\u003e test_req ","date":"2021-07-27","objectID":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/:9:0","tags":["GitHub","博客"],"title":"Mermaid教程收录","uri":"/2021/07/mermaid%E6%95%99%E7%A8%8B%E6%94%B6%E5%BD%95/"},{"categories":["C++"],"content":"字符的输入与输出","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"字符的输入与输出 \\b 退格 \\f 走纸换页 \\r 回车 \\t 横向跳格(ctrl-i) ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"格式化字符 %c 字符 %d 十进制整数 %s 字符串 %S or %ws 宽字符串 %x 十六进制整数 %p 指针或地址 %o 八进制整数 %f 小数(浮点数) %u 无符号十进制整数 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:1:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"scanf输入 scanf(\"%s\",\u0026str1); ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:2:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 ","date":"2021-07-27","objectID":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/:3:0","tags":["C++"],"title":"字符的输入与输出","uri":"/2021/07/%E5%AD%97%E7%AC%A6%E7%9A%84%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"指针读写内存","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/","tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"指针读写内存 #include \u003ccstdio\u003e#define BASE 0x00417000 int g_a = 111; //0x00417000 int g_b = 222; //0x00417004 int g_c = 333; //0x00417008 typedef struct T3 { int a1; //偏移0 int a2; //偏移4 int a3; //偏移8 }TYPE3; int main(int argc, char const *argv[]) { //指针读内存 int* p1=(int*)0x00417000; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,333 printf(\"B:%d,%d,%d \\n\",*(p1+0),*(p1+1),*(p1+2)); //B:111,222,333 printf(\"C:%d,%d,%d \\n\",p1[0],p1[1],p1[2]); //C:111,222,333 printf(\"D:%d,%d,%d \\n\",*(int*)0x0041700,*(int*)0x00417004,*(int*)0x0041708); //D:111,222,333 //用指针向内存地址写入数据 *(p1+2)=11567; printf(\"A:%d,%d,%d \\n\",g_a,g_b,g_c ); //A:111,222,11567 p1[2]=22567; printf(\"B:%d,%d,%d \\n\",g_a,g_b,g_c ); //B:111,222,22567 *(int*)(0x0041700+8)=333678; printf(\"C:%d,%d,%d \\n\",g_a,g_b,g_c ); //C:111,222,333678 TYPE3* p3 =(TYPE3*)0x00417000; printf(\"%p,%p,%p \\n\",\u0026p3-\u003ea1,\u0026p3-\u003ea2,\u0026p3-\u003ea3); //111,222,333678 printf(\"%d,%d,%d \\n\",p3-\u003ea1,p3-\u003ea2,p3-\u003ea3); //111,222,333678 printf(\"p3=%p,p3+1=%p,sizeof(TYPE3)=%X \\n\",p3,p3+1,sizeof(TYPE3)); //p3=00417000,p3+1=0041700C,sizeof(TYPE3)=C printf(\"p3=%p,p3+2=%p,sizeof(TYPE3)=%X \\n\",p3,p3+2,sizeof(TYPE3)); //p3=00417000,p3+2=00417018,sizeof(TYPE3)=C printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+sizeof(TYPE3)*2); //\u003e\u003e\u003e:p3+2=417018 =417018 printf(\"\u003e\u003e\u003e:p3+2=%X =%X \\n\",p3+2,0x00417000+0xC*2); //\u003e\u003e\u003e:p3+2=417018 =417018 return 0; } ","date":"2021-07-27","objectID":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/:0:0","tags":["C++"],"title":"指针读写内存","uri":"/2021/07/%E6%8C%87%E9%92%88%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/"},{"categories":["C++"],"content":"C++知识点","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"C++知识点 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:0:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"阻断函数 getchar() //等待键盘输入回车 sysem(\"pause\")//任意键继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:1:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"常用函数 printf(\"Hello World!\") //输出函数 atoi(arg) //字符串转整数 Sleep(arg) //等待 MessageBeep(1); //播放系统音乐,方便OD定位 void *memcpy(void *str1, const void *str2, size_t n) //内存copy(读取与写入) //str1 -- 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 //str2 -- 指向要复制的数据源，类型强制转换为 void* 指针。 //n -- 要被复制的字节数。 //返回值 -- 该函数返回一个指向目标存储区 str1 的指针。 void *memset(void *s, int ch, size_t n); //内存设置 //将s中当前位置后面的n个字节,用 ch 替换并返回 s 。 size_t strlen(const char *string); //计算给定字符串的长度 (ANSI) size_t wcslen(const wchar_t * str); //strlen函式的宽字节版 (Unicode) BOOL CloseHandle( HANDLE hObject //对象句柄 );//关闭对象句柄。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:2:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"用汇编来调用CALL int pcall =(int)MessageBoxC; __asm { push 0 //4 push 0 //3 push 0 //2 push 0 //1 call dword ptr ds:[MessageBoxA] //第一种 mov eax,MessageBoxB call eax //第二种 call pcall //第三种 ;分号 注释语句 } ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:3:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"循环 break; //退出循环 continue; //跳到循环首部,循环继续 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:4:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"其它 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"_In_ 表示是一个输入参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:1","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"_Out_ 表示是一个输出参数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:2","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"\u0026arg 引用 1.必须传变量 2.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:3","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"\u0026变量 取变量地址运算符 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:4","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"*arg 指针 1.会影响被引用的变量原本的值 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:5","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"冒号: 冒号代表标签,常用于goto跳转 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:6","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"typedef 关键字，作用是为一种数据类型定义一个新名字 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:7","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"三元运算子 条件式 ? 条件式为true时执行的陈述句 : 条件式为false时执行的陈述句 int ret, a = 10, b = 11; bool flag = true; if (flag) ret = a; else ret = b; 等价于 ret = flag ? a : b; ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:8","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"const 声明变量是不变的 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:9","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"define 定义宏,可用于起别名,也可带参数,如 #define hanshu(a,b) (a+b) ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:10","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"指针 LPSTR char* LPCSTR const char* LPCTSTR const TCHAR* LPTSTR TCHAR* LP = 指针 C = const 只读 TSTR = TCHAR ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:11","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"HINSTANCE “句柄型”数据类型。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:12","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"static 关键字 定义静态变量或静态函数,生存周期和全局变量一样,作用域和局部变量一样,初始化仅执行一次. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:5:13","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"char* 定义字符串 char p[256]=\"hijk\"; //可读写 char src2[]=\"opq\"; //可读写 char *p=\"abcd\"; //只读 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:1","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"strcpy 字符串复制(wcscpy宽字节版) char *strcpy(char* dest, const char *src); 把从src地址开始且含有NULL结束符的字符串复制到以dest开始的地址空间 strcpy_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:2","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"strcat 字符串连接(wcscat宽字节版) extern char *strcat(char *dest, const char *src); strcat_s 带有检测缓冲区的功能,更实用 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:3","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"strstr 查找字符串(wcsstr宽字节版) string strstr( string1，string2) ​ strstr返回一个指针，指向string2在string1中首次出现的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:4","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"strchr 查找字符(wcschr宽字节版) char *strchr(const char *str, int c) 在参数str所指向的字符串中搜索第一次出现字符c（一个无符号字符）的位置。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:5","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"strcmp 字符串比较(wcscmp宽字节版) extern int strcmp(const char *s1,const char *s2); 当s1\u003cs2时，返回为负数； 当s1=s2时，返回值= 0； 当s1\u003es2时，返回正数. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:6","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"以下仅了解 strrev strncmp strncmpi strerror strncpy strnicmp ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:6:7","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"Unicode字符串(wchar)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:7:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"wchar_t 宽字符 wchar_t c1='A'; //单个字符不用加\"L\" wchar_t wStr[]=L\"这是一段中文\"; //字符串前要加\"L\" wchar_t appName[5]=TEXT(\"test\"); //可以用TEXT()方法将char转换成wchar_t char是8位字符类型,wchar_t数据类型一般为16位或32位,wchar_t所能表示的字符数远超char型。 如果你想使用ANSI字符串，那么请使用这一套写法： char szString[100]; strcpy(szString,\"test\"); 如果你想使用Unicode字符串，那么请使用这一套： wchar_t szString[100]; wcscpyszString,L\"test\"); 如果你想通过定义_UNICODE宏，而编译ANSI或者Unicode字符串代码： TCHAR szString[100]; _tcscpy(szString,_TEXT(\"test\")); ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:7:1","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"相关函数见 多字节字符串(char)及常用函数 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:7:2","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"TCHAR兼容型字符串及常用函数 TCHAR ANSI Unicode TCHAR char wchar_t _tcscpy() strcpy() wcscpy() _tmain() main() wmain() _tWinMain() WinMain() wWinMain() _T\"str\" “str” L\"str\" _tprintf() printf() wprintf() _tcslen() strlen() wcslen() ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:8:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"DLL动态链接库及入口函数 LoadLibrary 加载动态链接库 HMODULE LoadLibrary(_In_ LPCTSTR lpFileName); __stdcall 参数从右向左压入堆栈 APIENTRY 则表明此函数是应用程序的入口点,其实都是__stdcall winapi 表示此函数是普通的winapi函数调用方式,其实都是__stdcall FreeLibrary 释放动态链接库 BOOL WINAPI FreeLibrary(_In_ HMODULE hModule); DLL_PROCESS_ATTACH 宏 进程载入 // 1 DLL_PROCESS_DETACH 宏 进程卸载 // 0 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:9:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"跨进程分配内存 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:10:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"VirtualAllocEx 向指定进程申请内存 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); ​ flAllocationType 可取下列值： MEM_COMMIT：为特定的页面区域分配内存中或磁盘的页面文件中的物理存储 MEM_PHYSICAL ：分配物理内存（仅用于地址窗口扩展内存） MEM_RESERVE：保留进程的虚拟地址空间，而不分配任何物理存储。保留页面可通过继续调用VirtualAlloc（）而被占用 MEM_RESET ：指明在内存中由参数lpAddress和dwSize指定的数据无效 MEM_TOP_DOWN：在尽可能高的地址上分配内存（Windows 98忽略此标志） MEM_WRITE_WATCH：必须与MEM_RESERVE一起指定，使系统跟踪那些被写入分配区域的页面（仅针对Windows 98） flProtect 可取下列值 PAGE_READONLY： 该区域为只读。如果应用程序试图访问区域中的页的时候，将会被拒绝访 PAGE_READWRITE 区域可被应用程序读写 PAGE_EXECUTE： 区域包含可被系统执行的代码。试图读写该区域的操作将被拒绝。 PAGE_EXECUTE_READ ：区域包含可执行代码，应用程序可以读该区域。 PAGE_EXECUTE_READWRITE： 区域包含可执行代码，应用程序可以读写该区域。 PAGE_GUARD： 区域第一次被访问时进入一个STATUS_GUARD_PAGE异常，这个标志要和其他保护标志合并使用，表明区域被第一次访问的权限 PAGE_NOACCESS： 任何访问该区域的操作将被拒绝 PAGE_NOCACHE： RAM中的页映射到该区域时将不会被微处理器缓存（cached) 注:PAGE_GUARD和PAGE_NOCHACHE标志可以和其他标志合并使用以进一步指定页的特征。PAGE_GUARD标志指定了一个防护页（guard page），即当一个页被提交时会因第一次被访问而产生一个one-shot异常，接着取得指定的访问权限。PAGE_NOCACHE防止当它映射到虚拟页的时候被微处理器缓存。这个标志方便设备驱动使用直接内存访问方式（DMA）来共享内存块。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:10:1","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"VirtualFreeEx 释放申请的虚拟内存空间 BOOL WINAPI VirtualFreeEx( HANDLE hProcess, //目标进程的句柄。 LPVOID lpAddress, //指向要释放的虚拟内存空间首地址的指针 SIZE_T dwSize, //虚拟内存空间的字节数 DWORD dwFreeType );//释放类型 ​ lpAddress ​ 指向要释放的虚拟内存空间首地址的指针。 ​ 如果 dwFreeType 为 MEM_RELEASE, 则该参数必须为VirtualAllocEx的返回值. ​ dwSize ​ 虚拟内存空间的字节数 ​ 如果 dwFreeType 为 MEM_RELEASE，则 dwSize 必须为0 . 按 VirtualAllocEx申请时的大小全部释放。 ​ 如果dwFreeType 为 MEM_DECOMMIT, 则释放从lpAddress 开始的一个或多个字节 ，即 lpAddress +dwSize。 ​ dwFreeType ​ 释放类型，取值见下表： 值 释义 MEM_DECOMMIT0x400016384D 这种试 仅标示 内存空间不可用，内存页还将存在。 MEM_RELEASE0x800032768D 这种方式 很彻底，完全回收。 ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:10:2","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"跨进程调用CALL ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:11:0","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["C++"],"content":"CreateRemoteThread 创建远程进程 HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, //进程句柄. _In_ LPSECURITY_ATTRIBUTES lpThreadAttributes, //指针,一般设置为NULL _In_ SIZE_T dwStackSize, //纯种堆栈大小,一船设置为0,表示默认为1M _In_ LPTHREAD_START_ROUTINE lpStartAddress, //线程函数的地址 _In_ LPVOID lpParameter, //线程参数 _In_ DWORD dwCreationFlags, //线程的创建标志 _Out_ LPDWORD lpThreadId //输出参数,记录创建的远程线程的ID,不输出可传NULL ); ​ 线程的创建标志. 值 含义 0 线程创建后立即运行 CREATE_SUSPENDED 0x00000004 线程创建后先将线程挂起,直到 ResumeThread 被调用. STACK_SIZE_PARAM_IS_A_RESERVATION0x00010000 dwStackSize 参数指定为线程栈预订大小,如果STACK_SIZE_PARAM_IS_A_RESERVATION没有被指定,dwStackSize 参数指定为线程栈分配大小. ","date":"2021-07-26","objectID":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/:11:1","tags":["C++"],"title":"C++知识点","uri":"/2021/07/c-%E7%9F%A5%E8%AF%86%E7%82%B9/"},{"categories":["GitHub"],"content":"GitHub回退历史版本","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"GitHub回退历史版本 前提是本地已经有了git的origin master库或者克隆需要回退的代码到本地。 ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:0","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"1. 查询历史对应不同版本的ID ，用于回退使用 git log --pretty=oneline 假设查到历史版本的id是 ： 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:1","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"2. 恢复到历史版本 git reset --hard 662095637a8e9320e83761341e594b143524049e ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:2","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"3. 把修改推到远程服务器 git push -f -u origin master ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:3","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"4. 重新更新 git pull ","date":"2021-07-26","objectID":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/:0:4","tags":["GitHub"],"title":"GitHub回退历史版本","uri":"/2021/07/github%E5%9B%9E%E9%80%80%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"},{"categories":["GitHub"],"content":"Git与GitHub绑定","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/","tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["GitHub"],"content":"Git与GitHub绑定 终端输入ssh-keygen -t rsa命令，表示我们指定 RSA 算法生成密钥，然后敲三次回车键，期间不需要输入密码，之后就就会生成两个文件，分别为id_rsa和id_rsa.pub，即密钥id_rsa和公钥id_rsa.pub. 对于这两个文件，其都为隐藏文件，默认生成在以下目录： Linux 系统：~/.ssh Mac 系统：~/.ssh Windows 系统：C:\\Documents and Settings\\username.ssh 密钥和公钥生成后，把公钥id_rsa.pub的内容添加到 GitHub，这样我们本地的密钥id_rsa和 GitHub 上的公钥id_rsa.pub才可以进行匹配，授权成功后，就可以向 GitHub 提交代码啦！ 在 Git Bash 中输入ssh -T git@github.com进行测试： ","date":"2021-07-26","objectID":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/:0:0","tags":["GitHub"],"title":"Git与GitHub绑定","uri":"/2021/07/git%E4%B8%8Egithub%E7%BB%91%E5%AE%9A/"},{"categories":["博客"],"content":"Hugo常用命令","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"Hugo常用命令 新建章节 hugo new –kind chapter /_index.md 新建文件 hugo new //_index.md hugo new /.md hugo new posts/.md 解除环境限制 hugo serve -e production 生成指定模板的样例文章 hugo new –kind post-bundle posts/my-post 实时预览 hugo serve –disableFastRender ","date":"2021-07-26","objectID":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["GitHub","博客"],"title":"Hugo常用命令","uri":"/2021/07/hugo%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":["博客"],"content":"安装hugo博客","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装hugo博客 在 macOS 上可使用 Homebrew 套件管理安裝 brew install hugo ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Generate new site 要產生一個新的 web site 內容，可直接執行 hugo new site ssg-site 執行後會建立一個名為 ssg-site 的資料夾，包含以下內容 . ├── archetypes │ └── default.md ├── config.toml ├── content ├── data ├── layouts ├── static └── themes 其中 archetypes: 放置生成文件的基礎樣板資料夾（可先暫時不管）。 config.toml: 控制 hugo 產生網頁內容的設定檔，預設使用 toml 格式。(也支援 yaml 與 json 格式) content: 放置 Markdown 文章與網頁內容的資料夾。 data: 儲存一些 configuration 檔案的地ㄌㄌ方，協助建構靜態網頁(也先不管)。 layouts: 儲存產生的網頁 layout 樣板(之後範例使用其他的 theme，先不管)。 static: 放置靜態內容，如圖片，CSS 以及 *.js 等內容。 themes: 從外部引入的 theme 檔案。 目前只要知道 config.toml, content, static 與 themes 這幾個部分即可。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:1","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Import Hugo themes Hugo 並沒有預設的 theme，所以在建立好內容資料夾後，需自行建立 theme 或使用其他 theme，在這我們已 Mainroad theme 做範例。 # 將 mainroid theme 加入 themes/ 中 cd /Users/xinqinew/ssg-site git clone https://github.com/Vimux/Mainroad.git themes/mainroad 除了使用 git 指令外，直接從 Github 上下載最新原始檔案壓縮檔，解壓縮後放到 themes 資料夾中。此外對 git 熟悉的是使用者也可用 git submodule 或 git subtree 等方式管理外部引入的 theme repo。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:2","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Configuration Hugo 在生成 SSG 時會使用到 config.toml 檔案的設定內容。我們可以將之前 Mainroad theme 中的 config.toml 修改後加以使用 # 將 mainroid 的 config.toml 覆蓋原先的預設值 cp themes/mainroad/exampleSite/config.toml . 之後編輯 config.toml 內容，將其修改為自己想要的內容。更詳細的 configuration 設定可參考 Hugo 官方文件 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:3","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"新增 Blog 文章 我們可以手動新增 Markdown 文件 hugo new post/hello-world.md 之後會在 ./content/post/hello-world.md 的位置新增一個 Markdown 文件，其中預設內容會根據 archetype/default.md 這個樣板檔案內容加以建立。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:4","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"預覽內容 先將 ./content/post/hello-world.md 內容修改為 --- title: \"Hello World\" date: 2018-07-06T16:00:21+08:00 categories: - \"Blog\" tags: - \"Hugo\" draft: true --- # Hello World. Post example 之後執行以下指令 hugo server --buildDrafts 若在 Markdown 的 Front Matter，加入 draft: true，代表該篇文章為草稿不會被 Hugo 轉換為網頁。因此可在指令後加入 --buildDrafts 來轉換草稿文件。 執行成功後會在 localhost:1313 建立一個暫時的網頁，可接載在瀏覽器網址列輸入預覽結果。 Hugo Mainroad theme 結果預覽 1313 為 Hugo 的預設 Port，可以使用 --port xxx 來指定使用其他 Port ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:5","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"生成靜態內容 Hugo 要生成靜態網頁內容只執行 hugo 指令即可 hugo 執行後生成的網頁內容會自動加入 public 資料夾中。 public 為預設資料夾，若要修改可在 config 檔案中設定 publishDir 參數指定輸出位置。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:0:6","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"從 Jekyll 轉移到 Hugo 如果要從其他的 SSG 轉換到 Hugo，官方也提供了一些轉換方式。以從 Jekyll 轉換到 Hugo 為例，只要執行 hugo import jekyll [jekyll_root_path] [target_path] 就會將 Jekyll 轉換為 Hugo 格式資料夾。但這方式也不是沒問題，原先在的 Jekyll 的 theme 無法直接在 Hugo 使用，且有部分 Front Matter 無法正確轉換，因此建議還是手動轉移較好。而因爲個人轉移時選用的 theme 為 Mainroad，在過程中也遇到了一些問題，在此提出來以供參考。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Markdown Front Matter 由於 Hugo 與 Jekyll 所使用的 Front Matter 設定不同，有些部分需要每個檔案逐一修改內容，如 categories 或 tags 的內容，之前使用的 voyager theme 在執行時會成格式不對，需修改將其改為 List 結構，如在 Jekyll 中， categories: posts 是可行的，但換到 Hugo 的 Mainroad theme 時，需使用 List 結構才行，如 categories: [\"posts\"] 才可正常產生靜態網頁，否則會出現錯誤。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:1","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Math equation support 在加入數學式的支援花了一些時間去解決，主要分為兩個問題 - Markdown 轉換成 HTML 以及 Mainroad theme 的 CSS conflict 問題。 Markdown parser support 在加入數學式時，我們習慣直接使用 Latex 語法在 Markdown 中，這樣可以更容易寫出方便的數學式。而 Hugo 預設的 Markdown parser Blackfriday(使用 Go 語言實作的 Markdown parser) 會進行某些預先處理，造成 MathJax 無法正確顯示內容以及斷行的問題。因此需要將原先的 Blackfriday parser 更換成 Mmark，即在 Markdown 文件中使用 Latex 數學式語法。方法為將檔案副檔名命名為 *.mmark，或是在 Markdown Front Matter 中加入 markup: \"mmark\" 來指定使用 Mmark 處理 Markdown 文件。更詳細的內容可參考官網說明。 Katex support 雖然 Mainroad theme 雖然有支援 MathJax，但該 theme 的 CSS style 中有部分和 Katex 的 CSS 設定衝突，造成當把 Mainroad 中的 MathJax 部分的樣板原始碼換成支援 Katex 後，在顯示 Matrix 時會造成跑版。詳情狀況可參考個人發在 GitHub 上的 Issue #1445。在 Katex 小組了解問題並經過 Mainroad 作者修改樣板後即解決了該問題。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:2","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Syntax highlighting 要在 Hugo 中讓程式碼有高亮效果，可在 config 檔案中加入以下設定 # use Chroma for syntax highlight pygmentsCodeFences = true # 啟動 Code Fence 區域的高亮效果 pygmentsCodefencesGuessSyntax = true # 對沒有指定程式類型的 Code Fence 自行推導語言類型 pygmentsStyle = \"fruity\" # 指定使用的高亮風格，如 vim 或 fruity 等(預設為 \"monokai\") 若想換成其他風格可參考這裡的格式，將 pgmentsStyle 的設定修改為該風格 Hugo 就會用該風格顯示 Markdown 中 Code Fence 區段的內容。其他設定可參考 Hugo 官網關於 Syntax Hightlighting 的章節。 pygment 為原先 Hugo 所使用的 Syntax Hightlighting 工具， 在 Hugo 0.28 版後改為 Chroma 為預設內容，但設定檔仍維持原先的格式。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:3","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"首頁大綱內容 Mainroad 的 Markdown 文件顯示在列表中的大綱內容，會是最前面段落開始一直延續到預設長度為止，這在排版上會很難看，因此可以手動在 Markdown 文件中加入 ` ` 標籤隔開大綱與主題內容，如下範例 ...{大綱內容}... \u003c!--more--\u003e ...{文章內容}... 這樣在首頁的列表中就只會顯示大綱內容的部分。 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:4","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Disqus Support Hugo 本身所產生的內容為靜態網頁，若要有像留言板之類的動態內容就必須藉助外部服務。Hugo 本身支援 Disqus 這個知名的 Blog 留言服務樣板，只要建立帳號取得 shortname，在 config 檔案中設定完成即可。若使用的 theme 有支援應該能正確顯示 disqusShortname = \"yourdiscussshortname\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:5","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Google Analysis support 和 Disqus 相同，Hugo 也有內部支援 Google Analysis 來統計你網站的流量與人潮。只要去 Google Analysis 申請一組 Tracking Id 並在 config 中加入設定。如 使用的 theme 有支援該功能則會自動設定 googleAnalytics = \"yourtrackingid\" ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:1:6","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"Reference Hugo Mainroad theme Disqus Katex 从Jekyll迁移到Hugo，Hugo不完全指南 ","date":"2021-07-26","objectID":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装hugo博客","uri":"/2021/07/%E5%AE%89%E8%A3%85hugo%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"\u003c\u003e尖括号","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/","tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"\u003c \u003e尖括号 我习惯将尖括号用于指定类型，作为参数: vector\u003cint\u003e vecOfInts ; 但是在rapidjson中，有这样的代码: document.Parse\u003c0\u003e(json) ; document.Parse方法的签名是: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 我不知道您可以在尖括号内传递值-认为尖括号仅用于类型名称。 这里的代码在做什么，为什么他在尖括号中传递一个值？ 这是一个好主意吗？什么时候？ 最佳答案 这里有两个不同的因素。 首先，可以定义除类型以外的参数化模板。例如，这是一个简单的数组类型: template \u003ctypename T, size_t N\u003e struct Array { T arr[N]; }; 我们可以这样使用 Array\u003cint, 137\u003e myArray; 我们知道vector\u003cint\u003e和vector\u003cdouble\u003e是不同的类型。但是现在我们还必须指出，Array\u003cint,137\u003e和Array\u003cint,136\u003e是不同的类型。 其次，使用模板时，编译器必须能够为所有模板参数找出一个值。使用模板类时，这就是为什么通常指定所有模板参数的原因。例如，您不说vector x，而是说类似vector\u003cdouble\u003e x。使用模板函数时，大多数时候编译器可以找出参数。例如，要使用std::sort，您只需说出类似 std::sort(v.begin(), v.end()); 但是，您也可以写 std::sort\u003cvector\u003cint\u003e::iterator\u003e(v.begin(), v.end()); 更明确地说。但是有时候，您有一个模板函数，对于该函数，并非所有参数都可以被找出来。在您的示例中，我们有: template \u003cunsigned parseFlags\u003e GenericDocument\u0026 Parse(const Ch* str) { RAPIDJSON_ASSERT(!(parseFlags \u0026 kParseInsituFlag)); GenericStringStream\u003cEncoding\u003e s(str); return ParseStream\u003cparseFlags\u003e(s); } 注意，不能仅从函数的参数推导parseFlags模板参数。因此，要调用该函数，必须指定template参数，否则编译器将无法确定该参数。这就是为什么你会写类似 Parse\u003c0\u003e(myString); 此处，0是模板参数(在编译时解析)，而myString是实际参数(在运行时解析)。 实际上，您可以使用结合了一些类型推断和一些显式类型参数的方法。例如，在Boost中，有一个函数lexical_cast可以在字符串类型之间进行转换。从非字符串类型转换为字符串类型的函数签名是 template \u003ctypename Target, typename Source\u003e Target lexical_cast(const Source\u0026 arg); 在这里，如果您调用lexical_cast，则编译器可以确定Source是什么，但如果没有一些提示，就无法推断出Target。因此，要使用lexical_cast，您需要编写类似 std::string myString = boost::lexical_cast\u003cstd::string\u003e(toConvertToString); 更一般而言，编译器说您必须指定一定数量的模板参数(可选为0)，它将尝试推断其余的参数。如果可以的话，太好了!如果不是，则为编译时错误。如果需要，可以使用此代码编写类似的函数 template \u003cint IntArgument, typename TypeArgment\u003e void DoSomething(const TypeArgument\u0026 t) { /* ... */ } 要调用此函数，您必须像这样调用它: DoSomething\u003cintArg\u003e(otherArg); 在这里，这是可行的，因为您必须显式告诉编译器IntArgument是什么，但是编译器可以从TypeArgument的参数类型推导DoSomething。 ","date":"2021-07-24","objectID":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/:0:0","tags":["C++"],"title":"\u003c\u003e尖括号","uri":"/2021/07/%E5%B0%96%E6%8B%AC%E5%8F%B7/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/","tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque clear()与erase()用法及示例 雙端隊列或雙頭隊列是序列容器，兩端都有擴展和收縮功能。它們類似於向量，但是在元素的結尾和開始處插入和刪除時效率更高。與向量不同，可能無法保證連續的存儲分配。 deque::clear() clear()函數用於刪除雙端隊列容器的所有元素，從而使其大小為0。 用法: dequename.clear() Parameters : No parameters are passed. Result : All the elements of the deque are removed ( or destroyed ) 例子： Input :mydeque = {1, 2, 3, 4, 5} mydeque.clear(); Output:mydeque = {} Input :mydeque = {} mydeque.clear(); Output:mydeque = {} 錯誤和異常 1.它沒有異常拋出保證。 2.傳遞參數時顯示錯誤。 // CPP program to illustrate // Implementation of clear() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; mydeque.clear(); // Deque becomes empty  // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： No Output deque::erase() erase()函數用於從指定位置或範圍中刪除容器中的元素。 用法: 1. _**dequename.erase(position)**_ 2. _**dequename.erase(startingposition, endingposition)**_ **Parameters :** Position of the element to be removed in the form of iterator. or the range specified using start and end iterator. **Result :** Elements are removed from the specified position of the container. 例子： Input : mydeque{1, 2, 3, 4, 5}, iterator= 2 mydeque.erase(iterator); Output : 1, 2, 4, 5 Input : mydeque{1, 2, 3, 4, 5, 6, 7, 8}, iterator1= 3, iterator2= 6 mydeque.erase(iterator1, iterator2); Output : 1, 2, 3, 8 錯誤和異常 1.如果位置有效，則沒有異常拋出保證。 2.否則顯示未定義的行為。 從特定位置移除元件 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it; it = mydeque.begin(); mydeque.erase(it); // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 2 3 4 5 刪除範圍內的元素 // CPP program to illustrate // Implementation of erase() function #include \u003cdeque\u003e #include \u003ciostream\u003e using namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it1, it2; it1 = mydeque.begin(); it2 = mydeque.end(); it2--; it2--; mydeque.erase(it1, it2); // Printing the deque  for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 4 5 應用 給定一個整數列表，從雙端隊列中刪除所有偶數元素並打印雙端隊列。 Input :1, 2, 3, 4, 5, 6, 7, 8, 9 Output :1 3 5 7 9 _Explanation - 2, 4, 6 and 8 which are even are erased from the deque_ 算法 1.循環運行，直到雙端隊列大小為止。 2.檢查每個位置的元素是否可被2整除，如果是，則刪除該元素並遞減迭代器。 3.打印最終雙端隊列。 // CPP program to illustrate // Application of erase() function #include \u003cdeque\u003e#include \u003ciostream\u003eusing namespace std; int main() { deque\u003cint\u003e mydeque{ 1, 2, 3, 4, 5, 6, 7, 8, 9 }; deque\u003cint\u003e::iterator i; i = mydeque.begin(); while (i != mydeque.end()) { if (*i % 2 == 0) /* Not a good idea to erase inside loop, if you delete last element, mydeque.end() cannot be found resulting in infinite loop */ mydeque.erase(i); i++; } // Printing the deque for (auto it = mydeque.begin(); it != mydeque.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; return 0; } 輸出： 1 3 5 7 9 clear() VS erase()。什麽時候使用什麽？ **clear()**從雙端隊列容器中刪除所有元素，從而使其大小為0。使用clear()函數刪除雙端隊列中的所有元素。 **erase()**另一方麵，“函數”用於從容器中刪除特定元素或從容器中刪除一係列元素，從而通過刪除元素的數量來減小其大小。 ","date":"2021-07-24","objectID":"/2021/07/deque_clear_and_erase/:0:0","tags":["queue","C++"],"title":"deque clear()与erase()用法及示例","uri":"/2021/07/deque_clear_and_erase/"},{"categories":["C++"],"content":"deque insert()用法及示例","date":"2021-07-24","objectID":"/2021/07/deque_insert/","tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque insert()用法及示例 deque::insert(函数是C++中的内置函数，用于在双端队列中插入元素。 insert()函数可以通过三种方式使用： 通过在一个位置插入新元素val来扩展双端队列。 通过在双端队列中插入n个新值val来扩展双端队列。 通过在(first，last)范围内插入新元素来扩展双端队列。 用法: deque_name.insert (iterator position, const value_type\u0026 val); deque_name.insert (iterator position, size_type n, const value_type\u0026 val); deque_name.insert (iterator position, InputIterator first, InputIterator last); 参数 position–指定要插入元素的位置。 val–指定要分配给新插入元素的值。 n–指定要插入的元素数。每个元素都初始化为val的副本。 first, last–指定迭代器，该迭代器指定要插入的元素范围。范围包括first和last之间的所有元素，包括first指向的元素，但last指向的元素。 返回值 该函数返回一个迭代器，该迭代器指向新插入的元素中的第一个。 示例1: // CPP program to illustrate the // deque::insert() function // insert elements by iterator #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; it = dq.insert(it, 10); // 1 10 2 3 4 5  std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 2 3 4 5 示例2: // CPP program to illustrate the // deque::insert() function // program for second syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); // 0 0 1 2 3 4 5  dq.insert(it, 2, 0); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 0 0 1 2 3 4 5 示例3: // CPP program to illustrate the // deque::insert() function // program for third syntax #include \u003cbits/stdc++.h\u003e using namespace std; int main() { deque\u003cint\u003e dq = { 1, 2, 3, 4, 5 }; deque\u003cint\u003e::iterator it = dq.begin(); ++it; vector\u003cint\u003e v(2, 10); // 1 10 10 2 3 4 5  dq.insert(it, v.begin(), v.end()); std::cout \u003c\u003c \"Deque contains:\"; for (it = dq.begin(); it != dq.end(); ++it) cout \u003c\u003c ' ' \u003c\u003c *it; cout \u003c\u003c '\\n'; return 0; } 输出： Deque contains: 1 10 10 2 3 4 5 ","date":"2021-07-24","objectID":"/2021/07/deque_insert/:0:0","tags":["queue","C++"],"title":"deque insert()用法及示例","uri":"/2021/07/deque_insert/"},{"categories":["C++"],"content":"deque 用法与示例","date":"2021-07-24","objectID":"/2021/07/deque/","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 用法与示例 本篇將介紹如何使用 C++ std deque 以及用法與範例，C++ std::deque 是一個雙向佇列(double-ended queue)，在頭尾兩端插入及刪除十分快速，在中間插入刪除元素比較費時。 std::deque 是 double-ended queue 而不是 double linked list，底層實做是用間接索引的方式實現的，類似一個 map 索引到若干個固定大小的資料區塊(連續記憶體空間)，利用兩次索引達成跟 vector 一樣的隨機訪問功能。 以下將依序介紹幾個 std::deque 容器常用的用法範例，分別為 deque 常用功能 範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 範例2. push_back 自定義類別 範例3. 用 for 迴圈遍歷 deque 容器 範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 deque 的優點與缺點 要使用 deque 容器的話，需要引入的標頭檔: \u003cdeque\u003e ","date":"2021-07-24","objectID":"/2021/07/deque/:0:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 常用功能 以下為 std::deque 內常用的成員函式 修改器 push_back: 把一個元素添加到尾端 push_front: 把一個元素插入到頭端 pop_back: 移除最後一個元素(尾端) pop_front: 移除第一個元素(頭端) insert: 插入元素 erase: 移除某個位置元素, 也可以移除某一段範圍的元素 clear: 清空容器裡所有元素 容量 empty: 回傳是否為空 size: 回傳目前長度 元素存取 [i]: 隨機存取索引值為i的元素 back: 取得最後一個元素 front: 取得第一個的元素 迭代器 begin:回傳指向第一個元素(頭端)的迭代器 cbegin:回傳指向第一個元素(頭端)的迭代器(const) end:回傳指向最後一個元素(尾端)的迭代器 cend:回傳指向最後一個元素(尾端)的迭代器(const) rbegin:回傳指向最後一個元素(尾端)的反向迭代器 crbegin:回傳指向最後一個元素(尾端)的反向迭代器(const) rend:回傳指向第一個元素(頭端)的反向迭代器 crend:回傳指向第一個元素(頭端)的反向迭代器(const) ","date":"2021-07-24","objectID":"/2021/07/deque/:1:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例1. 基本的 push_back, pop_front, push_front, pop_back 的用法範例 以下範例為push_back(), pop_front(), push_front(), pop_back() 用法， 其中 push_back() 與 pop_front() 應該是最常用到的函式了。 另外使用 deque 相對於 queue 的好處是deque可以使用隨機訪問的功能 [i]。 std-deque.cpp // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } 輸出內容如下： 0 2 3 4 0 2 3 ","date":"2021-07-24","objectID":"/2021/07/deque/:2:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例2. push_back 自定義類別 以下範例為 std::deque 容器使用 push_back() 來推放 Student 自定義類別的範例，使用 push_back() 來放進 deque 的最尾端，這個範例限制 deque 最多塞3個，多的會用 pop_front() 給 pop 掉，最後再將 deque 容器的所有的元素印出來。 // g++ std-deque2.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; class Student { public: Student(int id) { this-\u003eid = id; } int id; }; std::deque\u003cStudent\u003e d; void deque_push_back(Student a) { d.push_back(a); if (d.size() \u003e 3) { d.pop_front(); } } int main() { Student a1(1), a2(2), a3(3), a4(4); deque_push_back(a1); deque_push_back(a2); deque_push_back(a3); deque_push_back(a4); // 印出 deque 內所有內容, c++11 才支援 for (auto \u0026i : d) { cout \u003c\u003c i.id \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/deque/:3:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例3. 用 for 迴圈遍歷 deque 容器 以下範例是用 for 迴圈配合 deque 容器的迭代器，去遍歷 deque 並且把值印出來，前兩種是從頭印到尾，後兩種是從尾印到頭。從頭端印到最尾端就是使用 begin() 搭配 end() ，從最尾端印到頭端就是使用 rbegin() 搭配 rend() 。 這裡的 begin() / end() 與 cbegin() / cend() 有什麼不同呢？begin() / end() 是回傳 iterator，而 cbegin() / cend() 是回傳 const_iterator，iterator 可以修改元素值，const_iterator 則不可修改，簡單說就是回傳的東西能不能被修改的差異，要用哪種就自行判斷要用哪種了。 cbegin(), cend(), crbegin(), crend() 是 C++11 新增的，要使用時記得編譯器要加入-std=c++11選項。 第一個 for 迴圈裡面的迭代器使用懶人快速寫法auto it = d.begin();，其全名為std::deque\u003cint\u003e::iterator it = d.begin();，如果不想寫這麼長的話，就可以像我一樣用 auto 的懶人快速寫法。 // g++ std-deque3.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 //for (std::deque\u003cint\u003e::iterator it = d.begin(); it != d.end(); ++it) { for (auto it = d.begin(); it != d.end(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從頭到尾 for (auto it = d.cbegin(); it != d.cend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.rbegin(); it != d.rend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; // 從尾到頭 for (auto it = d.crbegin(); it != d.crend(); ++it) { cout \u003c\u003c *it \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; return 0; } 輸出 1 2 3 4 1 2 3 4 4 3 2 1 4 3 2 1 ","date":"2021-07-24","objectID":"/2021/07/deque/:4:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"範例4. 用 while 迴圈在 deque 容器裡搜尋/尋找 以下範例是用 while 迴圈在 deque 容器裡搜尋/尋找數字為3，這裡的 auto 懶人快速寫法如上範例解釋相同就不贅述了。 在 while 迴圈裡如果有找到就印個有找到的訊息，假如整個 while 迴圈都沒找到，最後可以判斷 it == d.end() 代表整個 deque 容器都遍歷過了也沒有找到，就印個沒找到的訊息。 // g++ std-deque4.cpp -o a.out -std=c++11 #include \u003ciostream\u003e #include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // 從頭到尾 int find_num = 3; //std::deque\u003cint\u003e::iterator it = d.begin(); auto it = d.begin(); while (it != d.end()) { if (*it == find_num) { cout \u003c\u003c \"Found \" \u003c\u003c find_num \u003c\u003c endl; break; } it++; } if (it == d.end()) { cout \u003c\u003c \"Not found \" \u003c\u003c find_num \u003c\u003c endl; } return 0; } 輸出 Found 3 如果將 find_num 變數改成 5 去搜尋/尋找的話則會找不到，輸出結果會變成 Not found 5 ","date":"2021-07-24","objectID":"/2021/07/deque/:5:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque 的優點與缺點 deque 的優點 可以再兩端進行 push 和 pop 操作 支持隨機訪問[i] deque 的缺點 佔用記憶體較多 ","date":"2021-07-24","objectID":"/2021/07/deque/:6:0","tags":["queue","C++"],"title":"deque 用法与示例","uri":"/2021/07/deque/"},{"categories":["C++"],"content":"deque和queue容器","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque和queue容器 标准模板库 STL 提供了两种容器：deque 和 queue，以实现和队列类似的数据 结构。deque 是一个双端队列。它类似于矢量，但允许在前端和后端高效地访问值。队列抽象数据类型就像栈抽象数据类型：它实际上是一个容器适配器。 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:0:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"deque容器 可以将 deque 容器想象成一个矢量，但它可以快速访问前端以及后端的元素（和矢量一样，deque 也可以使用 [] 运算符访问元素）。 图 1 deque 成员函数 使用双端队列 ADT 的程序必须包含 deque 头文件。由于本节更关心它与队列类似的特性，所以就来集中讨论一下 push_back、pop_front 和 front 成员函数，如图 1 所示。它们的示例和相应描述如表 2 所示。 成员函数 示例和描述 push_back iDeque.push back(7); 接受一个值作为参数插入到 deque 中。 参数被插入在最后一个元素之后（被推到 deque 后面） pop_front iDeque.pop front(); 删除 deque 的第一个元素并丢弃它 pop_front cout « iDeque.front() « endl; front 返回对 deque 第一个元素的引用 下面的程序演示了双端队列容器的使用： // This program demonstrates the STL deque container. #include \u003ciostream\u003e#include \u003cdeque\u003eu[sin](http://c.biancheng.net/ref/sin.html)g namespace std; int main() { deque\u003cint\u003e iDeque; cout \u003c\u003c \"I will now enqueue items. . . \\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iDeque.push_back(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while (!iDeque.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iDeque.front() \u003c\u003c endl; iDeque.pop_front(); } return 0; } 程序输出结果： I will now enqueue items. . . Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:1:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"queue容器适配器 queue 容器适配器可以建立在矢量、链表或者双端队列的基础上。默认情况下，它使用一个双端队列作为其基础。 queue 支持的插入和删除操作与栈 ADT 所支持的类似：push、pop 和 front。但是，它们的表现有所不同。queue 版本的 push 始终在队列的后面插入一个元素。queue 版本的 pop 始终从结构的前面删除一个元素。front 函数返回队列前面的元素的值。 下面的程序演示了一个队列。由于该队列的声明没有指定适配哪一种类型的容器，所以该队列将建立在一个双端队列上。 //This program demonstrates the STL queue container adapter. #include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int main() { queue\u003cint\u003e iQueue; cout \u003c\u003c \"I will now enqueue items...\\n\"; for (int x = 2; x \u003c 8; x += 2) { cout \u003c\u003c \"Pushing \" \u003c\u003c x \u003c\u003c endl; iQueue.push(x); } cout \u003c\u003c \"I will now dequeue items...\\n\"; while(!iQueue.empty()) { cout \u003c\u003c \"Popping \" \u003c\u003c iQueue.front () \u003c\u003c endl; iQueue.pop (); } return 0; } 程序输出结果： I will now enqueue items… Pushing 2 Pushing 4 Pushing 6 I will now dequeue items… Popping 2 Popping 4 Popping 6 ","date":"2021-07-24","objectID":"/2021/07/deque_and_queue/:2:0","tags":["queue","C++"],"title":"deque和queue容器","uri":"/2021/07/deque_and_queue/"},{"categories":["C++"],"content":"ifndef详解","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef详解 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:0:0","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"ifndef是\"if not defined\"的简写 #ifndef起到的效果是防止一个源文件多次包含同一个头文件, 而不是防止两个源文件包含同一个头文件。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:0","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"一、防止头文件的重复包含和编译 #ifndef \u003c标识\u003e #define \u003c标识\u003e ...... ...... #endif 标识的明明规则一般是头文件名全大写，前面加下划线，并把文件名中的\".“也变成下划线，如：stdio.h #ifndef _STDIO_H #define _STDIO_H ...... ...... #endif ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:1","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"二、便于程序的调试和移植 #ifndef 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #ifndef 标识符 #define 标识符 程序段 1 #else 程序段 2 #endif 它的作用是当“标识符”没有由#define定义过，则编译“程序段1”，否则编译“程序段2”。 #if 表达式 程序段 1 #else 程序段 2 #endif 它的作用是当“表达式”值为真时，编译“程序段1”，否则编译“程序段2”。 注：以上三种形式中#else不是强制的，可省略；当然，当#else后需要嵌套#if时，可以使用预处理命令#elif，它相当于#else#if。 ","date":"2021-07-24","objectID":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/:1:2","tags":["C++"],"title":"ifndef详解","uri":"/2021/07/ifndef%E8%AF%A6%E8%A7%A3/"},{"categories":["C++"],"content":"queue 和 deque的区别","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/","tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue 和 deque的区别 从使用的角度来讲主要差别就是： deque支持push_front、pop_front、push_back、pop_back。 queue支持push_back、pop_front。 deque是双端队列 #include\u003cdeque\u003e template\u003ctypename T,typename Allocator=std::allocator\u003cT\u003e\u003eclass deque; 支持push_front、pop_front、push_back、pop_back等几种操作的。queue是容器适配器，他的声明是 #include\u003cqueue\u003e template\u003ctypename T,typename Container=std::deque\u003cT\u003e\u003eclass queue; 类型Container是用来存储元素的，相当于是这个queue的实现。这个queue模板看起来像是包装了这个Container类型，只提供一些特殊的接口，使他看起来想一个queue。 模板参数Container需要满足顺序容器的条件，而且必须支持front、back、push_back、pop_front操作，标准容器中有deque和list满足。也就是说标准容器中deque和list可以封装成queue。 ","date":"2021-07-24","objectID":"/2021/07/queue_and_deque_dif/:0:0","tags":["queue","C++"],"title":"queue 和 deque的区别","uri":"/2021/07/queue_and_deque_dif/"},{"categories":["C++"],"content":"queue与deque示例","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"queue与deque示例 queue ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:0:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例1：queue #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { queue\u003cint\u003e myQueue; cout \u003c\u003c myQueue.empty() \u003c\u003c endl; cout \u003c\u003c myQueue.size()\u003c\u003c endl; myQueue.push(1); myQueue.push(2); myQueue.push(3); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; myQueue.pop(); cout \u003c\u003c myQueue.front()\u003c\u003cendl; cout \u003c\u003c myQueue.back()\u003c\u003cendl; return 0; } 运行结果： 1 0 1 3 2 3 queue没找到迭代器 deque: deque是双向队列Double ended queue；can be accessed with random access iterator deque是双端队列，是可以在两端扩展和收缩的连续容器。一般deque的实现是基于某种形式的动态数组，允许单个元素用随机获取 迭代器随机读取，数组容量自动管理。 因此它有和vector相似的函数，但在序列的开始也有高效的插入和删除。但不像vector，deque的元素并不是严格连续存储的。 vector和deque有相似的接口和相似的目的，但内部实现截然不同。 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:1:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例二：deque #include \"stdafx.h\"#include \u003ciostream\u003e#include \u003cdeque\u003eusing namespace std; int _tmain(int argc, _TCHAR* argv[]) { deque\u003cint\u003e myDeque; myDeque.push_front(1); myDeque.push_front(2); myDeque.push_back(3); myDeque.push_back(4); myDeque.push_back(5); myDeque.push_front(6); myDeque.pop_back(); deque\u003cint\u003e::iterator myItor; for(myItor=myDeque.begin(); myItor!=myDeque.end(); myItor++) cout\u003c\u003c*myItor\u003c\u003cendl; return 0; } 执行结果： 6 2 1 3 4 ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:2:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"示例3:deque 随机访问 // g++ std-deque.cpp -o a.out -std=c++11 #include \u003ciostream\u003e#include \u003cdeque\u003e using namespace std; int main() { deque\u003cint\u003e d = {1, 2, 3, 4}; // [1, 2, 3, 4] d.push_back(5); // [1, 2, 3, 4, 5] d.pop_front(); // [2, 3, 4, 5] d.push_front(0); // [0, 2, 3, 4, 5] d.pop_back(); // [0, 2, 3, 4] // 印出 deque 內所有內容, c++11 才支援 for (int \u0026i : d) { cout \u003c\u003c i \u003c\u003c \" \"; } cout \u003c\u003c \"\\n\"; cout \u003c\u003c d[0] \u003c\u003c \" \" \u003c\u003c d[1] \u003c\u003c \" \" \u003c\u003c d[2] \u003c\u003c \"\\n\"; return 0; } ","date":"2021-07-24","objectID":"/2021/07/queue_deque_exm/:3:0","tags":["queue","C++"],"title":"queue与deque示例","uri":"/2021/07/queue_deque_exm/"},{"categories":["C++"],"content":"typedef起小名","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/","tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"typedef起小名 C 语言提供了 typedef 关键字，您可以使用它来为类型取一个新的名字。下面的实例为单字节数字定义了一个术语 BYTE： typedef unsigned char BYTE; 在这个类型定义之后，标识符 BYTE 可作为类型 unsigned char 的缩写，例如： BYTE b1, b2; 按照惯例，定义时会大写字母，以便提醒用户类型名称是一个象征性的缩写，但您也可以使用小写字母，如下： typedef unsigned char byte; 您也可以使用 typedef 来为用户自定义的数据类型取一个新的名字。例如，您可以对结构体使用 typedef 来定义一个新的数据类型名字，然后使用这个新的数据类型来直接定义结构变量，如下： 实例 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e typedef struct Books { char title[50]; char author[50]; char subject[100]; int book_id; } Book; int main( ) { Book book; strcpy( book.title, \"C 教程\"); strcpy( book.author, \"Runoob\"); strcpy( book.subject, \"编程语言\"); book.book_id = 12345; printf( \"书标题 : %s\\n\", book.title); printf( \"书作者 : %s\\n\", book.author); printf( \"书类目 : %s\\n\", book.subject); printf( \"书 ID : %d\\n\", book.book_id); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： 书标题 : C 教程 书作者 : Runoob 书类目 : 编程语言 书 ID : 12345 typedef vs #define #define 是 C 指令，用于为各种数据类型定义别名，与 typedef 类似，但是它们有以下几点不同： typedef 仅限于为类型定义符号名称，#define 不仅可以为类型定义别名，也能为数值定义别名，比如您可以定义 1 为 ONE。 typedef 是由编译器执行解释的，#define 语句是由预编译器进行处理的。 下面是 #define 的最简单的用法： 实例 #include \u003cstdio.h\u003e #define TRUE 1 #define FALSE 0 int main( ) { printf( \"TRUE 的值: %d\\n\", TRUE); printf( \"FALSE 的值: %d\\n\", FALSE); return 0; } 当上面的代码被编译和执行时，它会产生下列结果： TRUE 的值: 1 FALSE 的值: 0 ","date":"2021-07-24","objectID":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/:0:0","tags":["C++"],"title":"typedef起小名","uri":"/2021/07/typedef%E8%B5%B7%E5%B0%8F%E5%90%8D/"},{"categories":["C++"],"content":"常用头文件","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/","tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"常用头文件 stdafx.h MFC预编译 stdio.h 输入输出 process.h 进程 stdlib.h 声明了数值与字符串转换函数, 伪随机数 生成函数, 动态内存分配函数, 进程控制函数等公共函数 Windows.h windows系统函数(如:Sleep) string.h ANSI,多字节字符串 wchar.h Unicode,宽字符串 tchar.h 混合ANSI和Unicode字符串 ","date":"2021-07-24","objectID":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/:0:0","tags":["C++"],"title":"常用头文件","uri":"/2021/07/%E5%B8%B8%E7%94%A8%E5%A4%B4%E6%96%87%E4%BB%B6/"},{"categories":["C++"],"content":"笔记queue与deque","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/","tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["C++"],"content":"笔记queue与deque queue操作： queue\u003cint\u003eq; //创建一个int型空队列q q.empty(); //判断队列是否为空，为空返回true q.push(s); //将变量s从队尾入队 q.pop(); //将队头元素弹出 q.front(); //只返回队头元素 q.back(); //只返回队尾元素 q.size(); //返回队列中元素个数 queue两端访问,队尾插入,队首删除。 deque操作： deque\u003cint\u003e dq; //创建一个数双端队列dq dq.empty(); //判断队列是否为空，为空返回true dq.push_front(s);//将s从队头入队 dq.push_back(s);//将s从队尾入队，和普通队列方式一样 dq.front(); //只返回队头元素 dq.back(); //只返回队尾元素 dq.pop_front(); //将队头元素弹出 dq.pop_back(); //将队尾元素弹出 dq.size(); //返回队列中元素个数 dq.clear(); //将队列清空 dq.insert();//插入新元素,最多有四个参数 //迭代器 dq.begin(); //回傳指向第一個元素(頭端)的迭代器 dq.cbegin(); //回傳指向第一個元素(頭端)的迭代器(const) dq.end(); //回傳指向最後一個元素(尾端)的迭代器 dq.cend(); //回傳指向最後一個元素(尾端)的迭代器(const) dq.rbegin(); //回傳指向最後一個元素(尾端)的反向迭代器 dq.crbegin(); //回傳指向最後一個元素(尾端)的反向迭代器(const) dq.rend(); //回傳指向第一個元素(頭端)的反向迭代器 dq.crend(); //回傳指向第一個元素(頭端)的反向迭代器(const) deque两端访问,两端插入,两端删除。 auto it = d.begin();其全名為std::deque\u003cint\u003e::iterator it = d.begin(); ","date":"2021-07-24","objectID":"/2021/07/note_queue_and_deque/:0:0","tags":["queue","C++"],"title":"笔记queue与deque","uri":"/2021/07/note_queue_and_deque/"},{"categories":["WOW"],"content":"64位Call的参数","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"64位Call的参数 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:0:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call上层 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+20+8_0 参数5 rsp+20+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:1:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["WOW"],"content":"call内 参数1 rcx ecx cx 参数2 rdx edx dx 参数3 r8 r8d 参数4 r9 r9d 参数5 rsp+28+8_0 参数5 rsp+28+8_1 ","date":"2021-07-23","objectID":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/:2:0","tags":["WOW"],"title":"64位Call的参数","uri":"/2021/07/64%E4%BD%8Dcall%E7%9A%84%E5%8F%82%E6%95%B0/"},{"categories":["C++"],"content":"cin和cout输入输出","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"cin和cout输入输出 简单的输入输出代码示例： #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number:\"\u003c\u003cendl; cin\u003e\u003ex; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"Please input a float number:\"\u003c\u003cendl; cin\u003e\u003ey; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果如下（↙表示按下回车键）： Please input an int number: 8↙ The int number is x= 8 Please input a float number: 7.4↙ The float number is y= 7.4 cin 连续输入示例 #include\u003ciostream\u003eusing namespace std; int main(){ int x; float y; cout\u003c\u003c\"Please input an int number and a float number:\"\u003c\u003cendl; cin\u003e\u003ex\u003e\u003ey; cout\u003c\u003c\"The int number is x= \"\u003c\u003cx\u003c\u003cendl; cout\u003c\u003c\"The float number is y= \"\u003c\u003cy\u003c\u003cendl; return 0; } 运行结果： Please input an int number and a float number: 8 7.4↙ The int number is x= 8 The float number is y= 7.4 ","date":"2021-07-23","objectID":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"cin和cout输入输出","uri":"/2021/07/cin%E5%92%8Ccout%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"class 类","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/","tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["C++"],"content":"class 类 #include \u003cstdio.h\u003e//通过class关键字类定义类 class Student{ public: //类包含的变量 char *name; int age; float score; //类包含的函数 void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; int main(){ //通过类来定义变量，即创建对象 class Student stu1; //也可以省略关键字class //为类的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; //调用类的成员函数 stu1.say(); return 0; } 类也是一种构造类型，但是进行了一些扩展，类的成员不但可以是变量，还可以是函数；通过类定义出来的变量也有特定的称呼，叫做“对象” ","date":"2021-07-23","objectID":"/2021/07/class%E7%B1%BB/:0:0","tags":["C++"],"title":"class 类","uri":"/2021/07/class%E7%B1%BB/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 搭建教程 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"如何使用 GitHub pages 首先你需要注册一个 GitHub 账号，并在个人主界面里选择创建一个新的 Repository 。 进入页面后，在 Repository name 的位置填写域名，格式是 username.GitHub.io。 创建成功之后，点击右上角的 Settings 找到 GitHub Pages 选项，选择一个 GitHub 官方提供的主题 这里我们就随意选择一个主题 Cayman，来看看他的效果是什么样的 选择完毕之后 GitHub Pages 就会自动帮你生成好网站，在他跳转的界面点击 Commit changes 按钮，网站就可以访问了。 在浏览器里输入你的项目名称，比如 brick713.GitHub.io，就可以看到，你刚刚选择的主题的个人网站的页面了。 到这里如果你只是想做一个例如可以随时在互联网上访问的简历，那么你只需要 GitHub Pages 项目的主页修改你 index.md 文件就可以了，比如我给出的这个模板。 修改完后，点击上图中左下角的 Commit Changes，然后访问你的自定义域名你就可以看到如下的样式了。 如果你想做一个功能更丰富的博客，那我们继续往下走。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"配置自定义域名并免费使用 HTTPS 在 2018 年 5 月 1 日之后，GitHub Pages 已经开始提供免费为自定义域名开启 HTTPS 的功能，并且大大简化了操作的流程，现在用户已经不再需要自己提供证书，只需要将自己的域名使用 CNAME 的方式指向自己的 GitHub Pages 域名即可。 首先在你的 DNS 解析里添加一条解析记录，例如我选择添加子域名 blog.moyu.life 通过 CNAME 的方式指向我刚刚自定义的 GitHub Pages 域名 brick713.GitHub.io。添加完成后等待 DNS 解析的生效（DNS 的解析记录生效到全球可能需要几分钟时间）。 之后重新回到最开始进入过的 Settings 界面，找到 GitHub Pages 的设置，填写我们刚刚建立的子域名，以我自己的 blog.moyu.life 举例，点击保存。 保存后 GitHub 需要一定的时间生成证书并确认域名的解析是否正常，我们只需要耐心的等待即可，成功后显示结果如下 现在我们再访问 blog.moyu.life 就会发现，我们的自定义域名和 HTTPS 都生效了！可以看到证书是由著名的机构 Let’s Encrypt 提供的。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:1","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"网站的同步 现在我们已经有了一个基本功能健全的网站了，接下来我们需要试着对博客的内容进行管理，并且给博客添加一些更个性化的设置，官方提供两种方式： 命令行方式（Mac 和 Windows 确保拥有 Git 环境） 桌面客户端形式（需要安装官方提供的客户端） 如果你没有任何 Git 的基础，也不想进行一些繁琐的配置，那么我推荐你使用桌面客户端的形式进行管理，如果你有一定的技术基础，那么 Git 的方式则更适合你。这里我两种方法都介绍一下。 首先在命令行中切换到你自定义的路径下，然后 Clone 下来你的项目（操作需要在 Mac 的 Terminal 中完成，Windows 系统可以使用 Git-bash。）这里注意这里的 path 和 username 需要根据你个人情况进行替换。 cd ~/Path git clone https://GitHub.com/username/username.GitHub.io 接着进入你的项目的文件中，并创作一个文章。 cd username.GitHub.io echo \"Hello World 我爱这个世界\" \u003e index.md 然后按照 Git 提交内容的流程，将我们的新创作的文章上传。 git add --all git commit -m \"Firs Push\" git push -u origin master 这里可能会碰到下面的情况： 按照他的提示我们把注册 GitHub 的邮箱和用户名依次输入即可： git config user.email \"你的邮箱\" git config user.name \"你的用户名\" 之后他可能会让你输入你的 GitHub 账号和密码，不用担心，正常输入即可。当我们看到这样的提升就证明提交成功了。 可以去我们的网站主页看看是不是起了变化。 如果你是使用GitHub 桌面客户端 那么就更简单了，下载安装了客户端之后，按照客户端的提示正常登陆你的 GitHub 账号。然后 Clone 下来你的 GitHub Pages 项目。 等待 Clone 完成后，界面上会显示几种管理修改你的项目的方式。 这里我选择使用 Sublime Text 进行管理，把开始的 index.md 里的内容改为 Hello World 我也爱这个世界 保存，然后在客户端上我们能看到文件的变化，我们先点击左下角的 Commit to master，再点击 Fetch origin 就可以将内容上传。 然后你发现你的主页也发生了相应改变了。到这里你基本上就掌握了网站管理的基本流程和文章发布的基本流程，下面我们要开始来学会使用静态模板系统来管理博客了。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:2","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"GitHub Pages 的生成工具 经历了上面的步骤，现在你的已经有了一个简单的页面了，可是他还远远未满足我们的需求，我们需要利用静态模板系统来让生产接管你博客的文章的生成，让你把更多的经历投入在创作里。下面就 GitHub 官方推荐的 Jekyll 为例子来展开讲讲。 因为 Jekyll 是基于 Ruby 的静态网页生成系统，因此我们首先得安装 Ruby 环境，在 Mac 下我们可以使用的 Homebrew 来进行安装。如果是其他操作系统，可以去参考 Ruby 官方安装文档进行安装。 brew install ruby command not found: brew问题解决方案 安装brew /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 看到==\u003e Installation successful!就说明安装成功了。 最后更新下： brew update 等 Ruby 安装完毕后再执行以下命令完成 Jekyll 的安装。 sudo gem install jekyll bundler 然后进入你 Clone 下来的 GitHub Pages 项目的路径 cd /Volumes/video/GitHub/xinqinew.github.io 执行以下命令： jekyll new . --force 完成后，Jekyll 会在你指定的目录下生成好所有文件，你可以使用 bundle exec jekyll serve 命令，然后就可以通过访问 127.0.0.1:4000 查看初始界面的样子了。 默认的界面看起来非常的简陋也很丑，但是没关系，你可以在这些网站里根据自己的喜好找到一些美观的主题http://jekyllthemes.org/、https://jekyllthemes.io/、http://themes.jekyllrc.org/。 安装方法很简单，一般情况下只需要下载主题包解压后完整的，复制到你的 GitHub Pages 的项目目录里，并覆盖你之前的文件即可，有些特殊的主题要参考作者给的安装步骤，这里我随意的更换了一个主题。 主题里的所有关键性配置都在 _config.yml 文件中，你可以根据个人的喜好和不同主题支持的功能来修改具体的内容，这里就不做展开。 到这里完整的搭建的流程已经结束了，你已经可以正常访问你一路配置下来的博客了，接下来你只需要找一个趁手的 Markdown 编辑器来编辑在你本地 GitHub Pages 项目中的 _posts 文件夹里的文章，并使用前面提到的两种方式将文章同步到 GitHub 上即可。需要注意的是，文章的内容和标题需要按照 Jekyll 的格式进行写作。 文章的文件名遵循下面的格式： 年-月-日-标题.markdown 文章内容顶部必须有下面的 YAML 头信息： --- layout: post title: Blogging Like a Hacker --- ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:3","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"尾巴 其实除了 Jekyll 还有非常多的第三方的静态模板系统来搭建 GitHub Pages。比如： Node.js 编写的 Hexo Go 编写的 Hugo Python 编写的 Pelican 以及更人性化的 Gridea 他们在各自的基础上实现了更多的功能，比如分析统计、搜索、评论系统、广告、分享系统等。喜欢折腾的同学不妨可以尝试尝试，未来如果有机会希望能更详细的给大家分享一下。 ","date":"2021-07-23","objectID":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","tags":["GitHub","博客"],"title":"GitHub Pages 搭建教程","uri":"/2021/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["GitHub"],"content":"Github汉化及常用插件","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"Github汉化及常用插件 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:0:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"插件 Sourcegraph Sourcegraph 可以让你在线学习代码，可以查看变量、函数等的定义和引用情况。把指针放到想查看的变量名上，它会自动显示寻找定义和引用的提示框，点击即可。 Octotree 查看整个项目的结构 油猴 Refined GitHub ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:1:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["GitHub"],"content":"汉化 桌面版一键汉化 下载版 chrome版汉化 GitHub那些事儿 Hexo + GitHub Pages 搭建博客 ","date":"2021-07-23","objectID":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/:2:0","tags":["GitHub"],"title":"Github汉化及常用插件","uri":"/2021/07/github%E6%B1%89%E5%8C%96%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6/"},{"categories":["Markdown"],"content":"Markdown语法","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"GitBook默认使用Markdown语法。 下面这些可以作为一个快速参考和展示。更多完整的信息，请参考 John Gruber’s original spec 和 Github-flavored Markdown info page。 标题 H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:0:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H2 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"H3 H4 H5 H6 对于H1和H2，有下划线样式可供选择： Alt-H1 ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:1:1","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["Markdown"],"content":"Alt-H2 强调 强调，又叫做斜体，使用 星号 或 下划线。 重点强调，又叫做粗体，使用 星号 或 下划线。 使用 **星号和_下划线_** 组合使用强调。 删除线使用两个波浪线。划掉这个 列表 在这个例子中，前导空格和尾部空格显示为圆点 : ⋅) 有序列表的第一项 另外一个项 ..* 无序子列表 事实上序号不起作用，那只是一个数字而已 ..1. 有序子列表 最后一个项 …你可以适当的缩紧列表项中的段落。注意上面的空行和前导空格（至少一个，但是这里我们使用三个来对齐原始的Markdown内容）。 …换行而不形成段落，你需要使用两个尾部空格。.. …注意这行是分开的，但还在同一个段落中。.. …（这个违背了不需要尾部空格的典型的GFM换行行为）。 无序列表可以使用星号 或者减号 或者加号 链接 有两种创建链接的方式。 内嵌式链接 带标题的内嵌式链接 引用式链接 相对引用一个库文件 你可以在引用式链接定义中使用数字 或者空着什么都不写 link text itself 用来说明引用链接的文字可以放在后面。 脚注 Markdown默认使用的脚注样式链接不会在页面中显示。有时包含一个读者可见的非超链接注脚很有用。对于这样的注脚，GitBook支持的一种简单的语法。 Text prior to footnote reference.1 这是我们的logo（停留查看标题） 内嵌式 Logo Title Text 1alt text \" Logo Title Text 1 引用式 Logo Title Text 2alt text \" Logo Title Text 2 代码和语法高亮 代码块是Markdown规范的一部分，但是语法高亮不是。然而，很多渲染器，比如GitHub的和这里的Markdown，都支持语法高亮。支持那种语言以及语言的名字应该怎样写随渲染器的不同而变化。这里的Markdown支持许语言；查看完整的列表，以及如何写语言的名字，请参考 highlight.js 演示页. 内嵌 代码 有 反引号 包含它. 代码块要么被包含三个反引号 ``` 的行包围，要么被四个空格缩进。推荐仅仅使用被包围的代码块，它们使用方便并且只有它们支持语法高亮。 var s = \"JavaScript语法高亮\"; alert(s); s = \"Python语法高亮\" print s 没有指明语言，所有没有语法高亮。 让我们随便写个标签试试 \u003cb\u003etag\u003c/b\u003e 表格 表格不是Markdown规范的核心部分，但是它是GFM的一部分，这里的Markdown也支持它。 冒号可以用来对其列。 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 The outer pipes (|) are optional, and you don’t need to make the raw Markdown line up prettily. You can also use inline Markdown. 外部的管道符 (|) 是可选的，而且不需要优雅的排列Markdown。你还可以在表格中内嵌其他Markdown。 Markdown Less Pretty Still renders nicely 1 2 3 块引用 在邮件中块引用中很方便用来仿真文本的回复。 这行是同一个块的一部分。 引用结束 当这行很长的文字被包裹的时候，它依然会被恰当的引用。让我们继续写下去来确保包裹它时对于每个人来说它足够长。你可以在块引用中使用其它Markdown。 内嵌HTML You can also use raw HTML in your Markdown, and it’ll mostly work pretty well. 你同样可以在Markdown中使用HTML，并且它能很好的工作。 Definition list Is something people use sometimes. Markdown in HTML Does *not* work **very** well. Use HTML tags. 水平线 三个或者更多… 连字符 星号 下划线 换行符 关于学习换行符是如何工作的，我的建议是去亲身实践并总结 – 敲击 键一次（也就是插入一个换行符），然后再敲击它两次（也就是插入两个换行），看一下发生了什么。不久你就能学会它。“Markdown Toggle” 是你的朋友。 这里有一些东西可以尝试一下： 我们以这行作为开始。 This line is separated from the one above by two newlines, so it will be a separate paragraph. 这行与上面那行被两个换行符分隔，所以它会成为一个 单独的段落。 This line is also a separate paragraph, but… This line is only separated by a single newline, so it’s a separate line in the same paragraph. 这行同样是一个单独的段落，但是… 这行仅仅被一个换行符分隔，所以它是一个在 同一段落 中的单独的行。 Youtube视频 视频不能被直接添加，但你可以添加一个链接至视频的图片，像这样： 或者，使用纯Markdown，但是会丢失掉图片的大小和边框： Comment to include in footnote. 图片 ↩︎ ","date":"2021-07-23","objectID":"/2021/07/markdown%E8%AF%AD%E6%B3%95/:2:0","tags":["Markdown"],"title":"Markdown语法","uri":"/2021/07/markdown%E8%AF%AD%E6%B3%95/"},{"categories":["C++"],"content":"namespace 命名空间","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"namespace 命名空间 namespace 是C++中的关键字，用来定义一个命名空间，语法格式为： namespace name{ //variables, functions, classes } name是命名空间的名字，它里面可以包含变量、函数、类、typedef、#define 等，最后由{ }包围。 namespace Li{ //小李的变量定义 FILE fp = NULL; } namespace Han{ //小韩的变量定义 FILE fp = NULL } Li::fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using Li::fp; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han :: fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp using namespace Li; fp = fopen(\"one.txt\", \"r\"); //使用小李定义的变量 fp Han::fp = fopen(\"two.txt\", \"rb+\"); //使用小韩定义的变量 fp #include \u003cstdio.h\u003e//将类定义在命名空间中 namespace Diy{ class Student{ public: char *name; int age; float score; public: void say(){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", name, age, score); } }; } int main(){ Diy::Student stu1; stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5f; stu1.say(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","tags":["C++"],"title":"namespace 命名空间","uri":"/2021/07/namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"printf输出","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"printf输出 函式原型： int printf ( const char * format, … ); 引數說明： %[flags][width][.precision][length]specifier %[旗標][寬度][.精度][長度修飾]資料型態 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:0:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"1. 資料型態 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 必填欄位 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.1) 字元/字串 %c, %C : 字元, char c; %s : 字元陣列, char buffer[MAX_PATH]; %S : 字元陣列(Unicode), wchar buffer[MAX_PATH]; [註] %C / %S 並未被收在標準函式庫裡，屬 MSVC 特殊支援。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:1","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.2) 整數 %d, %i : 10進制整數 , int x; [lemma] %u : 10進制無號數, unsigned int x; %o : 8進制無號數, unsigned int x; %x, %X : 16進制無號數, 小寫x輸出為\"abcdef\", 大寫 X 輸出為 \"ABCDEF\", unsigned x; %lld, %I64d : long long int, __int64 輸出型態 (註：vc6.0 下只有 __int64，沒有long long int) %llu, %I64u : unsigned long long int 輸出型態 [lemma] %d : dec; %i : integer，於 scanf 時有部份差異 (%d 只接受10進位, %i 可接受指定進位，如 0x23, 045)，但於 printf 時 %d, %i 並無顯著差異 (感謝 Jacob Lee 補充指導) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:2","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.3) 浮點數 %e, %E : 浮點數使用科學符號表示之,指數將帶正負號, float x,doubley; %f : 單精度浮點數(預設輸出精度6位), float x; (註 : 對 printf 而言, %f/%lf 可適用於 double / float) %lf : 倍精度浮點數(預設輸出精度6位), double x; %llf, %LF : 雙倍精度浮點數(預設輸出精度6位), long double x; %g, %G : 由系統決定是否採科學符號表示。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:3","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.4) 特殊 原創：edisonx.pixnet.net %p : 變數位置。 ex: int a=0, printf(\"%p\", \u0026a); 即 printf(\"%08x\", \u0026a); %n : 輸出至緩衝區之長度, ex: char str[]=\"test\", int len, printf(\"%s%n\", a, \u0026len); 輸出4bytes,len = 4 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:4","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"(1.5) C99新增 \u003c 建議 k spec. 最清楚 \u003e (註 : C99 新增了一些資料型態在 inttypes.h / stdint.h 裡面，有興趣搜尋 n1256.pdf 下載下來 K 標準， in section 7.8 。當然 MSVC 不支援 C99 是眾所皆知的事。) 部份原則還是掌握了 %i, %u, %d, %x，另由於這部份在 printf 會顯得很亂，故直接做範例對應。掌握一原則：新的資料型態在 printf 前三個字母一定是 PRI。 “%” PRIdN , “%” PRIiN: 以十進位有號數顯示 intN_t 系列之數值。ex : int8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRId8 \" \\n\", i8); int8_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIi16 \" \\n\", i16); int8_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRId32 \" \\n\", i32); int8_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIi64 \" \\n\", i64); 另上述將 PRIdN / PRIiN ，換成 PRIoN / PRIuN / PRIxN / PRIXN ，便可轉對 uintN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdLEASTN , “%” PRIiLEASTN: 以十進位有號數顯示 int_leastN_t 系列之數值。ex : int_least8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdLEAST8 \" \\n\", i8); int_least16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiLEAST16 \" \\n\", i16); int_least32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdLEAST32 \" \\n\", i32); int_least64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiLEAST64 \" \\n\", i64); 另上述將 PRIdLEASTN / PRIiLEASTN ， 換成 PRIoLEASTN/ PRIuLEASTN/ PRIxLEASTN/ PRIXLEASTN， 便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 \"%\" PRIdFASTN , \"%\" PRIiFASTN: 以十進位有號數顯示 int_fastN_t 系列之數值。ex : int_fast8_t i8 = 8 ; \u003c----\u003e printf( \"i8 = %\" PRIdFAST8 \" \\n\", i8); int_fast16_t i16 = 16 ; \u003c----\u003e printf( \"i16= %\" PRIiFAST16 \" \\n\", i16); int_fast32_t i32 = 32 ; \u003c----\u003e printf( \"i32= %\" PRIdFAST32 \" \\n\", i32); int_fast64_t i64 = 64 ; \u003c----\u003e printf( \"i64= %\" PRIiFAST64 \" \\n\", i64); 另上述將 PRIdFASTN / PRIiFASTN ，換成 PRIoFASTN/ PRIuFASTN/ PRIxFASTN/ PRIXFASTN，便可轉對 uint_leastN_t 資料型態做輸出，分別為 ( 8 進位、10進位、16進位小寫、16進位大寫)，有空自己試試，不贅述。 “%” PRIdMAX , “%” PRIdPTR : 分別顯示整數最大值與指標型態。 [註 : 特別注意 inttypes.h 裡面之型態，printf 引數和 scanf 引數差很多，一樣掌握一原則，新的資料型態在 scanf 前三個字母一定是 SCN， 如 intN_t 系列，scanf 用的是 “%” SCNdN / “%” SCNiN ； uintN_t 系列，scanf 用的是 “%” SCNoN / “%” SCNuN / “%” SCNxN / “%” SCNXN ； int_fastN_t / int_leastN_t 等系列資料型態便不贅述。 ) ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:1:5","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"2. 寬度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位net %m : 指定輸出之寬度。ex: int a=2, b=10; printf(\"%d%5d\", a, b); 輸出為 \"2 10\" (2與10之間有3個空白，因10為5個文字寬度)。 %* : 以引數方式代入指定輸出之寬度。ex: int a=2, width=10; printf(\"%*d\",width, a); 輸出為 \" 2\" (10個文字寬度)。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:2:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"3. 長度修飾 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %h : 將數字視為 short int (%hd) 或 unsigned int (%hu), 此修飾只對整數型態之 %hi, %hd, %ho, %hu, %hx, %hX 有效。 且針對 char 可用 %hhd，unsigned char 可用 %hhu。 (註 : MSVC 認得 %hd / %hu / %hhd / %hhu , 但在 gcc 下會發出認不得的警告 ) %l : 將數字視為 long int (%ld) 或 unsigned long int (%lu), 此修飾只對整數型態之 %li, %ld, %lo, %lu, %lx, %lX 有效。 %L : 此修飾只對浮點數型態之 long double 有效, 可用於修飾 %Le, %LE, %Lf, %Lg, %LG。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:3:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"4. 精度 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %.n : 欲輸出小數點後幾位數,即顯示之精度,此修飾只對浮點數資料型態有效(f,F,e,E,g), 若使用其它整數型態 (i, d, o, u, x, X) 則將 n 視為 0, 即不輸出小數位數。ex: double a=2.1234, printf(\"%.2lf\", a); 輸出則為 \"2.12\" 。 %.* : 和 %.n 相似，但其 n 值可用變數引入。ex: double a=1.3456, int preci=2, printf(\"%.*lf\",preci, a); 輸出則為 \"1.35\" 。 %m.n: 這是寬度和精度合用之方法, 代表輸出會有小數點後 n 位， 且整個輸出文字寬 m 個字(包含小數點、正負號及數字)。ex: double c = -102.34567, printf(\"%10.3lf\", c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 %*.*: 和上一說明一樣, 但寬度與精度可用引數決定。ex: double c = -102.34567, int m=10, int n=3; printf(\"%*.*lf\", m, n, c); 結果會輸出 \" -102.346\" ，前面將會保留二個空白，使得整體寬度為 10 。 ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:4:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"5. 旗標 ( %[旗標][寬度][.精度][長度修飾]資料型態 ) 選填欄位 %- : 原本輸出預設為向右對齊，使用後輸出向左對齊, 需與[寬度]配合使用。ex: char buf[] = \"Test\"; printf(\"%-10s\"); 輸出結果為 \"Test \"， Test 後面將保留6個空白。 %+ : 需為數值型之資料型態，強制輸出正負號，可與 '-' 旗標合用。 ex: double a = 3.4567: printf(\"%-+8.2lf\", a); // '-'使輸出靠左對齊, '+'強調輸出正負號, 整體寬度為8, 小數點顯示2位。 輸出結果為 \"+3.46 \" %0 : 若輸出之左半部為空白處, 則進行補0, (所以這不能和 '-' 合用) ex: unsigned int x = 122; printf(\"%05u\", x); // 寬度為5, 前半空白補零 輸出結果為 \"00122\" %# : 對進制加上前綴符號, 只對 %o, %x 有用, %#o為8進制,前綴符號為 0, %#x為16進制,前綴符號為 0x, %#X前綴符號則為 0X。ex: unsigned int a = 15; printf(\"%u %#o %#X\", a, a, a); 輸出結果為 \"15 017 0XF\" %(空白): 若數字為正號, 則會在該數字前面加上一空白，(故不可與 ‘+’ 合用)。 ex: int a=10; printf(\"% -5d\"); // 寬度5, 向左對齊, 保留正號位置 輸出結果為 \" 10 \" ","date":"2021-07-23","objectID":"/2021/07/printf%E8%BE%93%E5%87%BA/:5:0","tags":["C++"],"title":"printf输出","uri":"/2021/07/printf%E8%BE%93%E5%87%BA/"},{"categories":["C++"],"content":"queue用法详解","date":"2021-07-23","objectID":"/2021/07/queue/","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue用法详解 只能访问 queue 容器适配器的第一个和最后一个元素。只能在容器的末尾添加新元素，只能从头部移除元素。 许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。对于任何需要用 FIFO 准则处理的序列来说，使用 queue 容器适配器都是好的选择。 图 1 展示了一个 queue 容器及其一些基本操作： 图 1 queue容器 queue 的生成方式和 stack 相同，下面展示如何创建一个保存字符串对象的 queue: std::queue\u003cstd::string\u003e words; 也可以使用拷贝构造函数： std::queue\u003cstd::string\u003e copy_words {words}; // A duplicate of words stack、queue 这类适配器类都默认封装了一个 deque 容器，也可以通过指定第二个模板类型参数来使用其他类型的容器： std::queue\u003cstd::string, std::list\u003cstd::string\u003e\u003ewords; 底层容器必须提供这些操作：front()、back()、push_back()、pop_front()、empty() 和 size()。 ","date":"2021-07-23","objectID":"/2021/07/queue/:0:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 操作 queue 和 stack 有一些成员函数相似，但在一些情况下，工作方式有些不同： front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T\u0026 obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T\u0026\u0026 obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 emplace()：用传给 emplace() 的参数调用 T 的构造函数，在 queue 的尾部生成对象。 swap(queue \u0026other_q)：将当前 queue 中的元素和参数 queue 中的元素交换。它们需要包含相同类型的元素。也可以调用全局函数模板 swap() 来完成同样的操作。 queue 模板定义了拷贝和移动版的 operator=()，对于所保存元素类型相同的 queue 对象，它们有一整套的比较运算符，这些运算符的工作方式和 stack 容器相同。 和 stack 一样，queue 也没有迭代器。访问元素的唯一方式是遍历容器内容，并移除访问过的每一个元素。例如： 1. std::deque\u003cdouble\u003e values {1.5, 2.5, 3.5, 4.5}; std::queue\u003cdouble\u003e numbers(values); 2. 3. while (!numbers, empty()) 4. { 5. std ::cout \u003c\u003c numbers. front() \u003c\u003c \" \"; // Output the 1st element 6. numbers. pop(); // Delete the 1st element 7. } 8. std::cout \u003c\u003c std::endl; 用循环列出 numbers 的内容，循环由 empty() 返回的值控制。调用 empty() 可以保证我们能够调用一个空队列的 ftont() 函数。如代码所示，为了访问 queue 中的全部元素，必须删除它们。如果不想删除容器中的元素，必须将它们复制到另一个容器中。如果一定要这么操作，我们可能需要换一个容器。 ","date":"2021-07-23","objectID":"/2021/07/queue/:1:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"queue 容器的实际使用 这里汇集了一些使用 queue 容器的示例。这是一个用 queue 模拟超市运转的程序。结账队列的长度是超市运转的关键因素。它会影响超市可容纳的顾客数——因为太长的队伍会使顾客感到气馁，从而放弃排队。在很多情形中——医院可用病床数会严重影响应急处理设施的运转，也会产生同样的队列问题。我们的超市模拟是一个简单模型，灵活性有限。 可以在头文件 Customer.h 中定义一个类来模拟顾客： 1. // Defines a customer by their time to checkout 2. #ifndef CUSTOMER_H 3. #define CUSTOMER_H 4. 5. class Customer 6. { 7. protected: 8. size_t service_t {}; // Time to checkout 9. public: 10. explicit Customer(size_t st = 10) :service_t {st}{} 11. 12. // Decrement time remaining to checkout 13. Customer\u0026 time_decrement() 14. { 15. if (service_t \u003e 0) 16. --service_t; 17. return *this; 18. } 19. bool done() const { return service_t == 0; } 20. }; 21. #endif 这里只有一个成员变量 service_t，用来记录顾客结账需要的时间。每个顾客的结账时间都不同。每过一分钟，会调用一次 time_decrement() 函数，这个函数会减少 service_t 的值，它可以反映顾客结账所花费的时间。当 service_t 的值为 0 时，成员函数 done() 返回 true。 超市的每个结账柜台都有一队排队等待的顾客。Checkout.h 中定义的 Checkout 类如下： 1. // Supermarket checkout - maintains and processes customers in a queue 2. #ifndef CHECKOUT_H 3. #define CHECKOUT_H 4. #include \u003cqueue\u003e // For queue container 5. #include \"Customer.h\" 6. 7. class Checkout 8. { 9. private: 10. std::queue\u003cCustomer\u003e customers; // The queue waiting to checkout 11. public: 12. void add(const Customer\u0026 customer) { customers.push(customer); } 13. size_t qlength() const { return customers.size(); } 14. 15. // Increment the time by one minute 16. void time_increment() 17. { 18. if (!customers.empty()) 19. { // There are customers waiting... 20. if (customers.front().time_decrement().done()) // If the customer is done... 21. customers.pop(); // ...remove from the queue 22. } 23. }; 24. 25. bool operator\u003c(const Checkout\u0026 other) const { return qlength() \u003c other.qlength(); } 26. bool operator\u003e(const Checkout\u0026 other) const { return qlength() \u003e other.qlength(); } 27. }; 28. #endif 这相当于自我解释。queue 容器是 Checkout 唯一的成员变量，用来保存等待结账的 Customer 对象。成员函数 add() 可以向队列中添加新顾客。只能处理队列中的第一个元素。 每过一分钟，调用一次 Checkout 对象的成员函数 time_increment(}，它会调用第一个 Customer 对象的成员函数 time_decrement() 来减少剩余的服务时间，然后再调用成员函数 done()。如果 done() 返回 true，表明顾客结账完成，因此把他从队列中移除。Checkout 对象的比较运算符可以比较队列的长度。 为了模拟超市结账，我们需要有随机数生成的功能。因此打算使用 random 头文件中的一个非常简单的工具，但不打算深入解释它。我们会在教程后面的章节深入探讨 random 头文件中的内容。程序使用了一个 uniform_int_distribution() 类型的实例。顾名思义，它定义的整数值在最大值和最小值之间均匀分布。在均匀分布中，所有这个范围内的值都可能相等。可以在 10 和 100 之间定义如下分布： std::uniform_int_distribution\u003c\u003e d {10, 100}; 这里只定义了分布对象 d，它指定了整数值分布的范围。为了获取这个范围内的随机数，我们需要使用一个随机数生成器，然后把它作为参数传给 d 的调用运算符，从而返回一个随机整数。 random 头文件中定义了几种随机数生成器。这里我们使用最简单的一个，可以按如下方式定义： std::random_device random_number_engine; 为了在 d 分布范围内生成随机数，我们可以这样写： auto value = d(random_number_engine); // Calls operator()() for d value 的值在 d 分布范围内。 完整模拟器的源文件如下： 1. // Simulating a supermarket with multiple checkouts 2. #include \u003ciostream\u003e // For s[tan](http://c.biancheng.net/ref/tan.html)dard streams 3. #include \u003ciomanip\u003e // For stream manipulators 4. #include \u003cvector\u003e // For vector container 5. #include \u003cstring\u003e // For string class 6. #include \u003cnumeric\u003e // For accumulate() 7. #include \u003calgorithm\u003e // For min_element \u0026 max_element 8. #include \u003crandom\u003e // For random number generation 9. #include \"Customer.h\" 10. #include \"Checkout.h\" 12. u[sin](http://c.biancheng.net/ref/sin.html)g std::string; 13. using distribution = std::uniform_int_distribution\u003c\u003e; 15. // Output histogram of service times 16. void histogram(const std::vector\u003cint\u003e\u0026 v, int min) 17. { 18. string bar (60, '*'); // Row of asterisks for bar 19. for (size_t i {}; i \u003c v.size(); ++i) 20. { 21. std::cout \u003c\u003c std::setw(3) \u003c\u003c i+min \u003c\u003c \" \" // Service time is index + min 22. \u003c\u003c std::setw(4) \u003c\u003c v[i] \u003c\u003c \" \" // Output no. of occurrences 23. \u003c\u003c bar.substr(0, v[i]) // ...and that no. of asterisks 24. \u003c\u003c (v[i] \u003e static_cast\u003cint\u003e(bar.size()) ? \"...\": \"\") 25. \u003c\u003c std::endl; 26. } 27. } 29. int main() 30. { 31. std::random_device random_n; 33. // Setup minimum \u0026 maximum checkout periods - times in minutes 34. int service_t_min {2}, service_t_max {15}; 35. distribution service_t_d {service_t_min, service_t_max}; 37. // Setup minimum \u0026 maximum number of customers at store ","date":"2021-07-23","objectID":"/2021/07/queue/:2:0","tags":["queue","C++"],"title":"queue用法详解","uri":"/2021/07/queue/"},{"categories":["C++"],"content":"std命名空间","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/","tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"std命名空间 使用命名空间 std： #include \u003ccstdio\u003eint main(){ std::printf(\"http://c.biancheng.net\\n\"); return 0; } 不使用命名空间 std： #include \u003ccstdio\u003eint main(){ printf(\"http://c.biancheng.net\\n\"); return 0; } 演示了如何使用 C++ 库进行输入输出： #include \u003ciostream\u003e#include \u003cstring\u003e int main(){ //声明命名空间std using namespace std; //定义字符串变量 string str; //定义 int 变量 int age; //从控制台获取用户输入 cin\u003e\u003estr\u003e\u003eage; //将数据输出到控制台 cout\u003c\u003cstr\u003c\u003c\"已经成立\"\u003c\u003cage\u003c\u003c\"年了！\"\u003c\u003cendl; return 0; } 运行结果： C语言中文网↙ 6↙ C语言中文网已经成立6年了！ 在 main() 函数中声明命名空间 std，它的作用范围就位于 main() 函数内部，如果在其他函数中又用到了 std，就需要重新声明. #include \u003ciostream\u003e void func(){ //必须重新声明 using namespace std; cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ //声明命名空间std using namespace std; cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } 如果希望在所有函数中都使用命名空间 std，可以将它声明在全局范围中 #include \u003ciostream\u003e//声明命名空间std using namespace std; void func(){ cout\u003c\u003c\"http://c.biancheng.net\"\u003c\u003cendl; } int main(){ cout\u003c\u003c\"C语言中文网\"\u003c\u003cendl; func(); return 0; } ","date":"2021-07-23","objectID":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/:0:0","tags":["C++"],"title":"std命名空间","uri":"/2021/07/std%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"categories":["C++"],"content":"struct 结构体","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/","tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["C++"],"content":"struct 结构体 #include \u003cstdio.h\u003e //定义结构体 Student struct Student{ //结构体包含的成员变量 char *name; int age; float score; }; //显示结构体的成员变量 void display(struct Student stu){ printf(\"%s的年龄是 %d，成绩是 %f\\n\", stu.name, stu.age, stu.score); } int main(){ struct Student stu1; //为结构体的成员变量赋值 stu1.name = \"小明\"; stu1.age = 15; stu1.score = 92.5; //调用函数 display(stu1); return 0; } 结构体是一种构造类型，可以包含若干成员变量，每个成员变量的类型可以不同；可以通过结构体来定义结构体变量，每个变量拥有相同的性质。### ","date":"2021-07-23","objectID":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/:0:0","tags":["C++"],"title":"struct 结构体","uri":"/2021/07/struct%E7%BB%93%E6%9E%84%E4%BD%93/"},{"categories":["常见问题"],"content":"sublimetext常见问题","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"sublimetext常见问题 下载安装 汉化 1.点击tools—install package control 2.preferences—package control 3.选择 “Package Control: Install Package” 4.搜索LocalizedMenu并安装 乱码 推荐使用 Package Control 查找 ConvertToUTF8 进行自动下载安装与更新。 Mac使用Sublime撸C++代码 这两款软件让你在Mac上也能写C++ ","date":"2021-07-23","objectID":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"sublimetext常见问题","uri":"/2021/07/sublimetext%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"VS常见问题 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"解决VS生成sdf和ipch文件太大占用空间问题 [工具]—\u003e[选项]—\u003e[文本编辑器]—\u003eC/C++]—\u003e[高级]—\u003e[回退位置]里面的三项属性值按下图进行修改，其中回退路径随便设置。 设置个回退路径这样可比较好管理这些庞大的臃肿的文件，可以定期清理它们，释放磁盘空间 ","date":"2021-07-23","objectID":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":null,"title":"VS常见问题","uri":"/2021/07/vs%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["常见问题"],"content":"win10常见问题 禁止win10五笔输入法的shift切换功能 方法一：win10系统添加开机启动项 使用组合键win+R打开运行窗口，输入“shell:startup”打开启动项文件夹。 可以把软件快捷方式复制到“启动项文件夹|”中。 方法二：注册表添加启动项 1、打开运行，输入“regedit”，打开注册表。 2、在注册表中找到如下位置HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run，右键“Run”新建一个字符串类型的键值。 3、右键新建的键值，选择“修改”，将数值名称改为 你要启动的程序名称如：ctfmon.exe，数值数据改为 程序所在位置的路径 如：C:\\windows\\system32\\ctfmon.exe (直接不能修改名字的，可以先点击重命名，改好名字，再点击修改，修改数值数据) 如何彻底关闭win10系统windows defender实时保护功能？ ","date":"2021-07-23","objectID":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:0:0","tags":null,"title":"win10常见问题","uri":"/2021/07/win10%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["WOW"],"content":"WOW部分功能代码","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"WOW部分功能代码 ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:0:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色名字 // pcall5(对象地址,0,1,0,0);//返回名字地址 void CPAGE1::OnBnClickedButton() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase64 = (UINT_PTR) LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387c88)+0x200);//角色对象 TPCALL5 pcall5 =(TPCALL5)(pBase64+0xA7640); // TPCALL5 pcall5 = (TPCALL5)((UINT_PTR) LoadLibraryA(\"Wow.exe\")+0xA7640); char szpAscii[256]={0}; // char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); char *putf8Name =(char*) pcall5(pRoleObj,0,1,0,0); utf8ToAscii(putf8Name,szpAscii); m_edt_strA=szpAscii; UpdateData(FALSE);//把变量的数据更新到窗口 } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:1:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历怪物列表 void 遍历怪物列表() { UINT64 exeBase = (UINT64)LoadLibraryA(\"Wow.exe\"); for (UINT i=0;i\u003c=0x7F;i++)//7F可能不是 对象数量 对象的分类编号 { // UINT64 vrax=0; UINT64 vrax = R8(R8(R8(exeBase+0x2387C88)+0x30)+0x10+i*3*8); if (vrax == 0 ) { break; } // else//vrdx !=0 // { // vrax = vrdx; // } UINT64 vrcx = (UINT64)R4(R8(R8(exeBase+0x2387C88)+0x30)+i*3*8);//+28 while((vrax\u00261)==0) { //遍历同类链表 //rcx = dword([[wow.exe+0x2387C88]+0x30]+i*3*8) //0x28 //+198]+20 //float x,y,z UINT64 pNode198 = R8(vrax+0x198); float x = R4F(pNode198+0x20); float y = R4F(pNode198+0x24); float z = R4F(pNode198+0x28); char buf[2048]; char asciiObjName[2048]={0}; char *pObjName=GetObjName(vrax); if (pObjName\u0026\u0026pNode198) { utf8ToAscii(pObjName,asciiObjName); } sprintf_s(buf,\"yjx:[%d] vrax=%p (%f,%f,%f) vrcx=%llx name=%p %s\\r\\n\",i,vrax,x,y,z,vrcx,pObjName,asciiObjName); MessageBoxA(0,buf,\"while\",0); vrax = R8(vrcx+vrax+8); //链表 } } } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:2:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取对象名字 char* GetObjName(UINT64 vrcx) { char *putf8Name=NULL; __try { UINT64 pBase64 = (UINT_PTR)LoadLibraryA(\"Wow.exe\"); UINT64 pRoleObj = R8(R8(pBase64+0x2387C88)+0x200); TPCALL5 pcall5 = (TPCALL5)(pBase64+0x8AE040); char szpAscii[256]={0}; putf8Name = (char*)pcall5(vrcx,0,1,0,0); }__except(1) { } return putf8Name; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:3:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"使用技能 void TGCALL::UseActionCall(UINT32 SkillID,UINT64* argBuf40,UINT64 *TargetID16) { typedef UINT64 (*TPCALL4)(UINT64 arg1,UINT64* arg2,UINT64 arg3,UINT64* arg4); TPCALL4 pcall=(TPCALL4)(GameBase::GetExeBase()+0x77DC40); __try { pcall(SkillID,argBuf40,0,TargetID16); }__except(1) { MessageBoxA(0,\"ERROR 0x77DC40\",\"错误\",MB_OK); } return; } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"火球术 void CPAGE1::OnBnClickedButtonFire() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0,0}; // 0x006FCC00007B4493 /*ID1*/,0x204D880000001140 /*ID2*/};//目标怪物的ID TGCALL::UseActionCall(0x00000085,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:1","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"霜甲术 void CPAGE1::OnBnClickedButtonIce() { // TODO: 在此添加控件通知处理程序代码 UINT64 arg2buf[50]={0}; //疑似 坐标 方向 UINT64 ID16[50]={0/*ID1*/,0/*ID2*/}; //目标怪物的ID TGCALL::UseActionCall(0x000000A8,arg2buf,ID16); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:4:2","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"捡物 void CPAGE1::OnBnClickedButtonPick() { // TODO: 在此添加控件通知处理程序代码 TPCALL4 pcall4 = (TPCALL4)(GameBase::GetExeBase()+0xF2A620); pcall4(0,0,0,0); pcall4(1,0,0,0); pcall4(2,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:5:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"搜索选中怪身上的物品 void CPAGE1::OnBnClickedButtonSeachgoods() { // TODO: 在此添加控件通知处理程序代码 UINT64 pBase = R8(GameBase::GetExeBase()+0x21E2858); UINT64 ID1 = R8(pBase+0x30); UINT64 ID2 = R8(pBase+0x38); UINT64 arg1[40] = {ID1,ID2,0,0}; //通过选中对象ID 查找对象 TPCALL4 pcallGetObj1=(TPCALL4)(GameBase::GetExeBase()+0xB66AB0); UINT64 vrax = pcallGetObj1((UINT64)arg1,0,0,0);//一个参数 char buf[1024]; sprintf_s(buf,\"vrax=%llx \\r\\n\",vrax); TPCALL4 pcall =(TPCALL4)(R8(R8(vrax)+0x2C0));//2C0 右键单击 打开搜索物品的窗口 pcall(vrax,0,0,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:6:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取角色对象地址 UINT64 GameBase::GetRoleObj()//返回角色对象地址 { // return R8(R8(GetExeBase()+0x2387C88)+0x200); TPCALL2 pcall2 = (TPCALL2)(GameBase::GetExeBase()+0x1127550); const char *vrcx = \"player\"; return pcall2((UINT64)vrcx,0); } ","date":"2021-07-23","objectID":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/:7:0","tags":["WOW"],"title":"WOW部分功能代码","uri":"/2021/07/wow%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/","tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["WOW"],"content":"多字节字符串 转UTF-8字符串 让喊话内容支持中文 //AnsiToUtf8.h #pragma once //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); //AnsiToUtf8.cpp #include \"stdafx.h\"#include \"AsciiToUTF8.h\"#include \u003cWindows.h\u003e /* //字节集 转16进制 DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf); //ANSI 转 UTF8 DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf); //unicode 转 ascii char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr); //Uft-8 转 ascii char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii); */ DWORD AnsiToUtf8(LPCSTR Ansi,OUT LPSTR szpUtf8Buf) { int WLength = MultiByteToWideChar(CP_ACP, 0, Ansi, -1, NULL, 0); LPWSTR pszW = (LPWSTR) _alloca((WLength+1) * sizeof(WCHAR)); //Ansi字符串转Unicode字符串 MultiByteToWideChar(CP_ACP, 0, Ansi, -1, pszW, WLength); //计算UTF8转换所需要空间大小 int ALength = WideCharToMultiByte(CP_UTF8, 0, pszW, -1, NULL, 0, NULL, NULL); //LPSTR pszA = (LPSTR)_alloca( ALength + 1); WideCharToMultiByte(CP_UTF8, 0, pszW, -1, szpUtf8Buf, ALength, NULL, NULL); szpUtf8Buf[ALength]=0; szpUtf8Buf[ALength+1]=0; //pszA[ALength] = 0; return ALength;//返回UTF8字符串长度 } char* UniCodeToAscii(IN WCHAR*szpUnicodeStr,OUT char*szpAsciiStr) { //预算-缓冲区中多字节的长度 //CP_OEMCP int ansiiLen =WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,nullptr,0,nullptr,nullptr); //给指向缓冲区的指针变量分配内存 //把szpUnicodeStr里存放的Unicode编码字串 转成ASCII存放到 szpAsciiStr缓冲区 //CP_OEMCP WideCharToMultiByte(CP_ACP,0,szpUnicodeStr,-1,szpAsciiStr,ansiiLen,nullptr,nullptr); return szpAsciiStr; } WCHAR* utf8ToUnicode(IN char*szpUtf8,OUT WCHAR*szpUniCode) { //预算_缓冲区中宽字节的长度 //CP_UTF8 963页码 int unicodeLen = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); //给指向缓冲区的指针变量分配内存 WCHAR *pUnicode = (wchar_t*)malloc(sizeof(wchar_t)*unicodeLen); //开始向缓冲区转换字节 //CP_UTF8 963页码 也可能 MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,pUnicode,unicodeLen); wcscpy_s(szpUniCode,unicodeLen,pUnicode); free(pUnicode); return szpUniCode; } //注意此函数没检测缓冲区大小 char* utf8ToAscii(IN char*szpUtf8,OUT char*szpAscii) { int iSizeUtf8 = MultiByteToWideChar(CP_UTF8,0,szpUtf8,-1,nullptr,0); WCHAR*putf8Buf =(WCHAR*)malloc(sizeof(WCHAR)*iSizeUtf8); utf8ToUnicode(szpUtf8,putf8Buf); UniCodeToAscii(putf8Buf,szpAscii); return szpAscii; } BOOL CharToHex(OUT char*szpBufHex,BYTE c) { BYTE bLow =0; BYTE bHigh = 0; bLow = c%16;//取低位0..15 bHigh = c/16;//取高位0..15 if (bHigh\u003e9) { szpBufHex[0]='A'+bHigh-10;//'B' } else//0..9 { szpBufHex[0]='0'+bHigh;//'0'+2='2' } if (bLow\u003e9)//a,b,c,e,f { szpBufHex[1]='A'+bLow-10;//'B' } else//0..9 { szpBufHex[1]='0'+bLow;//'0'+2='2' } szpBufHex[2]=0;//0 return TRUE; } DWORD BytesToHexStr(IN BYTE*nbData, DWORD nbDataSize,OUT char*szpHexBuf) { //1 //01 for (DWORD i=0;i\u003c nbDataSize;i++) { //提高速度 CharToHex(\u0026szpHexBuf[i*2],nbData[i]); } return TRUE; } ","date":"2021-07-23","objectID":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["WOW"],"title":"多字节字符串 转UTF-8字符串","uri":"/2021/07/%E5%A4%9A%E5%AD%97%E8%8A%82%E5%AD%97%E7%AC%A6%E4%B8%B2-%E8%BD%ACutf-8%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装jekyll-rtd-theme博客 jekyll-rtd-theme 安装配置及写作 测试文档 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:0:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"安装时终端出现问题的解决办法 清空Gemfile文件内容 终端运行 bundle update Gemfile文件添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 终端再次运行 bundle update ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:1:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"一.安装 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"a.基于本地主题 1.清空Gemfile文件内容,并添加以下内容 source \"https://rubygems.org\" # gems.ruby-china.com gem \"jekyll-rtd-theme\" gem \"github-pages\", group: :jekyll_plugins 2.将以下内容添加到您的网站 _config.yml title:Your awesome titlelang:endescription:Write an awesome description for your new site heretheme:jekyll-rtd-theme ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:1","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"b.基于远程主题 将以下内容添加到您的 github 存储库 _config.yml remote_theme: rundocs/jekyll-rtd-theme 删除任何其他theme或remote_theme条目 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:2:2","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"二.设置侧边栏(子目录) 在根目录新建子目录 子目录中必须有一个README.md 排序 _config.yml中添加以下内容 readme_index: with_frontmatter: true 在需要排序的文件中添加 格式头 --- sort: 1 # follow a certain sequence of letters or numbers --- ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:3:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"三.在README文件中列出文件 在README文件中添加 如果要列出子目录的所有文件则添加 ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:4:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["博客"],"content":"四.语法 思维导图 graph TB c1--\u003ea2 subgraph one a1--\u003ea2 end subgraph two b1--\u003eb2 end subgraph three c1--\u003ec2 end 笔记 这是笔记 支持 Markdown, 文本可以是**粗体**, _斜体, or ~~删除线~~. [链接](https://github.com) 是蓝色的,且没有下划线 `inline code` [`inline code inside link`](#) 提示 它比面包盒还大.. 警告 强烈的散文可能会引起极度的脑力消耗。强烈建议读者酌情决定. 危险 疯狂的科学家在工作！ 更新 sudo bundle install sudo bundle update sudo bundle update jekyll ","date":"2021-07-23","objectID":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/:5:0","tags":["GitHub","博客"],"title":"安装jekyll-rtd-theme博客","uri":"/2021/07/%E5%AE%89%E8%A3%85jekyll-rtd-theme%E5%8D%9A%E5%AE%A2/"},{"categories":["C++"],"content":"常用API函数","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"常用API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:0:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"模拟鼠标 LRESULT SendMessage(HWND hWnd，UINT Msg，WPARAM wParam，LPARAM IParam); 其中Msg可以为WM_LBUTTONDOWN或WM_LBUTTONUP,表示对鼠标的软件模拟操作(虽然兼容性和安全性不如硬件模拟的mouse_event，但不改变移动鼠标指针) 故一般写作SendMessage(hwnd, WM_LBUTTONUP/WM_LBUTTONDOWN, 0, Y坐标«16+X); Msg也可以为WM_CLOSE,表示关闭窗口,其后的两个参数传0即可. ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:1:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL注入 HANDLE CreateThread(LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD ,LPDWORD); CreateThread 将在主线程的基础上创建一个新线程 LPVOID VirtualAllocEx( HANDLE hProcess, //申请内存所在的进程句柄。 LPVOID lpAddress, //保留页面的内存地址；一般用NULL自动分配 。 SIZE_T dwSize, //欲分配的内存大小，字节单位；注意实际分 配的内存大小是页内存大小的整数倍 DWORD flAllocationType, //一般用MEM_COMMIT DWORD flProtect //一般用PAGE_READWRITE(读写) ); VirtualAllocEx 向指定进程申请内存 FARPROC GetProcAddress(HMODULE hModule, LPCSTR); GetProcAddress 检索指定的动态链接库(DLL)中的输出库函数地址 HANDLE CreateRemoteThread(HANDLE, LPSECURITY_ATTRIBUTES, SIZE_T, LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD); CreateRemoteThread 创建一个在其它进程地址空间中运行的线程 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:2:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"DLL劫持 __asm{ } 执行括号内的汇编代码 JMP EAX 将EIP跳转到EAX执行，劫持DLL后要获取真正的原函数地址，使用时要进行跳转 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:3:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GDI绘图 HDC GetDC(HWND hWnd); 检索显示设备上下文环境的句柄 CDC CDC类定义的是设备上下文对象的类 CPoint CDC::MoveTo(int x,int y); CPoint CDC::LineTo(int x,int y); 绘制直线 BOOL CDC::Ellipse(int x1,int y1，int x2,int y2); 绘制圆形 BOOL CRgn::CreateRectRgn(int x1,int y1,int x2,int y2); 建立方形区域 BOOL CRgn::CreateEllipticRgn(int x1,int y1,int x2,int y2) 建立圆形区域 int CombineRgn(CRgn pRgn1,CRgn pRgn2,int nCombineMode ); 合并区域(圆点准心为使得中间透明采取大圆-小圆的区域) BOOL FillRgn(CRgn pRgn,CBrush pBrush ); 填充形状 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:4:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"其它API函数 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:0","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"MoveWindow BOOL MoveWindow( HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint ); 改变指定窗口的位置和大小 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:1","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindow BOOL IsWindow(HWND hWnd)； 判断是否是有效窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:2","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindow BOOL ShowWindow(HWND hWnd, int nCmdShow); 显示隐藏窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:3","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ShowWindowAsync BOOL ShowWindowAsync(HWND hWnd，int nCmdshow)； 异步显示窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:4","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowVisible BOOL IsWindowVisible(HWND hWnd); 获取窗口可视状态,即显示或隐藏 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:5","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsZoomed BOOL IsZoomed(HWND hWnd)； 窗口是否是最大化 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:6","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"IsWindowUnicode BOOL IswindowUnicode(HWND hwnd)； 判断窗口字符集 由RegisterClassA 还是RegisterClassW注册 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:7","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"CloseWindow BOOL CloseWindow(HWND hWnd); 关闭窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:8","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"WindowFromPoint HWND WindowFromPoint(POINT Point)； 获取指定坐标处的窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:9","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"ChildWindowFromPoint HWND ChildWindowFromPoint (HWND hWndParent, POINT Point); 获取指定窗口 坐标处子窗口句柄 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:10","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetWindowText Int GetWindowText(HWND hWnd,LPTSTR lpString,Int nMaxCount); 获取窗口标题字符串 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:11","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"GetClassName int GetClassName(HWND hWnd, LPTSTR IpClassName, int nMaxCount); 获取窗口注册的类名,由RegisterClass注册时的名字 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:12","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"BringWindowToTop B00L BringWindowToTop(HWND hWnd); 窗口激活并切换到Z序顶层 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:13","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnableWindow BOOL EnableWindow(HWND hWnd，BOOL bEnable); 是否接收键盘鼠标消息 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:14","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"EnumChildWindows BOOL EnumChildWindows(HWND hWndParent,WNDENUMPROC lpEnumFunc, LPARAM lParam); 遍历子窗口 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:15","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowPos WINUSERAPI BOOL WINAPI SetWindowPos(HWND hWnd,HWND hWndInsertAfter,int X,int Y,int cx, int cy, UINT uFlags); 窗口位置设置 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:16","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["C++"],"content":"SetWindowText BOOL SetWindowText(HWNDhwnd,LPCTSTRlpString); 设置窗口标题,SetWindowText也分A和W两种 ","date":"2021-07-23","objectID":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/:5:17","tags":["C++"],"title":"常用API函数","uri":"/2021/07/%E5%B8%B8%E7%94%A8api%E5%87%BD%E6%95%B0/"},{"categories":["WOW"],"content":"模块及进程相关代码","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"模块及进程相关代码 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:0:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"句柄 进程 内存 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"窗口句柄 HWND FindWindow(LPCTSTR IpClassName，LPCTSTR IpWindowName); HWND FindWindowW(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用Unicode字符集,IpWindowName前要加L,如L”魔兽世界“ HWND FindWindowA(LPCTSTR IpClassName，LPCTSTR IpWindowName); //使用多字节字符集 通过类名或窗口名查找，返回窗口句 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:1","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程ID和线程ID DWORD GetWindowThreadProcessId(HWND hWnd,LPDWORD lpdwProcessId); 得到窗口句柄后通过GetWindowThreadProcessId这个函数来获得窗口所属进程ID和线程ID ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:2","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"进程句柄 HANDLE OpenProcess(DWORD dwDesiredAccess,BOOL bInheritHandle,DWORD dwProcessId); 打开一个已存在的进程对象，并返回进程的句柄 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:3","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"写入内存 bool WriteProcessMemory(HANDLE hProcess,LPVOID lpBaseAddress,LPVOID lpBuffer,DWORD nSize,LPDWORD lpNumberOfBytesWritten ); 能写入某一进程的内存区域。入口区必须可以访问，否则操作将失败 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:4","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"读取内存 HWND ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, DWORD nSize, LPDWORD lpNumberOfBytesRead); 根据进程句柄读入该进程的某个内存空间lpBaseAddress的nSize字节，并写入缓冲区lpBuffer，多次计算基址和偏移即可 ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:1:5","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"遍历模块 int 遍历进程模块(DWORD 进程PID) { HMODULE hMods[1024]; //20*sizeof(HMODULE) HANDLE 进程句柄; DWORD cbNeeded; unsigned int i; //Print the proess identifier. printf(\"\\nprocess ID: %u\\n\",进程PID); //Get a handle to the process. 进程句柄=OpenProcess(PROCESS_ALL_ACCESS,FALSE,进程PID); if (NULL == 进程句柄) return 1; //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return 0; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:2:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取窗口句柄 HWND CFINDCODE::GetGameHwnd(void) { HWND hNext = FindWindowExA(HWND_DESKTOP,0,0,0); HWND h2 = FindWindowExA(HWND_DESKTOP,hNext,0,0); int i =0; while(h2) { char buf[256]={0}; GetWindowTextA(h2,buf,256); if (strstr(buf,szGameSubCaption)) { break; } h2 = FindWindowExA(HWND_DESKTOP,h2,0,0); } return h2; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:3:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程ID DWORD CFINDCODE::GetPID() { HWND h=GetGameHwnd(); DWORD dwpid=0; GetWindowThreadProcessId(h,\u0026dwpid); return dwpid; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:4:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取进程句柄 HANDLE CFINDCODE::GetGameHp() { DWORD dwPid = GetPID(); HANDLE hp = OpenProcess(PROCESS_ALL_ACCESS,0,dwPid); // printf(\"hp=%hp, pid=%d\\r\\n\",hp,dwPid); return hp; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:5:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块起始地址 UINT_PTR CFINDCODE::GetExeBase() { UINT_PTR exeBase64=NULL; HMODULE hMods[1024]; //20*sizeof(HMODULE) DWORD cbNeeded; unsigned int i; HANDLE 进程句柄=GetGameHp(); //Get a list of all the modules in this process. BOOL br = EnumProcessModules(进程句柄,hMods,sizeof(hMods),\u0026cbNeeded); if (br) { UINT32 模块数量=cbNeeded/sizeof(HMODULE); for ( i = 0; i \u003c 模块数量; i++) { TCHAR szModName[MAX_PATH]; //Get the full path to the module file. if(GetModuleFileNameEx(进程句柄,hMods[i],szModName, sizeof(szModName)/sizeof(TCHAR))) { //如果是“*.exe”的模块,直接返回基址 if (strstr(szModName,\".exe\")) { exeBase64 = (UINT_PTR)hMods[i]; } //Print the module name and handle value. //_tprintf(TEXT(\"模块名[%d]=%s 地址=%08X\\n\"),i,szModName,hModes[i]); // printf(\"模块名[%d]=%s 地址=%p\\n\",i,szModName,hMods[i]); } } } //Release the handle to the process. // CloseHandle(进程句柄); return exeBase64; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:6:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE结束地址 UINT_PTR CFINDCODE::GetExeEnd() { // HANDLE 进程句柄=GetGameHp(); // UINT_PTR 模块基址 = GetExeBegin(); // MEMORY_BASIC_INFORMATION meminfo; // //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 // SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); // UINT_PTR 结束地址=(UINT_PTR)meminfo.AllocationBase+meminfo.RegionSize; // printf(\"GetExeEnd: AllocationBase=%llx,RegionSize=%X 结束地址=%llx \\r\\n\",meminfo.AllocationBase,meminfo.RegionSize,结束地址); // return 结束地址; return GetExeBase()+GetExeSize(); } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:7:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["WOW"],"content":"获取EXE模块大小 SIZE_T CFINDCODE::GetExeSize(); { static SIZE_T nSize=0; if (nSize) { /* code */ return nSize; } HANDLE 进程句柄=GetGameHp(); UINT_PTR 模块基址 = GetExeBase(); MEMORY_BASIC_INFORMATION meminfo; //nSize函数写入lpBuffer的字节数,如果不等于sizeof(MEMORY_BASIC_INFORMATION)表示失败 SIZE_T nSize /*返回buf大小 */ = VirtualQueryEx(进程句柄,(LPCVOID)模块基址,\u0026meminfo,sizeof(meminfo)); nSize = meminfo.RegionSize; CloseHandle(进程句柄); return nSize; } ","date":"2021-07-23","objectID":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/:8:0","tags":["WOW"],"title":"模块及进程相关代码","uri":"/2021/07/%E6%A8%A1%E5%9D%97%E5%8F%8A%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81/"},{"categories":["博客"],"content":"LoveIt - 1前期准备","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"前言 这篇教程介绍了如何搭建这样效果的博客。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"所需步骤 可以从这样的角度出发： 注册域名。 使用CDN加快网站访问速度。 网站内容需要部署在服务器或对象存储平台上。 重要的是放什么内容。博客需要选择框架，或自己开发。 框架确定后，选择主题，或自己开发。 配置主题。 发表第一篇Hello World！ 在这个过程中，前期准备阶段包括：框架选择、主题选择、注册域名、备案和CDN配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:1:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"博客框架 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"框架选择 Wordpress 缺点：不安全。 主题推荐：Sakura Hexo 缺点：渲染生成文章速度不如Hugo。 主题推荐：matery Hugo The world’s fastest framework for building websites. ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"结论 选择Hugo框架。 静态博客方便备份。 用Markdown写文章，方便以后迁移。 缺点，使用对象存储服务需要支付流量费，存在被DDOS的风险。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"下载 Hugo和Hugo extend区别 Hugo extend支持Sass/SCSS。下载地址 Windows可考虑使用scoop下载, 安装与升级很方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"Hugo主题 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt 功能很全面的一个主题，支持很多功能，节省了不少自己折腾的时间。LoveIt主题介绍 安装主题有两种方案，如果不修改主题配置和模板，可以直接添加添加子模块，这样比较简单。 修改主题会麻烦一些，但是可以让自己的博客与众不同。需要将Fork到自己的仓库，有一个缺点，fork后添加的submodule是自己的仓库，使用Dependabot需要手动和上游同步之后，才会触发blog仓库更新检查。所以不适用Dependabot。 不修改主题模板 添加子模块到blog仓库的themes目录下。 git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 可设置Dependabot自动合并主题更新，参考：About Dependabot version updates和Automate Theme Update。 Fork主题后进行DIY fork主题到自己的仓库。 添加子模块： git submodule add \u003c自己仓库的url\u003e \u003cpath\u003e 设置上游进行同步，在主题目录中执行 git remote add upstream \u003c上游主题的url\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"toha toha是一个非常适合做个人简历的主题。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"注册域名 万网注册域名。 配置DNS解析，域名邮箱解析等可能存在冲突。 参考DNS解析冲突规则 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"HTTPS证书 使用HTTPS证书避免HTTP劫持风险，劫持https请求需要伪造证书。 阿里云可申请免费HTTPS证书，但是一个子域名需要单独申请一个证书。 Chrome浏览器HTTP网站显示“不安全”，是怎么回事? 谷歌从Chrome 56版本浏览器开始对使用HTTP协议传输密码信息的网站进行“不安全”警告；而2018年7月，谷歌Chrome 68将对所有HTTP网站显示“不安全”警告。随着Chrome浏览器的版本升级，会有越来越多的用户看到HTTP网站的“不安全”警告。来源：https://www.sohu.com/a/242732942_188485 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:4:1","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"备案 IPC备案 公安备案 如果在万网购买的域名，备案过程很简单，按要求填写信息，上传照片即可。注意照片要合要求，否则可能会被打回来重新上传。 香港，国外的服务器不需要备案。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"CDN 购买CDN资源包，加速域名访问。静态博客不需要购买动态请求次数。 以上步骤完成后，将域名解析到CDN，CDN加速源站或对象存储服务（在部署阶段介绍）。访问域名，确定CDN是否加速。 通过ping命令查看IP是否为CDN的IP。 打开Chrome控制台，查看返回包头是否有X-Cache字段。 ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/:7:0","tags":["GitHub","博客"],"title":"LoveIt - 1前期准备","uri":"/2020/12/loveit-1%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/"},{"categories":["博客"],"content":"LoveIt - 2部署","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"前言 完成前期的准备工作后，在部署阶段需要配置服务器或对象存储服务。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储和服务器对比 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对象存储平台 国内有阿里云OSS、腾讯COS、又拍云、七牛云等。国外有Github Pages、Netlify、Azure、Google等，其中Github Pages免费，但是有个说法：Github屏蔽百度爬虫，使用Github Pages的网站百度搜不到。 对象存储平台也可以做为Markdown图床，配合CDN，加快图片加载速度。 笔者的服务器是阿里家的，所以对象存储也用了阿里云OSS。 阿里云OSS部署参考 Hugo 静态网站部署及免费 HTTPS 证书配置 OSS常用工具汇总 对象存储的配置非常简单，哈喽沃德先生的这篇文章已经很详细了，按照这篇文章可以完成上传操作。文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 需要注意的是，上传的Bucket要设置为公共读权限，同时限制Refer，做好防盗链。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器 平时有使用VPS需求，可选择使用VPS。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"对比 对象存储： 优点：便宜，不需要搭建环境。 缺点：流量费用，要考虑图床的防盗链。 服务器： 优点各种踩坑😔，可以提升技能。 费用： 对象存储平台不考虑流量费：7.2元/年。 阿里云服务器，学生党及年龄小于等于24岁：10元/月；不满足以上条件的个人：121元/月。 结论 对象存储上手简单，成本低。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"服务器环境 不使用服务器部署的读者，可跳过这部分。 操作系统Ubuntu 更新安装源 apt update 修改hostname hostnamectl --static set-hostname localhost 重启 安装软件 apt install git apt install nginx apt install rz apt install unzip ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"SSH安全配置 安全组限制IP通过SSH远程登陆。如果使用Github Action安全组无法限制，Github Action的服务器部署在Azure上，官方文档中包含几万行IP段，不适合做限制。 修改22端口。由于第一个原因，只能修改端口。否则Massscan3分钟全网段扫描，触发SSH口令暴力破解，几乎每天都有告警。注意！修改之后，确定其他端口可以登陆再关闭22端口。 配置SSH key避免执行git命令时用户密码验证。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"Nginx配置 root权限启动。避免前端访问403的问题。/etc/nginx/nginx.conf中启动配置的用户与实际启动nginx的用户需要保持一致，可修改为低权限用户启动。 如果Nginx版本存在漏洞，以root权限启动，存在被拿到root权限的风险。 配置 /etc/nginx/nginx.conf ... include /etc/nginx/conf.d/*.conf; # 注释下面这行。如果sites-enabled/路径下存在默认配置文件，可能覆盖/etc/nginx/conf.d/default.conf配置 # include /etc/nginx/sites-enabled/*; ... 配置 /etc/nginx/conf.d/default.conf server { listen 80; server_name www.xiaodejiyi.com xiaodejiyi.com; # 注意www和没有www都要配置 index index.html index.htm; root /var/www/html/public; location / { root /var/www/html/public; index index.html; } error_page 404 /404.html; } ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"上传 将blog的public目录压缩为zip格式，使用rz命令上传到服务器上，unzip命令解压到Nginx配置的网站根目录中。 正常情况下，域名解析到CDN，CDN设置源站IP。到这一部可以访问域名，查看部署结果。如果blog配置未完成，可以先上传一张图片做测试。 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"参考 阿里云帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 2部署","uri":"/2020/12/loveit-2%E9%83%A8%E7%BD%B2/"},{"categories":["博客"],"content":"LoveIt - 3主题配置","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"前言 博客部署完成后，恭喜你可以发表第一篇：Hello world！但是LoveIt这么好用的主题，不配置一番可惜了。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"基本功能配置 主题配置最好参考已有的配置，比如LoveIt作者写的介绍，还有主题目录下的配置文件\\themes\\LoveIt\\exampleSite\\config.toml文件。 笔者认为一些配置项解释的不够清楚，所以将网站的源码放在了Github上，仅供参考。 下面介绍其中一些配置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"双语言配置 配置后需要每篇文章存在多个语言的文件，否则会报错。 例如：content\\about\\index.en.md、content\\about\\index.zh-cn.md ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"Gravatar头像 gravatar头像注册，需要使用wordpress帐号，注册帐号时，有些邮箱的邮件会被过滤，使用163邮箱等了1个多小时方才收到注册的邮件。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"图片画廊功能 在配置文件config.toml中开启lightgallery # 是否使用 lightgallery lightgallery = true 或者在文章的头部参数中设置lightgallery: true 最后文章中的图片引用格式为：![weichat](/images/weichat-logo_500px.png \"公众号\")，注意路径后面要加\"内容\"。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"搜索配置 使用algolia作为搜索引擎，因为lunr的加载速度会让你等到花都谢了。虽然algolia需要上传index.json，但是可以使用Algolia Atomic简化操作。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:4","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"评论系统设置 国内不能用disqus，不过还有Valine评论系统。留言可以设置邮件提醒功能，但是LeanCloud的云引擎域名需要使用自己的域名并配置DNS解析。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:5","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息设置 首页的社交信息，不同语言的界面，可分别设置。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:6","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"社交信息拓展 以微信公众号为例。 在config.toml的社交信息中添加 # 作者的社交信息设置[social]...Wechat = \"https://img.xiaodejiyi.com/img/wechat%20logo_500px.png\"... 配置themes\\LoveIt\\assets\\data\\social.yml: # 064: wechatwechat:# weight值排序Weight:2Title:公众号Newtab:trueIcon:Simpleicons:wechat 其中图标可参考其他形式，如： # Src形式cnblog:Weight:1Prefix:https://www.cnblogs.com/Title:博客园Icon:# themes\\LoveIt\\assets\\svg\\icons\\cnblog.svgSrc:svg/icons/cnblog.svg# fontawesome class形式mastodon:Weight:56Prefix:https://mastodon.social/Title:MastodonIcon:Class:fab fa-mastodon fa-fw# Simpleiconsgooglescholar:Weight:54Template:https://scholar.google.com/citations?%vTitle:Google ScholarIcon:# themes\\LoveIt\\assets\\lib\\simple-iconsSimpleicons:googlescholar ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:7","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"使用站长工具，向搜索引擎提交网站地图 让搜索引擎收录网站内容。 百度搜索资源平台 https://ziyuan.baidu.com/site/index#/ Google search console https://search.google.com/search-console/about?hl=zh-CN # 网站验证代码，用于 Google/Bing/Yandex/Pinterest/Baidu [verification] google = \"xxxxxxxxxxxxxxxx\" bing = \"\" yandex = \"\" pinterest = \"\" baidu = \"code-xxxxxxx\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:2:8","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站统计与分析 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站流量分析 分析网站点击流量，访客IP等数据。 Google Analytics 百度统计 注册后，需要先添加DNS解析，验证域名所有权，可能会与其他解析记录存在冲突。 解决方法，暂停其他解析，验证所有权通过后，在网站分析中配置ID，最后删除验证的DNS解析，重新开启其他冲突的解析记录。 # Google网站分析配置 [analytics] enable = true # Google Analytics [analytics.google] id = \"G-xxxxxxx\" # 是否匿名化用户 IP anonymizeIP = true 百度统计需要在网站代码中加入百度的统计代码，可以在themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中添加以下代码。 {{- /* baidu Analytics */ -}} \u003cscript\u003e var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); # 需要修改为自己的url hm.src = \"https://hm.baidu.com/hm.js?9c04b6d35915817e67da8ad2fdcfbfdf\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); \u003c/script\u003e # 下面网站访问数量统计中，友盟+和51LA也可以加在这里。 {{- /* 51la Analytics */ -}} \u003cscript type=\"text/javascript\" src=\"//js.users.51.la/21009067.js\"\u003e\u003c/script\u003e ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站访问数量统计 对比样式之后，选择了51LA统计。也可以用JS修改统计的样式。 这三个访问统计都需要在网站代码中加入统计的JS代码。注册后，获取JS统计代码，可以和网站流量分析中百度分析一样加到themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html中。 不算子 样式： 本文总阅读量929966次 本站总访问量3152598次 本站总访客数672421人 友盟+ 互联网数据服务平台缔元信和CNZZ合并成为友盟+。 样式： 站长统计 | 今日IP[43] | 今日PV[191] | 昨日IP[31] | 昨日PV[133] | 当前在线[5] 51LA 样式： 总访问量 21,195，本月访问量 2,820，昨日访问量 93，今日访问量 103，当前在线 4 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"归档页面文章总数 在themes\\LoveIt\\layouts\\_default\\section.html中添加以下代码： \u003c!-- articles --\u003e \u003cspan style=\"font-size:.8rem;font-weight:500;\"\u003e {{- len ( where .Site.RegularPages \"Section\" \"posts\" ) | dict \"Nums\" | T \"totalPageNums\" -}} \u003c/span\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [totalPageNums] other = \"共 {{ .Nums }} 篇文章\" # themes\\LoveIt\\i18n\\en.toml [totalPageNums] other = \" {{ .Nums }} articles\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站总字数统计 参考Hugo 总文章数和总字数。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:3:4","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"底部链接设计 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"关于知识共享许可协议 可以看这篇“知识共享”（CC协议）简单介绍，笔者最终决定采用：知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"网站运行时间 在themes\\LoveIt\\layouts\\partials\\footer.html中加入以下代码。 {{- /* Hugo and LoveIt */ -}} {{- if ne .Site.Params.footer.hugo false -}} \u003cdiv class=\"footer-line\"\u003e # 运行时间在这里 \u003cspan id=\"timeDate\"\u003e{{ T \"worktime\" }}\u0026nbsp;|\u0026nbsp;\u003c/span\u003e \u003cscript\u003e var now = new Date(); function createtime() { var start_time= new Date(\"09/16/2020 00:00:00\"); now.setTime(now.getTime()+250); days = (now - start_time ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); var worktime = document.getElementById(\"timeDate\").innerHTML.replace(/time/, Math.floor(days)); document.getElementById(\"timeDate\").innerHTML = worktime ; } createtime(); \u003c/script\u003e {{- $hugo := printf `\u003ca href=\"https://gohugo.io/\" target=\"_blank\" rel=\"noopener noreffer\" title=\"Hugo %v\"\u003eHugo\u003c/a\u003e` hugo.Version -}} {{- $theme := .Scratch.Get \"version\" | printf `\u003ca href=\"https://github.com/dillonzq/LoveIt\" target=\"_blank\" rel=\"noopener noreffer\" title=\"LoveIt %v\"\u003e\u003ci class=\"far fa-kiss-wink-heart fa-fw\"\u003e\u003c/i\u003e LoveIt\u003c/a\u003e` -}} {{- dict \"Hugo\" $hugo \"Theme\" $theme | T \"poweredBySome\" | safeHTML }} \u003c/div\u003e {{- end -}} i18n配置为： # themes\\LoveIt\\i18n\\zh-CN.toml [worktime] other = \"运行 time 天\" # themes\\LoveIt\\i18n\\en.toml [worktime] other = \"Almost time days.\" ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:2","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"小徽章 如果你喜欢这样的小徽章，前往shield进行DIY吧！参考动态小牌子制作 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:4:3","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"第三方库配置 使用jsdelivr加速第三方库文件的加载。 LoveIt主题对cdn文件的加载过程是这样的。 配置文件中补充cdn文件名称，可以直接复制主题的cdn文件到blog的assets/data/cdn/目录下。 [params.cdn] # CDN 数据文件名称, 默认不启用 # (\"jsdelivr.yml\") # 位于 \"themes/LoveIt/assets/data/cdn/\" 目录 # 可以在你的项目下相同路径存放你自己的数据文件: # \"assets/data/cdn/\" data = \"\" themes\\LoveIt\\layouts\\partials\\init.html中读取cdn文件中的数据，.Scratch.Set \"cdn\" $cdn设置全局变量，之后在其他文件中使用.Scratch.Get \"cdn\"获取cdn数据。 themes\\LoveIt\\layouts\\partials\\assets.html将cdn中的第三方库渲染后，追加在页面结尾部分。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"调用JS的三种方法 查找jsdelivr已有的第三方库，加入jsdelivr.yml中。 在themes\\LoveIt\\layouts\\partials\\assets.html中添加jquery.min.js，需要jquery文件位于assets\\js\\jquery.min.js。 {{- /* custom jquery */ -}} {{- $source := $cdn.jqueryJS | default ( resources.Get \"js/jquery.min.js\" ) -}} {{- dict \"Source\" $source \"Fingerprint\" $fingerprint | dict \"Scratch\" .Scratch \"Data\" | partial \"scratch/script.html\" -}} 配置文件中添加第三方库配置 # 第三方库配置 [page.library] [page.library.css] # someCSS = \"some.css\" # 位于 \"assets/\" # 或者 # someCSS = \"https://cdn.example.com/some.css\" # css路径：assets\\css\\custom.css customCSS = \"css/custom.css\" [page.library.js] # someJavascript = \"some.js\" # 位于 \"assets/\" # 或者 # someJavascript = \"https://cdn.example.com/some.js\" customJS = \"js/custom.js\" 完成以上配置后，可满足很多功能需求。但如果要拓展主题功能，像分类，列表页面，则需要学习Hugo语法。 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:5:1","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo帮助文档 ","date":"2020-12-28","objectID":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 3主题配置","uri":"/2020/12/loveit-3%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/"},{"categories":["博客"],"content":"LoveIt - 4功能拓展","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"前言 本文介绍一些拓展功能，如文章页面功能增加二级菜单，相关文章推荐和赞赏。另外，使用脚本会大大简化写作后的上传流程。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"文章页面功能 这部分功能的拓展主要是用前端的JS和CSS，如果对前端不了解，可以参考放在Github上的网站源码。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"二级菜单 导航栏放都太多链接不分主次，不够简洁。尝试多种方案后，做出了现在的二级菜单。 使用bootstrap框架 引入了太多样式，界面被扰乱，不够友好。 Select标签 样式单一，不能修改。 Hover属性 多个二级菜单不能使用相同参数的绝对定位，拓展太麻烦。 最终方案是：引入Jquery，使用Jquery的slideToggle()方法。可拓展，不影响原有界面。步骤如下。 调整下拉菜单的样式 /* dropdown menus css*/ .dropdown { position: relative; display: inline; margin: 0px; } .dropdown-menu { position: absolute; left: 0; z-index: 1000; float: left; min-width: auto; padding: 2px 1px; font-size: 14px; text-align: left; list-style: none; background-color: #fff; -webkit-background-clip: padding-box; background-clip: padding-box; border: 1px solid #ccc; border-radius: 4px; -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175); box-shadow: 0 6px 12px rgba(0, 0, 0, .175); } .dropdown-menu-mobile { width: 100%; position: relative; background: transparent; text-align: center; } .dropdown-menu.show { display: block; } .dropdown-item { display: block; margin: .4rem 0.5rem; clear: both; font-weight: 400; color: #212529; text-align: inherit; white-space: nowrap; background-color: transparent; line-height: 1.5rem; } .btn { vertical-align: inherit; font-weight: 400; color: #212529; text-align: center; -webkit-user-select: none; user-select: none; background-color: transparent; font-size: 1rem; border-radius: .25rem; } /* dropdown menus css*/ 调用JS $(\".dropdown\").each(function() { $(this).on(\"click\", function(e) { // 收起其他菜单 if (isMobile()) { $(\".menu\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } else { $(\".menu-inner\").find(\".dropdown-menu\").not($(this).children(\"div\")).slideUp(\"fast\"); } e.stopPropagation(); var downmenu = $(this).children(\"div\"); // 展开菜单 downmenu.slideToggle(\"fast\"); // 点击其他地方，隐藏菜单 if (downmenu.is(\":visible\")) { $(document).one(\"click\", function() { downmenu.slideUp(\"fast\"); }); } }); }); # 移动端 function isMobile(){ return window.matchMedia(\"only screen and (max-width: 680px)\").matches; } 修改菜单模板，详细代码参考header.html \u003cdiv class=\"menu\" style=\"overflow: visible\"\u003e \u003cdiv class=\"menu-inner\"\u003e {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\" style=\"display: inline;\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu\" style=\"display: none;\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active {{ end }}\" href=\"{{ $url }}\"{{ with .Title }} title=\"{{ . }}\"{{ end }}{{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e {{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} {{- end -}} {{- /* Mobile header */ -}} {{- range .Site.Menus.main -}} {{- /* MultiMenus */ -}} {{ if .HasChildren }} \u003cdiv class=\"dropdown menu-item\"\u003e \u003ca class=\"btn\" href=\"javascript:void(0);\" role=\"button\" data-toggle=\"dropdown\" aria-haspopup=\"true\" aria-expanded=\"false\"\u003e{{- .Pre | safeHTML }}{{ .Name }}{{ .Post | safeHTML -}}\u003c/a\u003e \u003cdiv class=\"dropdown-menu dropdown-menu-mobile\" style=\"display: none\"\u003e {{ range .Children }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"dropdown-item\" href=\"{{ $url }}\" {{ if (urls.Parse $url).Host }} rel=\"noopener noreffer\" target=\"_blank\"{{ end }}\u003e{{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}}\u003c/a\u003e {{ end }} \u003c/div\u003e \u003c/div\u003e {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u003ca class=\"menu-item\" href=\"{{ $url }}\" title=\"{{ .Title }}\"{{ i","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:1","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"相关文章推荐 参考Related Content themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*see also*/ -}} # 显示tag分类相关的前5篇文章 {{ $related := .Site.RegularPages.RelatedIndices . \"tags\" | first 5 }} {{ with $related }} \u003cdiv id=\"related-article\"\u003e \u003cp\u003e{{- T \"seeAlso\" -}}\u003c/p\u003e \u003cul\u003e {{ range . }} \u003cli\u003e\u003ca href=\"{{ .RelPermalink }}\"\u003e{{ .Title }}\u003c/a\u003e\u003c/li\u003e {{ end }} \u003c/ul\u003e \u003c/div\u003e {{ end }} ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:2","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"赞赏 赞赏功能需要在data\\imgURL.toml中添加图片的URL。 alipay = \"https://img.xiaodejiyi.com/img/alipay.jpg\"weichatPay = \"https://img.xiaodejiyi.com/img/wechat%20pay.jpg\" 然后在模板文件themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /* sponsor */ -}} \u003cdiv style=\"text-align:center;margin-bottom:30px;\"\u003e \u003ch5 style=\"font-weight:600;margin-bottom:10px;\"\u003e「\u0026nbsp;{{- T \"thanksSponsor\" -}}\u0026nbsp;」\u003c/h5\u003e \u003cbutton id=\"rewardButton\"\u003e\u003cspan\u003e{{- T \"tips\" -}}\u003c/span\u003e\u003c/button\u003e \u003cdiv id=\"QR\" style=\"display: none;\"\u003e \u003cdiv id=\"wechat\" style=\"display:inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"wechat_qr\" src=\"{{ .Site.Data.imgURL.weichatPay }}\" alt=\"WeChat Pay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"weichatTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003cdiv id=\"alipay\" style=\"display: inline-block\"\u003e \u003ca class=\"fancybox\" rel=\"group\"\u003e \u003cimg id=\"alipay_qr\" src=\"{{ .Site.Data.imgURL.alipay }}\" alt=\"Alipay\"\u003e\u003c/a\u003e \u003ch5 style=\"font-weight:600;margin-top:5px;\"\u003e{{- T \"aliTip\" -}}\u003c/h5\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e T和i18n函数是翻译函数，按照不同的语言，使用对应语言的字符串。参考i18n ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:3","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"版权声明 themes\\LoveIt\\layouts\\posts\\single.html添加以下代码： {{- /*copyright*/ -}} \u003cdiv id=\"copyright-container\"\u003e \u003cul class=\"post-copyright\"\u003e \u003cli class=\"post-copyright-author\"\u003e \u003cstrong\u003e{{- T \"articleAuthor\" -}}：\u003c/strong\u003e\u003ca href=\"{{ $.Site.Author.link | default .Site.Home.RelPermalink }}\" target=\"_blank\"\u003e{{ T \"penname\" }}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-link\"\u003e \u003cstrong\u003e{{- T \"articleLink\" -}}：\u003c/strong\u003e\u003ca href=\"#\" target=\"_blank\" title=\"{{ .Title }}\"\u003e{{- .Permalink | safeHTML -}}\u003c/a\u003e \u003c/li\u003e \u003cli class=\"post-copyright-license\"\u003e \u003cstrong\u003e{{- T \"copyRight\" -}}：\u003c/strong\u003e {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e 需要使用T函数翻译并且根据不同语言传递参数。 [copyRightMsg] other = \"本站所有文章除特别声明外，均采用 {{ .preCopyRight }} 转载请注明来自 {{ .afterCopyRight }} \" .Site.Params.footer.license在config.toml中设置: license = 'https://creativecommons.org/licenses/by-nc-sa/4.0/' ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:2:4","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"同步文章到服务器 如果需要了解同步文章到对象存储平台，请参考Hugo 静态网站部署及免费 HTTPS 证书配置和OSS常用工具汇总。 文章最后的“阅读全文”可以绕过，方法是在Chrome控制台的Network中找到readmore.js，右键Block request URL。 文章同步到服务器的步骤如下。 本地创建博客文章 配置SSH免密登陆 使用Python脚本生成网站静态资源，提交变更 Github Action使用rsync同步网站静态资源到服务器，并使用atomic-algolia同步index.json到Algolia。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"创建文章 在archetypes目录下的创建模板文件，使用hugo new --kind post-bundle posts/my-post生成指定模板的样例文章，不需要每次复制文章头部参数。 archetypes\\post-bundle\\index.md文件内容。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:1","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"SSH免密登陆 注意！服务器端要配置authorized_keys。参考设置 SSH 通过密钥登录 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:2","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"注册Algolia 使用Algolia搜索引擎为博客提供搜索功能。参考搜索配置 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:3","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"本地同步与备份脚本 在博客目录下执行该脚本，先推送blog到Github的blog仓库，再本地备份。(相信看到这里的读者都有Github帐号了) import time import os, sys def main(msg): # 备份blog/ print(\"*\"*10+\"push blog/\"+\"*\"*10, end=\"\\n\\n\") # 生成静态页面 os.system('hugo') # 需要安装Git os.system('git add .') os.system('git commit -m \"{}\"'.format(msg)) os.system('git push') local_back = input('\\n本地备份？提示: y\\n') if local_back == 'y': #7z、winrar压缩参数是一样的，只有winrar的话，7z换成winrar也可以运行 os.system(r'7z a D:\\src\\xxxxx.rar D:\\src\\xxxxx') os.system(r'move D:\\src\\code\\xxxxx.rar D:\\backup\\xxxxx') print('本地备份完成！') print('over...') if __name__ == '__main__': msg = input('commit: ') main(msg) 如果需要安装Git，试试Scoop，它用来安装应用程序非常方便。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:4","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"Github Action blog/文件根目录下创建package.json文件，并在scripts模块中加入\"algolia\": \"atomic-algolia\"。 { \"name\": \"algolia\", \"version\": \"0.2.0\", \"description\": \"atomic-algolia package\", \"private\": true, \"scripts\": { \"algolia\": \"atomic-algolia\" } } 在Github的Blog仓库中添加Secrets变量 同步index.json到Algolia需要配置如下变量： ALGOLIA_ADMIN_KEY ALGOLIA_APP_ID ALGOLIA_INDEX_NAME rsync同步需要配置如下变量 HOST PORT USER REMOTE_PATH Nginx中配置的网站根目录 SSH_KEY 使用Github Action，创建workflow，复制以下代码。 name: deploy_blog on: push: branches: [ master ] jobs: build: runs-on: ubuntu-latest steps:- name:Check Outuses:actions/checkout@v2#同步blog搜索- name:Use Node.jsuses:actions/setup-node@v1with:node-version:'12.x'- name:Install automic-algoliaenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:zh-cnALGOLIA_INDEX_FILE:\"./public/index.json\"run:| npm install atomic-algolianpm run algolia# 同步英语文章的json- name:en jsonenv:ALGOLIA_APP_ID:${{ secrets.ALGOLIA_APP_ID }}ALGOLIA_ADMIN_KEY:${{ secrets.ALGOLIA_ADMIN_KEY }}ALGOLIA_INDEX_NAME:enALGOLIA_INDEX_FILE:\"./public/en/index.json\"run:| npm run algolia- name:deploy to serveruses:AEnterprise/rsync-deploy@v1.0env:DEPLOY_KEY:${{ secrets.SSH_KEY }}# avzr参数，增量备份本地文件。-delete 删除目标地址中本地没有的文件ARGS:\"-avzr --delete\"SERVER_PORT:${{ secrets.PORT }}FOLDER:\"./public/\"SERVER_IP:${{ secrets.HOST }}USERNAME:${{ secrets.USER }}SERVER_DESTINATION:${{ secrets.REMOTE_PATH }} 如果出现问题，先在本地创建linux虚拟机，测试rsync命令，确定服务器同步是否正常。 代码改变世界，现在，写作多么简单。 ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:3:5","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"参考 LoveIt主题文档 LoveIt-extend Hugo官方文档 阿里云帮助文档 Windows软件包管理工具：Scoop ","date":"2020-12-28","objectID":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 4功能拓展","uri":"/2020/12/loveit-4%E5%8A%9F%E8%83%BD%E6%8B%93%E5%B1%95/"},{"categories":["博客"],"content":"LoveIt - 5页面模板","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"前言 最初在制作友链界面时，没有学习Hugo框架，一头雾水。网上有关的教程甚少，只能去学一遍Hugo。 在学习Hugo的过程中，了解了列表模板，分类模板。开发了几个功能页面，如：留言板，友链，记忆分类等。 本文介绍这些功能页面。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:1:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"里程碑页面 首先需要了解头部参数type，通过type指定文章使用的模板类型，默认为page类型。 要注意特殊模板的文章放在一般content根目录下，模板放在layouts目录下。 里程碑界面依据themes\\LoveIt\\layouts\\posts\\single.html修改，删除赞赏，相关文章推荐等功能。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- .Scratch.Delete \"this\" -}} {{- $params := .Scratch.Get \"params\" -}} {{- $toc := $params.toc -}} {{- if eq $toc true -}} {{- $toc = .Site.Params.page.toc | default dict -}} {{- else if eq $toc false -}} {{- $toc = dict \"enable\" false -}} {{- end -}} {{- /* Auto TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"toc\" id=\"toc-auto\"\u003e \u003ch2 class=\"toc-title\"\u003e{{ T \"contents\" }}\u003c/h2\u003e \u003cdiv class=\"toc-content{{ if eq $toc.auto false }} always-active{{ end }}\" id=\"toc-content-auto\"\u003e\u003c/div\u003e \u003c/div\u003e {{- end -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e \u003ci class=\"fas fa-monument fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} \u003c/h1\u003e {{- /* Static TOC */ -}} {{- if ne $toc.enable false -}} \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e {{- end -}} {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003cdiv id=\"post-footer\"\u003e\u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 这个模板也可以制作“爱情故事”。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:2:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"关于页面 相对里程碑界面，关于界面又删除了目录。 {{- define \"title\" }}{{ .Title }} - {{ .Site.Title }}{{ end -}} {{- define \"content\" -}} {{- $params := .Scratch.Get \"params\" -}} \u003carticle class=\"page single special\"\u003e {{- /* Title */ -}} \u003ch1 class=\"single-title animated flipInX\"\u003e{{ .Title }}\u003c/h1\u003e {{- /* Content */ -}} \u003cdiv class=\"content\" id=\"content\"\u003e {{- dict \"Content\" .Content \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c!-- 这里的版权声明是根据文章内容添加的，可删除 --\u003e {{- /*copyright*/ -}} {{- $prestr := printf `\u003ca href=\"%v\" target=\"_blank\" title=\"CC BY-NC-ND 4.0\"\u003e%v\u003c/a\u003e` .Site.Params.footer.license ( T \"license\" ) -}} {{- $laststr := printf `\u003ca href=\"%v\" target=\"_blank\"\u003e%v\u003c/a\u003e` ($.Site.Author.link | default .Site.Home.RelPermalink) ( T \"penname\" ) -}} {{- dict \"preCopyRight\" $prestr \"afterCopyRight\" $laststr | T \"copyRightMsg\" | safeHTML }} \u003c/div\u003e {{- /* Comment */ -}} {{- partial \"comment.html\" . -}} \u003c/article\u003e {{- end -}} 类似的留言板页面可以使用默认的\"page\"类型。如果页面中有标题，同时不希望有目录，“关于”页面的模板更合适。或者使用头部参数toc: false禁用目录。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:3:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"列表模板 列表页面是在文章的头部自定义参数，在模板中渲染。例如友链模板，参考LoveIt-extend/content/links/index.zh-cn.md。 头部参数需要按照yml文件的格式，注意不能用tab缩进。 links:me:name:我 weight:1people:- name:朤尧url:https://www.xiaodejiyi.com/avatar:https://www.gravatar.com/avatar/ae94c8d8ca3d56eb035a3e62c2595150?s=240\u0026d=mpdescription:just do sth i should do.friends:name:朋友 weight:2people: links模板为： \u003c!-- links按照weight排序，排序后改变了原来的数组结构，相当于weight变为key值，其他数据组成value --\u003e {{- range $weight, $website := sort .Params.links \"weight\" -}} \u003ch3 id=\"{{ $website.name }}\" tabindex=\"-1\" style=\"outline: none;\"\u003e\u003ca href=\"#{{ $website.name }}\"\u003e\u003c/a\u003e{{ $website.name }}\u003c/h3\u003e \u003cul style=\"list-style: none;\" id=\"firendLink\"\u003e {{- range $website.people -}} \u003cli\u003e \u003cdiv class=\"box\"\u003e \u003cdiv class=\"media\"\u003e \u003cdiv class=\"media-left\"\u003e\u003cimg src=\"{{ .avatar }}\" width=\"55\"\u003e\u003c/div\u003e \u003cdiv class=\"media-content\"\u003e \u003ci class=\"fa fa-user-ninja fa-fw\"\u003e\u003c/i\u003e \u003c!-- . 是 当前作用域 --\u003e {{ .name }}\u0026nbsp;\u003ci class=\"fa fa-link fa-fw\"\u003e\u003c/i\u003e \u003ca href=\"{{ .url }}\" target=\"_blank\"\u003e{{ .url }}\u003c/a\u003e \u003cp\u003e{{ .description }}\u003c/p\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/li\u003e {{- end -}} \u003c/ul\u003e {{- end -}} 不过这里有一个Bug，content\\links\\index.zh-cn.md正文部分不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 生成目录的代码： \u003c!-- 修改前的侧边目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e {{- dict \"Content\" .TableOfContents \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003c/div\u003e \u003c/div\u003e \u003c!-- 修改后links的目录 --\u003e \u003cdiv class=\"details toc\" id=\"toc-static\" kept=\"{{ if $toc.keepStatic }}true{{ end }}\"\u003e \u003cdiv class=\"details-summary toc-title\"\u003e \u003cspan\u003e{{ T \"contents\" }}\u003c/span\u003e \u003cspan\u003e\u003ci class=\"details-icon fas fa-angle-right\"\u003e\u003c/i\u003e\u003c/span\u003e \u003c/div\u003e \u003cdiv class=\"details-content toc-content\" id=\"toc-content-static\"\u003e \u003cnav id=\"TableOfContents\"\u003e \u003cul\u003e {{- /* modify director */ -}} {{- range $weight, $website := sort .Params.links \"weight\" -}} {{- $groupName := dict \"Content\" $website.name \"Ruby\" $params.ruby \"Fraction\" $params.fraction \"Fontawesome\" $params.fontawesome | partial \"function/content.html\" | safeHTML -}} \u003cli\u003e\u003ca href=\"#{{ $groupName }}\"\u003e{{ $groupName }}\u003c/a\u003e\u003c/li\u003e {{- end -}} \u003c/ul\u003e \u003c/nav\u003e \u003c/div\u003e \u003c/div\u003e 问题不大，还能用。同理，可以使用列表模板制作说说，相册，视频页面，只是样式设计上不同。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:4:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"分类模板 分类模板，需要考虑模板的渲染顺序，这个顺序很长，参考Hugo’s Lookup Order，而且需要其他背景知识，如type的详细分类等等。 不过，按照以下步骤，你不需要深入研究这个复杂的顺序。 在config.toml中配置分类 categories和tags为默认分类 [taxonomies]# 左边单数，右边复数形式category = \"categories\"tag = \"tags\"booklist = \"booklist\" 创建样例文章 在文章的头部参数中添加分类，注意要有中括号： categories: [\"demo1\"]tags: [\"demo2\"]booklist:[\"demo3\"] 创建分类模板 首先要覆盖主题默认的分类模板，分析默认模板themes\\LoveIt\\layouts\\taxonomy\\list.html的代码： ... {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else if eq $taxonomy \"tag\" -}} \u003ci class=\"fas fa-tag fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- else -}} {{- printf \"%v - %v\" (T $taxonomy | default $taxonomy) .Title -}} {{- end -}} ... 可以发现，默认模板中包含了category,tag和其他，这三种模板。 所以覆盖需要将这个模板拆开，复制到博客的layouts目录下，分别命名为：categories,tags,taxonomy。内容上可以不修改，也可以将if语句剪枝。例如layouts\\categories\\list.html： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"category\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 覆盖之后，创建booklist分类的模板，复制categories分类的模板，修改为： \u003ch2 class=\"single-title animated pulse faster\"\u003e {{- $taxonomy := .Data.Singular -}} {{- if eq $taxonomy \"booklist\" -}} \u003ci class=\"far fa-folder-open fa-fw\"\u003e\u003c/i\u003e\u0026nbsp;{{ .Title }} {{- end -}} \u003c/h2\u003e 是的，将if判断的category改为booklist，再换个Font Awesome图标。不要忘了还有layouts\\booklist\\terms.html也要改，同样修改if判断，改标题，改图标。 刷新界面，看看booklist分类有没有demo3的文章。如果没有，hugo server重新启动，现在应该有了。Hugo在这方面不能实时刷新。 首页文章增加分类 回到首页，你会发现，文章只有categories和tags的分类：demo1和demo2。添加demo3需要在themes\\LoveIt\\layouts\\_default\\summary.html中加入新的分类。 {{- $booklist := slice -}} {{- range .Params.booklist -}} {{- $category := partialCached \"function/path.html\" . . | printf \"/booklist/%v\" | $.Site.GetPage -}} {{- $booklist = $booklist | append (printf `\u003ca href=\"%v\"\u003e\u003ci class=\"fas fa-file-alt fa-fw\"\u003e\u003c/i\u003e%v\u003c/a\u003e` $category.RelPermalink $category.Title) -}} {{- end -}} {{- with delimit $booklist \"\u0026nbsp;\" -}} \u0026nbsp;\u003cspan class=\"post-category\"\u003e {{- . | safeHTML -}} \u003c/span\u003e {{- end -}} 继续加其他分类，只需要再复制一段，用编辑器Ctrl+H替换代码中的booklist。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:5:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"笔记页面 博客最初的设计是Hugo写文章，VuePress记笔记。在写这篇教程的过程中发现，如果把OneNote记的笔记放到VuePress上，再写文章，这会消耗大量时间。 不过VuePress能给文章加上一个背景知识。权衡之后放弃了VuePress。 如果你需要搭建一个笔记网站，可以考虑VuePress和Hugo的learn主题。 VuePress搭建过程可以参考B站教程和VuePress 中文文档。 搭建时需要注意这两点： Auto Sidebar插件自动生成侧边导航栏，如果没有这个插件，VuePress会繁琐得不想再用。 内置搜索只为页面的标题、h2、h3以及tags构建搜索索引。docsearch只支持技术文档，不支持博客索引和商业内容。Algolia搜索的方法可行，但是配置Algolia步骤很麻烦。 ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:6:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"最后 博客搭建教程结束，如果你想要添加更多的功能，更灵活的开发自己的博客，那么学习Hugo框架吧！只是这需要投入一些成本，学习Hugo花了11个小时，开发又用了95个小时。或许你还需要了解下自媒体以及公众号，知乎等其他写作平台，这消耗了28个小时。（番茄工作法统计得出） 专心于博客的内容创作或许是更好的选择，希望这篇教程可以帮到你。 如果想学习Hugo，那么Hugo论坛是一个不错的地方。 我为什么要搭博客呢？把知识留下来！ ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:7:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":["博客"],"content":"参考 Hugo官方文档 LoveIt-extend LoveIt Theme ","date":"2020-12-28","objectID":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/:8:0","tags":["GitHub","博客"],"title":"LoveIt - 5页面模板","uri":"/2020/12/loveit-5%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF/"},{"categories":null,"content":"alloc创建一个对象","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/","tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"​ alloc创建一个对象 dealloc销毁对象 retain增加对象的保留计数器值 release减少对象的保留计数器值 retainCount获得保留计数器的当前值 autorelease将来一个时间自动释放 NSAutoreleasePool自动释放池 ","date":"2020-10-16","objectID":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/:0:0","tags":null,"title":"alloc创建一个对象","uri":"/2020/10/alloc%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1/"},{"categories":null,"content":"NSArray","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/","tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSArray 是一个Cocoa类，用来存储对象的有序列表 arrayWithObjects用来创建新的NSArray initWithObjects 初始化数组并赋值 objectAtIndex获取指定索引处的对象 componentsSeparatedByString切分NSArray componentsJoinedByString合并NSArray NSMutableArray可变数组 arrayWithCapacity创建可变数组 addObject在数组末尾添加对象 removeObjectAtIndex删除特定索引处的对象 ","date":"2020-10-16","objectID":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/:0:0","tags":null,"title":"NSArray","uri":"/2020/10/nsarray%E6%98%AF%E4%B8%80%E4%B8%AAcocoa%E7%B1%BB/"},{"categories":null,"content":"NSEnumerator","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/","tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSEnumerator 用来描述集合运算的方式 objectEnumerator向数组请求枚举器 reverseObjectEnumerator从后向前浏览集合 nextObject下一个对象 NSDictionary字典，在给定的关键字下存储一个数值 dictionaryWithObjectsAndKeys创建字典 objectForKey获取字典中的值，向方法传递之前用来存储该值的关键字 NSMutableDictionary可变字典 dictionary可以向类NSMutableDictionary发送dictionary消息创建可变字典 dictionaryWithCapacity创建可变字典 setObject: forkey:给字典添加元素 removeObjectForKey删除可变字典中的关键字 ","date":"2020-10-16","objectID":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/:0:0","tags":null,"title":"NSEnumerator","uri":"/2020/10/nsenumerator%E7%94%A8%E6%9D%A5%E6%8F%8F%E8%BF%B0%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"NSNumber","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSNumber 用来包装基本数据类型 numberWithInt创建NSNumber intValue提取NSNumber NSValue可以包装任意值 valueWithBytes: objCType:创建新NSValue getValue提取NSValue @encode编译器指令可以接受数据类型的名称并为你生成合适的字符串 valueWithSize将struct型数据转换成NSValue NSNull代表无 NSFileManager对文件系统进行操作 defaultManager创建NSFileManager对象 stringByExpandingTildeInpath替换当前用户的主目录 NSDirectoryEnumerator 是NSEnumerator的子类，调用nextObject时返回该目录中一个文件的另一个路径，这个方法也可以搜索子目录。 pathExtension输出文件的扩展名(去掉了扩展名前面的点) ","date":"2020-10-16","objectID":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/:0:0","tags":null,"title":"NSNumber","uri":"/2020/10/nsnumber%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"categories":null,"content":"NSPredicate类","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/","tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"NSPredicate类 用于制定过滤器的条件 +predicateWithFormat创建谓词 -evaluateWithObject通知谓词根据指定的对象计算自身的值 -filteredArrayUsingPredicate循环过滤数组内容，根据谓词计算每个对象的值，并将值为Yes的对象累积到将被返回的新数组中 copy指针复制，浅拷贝，返回的是不能修改的对象 mutableCopy对象复制，深拷贝，返回的是可修改的对象 -filterUsingPredicate针对可变数组进行过滤及返回 predicateWithSubstitutionVariables构造新的专用谓词，创建一个键/值对字典，其中，键是变量名，值是插入谓词的内容 \u0026\u0026 AND 和 || OR 或 ! NOT 非 BETWEEN { }之间 BEGINSWITH检查某个字符串是否以另一个字符串开头 ENDSWITH检查某个字符串是否以另一个字符串结尾 CONTAINS检查某个字符串是否在另一个字符串内部 [c]不区分大小写 [d]不区分发音符号 [cd]不区分以上两项 LIKE 匹配运算符 ","date":"2020-10-16","objectID":"/2020/10/nspredicate%E7%B1%BB/:0:0","tags":null,"title":"NSPredicate类","uri":"/2020/10/nspredicate%E7%B1%BB/"},{"categories":null,"content":"协议","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/","tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"​ 协议 @protocol创建协议 encodeWithCoder用于接受对象的实例变量并将其转换为NSCoder类的对象 initWithCoder从NSCoder类的对象中提取经过转换的冻结的实例变量并使用它们初始化一个新对象 copyWithZone复制到一块可供分配的内存区域 class所属的类 allocWithZone分配内存并创建一个该类的新对象 @optional协议中的可选方法 @required协议中的必选方法 ","date":"2020-10-16","objectID":"/2020/10/%E5%8D%8F%E8%AE%AE/:0:0","tags":null,"title":"协议","uri":"/2020/10/%E5%8D%8F%E8%AE%AE/"},{"categories":null,"content":"多视图应用程序","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"多视图应用程序 UITabBarController标签栏界面 UINavigationController导航栏界面 addSubview添加视图，是将view加到所有层的最顶层 insertSubview在索引位置插入视图 initWithNibName: bundle:加载nib文件 removeFromSuperview从父视图删除 beginAnimation: context:声明动画块 setAnimationDuration:动画持续时间 setAnimationCurve:动画曲线 setAnimationTransition:动画转换类型 ","date":"2020-10-16","objectID":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/:0:0","tags":null,"title":"多视图应用程序","uri":"/2020/10/%E5%A4%9A%E8%A7%86%E5%9B%BE%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"},{"categories":null,"content":"导航控制器和表视图(一)","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/","tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"​ 导航控制器和表视图(一) UINavigationController 导航控制器 accessoryType 附件类型 navigationController 导航控制器属性 pushViewController: 入栈方法 viewWillAppear: 视图出现时加载 NSIndexPath 属性,索引路径 UITableViewCellAccessoryCheckmark 属性,检查标记(对勾) UITableViewCellAccessoryNone 属性,无标记 deselectRowAtIndexPath 取消选中某行 buttonWithType 按钮格式 setBackgroundImage 设置背景图片 addTarget 添加目标 forControlEvents 按钮事件 accessoryView 附加视图 buttonTapped: 轻击按钮 ","date":"2020-10-16","objectID":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/:0:0","tags":null,"title":"导航控制器和表视图(一)","uri":"/2020/10/%E5%AF%BC%E8%88%AA%E6%8E%A7%E5%88%B6%E5%99%A8%E5%92%8C%E8%A1%A8%E8%A7%86%E5%9B%BE%E4%B8%80/"},{"categories":null,"content":"文件加载和保存","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/","tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"​ 文件加载和保存 date获取当前的时间和日期 dateWithTimeIntervalSinceNow获取与当前时间相隔一定时差的日期 const它限定一个变量不允许被改变 writeToFile:atomically:将属性列表写入文件 arrayWithContentsOfFile读取文件 code编码 decode解码 encodeSomething: forKey:编码方法 decodeSomethingForKey解码方法 NSKeyedArchiver归档 archivedDataWithRootObject创建归档实例 NSKeyedUnarchiver重新创建档案,和归档相反 unarchiveObjectWithData重新创建档案实例 ","date":"2020-10-16","objectID":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/:0:0","tags":null,"title":"文件加载和保存","uri":"/2020/10/%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E5%92%8C%E4%BF%9D%E5%AD%98/"},{"categories":null,"content":"更丰富的用户界面(一)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/","tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(一) resignFirstResponder取消第一响应者状态 UISlider滑块控件 UISegmentedControl分段开关控件 #define定义常量 UISwitch切换开关控件 UITxtField文本控件 { isOn 获取切换开关控件的状态 setOn设置切换开关控件的状态 animated移动方式 YES为缓慢 NO为瞬间 } selectedSegmentIndex分段控件索引 hidden隐藏 { UIActionSheet操作表控件 initWithTitle:初始化操作表 delegate:操作表响应的委托 cancelButtonTitle:取消按钮 destructiveButtonTitle:继续按钮 otherButtonTitles:其它按钮 } ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/:0:0","tags":null,"title":"更丰富的用户界面(一)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%B8%80/"},{"categories":null,"content":"更丰富的用户界面(二)","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/","tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"更丰富的用户界面(二) showInView:在视图中显示 view视图 { UIAlertViewDelegate警报委托控件 UIActionSheetDelegate操作表委托控件(在例子中作为协议) actionSheet: didDismissWithButtonIndex:(在例子中作为协议的方法) } buttonIndex 按钮的索引 cancelButtonIndex 取消按钮的索引 { UIAlertView 警报控件 initWithTitle:初始化警报 message:警报内容 delegate:警报响应的委托 cancelButtonTitle:取消按钮 otherButtonTitles:其它按钮 } viewDidLoad视图加载方法 viewDidUnload视图卸载方法 UIImage图像控件 imageNamed: 加载图像文件 UIImageView 图像视图控件 initWithImage: 初始化图像视图 ","date":"2020-10-16","objectID":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/:0:0","tags":null,"title":"更丰富的用户界面(二)","uri":"/2020/10/%E6%9B%B4%E4%B8%B0%E5%AF%8C%E7%9A%84%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E4%BA%8C/"},{"categories":null,"content":"特性","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/","tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"​ 特性 @property表示声明了一个新对象的属性，自动声明属性的setter和getter方法 @synthesize 表示创建该属性的访问器 readwrite读写属性 readonly只读 ","date":"2020-10-16","objectID":"/2020/10/%E7%89%B9%E6%80%A7/:0:0","tags":null,"title":"特性","uri":"/2020/10/%E7%89%B9%E6%80%A7/"},{"categories":null,"content":"笔记1","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/","tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"​ 笔记1 \\n换行符 new 是alloc和init的结合 double精度是float的两倍 char单个字符 %o 八进制整数 %x十六进制整数 %f浮点计数法 %e科学计数法 %g %a和%f一样 long扩展值域，输出时要在%后添加l long long 特定扩展%后加ll short缩小值域 %后加h unsigned正数(无符号) id NSLog字符%p ","date":"2020-10-16","objectID":"/2020/10/%E7%AC%94%E8%AE%B01/:0:0","tags":null,"title":"笔记1","uri":"/2020/10/%E7%AC%94%E8%AE%B01/"},{"categories":null,"content":"自动旋转和自动调整大小","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/","tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"​ 自动旋转和自动调整大小 shouldAutorotateToInterfaceOrientation:旋转支持 willAnimateRotationToInterfaceOrientation: duration: 此方法将在旋转开始之后，最后的旋转动画发生之前自动调用 UIInterfaceOrientation界面方向控件 NSTimeInterval间隔时间 frame框架 CGRectMake大小和位置 transform变换 bounds边界 ","date":"2020-10-16","objectID":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/:0:0","tags":null,"title":"自动旋转和自动调整大小","uri":"/2020/10/%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%92%8C%E8%87%AA%E5%8A%A8%E8%B0%83%E6%95%B4%E5%A4%A7%E5%B0%8F/"},{"categories":null,"content":"键/值编码","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/","tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"​ 键/值编码 count计数 -valueForKey: 读取方法,以字符串的形式向对象发送消息 -setValue: forKey: 设置方法,以字符串的形式向对象发送消息(设置标量值需要封装数据) -valueForKeyPath: 路径读取方法 -setValue: forKeyPath: 路径设置方法 @运算符,它获取左侧指定的集合,对该集合中的每个对象使用右侧的键路径,然后将结果转换为一个集合 @count计数 @sum求和 @avg求平均值 @min取最小值 @max取最大值 @distinctUnionOfObjects取交集 lastObject方法,最后一个对象 dictionaryWithValuesForKeys它接受一个字符串数组,该数组中的数据成为键,对每个键使用读取方法,然后为键字符串和刚才获得的值构建一个字典. setValuesForKeysWithDictionary批量修改,用字典来修改键值 setNilValueForKey重设nil意义 valueForUndefinedKey:读取未知键 setValue: forUndefinedKey: 设置未知键 ","date":"2020-10-16","objectID":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/:0:0","tags":null,"title":"键/值编码","uri":"/2020/10/%E9%94%AE-%E5%80%BC%E7%BC%96%E7%A0%81/"},{"categories":null,"content":"2021 ","date":"2020-07-01","objectID":"/milestone/:1:0","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"5月 10日，开始学习《Shark恒零基础百集软件逆向教程》，暂时学完前两期。历时两周。 25日，开始学习《2020DNF》、《2020DOF》、《2021DNF不完整》系列教程。历时5天。 30日，开始学习《英雄联盟LOL》、《亿万僵尸》、《CE WALKer》，历时9天。 ","date":"2020-07-01","objectID":"/milestone/:1:1","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"6月 8日，开始学习《小冷过游戏检测技术》及相关过检测教程，历时4天。期间还看了WOW按键视频。 12日，开始学习《植物大战僵尸》，历时9天。 23日，开始学习《CS》。 27日，开始各种尝试。 ","date":"2020-07-01","objectID":"/milestone/:1:2","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"7月 3日，开始学习《郁金香2020 WOW》，教程未完待续。历时19天。 24日，开始学习《郁金香2019 VS2010》,仍在继续中。 26日，开始利用闲暇时间搭建博客，用于记录笔记及心路历程。尝试搭了5个不同的博客，第一款基于jekyll框架，效果不理想，之后不断摸索。 ","date":"2020-07-01","objectID":"/milestone/:1:3","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"8月 4日，博客最终锁定了Hugo框架LoveIt模板，也就是现在看到的样子。 ","date":"2020-07-01","objectID":"/milestone/:1:4","tags":null,"title":"里程碑","uri":"/milestone/"},{"categories":null,"content":"  LoveIt 是一个由 Dillon 开发的简洁、优雅且高效的 Hugo 博客主题。 它的原型基于 LeaveIt 主题 和 KeepIt 主题。 Hugo 主题 LoveItHugo 主题 LoveIt \" Hugo 主题 LoveIt ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"特性 性能和 SEO  性能优化：在 Google PageSpeed Insights 中， 99/100 的移动设备得分和 100/100 的桌面设备得分  使用基于 JSON-LD 格式 的 SEO SCHEMA 文件进行 SEO 优化  支持 Google Analytics  支持 Fathom Analytics  支持搜索引擎的网站验证 (Google, Bind, Yandex and Baidu)  支持所有第三方库的 CDN  基于 lazysizes 自动转换图片为懒加载 外观和布局 / 响应式布局 / 浅色/深色 主题模式  全局一致的设计语言  支持分页  易用和自动展开的文章目录  支持多语言和国际化  美观的 CSS 动画 社交和评论系统  支持 Gravatar 头像  支持本地头像  支持多达 64 种社交链接  支持多达 28 种网站分享  支持 Disqus 评论系统  支持 Gitalk 评论系统  支持 Valine 评论系统  支持 Facebook 评论系统  支持 Telegram comments 评论系统  支持 Commento 评论系统  支持 Utterances 评论系统 扩展功能  支持基于 Lunr.js 或 algolia 的搜索  支持 Twemoji  支持代码高亮  一键复制代码到剪贴板  支持基于 lightgallery.js 的图片画廊  支持 Font Awesome 图标的扩展 Markdown 语法  支持上标注释的扩展 Markdown 语法  支持分数的扩展 Markdown 语法  支持基于 $ \\KaTeX $ 的数学公式  支持基于 mermaid 的图表 shortcode  支持基于 ECharts 的交互式数据可视化 shortcode  支持基于 Mapbox GL JS 的 Mapbox shortcode  支持基于 APlayer 和 MetingJS 的音乐播放器 shortcode  支持 Bilibili 视频 shortcode  支持多种注释的 shortcode  支持自定义样式的 shortcode  支持自定义脚本的 shortcode  支持基于 TypeIt 的打字动画 shortcode  支持基于 Smooth Scroll 的滚动动画  支持基于 cookieconsent 的 Cookie 许可横幅 … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"许可协议 LoveIt 根据 MIT 许可协议授权。 更多信息请查看 LICENSE 文件。 LoveIt 主题中用到了以下项目，感谢它们的作者： normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"关于 LoveIt","uri":"/about/"},{"categories":null,"content":"这个地方不能使用Markdown的标题标签或h1,h2…标签，否则前端目录代码会报错。 原因： links数组与文档内容分为两个部分，模板代码中，我只考虑了links数组，未考虑文中的h标签。生成的目录应只有links数组的标题，如果文章中出现标题，结果是：正常渲染，页面目录数组溢出。 如果你准备修复这个问题，可以参考：Table of Contents。然后修改layouts\\links\\single.html模板文件中的目录代码。 ","date":"0001-01-01","objectID":"/links/:0:0","tags":null,"title":"友情链接","uri":"/links/"},{"categories":null,"content":"content ","date":"0001-01-01","objectID":"/websites/:0:0","tags":null,"title":"网站收藏","uri":"/websites/"}]